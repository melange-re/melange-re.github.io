# Melange Playground

[Melange Playground](https://melange.re/unstable/playground/) is an interactive
environment for running code and seeing its output, including the JavaScript
generated by Melange compiler. It's also a great way to share code
snippets--the URL can be copied and pasted into another tab, recreating the
exact text inside the code editor.

In the next section, we'll use the Melange Playground to explore OCaml's numeric
types.

## OCaml numeric types

Unlike JavaScript, OCaml makes a clear and hard distinction between integer and
float values. Try running the following program in the playground:

```reason
let foo = 42;   // int
let bar = 42.0; // float
Js.log(foo == bar);
```

You'll get a compiler error for the last line that says `This expression has
type float but an expression was expected of type int`. Unlike JavaScript, there
are no implicit conversions in OCaml. Therefore you cannot expect to compare an
integer and a float together, unless you convert one of the values so that both
values have the same type. To make the last line compile, you can change it to

```reason
Js.log(foo == Int.of_float(bar));
```

Another way to fix the last line is to convert `foo` from an int to a float:

```reason
Js.log(Float.of_int(foo) == bar);
```

What about addition? What from you've already seen, you can probably guess that
`Js.log(42 + 16.0)` won't compile. However, you may be surprised to discover
that `Js.log(42.0 + 16.0)` also won't compile! That's because OCaml uses
separate arithmetic operators for floats. What will compile is this:

```reason
Js.log(42.0 +. 16.0);
```

Underneath the covers, `foo` and `bar` are both instances of JavaScript's Number
type:

```reason
Js.log(Js.typeof(foo)); // prints "number"
Js.log(Js.typeof(bar)); // prints "number"
```

## Overview

- Melange Playground is a great way to play around with short OCaml programs
- Integer and float are separate types in OCaml, but both translate to
  JavaScript's Number type once your program is compiled
- Float arithmetic operators are not the same as integer arithmetic operators

## Exercises

1. Convert the Counter component we created in the previous chapter to use float
   instead of integer. Make the `-` button decrement by `0.5` and the `+` button
   increment by `1.5`.
1. Add an int64 value to your program (the underscore is added to make large
   numbers more readable):
   ```reason
   let baz = 42_000_000_000L; // int64
   Js.log(baz);
   ```
   What is the JavaScript representation of int64?
1. How do you add two int64 values? Hint: Take a look at the standard library's
   [Int64 module](https://v2.ocaml.org/api/Int64.html).

## Solutions

1. A Counter component that uses float instead of integer would look something
   like this:
   ```reason
   [@react.component]
   let make = () => {
     let (counter, setCounter) = React.useState(() => 0.0);

     <div>
       <button onClick={_evt => setCounter(v => v -. 0.5)}> {React.string("-")} </button>
       <span> {counter |> Float.to_string |> React.string} </span>
       <button onClick={_evt => setCounter(v => v +. 1.5)}> {React.string("+")} </button>
      </div>;
   };
   ```
1. Int64 values cannot be represented by JavaScript's Number type, which doesn't
   have enough precision. They're instead represented by an array of two
   numbers `[high, low]`, where `high` is signed, `low` is unsigned.
1. You can add two int64 values using `Int64.add`, e.g. `Int64.add(42L, 16L)`.
