(function(){"use strict";var e_=`// Generated by Melange


const Obj = {};

const Stdlib = {};

export {
  Obj,
  Stdlib,
}
/* No side effect */
`,r_=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,a_=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Js__Js_math from "melange.js/js_math.js";

function get(arr, i) {
  if (i >= 0 && i < arr.length) {
    return Caml_option.some(arr[i]);
  }
  
}

function getExn(arr, i) {
  if (!(i >= 0 && i < arr.length)) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "belt/belt_Array.ml",
            29,
            2
          ]
        });
  }
  return arr[i];
}

function set(arr, i, v) {
  if (i >= 0 && i < arr.length) {
    arr[i] = v;
    return true;
  } else {
    return false;
  }
}

function setExn(arr, i, v) {
  if (!(i >= 0 && i < arr.length)) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "belt/belt_Array.ml",
            39,
            2
          ]
        });
  }
  arr[i] = v;
}

function swapUnsafe(xs, i, j) {
  const tmp = xs[i];
  xs[i] = xs[j];
  xs[j] = tmp;
}

function shuffleInPlace(xs) {
  const len = xs.length;
  for (let i = 0; i < len; ++i) {
    swapUnsafe(xs, i, Js__Js_math.random_int(i, len));
  }
}

function shuffle(xs) {
  const result = xs.slice(0);
  shuffleInPlace(result);
  return result;
}

function reverseInPlace(xs) {
  const len = xs.length;
  let ofs = 0;
  for (let i = 0, i_finish = len / 2 | 0; i < i_finish; ++i) {
    swapUnsafe(xs, ofs + i | 0, ((ofs + len | 0) - i | 0) - 1 | 0);
  }
}

function reverse(xs) {
  const len = xs.length;
  const result = new Array(len);
  for (let i = 0; i < len; ++i) {
    result[i] = xs[(len - 1 | 0) - i | 0];
  }
  return result;
}

function make(l, f) {
  if (l <= 0) {
    return [];
  }
  const res = new Array(l);
  for (let i = 0; i < l; ++i) {
    res[i] = f;
  }
  return res;
}

function makeByU(l, f) {
  if (l <= 0) {
    return [];
  }
  const res = new Array(l);
  for (let i = 0; i < l; ++i) {
    res[i] = f(i);
  }
  return res;
}

function makeBy(l, f) {
  return makeByU(l, Curry.__1(f));
}

function makeByAndShuffleU(l, f) {
  const u = makeByU(l, f);
  shuffleInPlace(u);
  return u;
}

function makeByAndShuffle(l, f) {
  return makeByAndShuffleU(l, Curry.__1(f));
}

function range(start, finish) {
  const cut = finish - start | 0;
  if (cut < 0) {
    return [];
  }
  const arr = new Array(cut + 1 | 0);
  for (let i = 0; i <= cut; ++i) {
    arr[i] = start + i | 0;
  }
  return arr;
}

function rangeBy(start, finish, step) {
  const cut = finish - start | 0;
  if (cut < 0 || step <= 0) {
    return [];
  }
  const nb = (cut / step | 0) + 1 | 0;
  const arr = new Array(nb);
  let cur = start;
  for (let i = 0; i < nb; ++i) {
    arr[i] = cur;
    cur = cur + step | 0;
  }
  return arr;
}

function zip(xs, ys) {
  const lenx = xs.length;
  const leny = ys.length;
  const len = lenx < leny ? lenx : leny;
  const s = new Array(len);
  for (let i = 0; i < len; ++i) {
    s[i] = [
      xs[i],
      ys[i]
    ];
  }
  return s;
}

function zipByU(xs, ys, f) {
  const lenx = xs.length;
  const leny = ys.length;
  const len = lenx < leny ? lenx : leny;
  const s = new Array(len);
  for (let i = 0; i < len; ++i) {
    s[i] = f(xs[i], ys[i]);
  }
  return s;
}

function zipBy(xs, ys, f) {
  return zipByU(xs, ys, Curry.__2(f));
}

function concat(a1, a2) {
  const l1 = a1.length;
  const l2 = a2.length;
  const a1a2 = new Array(l1 + l2 | 0);
  for (let i = 0; i < l1; ++i) {
    a1a2[i] = a1[i];
  }
  for (let i$1 = 0; i$1 < l2; ++i$1) {
    a1a2[l1 + i$1 | 0] = a2[i$1];
  }
  return a1a2;
}

function concatMany(arrs) {
  const lenArrs = arrs.length;
  let totalLen = 0;
  for (let i = 0; i < lenArrs; ++i) {
    totalLen = totalLen + arrs[i].length | 0;
  }
  const result = new Array(totalLen);
  totalLen = 0;
  for (let j = 0; j < lenArrs; ++j) {
    const cur = arrs[j];
    for (let k = 0, k_finish = cur.length; k < k_finish; ++k) {
      result[totalLen] = cur[k];
      totalLen = totalLen + 1 | 0;
    }
  }
  return result;
}

function slice(a, offset, len) {
  if (len <= 0) {
    return [];
  }
  const lena = a.length;
  const ofs = offset < 0 ? Caml.caml_int_max(lena + offset | 0, 0) : offset;
  const hasLen = lena - ofs | 0;
  const copyLength = hasLen < len ? hasLen : len;
  if (copyLength <= 0) {
    return [];
  }
  const result = new Array(copyLength);
  for (let i = 0; i < copyLength; ++i) {
    result[i] = a[ofs + i | 0];
  }
  return result;
}

function sliceToEnd(a, offset) {
  const lena = a.length;
  const ofs = offset < 0 ? Caml.caml_int_max(lena + offset | 0, 0) : offset;
  const len = lena > ofs ? lena - ofs | 0 : 0;
  const result = new Array(len);
  for (let i = 0; i < len; ++i) {
    result[i] = a[ofs + i | 0];
  }
  return result;
}

function fill(a, offset, len, v) {
  if (len <= 0) {
    return;
  }
  const lena = a.length;
  const ofs = offset < 0 ? Caml.caml_int_max(lena + offset | 0, 0) : offset;
  const hasLen = lena - ofs | 0;
  const fillLength = hasLen < len ? hasLen : len;
  if (fillLength <= 0) {
    return;
  }
  for (let i = ofs, i_finish = ofs + fillLength | 0; i < i_finish; ++i) {
    a[i] = v;
  }
}

function blitUnsafe(a1, srcofs1, a2, srcofs2, blitLength) {
  if (srcofs2 <= srcofs1) {
    for (let j = 0; j < blitLength; ++j) {
      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];
    }
    return;
  }
  for (let j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1) {
    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  const lena1 = a1.length;
  const lena2 = a2.length;
  const srcofs1 = ofs1 < 0 ? Caml.caml_int_max(lena1 + ofs1 | 0, 0) : ofs1;
  const srcofs2 = ofs2 < 0 ? Caml.caml_int_max(lena2 + ofs2 | 0, 0) : ofs2;
  const blitLength = Caml.caml_int_min(len, Caml.caml_int_min(lena1 - srcofs1 | 0, lena2 - srcofs2 | 0));
  if (srcofs2 <= srcofs1) {
    for (let j = 0; j < blitLength; ++j) {
      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];
    }
    return;
  }
  for (let j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1) {
    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];
  }
}

function forEachU(a, f) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    f(a[i]);
  }
}

function forEach(a, f) {
  forEachU(a, Curry.__1(f));
}

function mapU(a, f) {
  const l = a.length;
  const r = new Array(l);
  for (let i = 0; i < l; ++i) {
    r[i] = f(a[i]);
  }
  return r;
}

function map(a, f) {
  return mapU(a, Curry.__1(f));
}

function flatMapU(a, f) {
  return concatMany(mapU(a, f));
}

function flatMap(a, f) {
  return concatMany(mapU(a, Curry.__1(f)));
}

function getByU(a, p) {
  const l = a.length;
  let i = 0;
  let r;
  while (r === undefined && i < l) {
    const v = a[i];
    if (p(v)) {
      r = Caml_option.some(v);
    }
    i = i + 1 | 0;
  };
  return r;
}

function getBy(a, p) {
  return getByU(a, Curry.__1(p));
}

function getIndexByU(a, p) {
  const l = a.length;
  let i = 0;
  let r;
  while (r === undefined && i < l) {
    const v = a[i];
    if (p(v)) {
      r = i;
    }
    i = i + 1 | 0;
  };
  return r;
}

function getIndexBy(a, p) {
  return getIndexByU(a, Curry.__1(p));
}

function keepU(a, f) {
  const l = a.length;
  const r = new Array(l);
  let j = 0;
  for (let i = 0; i < l; ++i) {
    const v = a[i];
    if (f(v)) {
      r[j] = v;
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keep(a, f) {
  return keepU(a, Curry.__1(f));
}

function keepWithIndexU(a, f) {
  const l = a.length;
  const r = new Array(l);
  let j = 0;
  for (let i = 0; i < l; ++i) {
    const v = a[i];
    if (f(v, i)) {
      r[j] = v;
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keepWithIndex(a, f) {
  return keepWithIndexU(a, Curry.__2(f));
}

function keepMapU(a, f) {
  const l = a.length;
  const r = new Array(l);
  let j = 0;
  for (let i = 0; i < l; ++i) {
    const v = a[i];
    const v$1 = f(v);
    if (v$1 !== undefined) {
      r[j] = Caml_option.valFromOption(v$1);
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keepMap(a, f) {
  return keepMapU(a, Curry.__1(f));
}

function forEachWithIndexU(a, f) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    f(i, a[i]);
  }
}

function forEachWithIndex(a, f) {
  forEachWithIndexU(a, Curry.__2(f));
}

function mapWithIndexU(a, f) {
  const l = a.length;
  const r = new Array(l);
  for (let i = 0; i < l; ++i) {
    r[i] = f(i, a[i]);
  }
  return r;
}

function mapWithIndex(a, f) {
  return mapWithIndexU(a, Curry.__2(f));
}

function reduceU(a, x, f) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = f(r, a[i]);
  }
  return r;
}

function reduce(a, x, f) {
  return reduceU(a, x, Curry.__2(f));
}

function reduceReverseU(a, x, f) {
  let r = x;
  for (let i = a.length - 1 | 0; i >= 0; --i) {
    r = f(r, a[i]);
  }
  return r;
}

function reduceReverse(a, x, f) {
  return reduceReverseU(a, x, Curry.__2(f));
}

function reduceReverse2U(a, b, x, f) {
  let r = x;
  const len = Caml.caml_int_min(a.length, b.length);
  for (let i = len - 1 | 0; i >= 0; --i) {
    r = f(r, a[i], b[i]);
  }
  return r;
}

function reduceReverse2(a, b, x, f) {
  return reduceReverse2U(a, b, x, Curry.__3(f));
}

function reduceWithIndexU(a, x, f) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = f(r, a[i], i);
  }
  return r;
}

function reduceWithIndex(a, x, f) {
  return reduceWithIndexU(a, x, Curry.__3(f));
}

function everyU(arr, b) {
  const len = arr.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === len) {
      return true;
    }
    if (!b(arr[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function every(arr, f) {
  return everyU(arr, Curry.__1(f));
}

function someU(arr, b) {
  const len = arr.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === len) {
      return false;
    }
    if (b(arr[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function some(arr, f) {
  return someU(arr, Curry.__1(f));
}

function everyAux2(arr1, arr2, _i, b, len) {
  while (true) {
    const i = _i;
    if (i === len) {
      return true;
    }
    if (!b(arr1[i], arr2[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function every2U(a, b, p) {
  return everyAux2(a, b, 0, p, Caml.caml_int_min(a.length, b.length));
}

function every2(a, b, p) {
  return every2U(a, b, Curry.__2(p));
}

function some2U(a, b, p) {
  let _i = 0;
  let len = Caml.caml_int_min(a.length, b.length);
  while (true) {
    const i = _i;
    if (i === len) {
      return false;
    }
    if (p(a[i], b[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function some2(a, b, p) {
  return some2U(a, b, Curry.__2(p));
}

function eqU(a, b, p) {
  const lena = a.length;
  const lenb = b.length;
  if (lena === lenb) {
    return everyAux2(a, b, 0, p, lena);
  } else {
    return false;
  }
}

function eq(a, b, p) {
  return eqU(a, b, Curry.__2(p));
}

function cmpU(a, b, p) {
  const lena = a.length;
  const lenb = b.length;
  if (lena > lenb) {
    return 1;
  } else if (lena < lenb) {
    return -1;
  } else {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === lena) {
        return 0;
      }
      const c = p(a[i], b[i]);
      if (c !== 0) {
        return c;
      }
      _i = i + 1 | 0;
      continue;
    };
  }
}

function cmp(a, b, p) {
  return cmpU(a, b, Curry.__2(p));
}

function partitionU(a, f) {
  const l = a.length;
  let i = 0;
  let j = 0;
  const a1 = new Array(l);
  const a2 = new Array(l);
  for (let ii = 0; ii < l; ++ii) {
    const v = a[ii];
    if (f(v)) {
      a1[i] = v;
      i = i + 1 | 0;
    } else {
      a2[j] = v;
      j = j + 1 | 0;
    }
  }
  a1.length = i;
  a2.length = j;
  return [
    a1,
    a2
  ];
}

function partition(a, f) {
  return partitionU(a, Curry.__1(f));
}

function unzip(a) {
  const l = a.length;
  const a1 = new Array(l);
  const a2 = new Array(l);
  for (let i = 0; i < l; ++i) {
    const match = a[i];
    a1[i] = match[0];
    a2[i] = match[1];
  }
  return [
    a1,
    a2
  ];
}

function joinWithU(a, sep, toString) {
  const l = a.length;
  if (l === 0) {
    return "";
  }
  const lastIndex = l - 1 | 0;
  let _i = 0;
  let _res = "";
  while (true) {
    const res = _res;
    const i = _i;
    if (i === lastIndex) {
      return res + toString(a[i]);
    }
    _res = res + (toString(a[i]) + sep);
    _i = i + 1 | 0;
    continue;
  };
}

function joinWith(a, sep, toString) {
  return joinWithU(a, sep, Curry.__1(toString));
}

function initU(n, f) {
  const v = new Array(n);
  for (let i = 0; i < n; ++i) {
    v[i] = f(i);
  }
  return v;
}

function init(n, f) {
  return initU(n, Curry.__1(f));
}

export {
  get,
  getExn,
  set,
  setExn,
  shuffleInPlace,
  shuffle,
  reverseInPlace,
  reverse,
  make,
  range,
  rangeBy,
  makeByU,
  makeBy,
  makeByAndShuffleU,
  makeByAndShuffle,
  zip,
  zipByU,
  zipBy,
  unzip,
  concat,
  concatMany,
  slice,
  sliceToEnd,
  fill,
  blit,
  blitUnsafe,
  forEachU,
  forEach,
  mapU,
  map,
  flatMapU,
  flatMap,
  getByU,
  getBy,
  getIndexByU,
  getIndexBy,
  keepU,
  keep,
  keepWithIndexU,
  keepWithIndex,
  keepMapU,
  keepMap,
  forEachWithIndexU,
  forEachWithIndex,
  mapWithIndexU,
  mapWithIndex,
  partitionU,
  partition,
  reduceU,
  reduce,
  reduceReverseU,
  reduceReverse,
  reduceReverse2U,
  reduceReverse2,
  reduceWithIndexU,
  reduceWithIndex,
  joinWithU,
  joinWith,
  someU,
  some,
  everyU,
  every,
  every2U,
  every2,
  some2U,
  some2,
  cmpU,
  cmp,
  eqU,
  eq,
  initU,
  init,
}
/* No side effect */
`,i_=`// Generated by Melange


function fromString(i) {
  const i$1 = parseFloat(i);
  if (isNaN(i$1)) {
    return;
  } else {
    return i$1;
  }
}

export {
  fromString,
}
/* No side effect */
`,s_=`// Generated by Melange

import * as Belt__Belt_internalBuckets from "./belt_internalBuckets.js";
import * as Belt__Belt_internalBucketsType from "./belt_internalBucketsType.js";
import * as Caml_option from "melange.js/caml_option.js";

function size(h) {
  return h.size;
}

function copyBucketReHash(hash, h_buckets, ndata_tail, _old_bucket) {
  while (true) {
    const old_bucket = _old_bucket;
    if (old_bucket === undefined) {
      return;
    }
    const nidx = hash(old_bucket.key) & (h_buckets.length - 1 | 0);
    const tail = ndata_tail[nidx];
    if (tail !== undefined) {
      tail.next = old_bucket;
    } else {
      h_buckets[nidx] = old_bucket;
    }
    ndata_tail[nidx] = old_bucket;
    _old_bucket = old_bucket.next;
    continue;
  };
}

function replaceInBucket(eq, key, info, _cell) {
  while (true) {
    const cell = _cell;
    if (eq(cell.key, key)) {
      cell.value = info;
      return false;
    }
    const cell$1 = cell.next;
    if (cell$1 === undefined) {
      return true;
    }
    _cell = cell$1;
    continue;
  };
}

function set0(h, key, value, eq, hash) {
  const h_buckets = h.buckets;
  const buckets_len = h_buckets.length;
  const i = hash(key) & (buckets_len - 1 | 0);
  const l = h_buckets[i];
  if (l !== undefined) {
    if (replaceInBucket(eq, key, value, l)) {
      h_buckets[i] = {
        key: key,
        value: value,
        next: l
      };
      h.size = h.size + 1 | 0;
    }
    
  } else {
    h_buckets[i] = {
      key: key,
      value: value,
      next: undefined
    };
    h.size = h.size + 1 | 0;
  }
  if (h.size > (buckets_len << 1)) {
    const odata = h.buckets;
    const osize = odata.length;
    const nsize = (osize << 1);
    if (nsize < osize) {
      return;
    }
    const h_buckets$1 = new Array(nsize);
    const ndata_tail = new Array(nsize);
    h.buckets = h_buckets$1;
    for (let i$1 = 0; i$1 < osize; ++i$1) {
      copyBucketReHash(hash, h_buckets$1, ndata_tail, odata[i$1]);
    }
    for (let i$2 = 0; i$2 < nsize; ++i$2) {
      const tail = ndata_tail[i$2];
      if (tail !== undefined) {
        tail.next = undefined;
      }
      
    }
    return;
  }
  
}

function set(h, key, value) {
  set0(h, key, value, h.eq, h.hash);
}

function remove(h, key) {
  const h_buckets = h.buckets;
  const i = h.hash(key) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[i];
  if (bucket === undefined) {
    return;
  }
  const eq = h.eq;
  if (eq(bucket.key, key)) {
    h_buckets[i] = bucket.next;
    h.size = h.size - 1 | 0;
    return;
  } else {
    let _prec = bucket;
    let _bucket = bucket.next;
    while (true) {
      const bucket$1 = _bucket;
      const prec = _prec;
      if (bucket$1 === undefined) {
        return;
      }
      const cell_next = bucket$1.next;
      if (eq(bucket$1.key, key)) {
        prec.next = cell_next;
        h.size = h.size - 1 | 0;
        return;
      }
      _bucket = cell_next;
      _prec = bucket$1;
      continue;
    };
  }
}

function get(h, key) {
  const h_buckets = h.buckets;
  const nid = h.hash(key) & (h_buckets.length - 1 | 0);
  const cell1 = h_buckets[nid];
  if (cell1 === undefined) {
    return;
  }
  const eq = h.eq;
  if (eq(key, cell1.key)) {
    return Caml_option.some(cell1.value);
  }
  const cell2 = cell1.next;
  if (cell2 === undefined) {
    return;
  }
  if (eq(key, cell2.key)) {
    return Caml_option.some(cell2.value);
  }
  const cell3 = cell2.next;
  if (cell3 !== undefined) {
    if (eq(key, cell3.key)) {
      return Caml_option.some(cell3.value);
    } else {
      let _buckets = cell3.next;
      while (true) {
        const buckets = _buckets;
        if (buckets === undefined) {
          return;
        }
        if (eq(key, buckets.key)) {
          return Caml_option.some(buckets.value);
        }
        _buckets = buckets.next;
        continue;
      };
    }
  }
  
}

function has(h, key) {
  const h_buckets = h.buckets;
  const nid = h.hash(key) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[nid];
  if (bucket !== undefined) {
    let _cell = bucket;
    let eq = h.eq;
    while (true) {
      const cell = _cell;
      if (eq(cell.key, key)) {
        return true;
      }
      const nextCell = cell.next;
      if (nextCell === undefined) {
        return false;
      }
      _cell = nextCell;
      continue;
    };
  } else {
    return false;
  }
}

function make(hintSize, id) {
  return Belt__Belt_internalBucketsType.make(id.hash, id.eq, hintSize);
}

function fromArray(arr, id) {
  const hash = id.hash;
  const eq = id.eq;
  const len = arr.length;
  const v = Belt__Belt_internalBucketsType.make(hash, eq, len);
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    set0(v, match[0], match[1], eq, hash);
  }
  return v;
}

function mergeMany(h, arr) {
  const hash = h.hash;
  const eq = h.eq;
  const len = arr.length;
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    set0(h, match[0], match[1], eq, hash);
  }
}

const clear = Belt__Belt_internalBucketsType.clear;

const isEmpty = Belt__Belt_internalBucketsType.isEmpty;

const copy = Belt__Belt_internalBuckets.copy;

const forEachU = Belt__Belt_internalBuckets.forEachU;

const forEach = Belt__Belt_internalBuckets.forEach;

const reduceU = Belt__Belt_internalBuckets.reduceU;

const reduce = Belt__Belt_internalBuckets.reduce;

const keepMapInPlaceU = Belt__Belt_internalBuckets.keepMapInPlaceU;

const keepMapInPlace = Belt__Belt_internalBuckets.keepMapInPlace;

const toArray = Belt__Belt_internalBuckets.toArray;

const keysToArray = Belt__Belt_internalBuckets.keysToArray;

const valuesToArray = Belt__Belt_internalBuckets.valuesToArray;

const getBucketHistogram = Belt__Belt_internalBuckets.getBucketHistogram;

const logStats = Belt__Belt_internalBuckets.logStats;

export {
  make,
  clear,
  isEmpty,
  set,
  copy,
  get,
  has,
  remove,
  forEachU,
  forEach,
  reduceU,
  reduce,
  keepMapInPlaceU,
  keepMapInPlace,
  size,
  toArray,
  keysToArray,
  valuesToArray,
  fromArray,
  mergeMany,
  getBucketHistogram,
  logStats,
}
/* No side effect */
`,o_=`// Generated by Melange

import * as Belt__Belt_internalBuckets from "./belt_internalBuckets.js";
import * as Belt__Belt_internalBucketsType from "./belt_internalBucketsType.js";
import * as Caml_hash_primitive from "melange.js/caml_hash_primitive.js";
import * as Caml_option from "melange.js/caml_option.js";

function copyBucketReHash(h_buckets, ndata_tail, _old_bucket) {
  while (true) {
    const old_bucket = _old_bucket;
    if (old_bucket === undefined) {
      return;
    }
    const nidx = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, old_bucket.key)) & (h_buckets.length - 1 | 0);
    const tail = ndata_tail[nidx];
    if (tail !== undefined) {
      tail.next = old_bucket;
    } else {
      h_buckets[nidx] = old_bucket;
    }
    ndata_tail[nidx] = old_bucket;
    _old_bucket = old_bucket.next;
    continue;
  };
}

function replaceInBucket(key, info, _cell) {
  while (true) {
    const cell = _cell;
    if (cell.key === key) {
      cell.value = info;
      return false;
    }
    const cell$1 = cell.next;
    if (cell$1 === undefined) {
      return true;
    }
    _cell = cell$1;
    continue;
  };
}

function set(h, key, value) {
  const h_buckets = h.buckets;
  const buckets_len = h_buckets.length;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, key)) & (buckets_len - 1 | 0);
  const l = h_buckets[i];
  if (l !== undefined) {
    if (replaceInBucket(key, value, l)) {
      h_buckets[i] = {
        key: key,
        value: value,
        next: l
      };
      h.size = h.size + 1 | 0;
    }
    
  } else {
    h_buckets[i] = {
      key: key,
      value: value,
      next: undefined
    };
    h.size = h.size + 1 | 0;
  }
  if (h.size > (buckets_len << 1)) {
    const odata = h.buckets;
    const osize = odata.length;
    const nsize = (osize << 1);
    if (nsize < osize) {
      return;
    }
    const h_buckets$1 = new Array(nsize);
    const ndata_tail = new Array(nsize);
    h.buckets = h_buckets$1;
    for (let i$1 = 0; i$1 < osize; ++i$1) {
      copyBucketReHash(h_buckets$1, ndata_tail, odata[i$1]);
    }
    for (let i$2 = 0; i$2 < nsize; ++i$2) {
      const tail = ndata_tail[i$2];
      if (tail !== undefined) {
        tail.next = undefined;
      }
      
    }
    return;
  }
  
}

function remove(h, key) {
  const h_buckets = h.buckets;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, key)) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[i];
  if (bucket !== undefined) {
    if (bucket.key === key) {
      h_buckets[i] = bucket.next;
      h.size = h.size - 1 | 0;
      return;
    } else {
      let _prec = bucket;
      let _buckets = bucket.next;
      while (true) {
        const buckets = _buckets;
        const prec = _prec;
        if (buckets === undefined) {
          return;
        }
        const cell_next = buckets.next;
        if (buckets.key === key) {
          prec.next = cell_next;
          h.size = h.size - 1 | 0;
          return;
        }
        _buckets = cell_next;
        _prec = buckets;
        continue;
      };
    }
  }
  
}

function get(h, key) {
  const h_buckets = h.buckets;
  const nid = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, key)) & (h_buckets.length - 1 | 0);
  const cell1 = h_buckets[nid];
  if (cell1 === undefined) {
    return;
  }
  if (key === cell1.key) {
    return Caml_option.some(cell1.value);
  }
  const cell2 = cell1.next;
  if (cell2 === undefined) {
    return;
  }
  if (key === cell2.key) {
    return Caml_option.some(cell2.value);
  }
  const cell3 = cell2.next;
  if (cell3 !== undefined) {
    if (key === cell3.key) {
      return Caml_option.some(cell3.value);
    } else {
      let _buckets = cell3.next;
      while (true) {
        const buckets = _buckets;
        if (buckets === undefined) {
          return;
        }
        if (key === buckets.key) {
          return Caml_option.some(buckets.value);
        }
        _buckets = buckets.next;
        continue;
      };
    }
  }
  
}

function has(h, key) {
  const h_buckets = h.buckets;
  const nid = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, key)) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[nid];
  if (bucket !== undefined) {
    let _cell = bucket;
    while (true) {
      const cell = _cell;
      if (cell.key === key) {
        return true;
      }
      const nextCell = cell.next;
      if (nextCell === undefined) {
        return false;
      }
      _cell = nextCell;
      continue;
    };
  } else {
    return false;
  }
}

function make(hintSize) {
  return Belt__Belt_internalBucketsType.make(undefined, undefined, hintSize);
}

function size(h) {
  return h.size;
}

function fromArray(arr) {
  const len = arr.length;
  const v = Belt__Belt_internalBucketsType.make(undefined, undefined, len);
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    set(v, match[0], match[1]);
  }
  return v;
}

function mergeMany(h, arr) {
  const len = arr.length;
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    set(h, match[0], match[1]);
  }
}

const clear = Belt__Belt_internalBucketsType.clear;

const isEmpty = Belt__Belt_internalBucketsType.isEmpty;

const copy = Belt__Belt_internalBuckets.copy;

const forEachU = Belt__Belt_internalBuckets.forEachU;

const forEach = Belt__Belt_internalBuckets.forEach;

const reduceU = Belt__Belt_internalBuckets.reduceU;

const reduce = Belt__Belt_internalBuckets.reduce;

const keepMapInPlaceU = Belt__Belt_internalBuckets.keepMapInPlaceU;

const keepMapInPlace = Belt__Belt_internalBuckets.keepMapInPlace;

const toArray = Belt__Belt_internalBuckets.toArray;

const keysToArray = Belt__Belt_internalBuckets.keysToArray;

const valuesToArray = Belt__Belt_internalBuckets.valuesToArray;

const getBucketHistogram = Belt__Belt_internalBuckets.getBucketHistogram;

const logStats = Belt__Belt_internalBuckets.logStats;

export {
  make,
  clear,
  isEmpty,
  set,
  copy,
  get,
  has,
  remove,
  forEachU,
  forEach,
  reduceU,
  reduce,
  keepMapInPlaceU,
  keepMapInPlace,
  size,
  toArray,
  keysToArray,
  valuesToArray,
  fromArray,
  mergeMany,
  getBucketHistogram,
  logStats,
}
/* No side effect */
`,l_=`// Generated by Melange

import * as Belt__Belt_internalBuckets from "./belt_internalBuckets.js";
import * as Belt__Belt_internalBucketsType from "./belt_internalBucketsType.js";
import * as Caml_hash_primitive from "melange.js/caml_hash_primitive.js";
import * as Caml_option from "melange.js/caml_option.js";

function copyBucketReHash(h_buckets, ndata_tail, _old_bucket) {
  while (true) {
    const old_bucket = _old_bucket;
    if (old_bucket === undefined) {
      return;
    }
    const nidx = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, old_bucket.key)) & (h_buckets.length - 1 | 0);
    const tail = ndata_tail[nidx];
    if (tail !== undefined) {
      tail.next = old_bucket;
    } else {
      h_buckets[nidx] = old_bucket;
    }
    ndata_tail[nidx] = old_bucket;
    _old_bucket = old_bucket.next;
    continue;
  };
}

function replaceInBucket(key, info, _cell) {
  while (true) {
    const cell = _cell;
    if (cell.key === key) {
      cell.value = info;
      return false;
    }
    const cell$1 = cell.next;
    if (cell$1 === undefined) {
      return true;
    }
    _cell = cell$1;
    continue;
  };
}

function set(h, key, value) {
  const h_buckets = h.buckets;
  const buckets_len = h_buckets.length;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) & (buckets_len - 1 | 0);
  const l = h_buckets[i];
  if (l !== undefined) {
    if (replaceInBucket(key, value, l)) {
      h_buckets[i] = {
        key: key,
        value: value,
        next: l
      };
      h.size = h.size + 1 | 0;
    }
    
  } else {
    h_buckets[i] = {
      key: key,
      value: value,
      next: undefined
    };
    h.size = h.size + 1 | 0;
  }
  if (h.size > (buckets_len << 1)) {
    const odata = h.buckets;
    const osize = odata.length;
    const nsize = (osize << 1);
    if (nsize < osize) {
      return;
    }
    const h_buckets$1 = new Array(nsize);
    const ndata_tail = new Array(nsize);
    h.buckets = h_buckets$1;
    for (let i$1 = 0; i$1 < osize; ++i$1) {
      copyBucketReHash(h_buckets$1, ndata_tail, odata[i$1]);
    }
    for (let i$2 = 0; i$2 < nsize; ++i$2) {
      const tail = ndata_tail[i$2];
      if (tail !== undefined) {
        tail.next = undefined;
      }
      
    }
    return;
  }
  
}

function remove(h, key) {
  const h_buckets = h.buckets;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[i];
  if (bucket !== undefined) {
    if (bucket.key === key) {
      h_buckets[i] = bucket.next;
      h.size = h.size - 1 | 0;
      return;
    } else {
      let _prec = bucket;
      let _buckets = bucket.next;
      while (true) {
        const buckets = _buckets;
        const prec = _prec;
        if (buckets === undefined) {
          return;
        }
        const cell_next = buckets.next;
        if (buckets.key === key) {
          prec.next = cell_next;
          h.size = h.size - 1 | 0;
          return;
        }
        _buckets = cell_next;
        _prec = buckets;
        continue;
      };
    }
  }
  
}

function get(h, key) {
  const h_buckets = h.buckets;
  const nid = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) & (h_buckets.length - 1 | 0);
  const cell1 = h_buckets[nid];
  if (cell1 === undefined) {
    return;
  }
  if (key === cell1.key) {
    return Caml_option.some(cell1.value);
  }
  const cell2 = cell1.next;
  if (cell2 === undefined) {
    return;
  }
  if (key === cell2.key) {
    return Caml_option.some(cell2.value);
  }
  const cell3 = cell2.next;
  if (cell3 !== undefined) {
    if (key === cell3.key) {
      return Caml_option.some(cell3.value);
    } else {
      let _buckets = cell3.next;
      while (true) {
        const buckets = _buckets;
        if (buckets === undefined) {
          return;
        }
        if (key === buckets.key) {
          return Caml_option.some(buckets.value);
        }
        _buckets = buckets.next;
        continue;
      };
    }
  }
  
}

function has(h, key) {
  const h_buckets = h.buckets;
  const nid = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[nid];
  if (bucket !== undefined) {
    let _cell = bucket;
    while (true) {
      const cell = _cell;
      if (cell.key === key) {
        return true;
      }
      const nextCell = cell.next;
      if (nextCell === undefined) {
        return false;
      }
      _cell = nextCell;
      continue;
    };
  } else {
    return false;
  }
}

function make(hintSize) {
  return Belt__Belt_internalBucketsType.make(undefined, undefined, hintSize);
}

function size(h) {
  return h.size;
}

function fromArray(arr) {
  const len = arr.length;
  const v = Belt__Belt_internalBucketsType.make(undefined, undefined, len);
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    set(v, match[0], match[1]);
  }
  return v;
}

function mergeMany(h, arr) {
  const len = arr.length;
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    set(h, match[0], match[1]);
  }
}

const clear = Belt__Belt_internalBucketsType.clear;

const isEmpty = Belt__Belt_internalBucketsType.isEmpty;

const copy = Belt__Belt_internalBuckets.copy;

const forEachU = Belt__Belt_internalBuckets.forEachU;

const forEach = Belt__Belt_internalBuckets.forEach;

const reduceU = Belt__Belt_internalBuckets.reduceU;

const reduce = Belt__Belt_internalBuckets.reduce;

const keepMapInPlaceU = Belt__Belt_internalBuckets.keepMapInPlaceU;

const keepMapInPlace = Belt__Belt_internalBuckets.keepMapInPlace;

const toArray = Belt__Belt_internalBuckets.toArray;

const keysToArray = Belt__Belt_internalBuckets.keysToArray;

const valuesToArray = Belt__Belt_internalBuckets.valuesToArray;

const getBucketHistogram = Belt__Belt_internalBuckets.getBucketHistogram;

const logStats = Belt__Belt_internalBuckets.logStats;

export {
  make,
  clear,
  isEmpty,
  set,
  copy,
  get,
  has,
  remove,
  forEachU,
  forEach,
  reduceU,
  reduce,
  keepMapInPlaceU,
  keepMapInPlace,
  size,
  toArray,
  keysToArray,
  valuesToArray,
  fromArray,
  mergeMany,
  getBucketHistogram,
  logStats,
}
/* No side effect */
`,c_=`// Generated by Melange

import * as Belt__Belt_internalBucketsType from "./belt_internalBucketsType.js";
import * as Belt__Belt_internalSetBuckets from "./belt_internalSetBuckets.js";

function copyBucket(hash, h_buckets, ndata_tail, _old_bucket) {
  while (true) {
    const old_bucket = _old_bucket;
    if (old_bucket === undefined) {
      return;
    }
    const nidx = hash(old_bucket.key) & (h_buckets.length - 1 | 0);
    const tail = ndata_tail[nidx];
    if (tail !== undefined) {
      tail.next = old_bucket;
    } else {
      h_buckets[nidx] = old_bucket;
    }
    ndata_tail[nidx] = old_bucket;
    _old_bucket = old_bucket.next;
    continue;
  };
}

function remove(h, key) {
  const eq = h.eq;
  const h_buckets = h.buckets;
  const i = h.hash(key) & (h_buckets.length - 1 | 0);
  const l = h_buckets[i];
  if (l === undefined) {
    return;
  }
  const next_cell = l.next;
  if (eq(l.key, key)) {
    h.size = h.size - 1 | 0;
    h_buckets[i] = next_cell;
    return;
  } else if (next_cell !== undefined) {
    let _prec = l;
    let _cell = next_cell;
    while (true) {
      const cell = _cell;
      const prec = _prec;
      const cell_next = cell.next;
      if (eq(cell.key, key)) {
        prec.next = cell_next;
        h.size = h.size - 1 | 0;
        return;
      }
      if (cell_next === undefined) {
        return;
      }
      _cell = cell_next;
      _prec = cell;
      continue;
    };
  } else {
    return;
  }
}

function addBucket(h, key, _cell, eq) {
  while (true) {
    const cell = _cell;
    if (eq(cell.key, key)) {
      return;
    }
    const n = cell.next;
    if (n !== undefined) {
      _cell = n;
      continue;
    }
    h.size = h.size + 1 | 0;
    cell.next = {
      key: key,
      next: undefined
    };
    return;
  };
}

function add0(h, key, hash, eq) {
  const h_buckets = h.buckets;
  const buckets_len = h_buckets.length;
  const i = hash(key) & (buckets_len - 1 | 0);
  const l = h_buckets[i];
  if (l !== undefined) {
    addBucket(h, key, l, eq);
  } else {
    h.size = h.size + 1 | 0;
    h_buckets[i] = {
      key: key,
      next: undefined
    };
  }
  if (h.size > (buckets_len << 1)) {
    const odata = h.buckets;
    const osize = odata.length;
    const nsize = (osize << 1);
    if (nsize < osize) {
      return;
    }
    const h_buckets$1 = new Array(nsize);
    const ndata_tail = new Array(nsize);
    h.buckets = h_buckets$1;
    for (let i$1 = 0; i$1 < osize; ++i$1) {
      copyBucket(hash, h_buckets$1, ndata_tail, odata[i$1]);
    }
    for (let i$2 = 0; i$2 < nsize; ++i$2) {
      const tail = ndata_tail[i$2];
      if (tail !== undefined) {
        tail.next = undefined;
      }
      
    }
    return;
  }
  
}

function add(h, key) {
  add0(h, key, h.hash, h.eq);
}

function has(h, key) {
  const eq = h.eq;
  const h_buckets = h.buckets;
  const nid = h.hash(key) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[nid];
  if (bucket !== undefined) {
    let _cell = bucket;
    while (true) {
      const cell = _cell;
      if (eq(cell.key, key)) {
        return true;
      }
      const nextCell = cell.next;
      if (nextCell === undefined) {
        return false;
      }
      _cell = nextCell;
      continue;
    };
  } else {
    return false;
  }
}

function make(hintSize, id) {
  return Belt__Belt_internalBucketsType.make(id.hash, id.eq, hintSize);
}

function size(h) {
  return h.size;
}

function fromArray(arr, id) {
  const eq = id.eq;
  const hash = id.hash;
  const len = arr.length;
  const v = Belt__Belt_internalBucketsType.make(hash, eq, len);
  for (let i = 0; i < len; ++i) {
    add0(v, arr[i], hash, eq);
  }
  return v;
}

function mergeMany(h, arr) {
  const eq = h.eq;
  const hash = h.hash;
  const len = arr.length;
  for (let i = 0; i < len; ++i) {
    add0(h, arr[i], hash, eq);
  }
}

const clear = Belt__Belt_internalBucketsType.clear;

const isEmpty = Belt__Belt_internalBucketsType.isEmpty;

const copy = Belt__Belt_internalSetBuckets.copy;

const forEachU = Belt__Belt_internalSetBuckets.forEachU;

const forEach = Belt__Belt_internalSetBuckets.forEach;

const reduceU = Belt__Belt_internalSetBuckets.reduceU;

const reduce = Belt__Belt_internalSetBuckets.reduce;

const logStats = Belt__Belt_internalSetBuckets.logStats;

const toArray = Belt__Belt_internalSetBuckets.toArray;

const getBucketHistogram = Belt__Belt_internalSetBuckets.getBucketHistogram;

export {
  make,
  clear,
  isEmpty,
  add,
  copy,
  has,
  remove,
  forEachU,
  forEach,
  reduceU,
  reduce,
  size,
  logStats,
  toArray,
  fromArray,
  mergeMany,
  getBucketHistogram,
}
/* No side effect */
`,__=`// Generated by Melange

import * as Belt__Belt_internalBucketsType from "./belt_internalBucketsType.js";
import * as Belt__Belt_internalSetBuckets from "./belt_internalSetBuckets.js";
import * as Caml_hash_primitive from "melange.js/caml_hash_primitive.js";

function copyBucket(h_buckets, ndata_tail, _old_bucket) {
  while (true) {
    const old_bucket = _old_bucket;
    if (old_bucket === undefined) {
      return;
    }
    const nidx = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, old_bucket.key)) & (h_buckets.length - 1 | 0);
    const tail = ndata_tail[nidx];
    if (tail !== undefined) {
      tail.next = old_bucket;
    } else {
      h_buckets[nidx] = old_bucket;
    }
    ndata_tail[nidx] = old_bucket;
    _old_bucket = old_bucket.next;
    continue;
  };
}

function remove(h, key) {
  const h_buckets = h.buckets;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, key)) & (h_buckets.length - 1 | 0);
  const l = h_buckets[i];
  if (l === undefined) {
    return;
  }
  const next_cell = l.next;
  if (l.key === key) {
    h.size = h.size - 1 | 0;
    h_buckets[i] = next_cell;
    return;
  } else if (next_cell !== undefined) {
    let _prec = l;
    let _cell = next_cell;
    while (true) {
      const cell = _cell;
      const prec = _prec;
      const cell_next = cell.next;
      if (cell.key === key) {
        prec.next = cell_next;
        h.size = h.size - 1 | 0;
        return;
      }
      if (cell_next === undefined) {
        return;
      }
      _cell = cell_next;
      _prec = cell;
      continue;
    };
  } else {
    return;
  }
}

function addBucket(h, key, _cell) {
  while (true) {
    const cell = _cell;
    if (cell.key === key) {
      return;
    }
    const n = cell.next;
    if (n !== undefined) {
      _cell = n;
      continue;
    }
    h.size = h.size + 1 | 0;
    cell.next = {
      key: key,
      next: undefined
    };
    return;
  };
}

function add(h, key) {
  const h_buckets = h.buckets;
  const buckets_len = h_buckets.length;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, key)) & (buckets_len - 1 | 0);
  const l = h_buckets[i];
  if (l !== undefined) {
    addBucket(h, key, l);
  } else {
    h_buckets[i] = {
      key: key,
      next: undefined
    };
    h.size = h.size + 1 | 0;
  }
  if (h.size > (buckets_len << 1)) {
    const odata = h.buckets;
    const osize = odata.length;
    const nsize = (osize << 1);
    if (nsize < osize) {
      return;
    }
    const h_buckets$1 = new Array(nsize);
    const ndata_tail = new Array(nsize);
    h.buckets = h_buckets$1;
    for (let i$1 = 0; i$1 < osize; ++i$1) {
      copyBucket(h_buckets$1, ndata_tail, odata[i$1]);
    }
    for (let i$2 = 0; i$2 < nsize; ++i$2) {
      const tail = ndata_tail[i$2];
      if (tail !== undefined) {
        tail.next = undefined;
      }
      
    }
    return;
  }
  
}

function has(h, key) {
  const h_buckets = h.buckets;
  const nid = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_int(0, key)) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[nid];
  if (bucket !== undefined) {
    let _cell = bucket;
    while (true) {
      const cell = _cell;
      if (cell.key === key) {
        return true;
      }
      const nextCell = cell.next;
      if (nextCell === undefined) {
        return false;
      }
      _cell = nextCell;
      continue;
    };
  } else {
    return false;
  }
}

function make(hintSize) {
  return Belt__Belt_internalBucketsType.make(undefined, undefined, hintSize);
}

function size(h) {
  return h.size;
}

function fromArray(arr) {
  const len = arr.length;
  const v = Belt__Belt_internalBucketsType.make(undefined, undefined, len);
  for (let i = 0; i < len; ++i) {
    add(v, arr[i]);
  }
  return v;
}

function mergeMany(h, arr) {
  const len = arr.length;
  for (let i = 0; i < len; ++i) {
    add(h, arr[i]);
  }
}

const clear = Belt__Belt_internalBucketsType.clear;

const isEmpty = Belt__Belt_internalBucketsType.isEmpty;

const copy = Belt__Belt_internalSetBuckets.copy;

const forEachU = Belt__Belt_internalSetBuckets.forEachU;

const forEach = Belt__Belt_internalSetBuckets.forEach;

const reduceU = Belt__Belt_internalSetBuckets.reduceU;

const reduce = Belt__Belt_internalSetBuckets.reduce;

const logStats = Belt__Belt_internalSetBuckets.logStats;

const toArray = Belt__Belt_internalSetBuckets.toArray;

const getBucketHistogram = Belt__Belt_internalSetBuckets.getBucketHistogram;

export {
  make,
  clear,
  isEmpty,
  add,
  copy,
  has,
  remove,
  forEachU,
  forEach,
  reduceU,
  reduce,
  size,
  logStats,
  toArray,
  fromArray,
  mergeMany,
  getBucketHistogram,
}
/* No side effect */
`,u_=`// Generated by Melange

import * as Belt__Belt_internalBucketsType from "./belt_internalBucketsType.js";
import * as Belt__Belt_internalSetBuckets from "./belt_internalSetBuckets.js";
import * as Caml_hash_primitive from "melange.js/caml_hash_primitive.js";

function copyBucket(h_buckets, ndata_tail, _old_bucket) {
  while (true) {
    const old_bucket = _old_bucket;
    if (old_bucket === undefined) {
      return;
    }
    const nidx = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, old_bucket.key)) & (h_buckets.length - 1 | 0);
    const tail = ndata_tail[nidx];
    if (tail !== undefined) {
      tail.next = old_bucket;
    } else {
      h_buckets[nidx] = old_bucket;
    }
    ndata_tail[nidx] = old_bucket;
    _old_bucket = old_bucket.next;
    continue;
  };
}

function remove(h, key) {
  const h_buckets = h.buckets;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) & (h_buckets.length - 1 | 0);
  const l = h_buckets[i];
  if (l === undefined) {
    return;
  }
  const next_cell = l.next;
  if (l.key === key) {
    h.size = h.size - 1 | 0;
    h_buckets[i] = next_cell;
    return;
  } else if (next_cell !== undefined) {
    let _prec = l;
    let _cell = next_cell;
    while (true) {
      const cell = _cell;
      const prec = _prec;
      const cell_next = cell.next;
      if (cell.key === key) {
        prec.next = cell_next;
        h.size = h.size - 1 | 0;
        return;
      }
      if (cell_next === undefined) {
        return;
      }
      _cell = cell_next;
      _prec = cell;
      continue;
    };
  } else {
    return;
  }
}

function addBucket(h, key, _cell) {
  while (true) {
    const cell = _cell;
    if (cell.key === key) {
      return;
    }
    const n = cell.next;
    if (n !== undefined) {
      _cell = n;
      continue;
    }
    h.size = h.size + 1 | 0;
    cell.next = {
      key: key,
      next: undefined
    };
    return;
  };
}

function add(h, key) {
  const h_buckets = h.buckets;
  const buckets_len = h_buckets.length;
  const i = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) & (buckets_len - 1 | 0);
  const l = h_buckets[i];
  if (l !== undefined) {
    addBucket(h, key, l);
  } else {
    h_buckets[i] = {
      key: key,
      next: undefined
    };
    h.size = h.size + 1 | 0;
  }
  if (h.size > (buckets_len << 1)) {
    const odata = h.buckets;
    const osize = odata.length;
    const nsize = (osize << 1);
    if (nsize < osize) {
      return;
    }
    const h_buckets$1 = new Array(nsize);
    const ndata_tail = new Array(nsize);
    h.buckets = h_buckets$1;
    for (let i$1 = 0; i$1 < osize; ++i$1) {
      copyBucket(h_buckets$1, ndata_tail, odata[i$1]);
    }
    for (let i$2 = 0; i$2 < nsize; ++i$2) {
      const tail = ndata_tail[i$2];
      if (tail !== undefined) {
        tail.next = undefined;
      }
      
    }
    return;
  }
  
}

function has(h, key) {
  const h_buckets = h.buckets;
  const nid = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) & (h_buckets.length - 1 | 0);
  const bucket = h_buckets[nid];
  if (bucket !== undefined) {
    let _cell = bucket;
    while (true) {
      const cell = _cell;
      if (cell.key === key) {
        return true;
      }
      const nextCell = cell.next;
      if (nextCell === undefined) {
        return false;
      }
      _cell = nextCell;
      continue;
    };
  } else {
    return false;
  }
}

function make(hintSize) {
  return Belt__Belt_internalBucketsType.make(undefined, undefined, hintSize);
}

function size(h) {
  return h.size;
}

function fromArray(arr) {
  const len = arr.length;
  const v = Belt__Belt_internalBucketsType.make(undefined, undefined, len);
  for (let i = 0; i < len; ++i) {
    add(v, arr[i]);
  }
  return v;
}

function mergeMany(h, arr) {
  const len = arr.length;
  for (let i = 0; i < len; ++i) {
    add(h, arr[i]);
  }
}

const clear = Belt__Belt_internalBucketsType.clear;

const isEmpty = Belt__Belt_internalBucketsType.isEmpty;

const copy = Belt__Belt_internalSetBuckets.copy;

const forEachU = Belt__Belt_internalSetBuckets.forEachU;

const forEach = Belt__Belt_internalSetBuckets.forEach;

const reduceU = Belt__Belt_internalSetBuckets.reduceU;

const reduce = Belt__Belt_internalSetBuckets.reduce;

const logStats = Belt__Belt_internalSetBuckets.logStats;

const toArray = Belt__Belt_internalSetBuckets.toArray;

const getBucketHistogram = Belt__Belt_internalSetBuckets.getBucketHistogram;

export {
  make,
  clear,
  isEmpty,
  add,
  copy,
  has,
  remove,
  forEachU,
  forEach,
  reduceU,
  reduce,
  size,
  logStats,
  toArray,
  fromArray,
  mergeMany,
  getBucketHistogram,
}
/* No side effect */
`,f_=`// Generated by Melange

import * as Curry from "melange.js/curry.js";

function MakeComparableU(M) {
  return M;
}

function MakeComparable(M) {
  const cmp = M.cmp;
  const cmp$1 = Curry.__2(cmp);
  return {
    cmp: cmp$1
  };
}

function comparableU(cmp) {
  return {
    cmp: cmp
  };
}

function comparable(cmp) {
  const cmp$1 = Curry.__2(cmp);
  return {
    cmp: cmp$1
  };
}

function MakeHashableU(M) {
  return M;
}

function MakeHashable(M) {
  const hash = M.hash;
  const hash$1 = Curry.__1(hash);
  const eq = M.eq;
  const eq$1 = Curry.__2(eq);
  return {
    hash: hash$1,
    eq: eq$1
  };
}

function hashableU(hash, eq) {
  return {
    hash: hash,
    eq: eq
  };
}

function hashable(hash, eq) {
  const hash$1 = Curry.__1(hash);
  const eq$1 = Curry.__2(eq);
  return {
    hash: hash$1,
    eq: eq$1
  };
}

export {
  MakeComparableU,
  MakeComparable,
  comparableU,
  comparable,
  MakeHashableU,
  MakeHashable,
  hashableU,
  hashable,
}
/* No side effect */
`,m_=`// Generated by Melange


function fromString(i) {
  const i$1 = parseInt(i, 10);
  if (isNaN(i$1)) {
    return;
  } else {
    return i$1;
  }
}

export {
  fromString,
}
/* No side effect */
`,d_=`// Generated by Melange

import * as Belt__Belt_Array from "./belt_Array.js";
import * as Belt__Belt_SortArray from "./belt_SortArray.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function head(x) {
  if (x) {
    return Caml_option.some(x.hd);
  }
  
}

function headExn(x) {
  if (x) {
    return x.hd;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
}

function tail(x) {
  if (x) {
    return x.tl;
  }
  
}

function tailExn(x) {
  if (x) {
    return x.tl;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
}

function add(xs, x) {
  return {
    hd: x,
    tl: xs
  };
}

function get(x, n) {
  if (n < 0) {
    return;
  } else {
    let _x = x;
    let _n = n;
    while (true) {
      const n$1 = _n;
      const x$1 = _x;
      if (!x$1) {
        return;
      }
      if (n$1 === 0) {
        return Caml_option.some(x$1.hd);
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue;
    };
  }
}

function getExn(x, n) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  let _x = x;
  let _n = n;
  while (true) {
    const n$1 = _n;
    const x$1 = _x;
    if (x$1) {
      if (n$1 === 0) {
        return x$1.hd;
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function partitionAux(p, _cell, _precX, _precY) {
  while (true) {
    const precY = _precY;
    const precX = _precX;
    const cell = _cell;
    if (!cell) {
      return;
    }
    const t = cell.tl;
    const h = cell.hd;
    const next = {
      hd: h,
      tl: /* [] */ 0
    };
    if (p(h)) {
      precX.tl = next;
      _precX = next;
      _cell = t;
      continue;
    }
    precY.tl = next;
    _precY = next;
    _cell = t;
    continue;
  };
}

function splitAux(_cell, _precX, _precY) {
  while (true) {
    const precY = _precY;
    const precX = _precX;
    const cell = _cell;
    if (!cell) {
      return;
    }
    const match = cell.hd;
    const nextA = {
      hd: match[0],
      tl: /* [] */ 0
    };
    const nextB = {
      hd: match[1],
      tl: /* [] */ 0
    };
    precX.tl = nextA;
    precY.tl = nextB;
    _precY = nextB;
    _precX = nextA;
    _cell = cell.tl;
    continue;
  };
}

function copyAuxCont(_cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return prec;
    }
    const next = {
      hd: cellX.hd,
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue;
  };
}

function copyAuxWitFilter(f, _cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (f(h)) {
      const next = {
        hd: h,
        tl: /* [] */ 0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue;
    }
    _cellX = t;
    continue;
  };
}

function copyAuxWithFilterIndex(f, _cellX, _prec, _i) {
  while (true) {
    const i = _i;
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (f(h, i)) {
      const next = {
        hd: h,
        tl: /* [] */ 0
      };
      prec.tl = next;
      _i = i + 1 | 0;
      _prec = next;
      _cellX = t;
      continue;
    }
    _i = i + 1 | 0;
    _cellX = t;
    continue;
  };
}

function copyAuxWitFilterMap(f, _cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const t = cellX.tl;
    const h = f(cellX.hd);
    if (h !== undefined) {
      const next = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */ 0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue;
    }
    _cellX = t;
    continue;
  };
}

function removeAssocAuxWithMap(_cellX, x, _prec, f) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return false;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (f(h[0], x)) {
      prec.tl = t;
      return true;
    }
    const next = {
      hd: h,
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue;
  };
}

function setAssocAuxWithMap(_cellX, x, k, _prec, eq) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return false;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (eq(h[0], x)) {
      prec.tl = {
        hd: [
          x,
          k
        ],
        tl: t
      };
      return true;
    }
    const next = {
      hd: h,
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue;
  };
}

function copyAuxWithMap(_cellX, _prec, f) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const next = {
      hd: f(cellX.hd),
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue;
  };
}

function zipAux(_cellX, _cellY, _prec) {
  while (true) {
    const prec = _prec;
    const cellY = _cellY;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    if (!cellY) {
      return;
    }
    const next = {
      hd: [
        cellX.hd,
        cellY.hd
      ],
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue;
  };
}

function copyAuxWithMap2(f, _cellX, _cellY, _prec) {
  while (true) {
    const prec = _prec;
    const cellY = _cellY;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    if (!cellY) {
      return;
    }
    const next = {
      hd: f(cellX.hd, cellY.hd),
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue;
  };
}

function copyAuxWithMapI(f, _i, _cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    const i = _i;
    if (!cellX) {
      return;
    }
    const next = {
      hd: f(i, cellX.hd),
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function takeAux(_n, _cell, _prec) {
  while (true) {
    const prec = _prec;
    const cell = _cell;
    const n = _n;
    if (n === 0) {
      return true;
    }
    if (!cell) {
      return false;
    }
    const cell$1 = {
      hd: cell.hd,
      tl: /* [] */ 0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue;
  };
}

function splitAtAux(_n, _cell, _prec) {
  while (true) {
    const prec = _prec;
    const cell = _cell;
    const n = _n;
    if (n === 0) {
      return cell;
    }
    if (!cell) {
      return;
    }
    const cell$1 = {
      hd: cell.hd,
      tl: /* [] */ 0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue;
  };
}

function take(lst, n) {
  if (n < 0) {
    return;
  }
  if (n === 0) {
    return /* [] */ 0;
  }
  if (!lst) {
    return;
  }
  const cell = {
    hd: lst.hd,
    tl: /* [] */ 0
  };
  const has = takeAux(n - 1 | 0, lst.tl, cell);
  if (has) {
    return cell;
  }
  
}

function drop(lst, n) {
  if (n < 0) {
    return;
  } else {
    let _l = lst;
    let _n = n;
    while (true) {
      const n$1 = _n;
      const l = _l;
      if (n$1 === 0) {
        return l;
      }
      if (!l) {
        return;
      }
      _n = n$1 - 1 | 0;
      _l = l.tl;
      continue;
    };
  }
}

function splitAt(lst, n) {
  if (n < 0) {
    return;
  }
  if (n === 0) {
    return [
      /* [] */ 0,
      lst
    ];
  }
  if (!lst) {
    return;
  }
  const cell = {
    hd: lst.hd,
    tl: /* [] */ 0
  };
  const rest = splitAtAux(n - 1 | 0, lst.tl, cell);
  if (rest !== undefined) {
    return [
      cell,
      rest
    ];
  }
  
}

function concat(xs, ys) {
  if (!xs) {
    return ys;
  }
  const cell = {
    hd: xs.hd,
    tl: /* [] */ 0
  };
  copyAuxCont(xs.tl, cell).tl = ys;
  return cell;
}

function mapU(xs, f) {
  if (!xs) {
    return /* [] */ 0;
  }
  const cell = {
    hd: f(xs.hd),
    tl: /* [] */ 0
  };
  copyAuxWithMap(xs.tl, cell, f);
  return cell;
}

function map(xs, f) {
  return mapU(xs, Curry.__1(f));
}

function zipByU(l1, l2, f) {
  if (!l1) {
    return /* [] */ 0;
  }
  if (!l2) {
    return /* [] */ 0;
  }
  const cell = {
    hd: f(l1.hd, l2.hd),
    tl: /* [] */ 0
  };
  copyAuxWithMap2(f, l1.tl, l2.tl, cell);
  return cell;
}

function zipBy(l1, l2, f) {
  return zipByU(l1, l2, Curry.__2(f));
}

function mapWithIndexU(xs, f) {
  if (!xs) {
    return /* [] */ 0;
  }
  const cell = {
    hd: f(0, xs.hd),
    tl: /* [] */ 0
  };
  copyAuxWithMapI(f, 1, xs.tl, cell);
  return cell;
}

function mapWithIndex(xs, f) {
  return mapWithIndexU(xs, Curry.__2(f));
}

function makeByU(n, f) {
  if (n <= 0) {
    return /* [] */ 0;
  }
  const headX = {
    hd: f(0),
    tl: /* [] */ 0
  };
  let cur = headX;
  let i = 1;
  while (i < n) {
    const v = {
      hd: f(i),
      tl: /* [] */ 0
    };
    cur.tl = v;
    cur = v;
    i = i + 1 | 0;
  };
  return headX;
}

function makeBy(n, f) {
  return makeByU(n, Curry.__1(f));
}

function make(n, v) {
  if (n <= 0) {
    return /* [] */ 0;
  }
  const headX = {
    hd: v,
    tl: /* [] */ 0
  };
  let cur = headX;
  let i = 1;
  while (i < n) {
    const v$1 = {
      hd: v,
      tl: /* [] */ 0
    };
    cur.tl = v$1;
    cur = v$1;
    i = i + 1 | 0;
  };
  return headX;
}

function length(xs) {
  let _x = xs;
  let _acc = 0;
  while (true) {
    const acc = _acc;
    const x = _x;
    if (!x) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _x = x.tl;
    continue;
  };
}

function fillAux(arr, _i, _x) {
  while (true) {
    const x = _x;
    const i = _i;
    if (!x) {
      return;
    }
    arr[i] = x.hd;
    _x = x.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function fromArray(a) {
  let _i = a.length - 1 | 0;
  let _res = /* [] */ 0;
  while (true) {
    const res = _res;
    const i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue;
  };
}

function toArray(x) {
  const len = length(x);
  const arr = new Array(len);
  fillAux(arr, 0, x);
  return arr;
}

function shuffle(xs) {
  const v = toArray(xs);
  Belt__Belt_Array.shuffleInPlace(v);
  return fromArray(v);
}

function reverseConcat(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue;
  };
}

function reverse(l) {
  return reverseConcat(l, /* [] */ 0);
}

function flattenAux(_prec, _xs) {
  while (true) {
    const xs = _xs;
    const prec = _prec;
    if (xs) {
      _xs = xs.tl;
      _prec = copyAuxCont(xs.hd, prec);
      continue;
    }
    prec.tl = /* [] */ 0;
    return;
  };
}

function flatten(_xs) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* [] */ 0;
    }
    const match = xs.hd;
    if (match) {
      const cell = {
        hd: match.hd,
        tl: /* [] */ 0
      };
      flattenAux(copyAuxCont(match.tl, cell), xs.tl);
      return cell;
    }
    _xs = xs.tl;
    continue;
  };
}

function concatMany(xs) {
  const len = xs.length;
  if (len === 1) {
    return xs[0];
  }
  if (!len) {
    return /* [] */ 0;
  }
  const len$1 = xs.length;
  let v = xs[len$1 - 1 | 0];
  for (let i = len$1 - 2 | 0; i >= 0; --i) {
    v = concat(xs[i], v);
  }
  return v;
}

function mapReverseU(l, f) {
  let _accu = /* [] */ 0;
  let _xs = l;
  while (true) {
    const xs = _xs;
    const accu = _accu;
    if (!xs) {
      return accu;
    }
    _xs = xs.tl;
    _accu = {
      hd: f(xs.hd),
      tl: accu
    };
    continue;
  };
}

function mapReverse(l, f) {
  return mapReverseU(l, Curry.__1(f));
}

function forEachU(_xs, f) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return;
    }
    f(xs.hd);
    _xs = xs.tl;
    continue;
  };
}

function forEach(xs, f) {
  forEachU(xs, Curry.__1(f));
}

function forEachWithIndexU(l, f) {
  let _xs = l;
  let _i = 0;
  while (true) {
    const i = _i;
    const xs = _xs;
    if (!xs) {
      return;
    }
    f(i, xs.hd);
    _i = i + 1 | 0;
    _xs = xs.tl;
    continue;
  };
}

function forEachWithIndex(l, f) {
  forEachWithIndexU(l, Curry.__2(f));
}

function reduceU(_l, _accu, f) {
  while (true) {
    const accu = _accu;
    const l = _l;
    if (!l) {
      return accu;
    }
    _accu = f(accu, l.hd);
    _l = l.tl;
    continue;
  };
}

function reduce(l, accu, f) {
  return reduceU(l, accu, Curry.__2(f));
}

function reduceReverseUnsafeU(l, accu, f) {
  if (l) {
    return f(reduceReverseUnsafeU(l.tl, accu, f), l.hd);
  } else {
    return accu;
  }
}

function reduceReverseU(l, acc, f) {
  const len = length(l);
  if (len < 1000) {
    return reduceReverseUnsafeU(l, acc, f);
  } else {
    return Belt__Belt_Array.reduceReverseU(toArray(l), acc, f);
  }
}

function reduceReverse(l, accu, f) {
  return reduceReverseU(l, accu, Curry.__2(f));
}

function reduceWithIndexU(l, acc, f) {
  let _l = l;
  let _acc = acc;
  let _i = 0;
  while (true) {
    const i = _i;
    const acc$1 = _acc;
    const l$1 = _l;
    if (!l$1) {
      return acc$1;
    }
    _i = i + 1 | 0;
    _acc = f(acc$1, l$1.hd, i);
    _l = l$1.tl;
    continue;
  };
}

function reduceWithIndex(l, acc, f) {
  return reduceWithIndexU(l, acc, Curry.__3(f));
}

function mapReverse2U(l1, l2, f) {
  let _l1 = l1;
  let _l2 = l2;
  let _accu = /* [] */ 0;
  while (true) {
    const accu = _accu;
    const l2$1 = _l2;
    const l1$1 = _l1;
    if (!l1$1) {
      return accu;
    }
    if (!l2$1) {
      return accu;
    }
    _accu = {
      hd: f(l1$1.hd, l2$1.hd),
      tl: accu
    };
    _l2 = l2$1.tl;
    _l1 = l1$1.tl;
    continue;
  };
}

function mapReverse2(l1, l2, f) {
  return mapReverse2U(l1, l2, Curry.__2(f));
}

function forEach2U(_l1, _l2, f) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return;
    }
    if (!l2) {
      return;
    }
    f(l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function forEach2(l1, l2, f) {
  forEach2U(l1, l2, Curry.__2(f));
}

function reduce2U(_l1, _l2, _accu, f) {
  while (true) {
    const accu = _accu;
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return accu;
    }
    if (!l2) {
      return accu;
    }
    _accu = f(accu, l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function reduce2(l1, l2, acc, f) {
  return reduce2U(l1, l2, acc, Curry.__3(f));
}

function reduceReverse2UnsafeU(l1, l2, accu, f) {
  if (l1 && l2) {
    return f(reduceReverse2UnsafeU(l1.tl, l2.tl, accu, f), l1.hd, l2.hd);
  } else {
    return accu;
  }
}

function reduceReverse2U(l1, l2, acc, f) {
  const len = length(l1);
  if (len < 1000) {
    return reduceReverse2UnsafeU(l1, l2, acc, f);
  } else {
    return Belt__Belt_Array.reduceReverse2U(toArray(l1), toArray(l2), acc, f);
  }
}

function reduceReverse2(l1, l2, acc, f) {
  return reduceReverse2U(l1, l2, acc, Curry.__3(f));
}

function everyU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return true;
    }
    if (!p(xs.hd)) {
      return false;
    }
    _xs = xs.tl;
    continue;
  };
}

function every(xs, p) {
  return everyU(xs, Curry.__1(p));
}

function someU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (p(xs.hd)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function some(xs, p) {
  return someU(xs, Curry.__1(p));
}

function every2U(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return true;
    }
    if (!l2) {
      return true;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function every2(l1, l2, p) {
  return every2U(l1, l2, Curry.__2(p));
}

function cmpByLength(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function cmpU(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    const c = p(l1.hd, l2.hd);
    if (c !== 0) {
      return c;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function cmp(l1, l2, f) {
  return cmpU(l1, l2, Curry.__2(f));
}

function eqU(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function eq(l1, l2, f) {
  return eqU(l1, l2, Curry.__2(f));
}

function some2U(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return false;
    }
    if (!l2) {
      return false;
    }
    if (p(l1.hd, l2.hd)) {
      return true;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function some2(l1, l2, p) {
  return some2U(l1, l2, Curry.__2(p));
}

function hasU(_xs, x, eq) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd, x)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function has(xs, x, eq) {
  return hasU(xs, x, Curry.__2(eq));
}

function getAssocU(_xs, x, eq) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return;
    }
    const match = xs.hd;
    if (eq(match[0], x)) {
      return Caml_option.some(match[1]);
    }
    _xs = xs.tl;
    continue;
  };
}

function getAssoc(xs, x, eq) {
  return getAssocU(xs, x, Curry.__2(eq));
}

function hasAssocU(_xs, x, eq) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd[0], x)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function hasAssoc(xs, x, eq) {
  return hasAssocU(xs, x, Curry.__2(eq));
}

function removeAssocU(xs, x, eq) {
  if (!xs) {
    return /* [] */ 0;
  }
  const l = xs.tl;
  const pair = xs.hd;
  if (eq(pair[0], x)) {
    return l;
  }
  const cell = {
    hd: pair,
    tl: /* [] */ 0
  };
  const removed = removeAssocAuxWithMap(l, x, cell, eq);
  if (removed) {
    return cell;
  } else {
    return xs;
  }
}

function removeAssoc(xs, x, eq) {
  return removeAssocU(xs, x, Curry.__2(eq));
}

function setAssocU(xs, x, k, eq) {
  if (!xs) {
    return {
      hd: [
        x,
        k
      ],
      tl: /* [] */ 0
    };
  }
  const l = xs.tl;
  const pair = xs.hd;
  if (eq(pair[0], x)) {
    return {
      hd: [
        x,
        k
      ],
      tl: l
    };
  }
  const cell = {
    hd: pair,
    tl: /* [] */ 0
  };
  const replaced = setAssocAuxWithMap(l, x, k, cell, eq);
  if (replaced) {
    return cell;
  } else {
    return {
      hd: [
        x,
        k
      ],
      tl: xs
    };
  }
}

function setAssoc(xs, x, k, eq) {
  return setAssocU(xs, x, k, Curry.__2(eq));
}

function sortU(xs, cmp) {
  const arr = toArray(xs);
  Belt__Belt_SortArray.stableSortInPlaceByU(arr, cmp);
  return fromArray(arr);
}

function sort(xs, cmp) {
  return sortU(xs, Curry.__2(cmp));
}

function getByU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return;
    }
    const x = xs.hd;
    if (p(x)) {
      return Caml_option.some(x);
    }
    _xs = xs.tl;
    continue;
  };
}

function getBy(xs, p) {
  return getByU(xs, Curry.__1(p));
}

function keepU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* [] */ 0;
    }
    const t = xs.tl;
    const h = xs.hd;
    if (p(h)) {
      const cell = {
        hd: h,
        tl: /* [] */ 0
      };
      copyAuxWitFilter(p, t, cell);
      return cell;
    }
    _xs = t;
    continue;
  };
}

function keep(xs, p) {
  return keepU(xs, Curry.__1(p));
}

function keepWithIndexU(xs, p) {
  let _xs = xs;
  let _i = 0;
  while (true) {
    const i = _i;
    const xs$1 = _xs;
    if (!xs$1) {
      return /* [] */ 0;
    }
    const t = xs$1.tl;
    const h = xs$1.hd;
    if (p(h, i)) {
      const cell = {
        hd: h,
        tl: /* [] */ 0
      };
      copyAuxWithFilterIndex(p, t, cell, i + 1 | 0);
      return cell;
    }
    _i = i + 1 | 0;
    _xs = t;
    continue;
  };
}

function keepWithIndex(xs, p) {
  return keepWithIndexU(xs, Curry.__2(p));
}

function keepMapU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* [] */ 0;
    }
    const t = xs.tl;
    const h = p(xs.hd);
    if (h !== undefined) {
      const cell = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */ 0
      };
      copyAuxWitFilterMap(p, t, cell);
      return cell;
    }
    _xs = t;
    continue;
  };
}

function keepMap(xs, p) {
  return keepMapU(xs, Curry.__1(p));
}

function partitionU(l, p) {
  if (!l) {
    return [
      /* [] */ 0,
      /* [] */ 0
    ];
  }
  const h = l.hd;
  const nextX = {
    hd: h,
    tl: /* [] */ 0
  };
  const nextY = {
    hd: h,
    tl: /* [] */ 0
  };
  const b = p(h);
  partitionAux(p, l.tl, nextX, nextY);
  if (b) {
    return [
      nextX,
      nextY.tl
    ];
  } else {
    return [
      nextX.tl,
      nextY
    ];
  }
}

function partition(l, p) {
  return partitionU(l, Curry.__1(p));
}

function unzip(xs) {
  if (!xs) {
    return [
      /* [] */ 0,
      /* [] */ 0
    ];
  }
  const match = xs.hd;
  const cellX = {
    hd: match[0],
    tl: /* [] */ 0
  };
  const cellY = {
    hd: match[1],
    tl: /* [] */ 0
  };
  splitAux(xs.tl, cellX, cellY);
  return [
    cellX,
    cellY
  ];
}

function zip(l1, l2) {
  if (!l1) {
    return /* [] */ 0;
  }
  if (!l2) {
    return /* [] */ 0;
  }
  const cell = {
    hd: [
      l1.hd,
      l2.hd
    ],
    tl: /* [] */ 0
  };
  zipAux(l1.tl, l2.tl, cell);
  return cell;
}

const size = length;

export {
  length,
  size,
  head,
  headExn,
  tail,
  tailExn,
  add,
  get,
  getExn,
  make,
  makeByU,
  makeBy,
  shuffle,
  drop,
  take,
  splitAt,
  concat,
  concatMany,
  reverseConcat,
  flatten,
  mapU,
  map,
  zip,
  zipByU,
  zipBy,
  mapWithIndexU,
  mapWithIndex,
  fromArray,
  toArray,
  reverse,
  mapReverseU,
  mapReverse,
  forEachU,
  forEach,
  forEachWithIndexU,
  forEachWithIndex,
  reduceU,
  reduce,
  reduceWithIndexU,
  reduceWithIndex,
  reduceReverseU,
  reduceReverse,
  mapReverse2U,
  mapReverse2,
  forEach2U,
  forEach2,
  reduce2U,
  reduce2,
  reduceReverse2U,
  reduceReverse2,
  everyU,
  every,
  someU,
  some,
  every2U,
  every2,
  some2U,
  some2,
  cmpByLength,
  cmpU,
  cmp,
  eqU,
  eq,
  hasU,
  has,
  getByU,
  getBy,
  keepU,
  keep,
  keepWithIndexU,
  keepWithIndex,
  keepMapU,
  keepMap,
  partitionU,
  partition,
  unzip,
  getAssocU,
  getAssoc,
  hasAssocU,
  hasAssoc,
  removeAssocU,
  removeAssoc,
  setAssocU,
  setAssoc,
  sortU,
  sort,
}
/* No side effect */
`,p_=`// Generated by Melange

import * as Belt__Belt_MapDict from "./belt_MapDict.js";
import * as Curry from "melange.js/curry.js";

function fromArray(data, id) {
  const cmp = id.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_MapDict.fromArray(data, cmp)
  };
}

function remove(m, x) {
  const odata = m.data;
  const cmp = m.cmp;
  const newData = Belt__Belt_MapDict.remove(odata, x, cmp);
  if (newData === odata) {
    return m;
  } else {
    return {
      cmp: cmp,
      data: newData
    };
  }
}

function removeMany(m, x) {
  const cmp = m.cmp;
  const newData = Belt__Belt_MapDict.removeMany(m.data, x, cmp);
  return {
    cmp: cmp,
    data: newData
  };
}

function set(m, key, d) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_MapDict.set(m.data, key, d, cmp)
  };
}

function mergeMany(m, e) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_MapDict.mergeMany(m.data, e, cmp)
  };
}

function updateU(m, key, f) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_MapDict.updateU(m.data, key, f, cmp)
  };
}

function update(m, key, f) {
  return updateU(m, key, Curry.__1(f));
}

function split(m, x) {
  const cmp = m.cmp;
  const match = Belt__Belt_MapDict.split(m.data, x, cmp);
  const match$1 = match[0];
  return [
    [
      {
        cmp: cmp,
        data: match$1[0]
      },
      {
        cmp: cmp,
        data: match$1[1]
      }
    ],
    match[1]
  ];
}

function mergeU(s1, s2, f) {
  const cmp = s1.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_MapDict.mergeU(s1.data, s2.data, f, cmp)
  };
}

function merge(s1, s2, f) {
  return mergeU(s1, s2, Curry.__3(f));
}

function make(id) {
  return {
    cmp: id.cmp,
    data: undefined
  };
}

function isEmpty(map) {
  return Belt__Belt_MapDict.isEmpty(map.data);
}

function findFirstByU(m, f) {
  return Belt__Belt_MapDict.findFirstByU(m.data, f);
}

function findFirstBy(m, f) {
  return Belt__Belt_MapDict.findFirstByU(m.data, Curry.__2(f));
}

function forEachU(m, f) {
  Belt__Belt_MapDict.forEachU(m.data, f);
}

function forEach(m, f) {
  Belt__Belt_MapDict.forEachU(m.data, Curry.__2(f));
}

function reduceU(m, acc, f) {
  return Belt__Belt_MapDict.reduceU(m.data, acc, f);
}

function reduce(m, acc, f) {
  return reduceU(m, acc, Curry.__3(f));
}

function everyU(m, f) {
  return Belt__Belt_MapDict.everyU(m.data, f);
}

function every(m, f) {
  return Belt__Belt_MapDict.everyU(m.data, Curry.__2(f));
}

function someU(m, f) {
  return Belt__Belt_MapDict.someU(m.data, f);
}

function some(m, f) {
  return Belt__Belt_MapDict.someU(m.data, Curry.__2(f));
}

function keepU(m, f) {
  return {
    cmp: m.cmp,
    data: Belt__Belt_MapDict.keepU(m.data, f)
  };
}

function keep(m, f) {
  return keepU(m, Curry.__2(f));
}

function partitionU(m, p) {
  const cmp = m.cmp;
  const match = Belt__Belt_MapDict.partitionU(m.data, p);
  return [
    {
      cmp: cmp,
      data: match[0]
    },
    {
      cmp: cmp,
      data: match[1]
    }
  ];
}

function partition(m, p) {
  return partitionU(m, Curry.__2(p));
}

function mapU(m, f) {
  return {
    cmp: m.cmp,
    data: Belt__Belt_MapDict.mapU(m.data, f)
  };
}

function map(m, f) {
  return mapU(m, Curry.__1(f));
}

function mapWithKeyU(m, f) {
  return {
    cmp: m.cmp,
    data: Belt__Belt_MapDict.mapWithKeyU(m.data, f)
  };
}

function mapWithKey(m, f) {
  return mapWithKeyU(m, Curry.__2(f));
}

function size(map) {
  return Belt__Belt_MapDict.size(map.data);
}

function toList(map) {
  return Belt__Belt_MapDict.toList(map.data);
}

function toArray(m) {
  return Belt__Belt_MapDict.toArray(m.data);
}

function keysToArray(m) {
  return Belt__Belt_MapDict.keysToArray(m.data);
}

function valuesToArray(m) {
  return Belt__Belt_MapDict.valuesToArray(m.data);
}

function minKey(m) {
  return Belt__Belt_MapDict.minKey(m.data);
}

function minKeyUndefined(m) {
  return Belt__Belt_MapDict.minKeyUndefined(m.data);
}

function maxKey(m) {
  return Belt__Belt_MapDict.maxKey(m.data);
}

function maxKeyUndefined(m) {
  return Belt__Belt_MapDict.maxKeyUndefined(m.data);
}

function minimum(m) {
  return Belt__Belt_MapDict.minimum(m.data);
}

function minUndefined(m) {
  return Belt__Belt_MapDict.minUndefined(m.data);
}

function maximum(m) {
  return Belt__Belt_MapDict.maximum(m.data);
}

function maxUndefined(m) {
  return Belt__Belt_MapDict.maxUndefined(m.data);
}

function get(map, x) {
  return Belt__Belt_MapDict.get(map.data, x, map.cmp);
}

function getUndefined(map, x) {
  return Belt__Belt_MapDict.getUndefined(map.data, x, map.cmp);
}

function getWithDefault(map, x, def) {
  return Belt__Belt_MapDict.getWithDefault(map.data, x, def, map.cmp);
}

function getExn(map, x) {
  return Belt__Belt_MapDict.getExn(map.data, x, map.cmp);
}

function has(map, x) {
  return Belt__Belt_MapDict.has(map.data, x, map.cmp);
}

function checkInvariantInternal(m) {
  Belt__Belt_MapDict.checkInvariantInternal(m.data);
}

function eqU(m1, m2, veq) {
  return Belt__Belt_MapDict.eqU(m1.data, m2.data, m1.cmp, veq);
}

function eq(m1, m2, veq) {
  return eqU(m1, m2, Curry.__2(veq));
}

function cmpU(m1, m2, vcmp) {
  return Belt__Belt_MapDict.cmpU(m1.data, m2.data, m1.cmp, vcmp);
}

function cmp(m1, m2, vcmp) {
  return cmpU(m1, m2, Curry.__2(vcmp));
}

function getData(m) {
  return m.data;
}

function getId(m) {
  const cmp = m.cmp;
  return {
    cmp: cmp
  };
}

function packIdData(id, data) {
  return {
    cmp: id.cmp,
    data: data
  };
}

export {
  make,
  isEmpty,
  has,
  cmpU,
  cmp,
  eqU,
  eq,
  findFirstByU,
  findFirstBy,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  size,
  toArray,
  toList,
  fromArray,
  keysToArray,
  valuesToArray,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  remove,
  removeMany,
  set,
  updateU,
  update,
  mergeMany,
  mergeU,
  merge,
  keepU,
  keep,
  partitionU,
  partition,
  split,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
  getData,
  getId,
  packIdData,
  checkInvariantInternal,
}
/* No side effect */
`,h_=`// Generated by Melange

import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function set(t, newK, newD, cmp) {
  if (t === undefined) {
    return Belt__Belt_internalAVLtree.singleton(newK, newD);
  }
  const n = Caml_option.valFromOption(t);
  const k = n.k;
  const c = cmp(newK, k);
  if (c === 0) {
    return Belt__Belt_internalAVLtree.updateValue(n, newD);
  }
  const l = n.l;
  const r = n.r;
  const v = n.v;
  if (c < 0) {
    return Belt__Belt_internalAVLtree.bal(set(l, newK, newD, cmp), k, v, r);
  } else {
    return Belt__Belt_internalAVLtree.bal(l, k, v, set(r, newK, newD, cmp));
  }
}

function updateU(t, newK, f, cmp) {
  if (t !== undefined) {
    const n = Caml_option.valFromOption(t);
    const k = n.k;
    const c = cmp(newK, k);
    if (c === 0) {
      const newD = f(Caml_option.some(n.v));
      if (newD !== undefined) {
        return Belt__Belt_internalAVLtree.updateValue(n, Caml_option.valFromOption(newD));
      }
      const l = n.l;
      const r = n.r;
      if (l === undefined) {
        return r;
      }
      if (r === undefined) {
        return l;
      }
      const rn = Caml_option.valFromOption(r);
      const kr = {
        contents: rn.k
      };
      const vr = {
        contents: rn.v
      };
      const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
      return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
    }
    const l$1 = n.l;
    const r$2 = n.r;
    const v = n.v;
    if (c < 0) {
      const ll = updateU(l$1, newK, f, cmp);
      if (l$1 === ll) {
        return t;
      } else {
        return Belt__Belt_internalAVLtree.bal(ll, k, v, r$2);
      }
    }
    const rr = updateU(r$2, newK, f, cmp);
    if (r$2 === rr) {
      return t;
    } else {
      return Belt__Belt_internalAVLtree.bal(l$1, k, v, rr);
    }
  }
  const newD$1 = f(undefined);
  if (newD$1 !== undefined) {
    return Belt__Belt_internalAVLtree.singleton(newK, Caml_option.valFromOption(newD$1));
  } else {
    return t;
  }
}

function update(t, newK, f, cmp) {
  return updateU(t, newK, Curry.__1(f), cmp);
}

function removeAux0(n, x, cmp) {
  const v = n.k;
  const l = n.l;
  const r = n.r;
  const c = cmp(x, v);
  if (c === 0) {
    if (l === undefined) {
      return r;
    }
    if (r === undefined) {
      return l;
    }
    const rn = Caml_option.valFromOption(r);
    const kr = {
      contents: rn.k
    };
    const vr = {
      contents: rn.v
    };
    const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
    return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
  }
  if (c < 0) {
    if (l === undefined) {
      return n;
    }
    const ll = removeAux0(Caml_option.valFromOption(l), x, cmp);
    if (ll === l) {
      return n;
    } else {
      return Belt__Belt_internalAVLtree.bal(ll, v, n.v, r);
    }
  }
  if (r === undefined) {
    return n;
  }
  const rr = removeAux0(Caml_option.valFromOption(r), x, cmp);
  if (rr === r) {
    return n;
  } else {
    return Belt__Belt_internalAVLtree.bal(l, v, n.v, rr);
  }
}

function remove(n, x, cmp) {
  if (n !== undefined) {
    return removeAux0(n, x, cmp);
  }
  
}

function mergeMany(h, arr, cmp) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    v = set(v, match[0], match[1], cmp);
  }
  return v;
}

function splitAuxPivot(n, x, pres, cmp) {
  const v = n.k;
  const d = n.v;
  const l = n.l;
  const r = n.r;
  const c = cmp(x, v);
  if (c === 0) {
    pres.contents = Caml_option.some(d);
    return [
      l,
      r
    ];
  }
  if (c < 0) {
    if (l === undefined) {
      return [
        undefined,
        n
      ];
    }
    const match = splitAuxPivot(Caml_option.valFromOption(l), x, pres, cmp);
    return [
      match[0],
      Belt__Belt_internalAVLtree.join(match[1], v, d, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined
    ];
  }
  const match$1 = splitAuxPivot(Caml_option.valFromOption(r), x, pres, cmp);
  return [
    Belt__Belt_internalAVLtree.join(l, v, d, match$1[0]),
    match$1[1]
  ];
}

function split(n, x, cmp) {
  if (n === undefined) {
    return [
      [
        undefined,
        undefined
      ],
      undefined
    ];
  }
  const pres = {
    contents: undefined
  };
  const v = splitAuxPivot(n, x, pres, cmp);
  return [
    v,
    pres.contents
  ];
}

function mergeU(s1, s2, f, cmp) {
  if (s1 === undefined) {
    if (s2 !== undefined) {
      return Belt__Belt_internalAVLtree.keepMapU(s2, (function (k, v) {
        return f(k, undefined, Caml_option.some(v));
      }));
    } else {
      return;
    }
  }
  const s1n = Caml_option.valFromOption(s1);
  if (s2 === undefined) {
    return Belt__Belt_internalAVLtree.keepMapU(s1, (function (k, v) {
      return f(k, Caml_option.some(v), undefined);
    }));
  }
  const s2n = Caml_option.valFromOption(s2);
  if (s1n.h >= s2n.h) {
    const v1 = s1n.k;
    const d1 = s1n.v;
    const l1 = s1n.l;
    const r1 = s1n.r;
    const d2 = {
      contents: undefined
    };
    const match = splitAuxPivot(s2n, v1, d2, cmp);
    const d2$1 = d2.contents;
    const newLeft = mergeU(l1, match[0], f, cmp);
    const newD = f(v1, Caml_option.some(d1), d2$1);
    const newRight = mergeU(r1, match[1], f, cmp);
    return Belt__Belt_internalAVLtree.concatOrJoin(newLeft, v1, newD, newRight);
  }
  const v2 = s2n.k;
  const d2$2 = s2n.v;
  const l2 = s2n.l;
  const r2 = s2n.r;
  const d1$1 = {
    contents: undefined
  };
  const match$1 = splitAuxPivot(s1n, v2, d1$1, cmp);
  const d1$2 = d1$1.contents;
  const newLeft$1 = mergeU(match$1[0], l2, f, cmp);
  const newD$1 = f(v2, d1$2, Caml_option.some(d2$2));
  const newRight$1 = mergeU(match$1[1], r2, f, cmp);
  return Belt__Belt_internalAVLtree.concatOrJoin(newLeft$1, v2, newD$1, newRight$1);
}

function merge(s1, s2, f, cmp) {
  return mergeU(s1, s2, Curry.__3(f), cmp);
}

function removeMany(t, keys, cmp) {
  const len = keys.length;
  if (t !== undefined) {
    let _t = t;
    let _i = 0;
    while (true) {
      const i = _i;
      const t$1 = _t;
      if (i >= len) {
        return t$1;
      }
      const ele = keys[i];
      const u = removeAux0(t$1, ele, cmp);
      if (u === undefined) {
        return u;
      }
      _i = i + 1 | 0;
      _t = Caml_option.valFromOption(u);
      continue;
    };
  }
  
}

let empty;

const isEmpty = Belt__Belt_internalAVLtree.isEmpty;

const has = Belt__Belt_internalAVLtree.has;

const cmpU = Belt__Belt_internalAVLtree.cmpU;

const cmp = Belt__Belt_internalAVLtree.cmp;

const eqU = Belt__Belt_internalAVLtree.eqU;

const eq = Belt__Belt_internalAVLtree.eq;

const findFirstByU = Belt__Belt_internalAVLtree.findFirstByU;

const findFirstBy = Belt__Belt_internalAVLtree.findFirstBy;

const forEachU = Belt__Belt_internalAVLtree.forEachU;

const forEach = Belt__Belt_internalAVLtree.forEach;

const reduceU = Belt__Belt_internalAVLtree.reduceU;

const reduce = Belt__Belt_internalAVLtree.reduce;

const everyU = Belt__Belt_internalAVLtree.everyU;

const every = Belt__Belt_internalAVLtree.every;

const someU = Belt__Belt_internalAVLtree.someU;

const some = Belt__Belt_internalAVLtree.some;

const size = Belt__Belt_internalAVLtree.size;

const toList = Belt__Belt_internalAVLtree.toList;

const toArray = Belt__Belt_internalAVLtree.toArray;

const fromArray = Belt__Belt_internalAVLtree.fromArray;

const keysToArray = Belt__Belt_internalAVLtree.keysToArray;

const valuesToArray = Belt__Belt_internalAVLtree.valuesToArray;

const minKey = Belt__Belt_internalAVLtree.minKey;

const minKeyUndefined = Belt__Belt_internalAVLtree.minKeyUndefined;

const maxKey = Belt__Belt_internalAVLtree.maxKey;

const maxKeyUndefined = Belt__Belt_internalAVLtree.maxKeyUndefined;

const minimum = Belt__Belt_internalAVLtree.minimum;

const minUndefined = Belt__Belt_internalAVLtree.minUndefined;

const maximum = Belt__Belt_internalAVLtree.maximum;

const maxUndefined = Belt__Belt_internalAVLtree.maxUndefined;

const get = Belt__Belt_internalAVLtree.get;

const getUndefined = Belt__Belt_internalAVLtree.getUndefined;

const getWithDefault = Belt__Belt_internalAVLtree.getWithDefault;

const getExn = Belt__Belt_internalAVLtree.getExn;

const checkInvariantInternal = Belt__Belt_internalAVLtree.checkInvariantInternal;

const keepU = Belt__Belt_internalAVLtree.keepSharedU;

const keep = Belt__Belt_internalAVLtree.keepShared;

const partitionU = Belt__Belt_internalAVLtree.partitionSharedU;

const partition = Belt__Belt_internalAVLtree.partitionShared;

const mapU = Belt__Belt_internalAVLtree.mapU;

const map = Belt__Belt_internalAVLtree.map;

const mapWithKeyU = Belt__Belt_internalAVLtree.mapWithKeyU;

const mapWithKey = Belt__Belt_internalAVLtree.mapWithKey;

export {
  empty,
  isEmpty,
  has,
  cmpU,
  cmp,
  eqU,
  eq,
  findFirstByU,
  findFirstBy,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  size,
  toList,
  toArray,
  fromArray,
  keysToArray,
  valuesToArray,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  checkInvariantInternal,
  remove,
  removeMany,
  set,
  updateU,
  update,
  mergeU,
  merge,
  mergeMany,
  keepU,
  keep,
  partitionU,
  partition,
  split,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
}
/* No side effect */
`,g_=`// Generated by Melange

import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Belt__Belt_internalMapInt from "./belt_internalMapInt.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function set(t, newK, newD) {
  if (t === undefined) {
    return Belt__Belt_internalAVLtree.singleton(newK, newD);
  }
  const n = Caml_option.valFromOption(t);
  const k = n.k;
  if (newK === k) {
    return Belt__Belt_internalAVLtree.updateValue(n, newD);
  }
  const v = n.v;
  if (newK < k) {
    return Belt__Belt_internalAVLtree.bal(set(n.l, newK, newD), k, v, n.r);
  } else {
    return Belt__Belt_internalAVLtree.bal(n.l, k, v, set(n.r, newK, newD));
  }
}

function updateU(t, x, f) {
  if (t !== undefined) {
    const n = Caml_option.valFromOption(t);
    const k = n.k;
    if (x === k) {
      const data = f(Caml_option.some(n.v));
      if (data !== undefined) {
        return Belt__Belt_internalAVLtree.updateValue(n, Caml_option.valFromOption(data));
      }
      const l = n.l;
      const r = n.r;
      if (l === undefined) {
        return r;
      }
      if (r === undefined) {
        return l;
      }
      const rn = Caml_option.valFromOption(r);
      const kr = {
        contents: rn.k
      };
      const vr = {
        contents: rn.v
      };
      const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
      return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
    }
    const v = n.v;
    const l$1 = n.l;
    const r$2 = n.r;
    if (x < k) {
      const ll = updateU(l$1, x, f);
      if (l$1 === ll) {
        return t;
      } else {
        return Belt__Belt_internalAVLtree.bal(ll, k, v, r$2);
      }
    }
    const rr = updateU(r$2, x, f);
    if (r$2 === rr) {
      return t;
    } else {
      return Belt__Belt_internalAVLtree.bal(l$1, k, v, rr);
    }
  }
  const data$1 = f(undefined);
  if (data$1 !== undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, Caml_option.valFromOption(data$1));
  } else {
    return t;
  }
}

function update(t, x, f) {
  return updateU(t, x, Curry.__1(f));
}

function removeAux(n, x) {
  const v = n.k;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    if (l === undefined) {
      return r;
    }
    if (r === undefined) {
      return l;
    }
    const rn = Caml_option.valFromOption(r);
    const kr = {
      contents: rn.k
    };
    const vr = {
      contents: rn.v
    };
    const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
    return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
  }
  if (x < v) {
    if (l === undefined) {
      return n;
    }
    const ll = removeAux(Caml_option.valFromOption(l), x);
    if (ll === l) {
      return n;
    } else {
      return Belt__Belt_internalAVLtree.bal(ll, v, n.v, r);
    }
  }
  if (r === undefined) {
    return n;
  }
  const rr = removeAux(Caml_option.valFromOption(r), x);
  return Belt__Belt_internalAVLtree.bal(l, v, n.v, rr);
}

function remove(n, x) {
  if (n !== undefined) {
    return removeAux(n, x);
  }
  
}

function removeMany(t, keys) {
  const len = keys.length;
  if (t !== undefined) {
    let _t = t;
    let _i = 0;
    while (true) {
      const i = _i;
      const t$1 = _t;
      if (i >= len) {
        return t$1;
      }
      const ele = keys[i];
      const u = removeAux(t$1, ele);
      if (u === undefined) {
        return u;
      }
      _i = i + 1 | 0;
      _t = Caml_option.valFromOption(u);
      continue;
    };
  }
  
}

function mergeMany(h, arr) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    v = set(v, match[0], match[1]);
  }
  return v;
}

let empty;

const isEmpty = Belt__Belt_internalAVLtree.isEmpty;

const has = Belt__Belt_internalMapInt.has;

const cmpU = Belt__Belt_internalMapInt.cmpU;

const cmp = Belt__Belt_internalMapInt.cmp;

const eqU = Belt__Belt_internalMapInt.eqU;

const eq = Belt__Belt_internalMapInt.eq;

const findFirstByU = Belt__Belt_internalAVLtree.findFirstByU;

const findFirstBy = Belt__Belt_internalAVLtree.findFirstBy;

const forEachU = Belt__Belt_internalAVLtree.forEachU;

const forEach = Belt__Belt_internalAVLtree.forEach;

const reduceU = Belt__Belt_internalAVLtree.reduceU;

const reduce = Belt__Belt_internalAVLtree.reduce;

const everyU = Belt__Belt_internalAVLtree.everyU;

const every = Belt__Belt_internalAVLtree.every;

const someU = Belt__Belt_internalAVLtree.someU;

const some = Belt__Belt_internalAVLtree.some;

const size = Belt__Belt_internalAVLtree.size;

const toList = Belt__Belt_internalAVLtree.toList;

const toArray = Belt__Belt_internalAVLtree.toArray;

const fromArray = Belt__Belt_internalMapInt.fromArray;

const keysToArray = Belt__Belt_internalAVLtree.keysToArray;

const valuesToArray = Belt__Belt_internalAVLtree.valuesToArray;

const minKey = Belt__Belt_internalAVLtree.minKey;

const minKeyUndefined = Belt__Belt_internalAVLtree.minKeyUndefined;

const maxKey = Belt__Belt_internalAVLtree.maxKey;

const maxKeyUndefined = Belt__Belt_internalAVLtree.maxKeyUndefined;

const minimum = Belt__Belt_internalAVLtree.minimum;

const minUndefined = Belt__Belt_internalAVLtree.minUndefined;

const maximum = Belt__Belt_internalAVLtree.maximum;

const maxUndefined = Belt__Belt_internalAVLtree.maxUndefined;

const get = Belt__Belt_internalMapInt.get;

const getUndefined = Belt__Belt_internalMapInt.getUndefined;

const getWithDefault = Belt__Belt_internalMapInt.getWithDefault;

const getExn = Belt__Belt_internalMapInt.getExn;

const checkInvariantInternal = Belt__Belt_internalAVLtree.checkInvariantInternal;

const mergeU = Belt__Belt_internalMapInt.mergeU;

const merge = Belt__Belt_internalMapInt.merge;

const keepU = Belt__Belt_internalAVLtree.keepSharedU;

const keep = Belt__Belt_internalAVLtree.keepShared;

const partitionU = Belt__Belt_internalAVLtree.partitionSharedU;

const partition = Belt__Belt_internalAVLtree.partitionShared;

const split = Belt__Belt_internalMapInt.split;

const mapU = Belt__Belt_internalAVLtree.mapU;

const map = Belt__Belt_internalAVLtree.map;

const mapWithKeyU = Belt__Belt_internalAVLtree.mapWithKeyU;

const mapWithKey = Belt__Belt_internalAVLtree.mapWithKey;

export {
  empty,
  isEmpty,
  has,
  cmpU,
  cmp,
  eqU,
  eq,
  findFirstByU,
  findFirstBy,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  size,
  toList,
  toArray,
  fromArray,
  keysToArray,
  valuesToArray,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  checkInvariantInternal,
  remove,
  removeMany,
  set,
  updateU,
  update,
  mergeU,
  merge,
  mergeMany,
  keepU,
  keep,
  partitionU,
  partition,
  split,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
}
/* No side effect */
`,y_=`// Generated by Melange

import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Belt__Belt_internalMapString from "./belt_internalMapString.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function set(t, newK, newD) {
  if (t === undefined) {
    return Belt__Belt_internalAVLtree.singleton(newK, newD);
  }
  const n = Caml_option.valFromOption(t);
  const k = n.k;
  if (newK === k) {
    return Belt__Belt_internalAVLtree.updateValue(n, newD);
  }
  const v = n.v;
  if (newK < k) {
    return Belt__Belt_internalAVLtree.bal(set(n.l, newK, newD), k, v, n.r);
  } else {
    return Belt__Belt_internalAVLtree.bal(n.l, k, v, set(n.r, newK, newD));
  }
}

function updateU(t, x, f) {
  if (t !== undefined) {
    const n = Caml_option.valFromOption(t);
    const k = n.k;
    if (x === k) {
      const data = f(Caml_option.some(n.v));
      if (data !== undefined) {
        return Belt__Belt_internalAVLtree.updateValue(n, Caml_option.valFromOption(data));
      }
      const l = n.l;
      const r = n.r;
      if (l === undefined) {
        return r;
      }
      if (r === undefined) {
        return l;
      }
      const rn = Caml_option.valFromOption(r);
      const kr = {
        contents: rn.k
      };
      const vr = {
        contents: rn.v
      };
      const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
      return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
    }
    const v = n.v;
    const l$1 = n.l;
    const r$2 = n.r;
    if (x < k) {
      const ll = updateU(l$1, x, f);
      if (l$1 === ll) {
        return t;
      } else {
        return Belt__Belt_internalAVLtree.bal(ll, k, v, r$2);
      }
    }
    const rr = updateU(r$2, x, f);
    if (r$2 === rr) {
      return t;
    } else {
      return Belt__Belt_internalAVLtree.bal(l$1, k, v, rr);
    }
  }
  const data$1 = f(undefined);
  if (data$1 !== undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, Caml_option.valFromOption(data$1));
  } else {
    return t;
  }
}

function update(t, x, f) {
  return updateU(t, x, Curry.__1(f));
}

function removeAux(n, x) {
  const v = n.k;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    if (l === undefined) {
      return r;
    }
    if (r === undefined) {
      return l;
    }
    const rn = Caml_option.valFromOption(r);
    const kr = {
      contents: rn.k
    };
    const vr = {
      contents: rn.v
    };
    const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
    return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
  }
  if (x < v) {
    if (l === undefined) {
      return n;
    }
    const ll = removeAux(Caml_option.valFromOption(l), x);
    if (ll === l) {
      return n;
    } else {
      return Belt__Belt_internalAVLtree.bal(ll, v, n.v, r);
    }
  }
  if (r === undefined) {
    return n;
  }
  const rr = removeAux(Caml_option.valFromOption(r), x);
  return Belt__Belt_internalAVLtree.bal(l, v, n.v, rr);
}

function remove(n, x) {
  if (n !== undefined) {
    return removeAux(n, x);
  }
  
}

function removeMany(t, keys) {
  const len = keys.length;
  if (t !== undefined) {
    let _t = t;
    let _i = 0;
    while (true) {
      const i = _i;
      const t$1 = _t;
      if (i >= len) {
        return t$1;
      }
      const ele = keys[i];
      const u = removeAux(t$1, ele);
      if (u === undefined) {
        return u;
      }
      _i = i + 1 | 0;
      _t = Caml_option.valFromOption(u);
      continue;
    };
  }
  
}

function mergeMany(h, arr) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const match = arr[i];
    v = set(v, match[0], match[1]);
  }
  return v;
}

let empty;

const isEmpty = Belt__Belt_internalAVLtree.isEmpty;

const has = Belt__Belt_internalMapString.has;

const cmpU = Belt__Belt_internalMapString.cmpU;

const cmp = Belt__Belt_internalMapString.cmp;

const eqU = Belt__Belt_internalMapString.eqU;

const eq = Belt__Belt_internalMapString.eq;

const findFirstByU = Belt__Belt_internalAVLtree.findFirstByU;

const findFirstBy = Belt__Belt_internalAVLtree.findFirstBy;

const forEachU = Belt__Belt_internalAVLtree.forEachU;

const forEach = Belt__Belt_internalAVLtree.forEach;

const reduceU = Belt__Belt_internalAVLtree.reduceU;

const reduce = Belt__Belt_internalAVLtree.reduce;

const everyU = Belt__Belt_internalAVLtree.everyU;

const every = Belt__Belt_internalAVLtree.every;

const someU = Belt__Belt_internalAVLtree.someU;

const some = Belt__Belt_internalAVLtree.some;

const size = Belt__Belt_internalAVLtree.size;

const toList = Belt__Belt_internalAVLtree.toList;

const toArray = Belt__Belt_internalAVLtree.toArray;

const fromArray = Belt__Belt_internalMapString.fromArray;

const keysToArray = Belt__Belt_internalAVLtree.keysToArray;

const valuesToArray = Belt__Belt_internalAVLtree.valuesToArray;

const minKey = Belt__Belt_internalAVLtree.minKey;

const minKeyUndefined = Belt__Belt_internalAVLtree.minKeyUndefined;

const maxKey = Belt__Belt_internalAVLtree.maxKey;

const maxKeyUndefined = Belt__Belt_internalAVLtree.maxKeyUndefined;

const minimum = Belt__Belt_internalAVLtree.minimum;

const minUndefined = Belt__Belt_internalAVLtree.minUndefined;

const maximum = Belt__Belt_internalAVLtree.maximum;

const maxUndefined = Belt__Belt_internalAVLtree.maxUndefined;

const get = Belt__Belt_internalMapString.get;

const getUndefined = Belt__Belt_internalMapString.getUndefined;

const getWithDefault = Belt__Belt_internalMapString.getWithDefault;

const getExn = Belt__Belt_internalMapString.getExn;

const checkInvariantInternal = Belt__Belt_internalAVLtree.checkInvariantInternal;

const mergeU = Belt__Belt_internalMapString.mergeU;

const merge = Belt__Belt_internalMapString.merge;

const keepU = Belt__Belt_internalAVLtree.keepSharedU;

const keep = Belt__Belt_internalAVLtree.keepShared;

const partitionU = Belt__Belt_internalAVLtree.partitionSharedU;

const partition = Belt__Belt_internalAVLtree.partitionShared;

const split = Belt__Belt_internalMapString.split;

const mapU = Belt__Belt_internalAVLtree.mapU;

const map = Belt__Belt_internalAVLtree.map;

const mapWithKeyU = Belt__Belt_internalAVLtree.mapWithKeyU;

const mapWithKey = Belt__Belt_internalAVLtree.mapWithKey;

export {
  empty,
  isEmpty,
  has,
  cmpU,
  cmp,
  eqU,
  eq,
  findFirstByU,
  findFirstBy,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  size,
  toList,
  toArray,
  fromArray,
  keysToArray,
  valuesToArray,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  checkInvariantInternal,
  remove,
  removeMany,
  set,
  updateU,
  update,
  mergeU,
  merge,
  mergeMany,
  keepU,
  keep,
  partitionU,
  partition,
  split,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
}
/* No side effect */
`,b_=`// Generated by Melange

import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function removeMutateAux(nt, x, cmp) {
  const k = nt.k;
  const c = cmp(x, k);
  if (c === 0) {
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLtree.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
        return Belt__Belt_internalAVLtree.balMutate(nt);
      } else {
        return l;
      }
    } else if (r !== undefined) {
      return r;
    } else {
      return l;
    }
  }
  if (c < 0) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = removeMutateAux(Caml_option.valFromOption(l$1), x, cmp);
      return Belt__Belt_internalAVLtree.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = removeMutateAux(Caml_option.valFromOption(r$1), x, cmp);
    return Belt__Belt_internalAVLtree.balMutate(nt);
  } else {
    return nt;
  }
}

function remove(d, k) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const newRoot = removeMutateAux(Caml_option.valFromOption(oldRoot), k, d.cmp);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function removeArrayMutateAux(_t, xs, _i, len, cmp) {
  while (true) {
    const i = _i;
    const t = _t;
    if (i >= len) {
      return t;
    }
    const ele = xs[i];
    const u = removeMutateAux(t, ele, cmp);
    if (u === undefined) {
      return;
    }
    _i = i + 1 | 0;
    _t = Caml_option.valFromOption(u);
    continue;
  };
}

function removeMany(d, xs) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const len = xs.length;
  const newRoot = removeArrayMutateAux(Caml_option.valFromOption(oldRoot), xs, 0, len, d.cmp);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function updateDone(t, x, f, cmp) {
  if (t !== undefined) {
    const nt = Caml_option.valFromOption(t);
    const k = nt.k;
    const c = cmp(x, k);
    if (c === 0) {
      const data = f(Caml_option.some(nt.v));
      if (data !== undefined) {
        nt.v = Caml_option.valFromOption(data);
        return nt;
      }
      const l = nt.l;
      const r = nt.r;
      if (l !== undefined) {
        if (r !== undefined) {
          nt.r = Belt__Belt_internalAVLtree.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
          return Belt__Belt_internalAVLtree.balMutate(nt);
        } else {
          return l;
        }
      } else if (r !== undefined) {
        return r;
      } else {
        return l;
      }
    }
    if (c < 0) {
      nt.l = updateDone(nt.l, x, f, cmp);
    } else {
      nt.r = updateDone(nt.r, x, f, cmp);
    }
    return Belt__Belt_internalAVLtree.balMutate(nt);
  }
  const data$1 = f(undefined);
  if (data$1 !== undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, Caml_option.valFromOption(data$1));
  } else {
    return t;
  }
}

function updateU(t, x, f) {
  const oldRoot = t.data;
  const newRoot = updateDone(oldRoot, x, f, t.cmp);
  if (newRoot !== oldRoot) {
    t.data = newRoot;
    return;
  }
  
}

function update(t, x, f) {
  updateU(t, x, Curry.__1(f));
}

function make(id) {
  return {
    cmp: id.cmp,
    data: undefined
  };
}

function clear(m) {
  m.data = undefined;
}

function isEmpty(d) {
  const x = d.data;
  return x === undefined;
}

function minKey(m) {
  return Belt__Belt_internalAVLtree.minKey(m.data);
}

function minKeyUndefined(m) {
  return Belt__Belt_internalAVLtree.minKeyUndefined(m.data);
}

function maxKey(m) {
  return Belt__Belt_internalAVLtree.maxKey(m.data);
}

function maxKeyUndefined(m) {
  return Belt__Belt_internalAVLtree.maxKeyUndefined(m.data);
}

function minimum(m) {
  return Belt__Belt_internalAVLtree.minimum(m.data);
}

function minUndefined(m) {
  return Belt__Belt_internalAVLtree.minUndefined(m.data);
}

function maximum(m) {
  return Belt__Belt_internalAVLtree.maximum(m.data);
}

function maxUndefined(m) {
  return Belt__Belt_internalAVLtree.maxUndefined(m.data);
}

function forEachU(d, f) {
  Belt__Belt_internalAVLtree.forEachU(d.data, f);
}

function forEach(d, f) {
  Belt__Belt_internalAVLtree.forEachU(d.data, Curry.__2(f));
}

function reduceU(d, acc, cb) {
  return Belt__Belt_internalAVLtree.reduceU(d.data, acc, cb);
}

function reduce(d, acc, cb) {
  return reduceU(d, acc, Curry.__3(cb));
}

function everyU(d, p) {
  return Belt__Belt_internalAVLtree.everyU(d.data, p);
}

function every(d, p) {
  return Belt__Belt_internalAVLtree.everyU(d.data, Curry.__2(p));
}

function someU(d, p) {
  return Belt__Belt_internalAVLtree.someU(d.data, p);
}

function some(d, p) {
  return Belt__Belt_internalAVLtree.someU(d.data, Curry.__2(p));
}

function size(d) {
  return Belt__Belt_internalAVLtree.size(d.data);
}

function toList(d) {
  return Belt__Belt_internalAVLtree.toList(d.data);
}

function toArray(d) {
  return Belt__Belt_internalAVLtree.toArray(d.data);
}

function keysToArray(d) {
  return Belt__Belt_internalAVLtree.keysToArray(d.data);
}

function valuesToArray(d) {
  return Belt__Belt_internalAVLtree.valuesToArray(d.data);
}

function checkInvariantInternal(d) {
  Belt__Belt_internalAVLtree.checkInvariantInternal(d.data);
}

function cmpU(m1, m2, cmp) {
  return Belt__Belt_internalAVLtree.cmpU(m1.data, m2.data, m1.cmp, cmp);
}

function cmp(m1, m2, cmp$1) {
  return cmpU(m1, m2, Curry.__2(cmp$1));
}

function eqU(m1, m2, cmp) {
  return Belt__Belt_internalAVLtree.eqU(m1.data, m2.data, m1.cmp, cmp);
}

function eq(m1, m2, cmp) {
  return eqU(m1, m2, Curry.__2(cmp));
}

function mapU(m, f) {
  return {
    cmp: m.cmp,
    data: Belt__Belt_internalAVLtree.mapU(m.data, f)
  };
}

function map(m, f) {
  return mapU(m, Curry.__1(f));
}

function mapWithKeyU(m, f) {
  return {
    cmp: m.cmp,
    data: Belt__Belt_internalAVLtree.mapWithKeyU(m.data, f)
  };
}

function mapWithKey(m, f) {
  return mapWithKeyU(m, Curry.__2(f));
}

function get(m, x) {
  return Belt__Belt_internalAVLtree.get(m.data, x, m.cmp);
}

function getUndefined(m, x) {
  return Belt__Belt_internalAVLtree.getUndefined(m.data, x, m.cmp);
}

function getWithDefault(m, x, def) {
  return Belt__Belt_internalAVLtree.getWithDefault(m.data, x, def, m.cmp);
}

function getExn(m, x) {
  return Belt__Belt_internalAVLtree.getExn(m.data, x, m.cmp);
}

function has(m, x) {
  return Belt__Belt_internalAVLtree.has(m.data, x, m.cmp);
}

function fromArray(data, id) {
  const cmp = id.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_internalAVLtree.fromArray(data, cmp)
  };
}

function set(m, e, v) {
  const oldRoot = m.data;
  const newRoot = Belt__Belt_internalAVLtree.updateMutate(oldRoot, e, v, m.cmp);
  if (newRoot !== oldRoot) {
    m.data = newRoot;
    return;
  }
  
}

function mergeManyAux(t, xs, cmp) {
  let v = t;
  for (let i = 0, i_finish = xs.length; i < i_finish; ++i) {
    const match = xs[i];
    v = Belt__Belt_internalAVLtree.updateMutate(v, match[0], match[1], cmp);
  }
  return v;
}

function mergeMany(d, xs) {
  const oldRoot = d.data;
  const newRoot = mergeManyAux(oldRoot, xs, d.cmp);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

export {
  make,
  clear,
  isEmpty,
  has,
  cmpU,
  cmp,
  eqU,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  size,
  toList,
  toArray,
  fromArray,
  keysToArray,
  valuesToArray,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  checkInvariantInternal,
  remove,
  removeMany,
  set,
  updateU,
  update,
  mergeMany,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
}
/* No side effect */
`,x_=`// Generated by Melange

import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Belt__Belt_internalMapInt from "./belt_internalMapInt.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function make(param) {
  return {
    data: undefined
  };
}

function isEmpty(m) {
  const x = m.data;
  return x === undefined;
}

function clear(m) {
  m.data = undefined;
}

function minKeyUndefined(m) {
  return Belt__Belt_internalAVLtree.minKeyUndefined(m.data);
}

function minKey(m) {
  return Belt__Belt_internalAVLtree.minKey(m.data);
}

function maxKeyUndefined(m) {
  return Belt__Belt_internalAVLtree.maxKeyUndefined(m.data);
}

function maxKey(m) {
  return Belt__Belt_internalAVLtree.maxKey(m.data);
}

function minimum(m) {
  return Belt__Belt_internalAVLtree.minimum(m.data);
}

function minUndefined(m) {
  return Belt__Belt_internalAVLtree.minUndefined(m.data);
}

function maximum(m) {
  return Belt__Belt_internalAVLtree.maximum(m.data);
}

function maxUndefined(m) {
  return Belt__Belt_internalAVLtree.maxUndefined(m.data);
}

function set(m, k, v) {
  const old_data = m.data;
  const v$1 = Belt__Belt_internalMapInt.addMutate(old_data, k, v);
  if (v$1 !== old_data) {
    m.data = v$1;
    return;
  }
  
}

function forEachU(d, f) {
  Belt__Belt_internalAVLtree.forEachU(d.data, f);
}

function forEach(d, f) {
  Belt__Belt_internalAVLtree.forEachU(d.data, Curry.__2(f));
}

function mapU(d, f) {
  return {
    data: Belt__Belt_internalAVLtree.mapU(d.data, f)
  };
}

function map(d, f) {
  return mapU(d, Curry.__1(f));
}

function mapWithKeyU(d, f) {
  return {
    data: Belt__Belt_internalAVLtree.mapWithKeyU(d.data, f)
  };
}

function mapWithKey(d, f) {
  return mapWithKeyU(d, Curry.__2(f));
}

function reduceU(d, acc, f) {
  return Belt__Belt_internalAVLtree.reduceU(d.data, acc, f);
}

function reduce(d, acc, f) {
  return reduceU(d, acc, Curry.__3(f));
}

function everyU(d, f) {
  return Belt__Belt_internalAVLtree.everyU(d.data, f);
}

function every(d, f) {
  return Belt__Belt_internalAVLtree.everyU(d.data, Curry.__2(f));
}

function someU(d, f) {
  return Belt__Belt_internalAVLtree.someU(d.data, f);
}

function some(d, f) {
  return Belt__Belt_internalAVLtree.someU(d.data, Curry.__2(f));
}

function size(d) {
  return Belt__Belt_internalAVLtree.size(d.data);
}

function toList(d) {
  return Belt__Belt_internalAVLtree.toList(d.data);
}

function toArray(d) {
  return Belt__Belt_internalAVLtree.toArray(d.data);
}

function keysToArray(d) {
  return Belt__Belt_internalAVLtree.keysToArray(d.data);
}

function valuesToArray(d) {
  return Belt__Belt_internalAVLtree.valuesToArray(d.data);
}

function checkInvariantInternal(d) {
  Belt__Belt_internalAVLtree.checkInvariantInternal(d.data);
}

function has(d, v) {
  return Belt__Belt_internalMapInt.has(d.data, v);
}

function removeMutateAux(nt, x) {
  const k = nt.k;
  if (x === k) {
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLtree.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
        return Belt__Belt_internalAVLtree.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (x < k) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = removeMutateAux(Caml_option.valFromOption(l$1), x);
      return Belt__Belt_internalAVLtree.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = removeMutateAux(Caml_option.valFromOption(r$1), x);
    return Belt__Belt_internalAVLtree.balMutate(nt);
  } else {
    return nt;
  }
}

function remove(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const newRoot = removeMutateAux(Caml_option.valFromOption(oldRoot), v);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function updateDone(t, x, f) {
  if (t !== undefined) {
    const nt = Caml_option.valFromOption(t);
    const k = nt.k;
    if (k === x) {
      const data = f(Caml_option.some(nt.v));
      if (data !== undefined) {
        nt.v = Caml_option.valFromOption(data);
        return nt;
      }
      const l = nt.l;
      const r = nt.r;
      if (l !== undefined) {
        if (r !== undefined) {
          nt.r = Belt__Belt_internalAVLtree.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
          return Belt__Belt_internalAVLtree.balMutate(nt);
        } else {
          return l;
        }
      } else {
        return r;
      }
    }
    const l$1 = nt.l;
    const r$1 = nt.r;
    if (x < k) {
      const ll = updateDone(l$1, x, f);
      nt.l = ll;
    } else {
      nt.r = updateDone(r$1, x, f);
    }
    return Belt__Belt_internalAVLtree.balMutate(nt);
  }
  const data$1 = f(undefined);
  if (data$1 !== undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, Caml_option.valFromOption(data$1));
  } else {
    return t;
  }
}

function updateU(t, x, f) {
  const oldRoot = t.data;
  const newRoot = updateDone(oldRoot, x, f);
  if (newRoot !== oldRoot) {
    t.data = newRoot;
    return;
  }
  
}

function update(t, x, f) {
  updateU(t, x, Curry.__1(f));
}

function removeArrayMutateAux(_t, xs, _i, len) {
  while (true) {
    const i = _i;
    const t = _t;
    if (i >= len) {
      return t;
    }
    const ele = xs[i];
    const u = removeMutateAux(t, ele);
    if (u === undefined) {
      return;
    }
    _i = i + 1 | 0;
    _t = Caml_option.valFromOption(u);
    continue;
  };
}

function removeMany(d, xs) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const len = xs.length;
  const newRoot = removeArrayMutateAux(Caml_option.valFromOption(oldRoot), xs, 0, len);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function fromArray(xs) {
  return {
    data: Belt__Belt_internalMapInt.fromArray(xs)
  };
}

function cmpU(d0, d1, f) {
  return Belt__Belt_internalMapInt.cmpU(d0.data, d1.data, f);
}

function cmp(d0, d1, f) {
  return cmpU(d0, d1, Curry.__2(f));
}

function eqU(d0, d1, f) {
  return Belt__Belt_internalMapInt.eqU(d0.data, d1.data, f);
}

function eq(d0, d1, f) {
  return eqU(d0, d1, Curry.__2(f));
}

function get(d, x) {
  return Belt__Belt_internalMapInt.get(d.data, x);
}

function getUndefined(d, x) {
  return Belt__Belt_internalMapInt.getUndefined(d.data, x);
}

function getWithDefault(d, x, def) {
  return Belt__Belt_internalMapInt.getWithDefault(d.data, x, def);
}

function getExn(d, x) {
  return Belt__Belt_internalMapInt.getExn(d.data, x);
}

export {
  make,
  clear,
  isEmpty,
  has,
  cmpU,
  cmp,
  eqU,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  size,
  toList,
  toArray,
  fromArray,
  keysToArray,
  valuesToArray,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  checkInvariantInternal,
  remove,
  removeMany,
  set,
  updateU,
  update,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
}
/* No side effect */
`,v_=`// Generated by Melange

import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Belt__Belt_internalMapString from "./belt_internalMapString.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function make(param) {
  return {
    data: undefined
  };
}

function isEmpty(m) {
  const x = m.data;
  return x === undefined;
}

function clear(m) {
  m.data = undefined;
}

function minKeyUndefined(m) {
  return Belt__Belt_internalAVLtree.minKeyUndefined(m.data);
}

function minKey(m) {
  return Belt__Belt_internalAVLtree.minKey(m.data);
}

function maxKeyUndefined(m) {
  return Belt__Belt_internalAVLtree.maxKeyUndefined(m.data);
}

function maxKey(m) {
  return Belt__Belt_internalAVLtree.maxKey(m.data);
}

function minimum(m) {
  return Belt__Belt_internalAVLtree.minimum(m.data);
}

function minUndefined(m) {
  return Belt__Belt_internalAVLtree.minUndefined(m.data);
}

function maximum(m) {
  return Belt__Belt_internalAVLtree.maximum(m.data);
}

function maxUndefined(m) {
  return Belt__Belt_internalAVLtree.maxUndefined(m.data);
}

function set(m, k, v) {
  const old_data = m.data;
  const v$1 = Belt__Belt_internalMapString.addMutate(old_data, k, v);
  if (v$1 !== old_data) {
    m.data = v$1;
    return;
  }
  
}

function forEachU(d, f) {
  Belt__Belt_internalAVLtree.forEachU(d.data, f);
}

function forEach(d, f) {
  Belt__Belt_internalAVLtree.forEachU(d.data, Curry.__2(f));
}

function mapU(d, f) {
  return {
    data: Belt__Belt_internalAVLtree.mapU(d.data, f)
  };
}

function map(d, f) {
  return mapU(d, Curry.__1(f));
}

function mapWithKeyU(d, f) {
  return {
    data: Belt__Belt_internalAVLtree.mapWithKeyU(d.data, f)
  };
}

function mapWithKey(d, f) {
  return mapWithKeyU(d, Curry.__2(f));
}

function reduceU(d, acc, f) {
  return Belt__Belt_internalAVLtree.reduceU(d.data, acc, f);
}

function reduce(d, acc, f) {
  return reduceU(d, acc, Curry.__3(f));
}

function everyU(d, f) {
  return Belt__Belt_internalAVLtree.everyU(d.data, f);
}

function every(d, f) {
  return Belt__Belt_internalAVLtree.everyU(d.data, Curry.__2(f));
}

function someU(d, f) {
  return Belt__Belt_internalAVLtree.someU(d.data, f);
}

function some(d, f) {
  return Belt__Belt_internalAVLtree.someU(d.data, Curry.__2(f));
}

function size(d) {
  return Belt__Belt_internalAVLtree.size(d.data);
}

function toList(d) {
  return Belt__Belt_internalAVLtree.toList(d.data);
}

function toArray(d) {
  return Belt__Belt_internalAVLtree.toArray(d.data);
}

function keysToArray(d) {
  return Belt__Belt_internalAVLtree.keysToArray(d.data);
}

function valuesToArray(d) {
  return Belt__Belt_internalAVLtree.valuesToArray(d.data);
}

function checkInvariantInternal(d) {
  Belt__Belt_internalAVLtree.checkInvariantInternal(d.data);
}

function has(d, v) {
  return Belt__Belt_internalMapString.has(d.data, v);
}

function removeMutateAux(nt, x) {
  const k = nt.k;
  if (x === k) {
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLtree.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
        return Belt__Belt_internalAVLtree.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (x < k) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = removeMutateAux(Caml_option.valFromOption(l$1), x);
      return Belt__Belt_internalAVLtree.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = removeMutateAux(Caml_option.valFromOption(r$1), x);
    return Belt__Belt_internalAVLtree.balMutate(nt);
  } else {
    return nt;
  }
}

function remove(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const newRoot = removeMutateAux(Caml_option.valFromOption(oldRoot), v);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function updateDone(t, x, f) {
  if (t !== undefined) {
    const nt = Caml_option.valFromOption(t);
    const k = nt.k;
    if (k === x) {
      const data = f(Caml_option.some(nt.v));
      if (data !== undefined) {
        nt.v = Caml_option.valFromOption(data);
        return nt;
      }
      const l = nt.l;
      const r = nt.r;
      if (l !== undefined) {
        if (r !== undefined) {
          nt.r = Belt__Belt_internalAVLtree.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
          return Belt__Belt_internalAVLtree.balMutate(nt);
        } else {
          return l;
        }
      } else {
        return r;
      }
    }
    const l$1 = nt.l;
    const r$1 = nt.r;
    if (x < k) {
      const ll = updateDone(l$1, x, f);
      nt.l = ll;
    } else {
      nt.r = updateDone(r$1, x, f);
    }
    return Belt__Belt_internalAVLtree.balMutate(nt);
  }
  const data$1 = f(undefined);
  if (data$1 !== undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, Caml_option.valFromOption(data$1));
  } else {
    return t;
  }
}

function updateU(t, x, f) {
  const oldRoot = t.data;
  const newRoot = updateDone(oldRoot, x, f);
  if (newRoot !== oldRoot) {
    t.data = newRoot;
    return;
  }
  
}

function update(t, x, f) {
  updateU(t, x, Curry.__1(f));
}

function removeArrayMutateAux(_t, xs, _i, len) {
  while (true) {
    const i = _i;
    const t = _t;
    if (i >= len) {
      return t;
    }
    const ele = xs[i];
    const u = removeMutateAux(t, ele);
    if (u === undefined) {
      return;
    }
    _i = i + 1 | 0;
    _t = Caml_option.valFromOption(u);
    continue;
  };
}

function removeMany(d, xs) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const len = xs.length;
  const newRoot = removeArrayMutateAux(Caml_option.valFromOption(oldRoot), xs, 0, len);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function fromArray(xs) {
  return {
    data: Belt__Belt_internalMapString.fromArray(xs)
  };
}

function cmpU(d0, d1, f) {
  return Belt__Belt_internalMapString.cmpU(d0.data, d1.data, f);
}

function cmp(d0, d1, f) {
  return cmpU(d0, d1, Curry.__2(f));
}

function eqU(d0, d1, f) {
  return Belt__Belt_internalMapString.eqU(d0.data, d1.data, f);
}

function eq(d0, d1, f) {
  return eqU(d0, d1, Curry.__2(f));
}

function get(d, x) {
  return Belt__Belt_internalMapString.get(d.data, x);
}

function getUndefined(d, x) {
  return Belt__Belt_internalMapString.getUndefined(d.data, x);
}

function getWithDefault(d, x, def) {
  return Belt__Belt_internalMapString.getWithDefault(d.data, x, def);
}

function getExn(d, x) {
  return Belt__Belt_internalMapString.getExn(d.data, x);
}

export {
  make,
  clear,
  isEmpty,
  has,
  cmpU,
  cmp,
  eqU,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  size,
  toList,
  toArray,
  fromArray,
  keysToArray,
  valuesToArray,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  checkInvariantInternal,
  remove,
  removeMany,
  set,
  updateU,
  update,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
}
/* No side effect */
`,$_=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function make(param) {
  return {
    length: 0,
    first: undefined,
    last: undefined
  };
}

function clear(q) {
  q.length = 0;
  q.first = undefined;
  q.last = undefined;
}

function add(q, x) {
  const cell = {
    content: x,
    next: undefined
  };
  const last = q.last;
  if (last !== undefined) {
    q.length = q.length + 1 | 0;
    Caml_option.valFromOption(last).next = cell;
    q.last = cell;
  } else {
    q.length = 1;
    q.first = cell;
    q.last = cell;
  }
}

function peek(q) {
  const v = q.first;
  if (v !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(v).content);
  }
  
}

function peekUndefined(q) {
  const v = q.first;
  if (v !== undefined) {
    return Caml_option.valFromOption(v).content;
  }
  
}

function peekExn(q) {
  const v = q.first;
  if (v !== undefined) {
    return Caml_option.valFromOption(v).content;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
}

function pop(q) {
  const x = q.first;
  if (x === undefined) {
    return;
  }
  const x$1 = Caml_option.valFromOption(x);
  const next = x$1.next;
  if (next === undefined) {
    clear(q);
    return Caml_option.some(x$1.content);
  } else {
    q.length = q.length - 1 | 0;
    q.first = next;
    return Caml_option.some(x$1.content);
  }
}

function popExn(q) {
  const x = q.first;
  if (x !== undefined) {
    const x$1 = Caml_option.valFromOption(x);
    const next = x$1.next;
    if (next === undefined) {
      clear(q);
      return x$1.content;
    } else {
      q.length = q.length - 1 | 0;
      q.first = next;
      return x$1.content;
    }
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
}

function popUndefined(q) {
  const x = q.first;
  if (x === undefined) {
    return;
  }
  const x$1 = Caml_option.valFromOption(x);
  const next = x$1.next;
  if (next === undefined) {
    clear(q);
    return x$1.content;
  } else {
    q.length = q.length - 1 | 0;
    q.first = next;
    return x$1.content;
  }
}

function copy(q) {
  let qRes = {
    length: q.length,
    first: undefined,
    last: undefined
  };
  let _prev;
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    const prev = _prev;
    if (cell !== undefined) {
      const x = Caml_option.valFromOption(cell);
      const content = x.content;
      const res = {
        content: content,
        next: undefined
      };
      if (prev !== undefined) {
        Caml_option.valFromOption(prev).next = res;
      } else {
        qRes.first = res;
      }
      _cell = x.next;
      _prev = res;
      continue;
    }
    qRes.last = prev;
    return qRes;
  };
}

function mapU(q, f) {
  let qRes = {
    length: q.length,
    first: undefined,
    last: undefined
  };
  let _prev;
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    const prev = _prev;
    if (cell !== undefined) {
      const x = Caml_option.valFromOption(cell);
      const content = f(x.content);
      const res = {
        content: content,
        next: undefined
      };
      if (prev !== undefined) {
        Caml_option.valFromOption(prev).next = res;
      } else {
        qRes.first = res;
      }
      _cell = x.next;
      _prev = res;
      continue;
    }
    qRes.last = prev;
    return qRes;
  };
}

function map(q, f) {
  return mapU(q, Curry.__1(f));
}

function isEmpty(q) {
  return q.length === 0;
}

function size(q) {
  return q.length;
}

function forEachU(q, f) {
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    if (cell === undefined) {
      return;
    }
    const x = Caml_option.valFromOption(cell);
    f(x.content);
    _cell = x.next;
    continue;
  };
}

function forEach(q, f) {
  forEachU(q, Curry.__1(f));
}

function reduceU(q, accu, f) {
  let _accu = accu;
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    const accu$1 = _accu;
    if (cell === undefined) {
      return accu$1;
    }
    const x = Caml_option.valFromOption(cell);
    const accu$2 = f(accu$1, x.content);
    _cell = x.next;
    _accu = accu$2;
    continue;
  };
}

function reduce(q, accu, f) {
  return reduceU(q, accu, Curry.__2(f));
}

function transfer(q1, q2) {
  if (q1.length <= 0) {
    return;
  }
  const l = q2.last;
  if (l !== undefined) {
    q2.length = q2.length + q1.length | 0;
    Caml_option.valFromOption(l).next = q1.first;
    q2.last = q1.last;
    return clear(q1);
  } else {
    q2.length = q1.length;
    q2.first = q1.first;
    q2.last = q1.last;
    return clear(q1);
  }
}

function fillAux(_i, arr, _cell) {
  while (true) {
    const cell = _cell;
    const i = _i;
    if (cell === undefined) {
      return;
    }
    const x = Caml_option.valFromOption(cell);
    arr[i] = x.content;
    _cell = x.next;
    _i = i + 1 | 0;
    continue;
  };
}

function toArray(x) {
  const v = new Array(x.length);
  fillAux(0, v, x.first);
  return v;
}

function fromArray(arr) {
  const q = {
    length: 0,
    first: undefined,
    last: undefined
  };
  for (let i = 0, i_finish = arr.length; i < i_finish; ++i) {
    add(q, arr[i]);
  }
  return q;
}

export {
  make,
  clear,
  isEmpty,
  fromArray,
  add,
  peek,
  peekUndefined,
  peekExn,
  pop,
  popUndefined,
  popExn,
  copy,
  size,
  mapU,
  map,
  forEachU,
  forEach,
  reduceU,
  reduce,
  transfer,
  toArray,
}
/* No side effect */
`,k_=`// Generated by Melange

import * as Belt__Belt_SortArray from "./belt_SortArray.js";
import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function remove0(nt, x, cmp) {
  const k = nt.v;
  const c = cmp(x, k);
  if (c === 0) {
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLset.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
        return Belt__Belt_internalAVLset.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (c < 0) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = remove0(Caml_option.valFromOption(l$1), x, cmp);
      return Belt__Belt_internalAVLset.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = remove0(Caml_option.valFromOption(r$1), x, cmp);
    return Belt__Belt_internalAVLset.balMutate(nt);
  } else {
    return nt;
  }
}

function remove(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const newRoot = remove0(Caml_option.valFromOption(oldRoot), v, d.cmp);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function removeMany0(_t, xs, _i, len, cmp) {
  while (true) {
    const i = _i;
    const t = _t;
    if (i >= len) {
      return t;
    }
    const ele = xs[i];
    const u = remove0(t, ele, cmp);
    if (u === undefined) {
      return;
    }
    _i = i + 1 | 0;
    _t = Caml_option.valFromOption(u);
    continue;
  };
}

function removeMany(d, xs) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const len = xs.length;
  d.data = removeMany0(Caml_option.valFromOption(oldRoot), xs, 0, len, d.cmp);
}

function removeCheck0(nt, x, removed, cmp) {
  const k = nt.v;
  const c = cmp(x, k);
  if (c === 0) {
    removed.contents = true;
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLset.removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(r));
        return Belt__Belt_internalAVLset.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (c < 0) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = removeCheck0(Caml_option.valFromOption(l$1), x, removed, cmp);
      return Belt__Belt_internalAVLset.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = removeCheck0(Caml_option.valFromOption(r$1), x, removed, cmp);
    return Belt__Belt_internalAVLset.balMutate(nt);
  } else {
    return nt;
  }
}

function removeCheck(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return false;
  }
  const removed = {
    contents: false
  };
  const newRoot = removeCheck0(Caml_option.valFromOption(oldRoot), v, removed, d.cmp);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
  }
  return removed.contents;
}

function addCheck0(t, x, added, cmp) {
  if (t !== undefined) {
    const nt = Caml_option.valFromOption(t);
    const k = nt.v;
    const c = cmp(x, k);
    if (c === 0) {
      return t;
    }
    const l = nt.l;
    const r = nt.r;
    if (c < 0) {
      const ll = addCheck0(l, x, added, cmp);
      nt.l = ll;
    } else {
      nt.r = addCheck0(r, x, added, cmp);
    }
    return Belt__Belt_internalAVLset.balMutate(nt);
  }
  added.contents = true;
  return Belt__Belt_internalAVLset.singleton(x);
}

function addCheck(m, e) {
  const oldRoot = m.data;
  const added = {
    contents: false
  };
  const newRoot = addCheck0(oldRoot, e, added, m.cmp);
  if (newRoot !== oldRoot) {
    m.data = newRoot;
  }
  return added.contents;
}

function add(m, e) {
  const oldRoot = m.data;
  const newRoot = Belt__Belt_internalAVLset.addMutate(m.cmp, oldRoot, e);
  if (newRoot !== oldRoot) {
    m.data = newRoot;
    return;
  }
  
}

function addArrayMutate(t, xs, cmp) {
  let v = t;
  for (let i = 0, i_finish = xs.length; i < i_finish; ++i) {
    v = Belt__Belt_internalAVLset.addMutate(cmp, v, xs[i]);
  }
  return v;
}

function mergeMany(d, xs) {
  d.data = addArrayMutate(d.data, xs, d.cmp);
}

function make(id) {
  return {
    cmp: id.cmp,
    data: undefined
  };
}

function isEmpty(d) {
  const n = d.data;
  return n === undefined;
}

function minimum(d) {
  return Belt__Belt_internalAVLset.minimum(d.data);
}

function minUndefined(d) {
  return Belt__Belt_internalAVLset.minUndefined(d.data);
}

function maximum(d) {
  return Belt__Belt_internalAVLset.maximum(d.data);
}

function maxUndefined(d) {
  return Belt__Belt_internalAVLset.maxUndefined(d.data);
}

function forEachU(d, f) {
  Belt__Belt_internalAVLset.forEachU(d.data, f);
}

function forEach(d, f) {
  Belt__Belt_internalAVLset.forEachU(d.data, Curry.__1(f));
}

function reduceU(d, acc, cb) {
  return Belt__Belt_internalAVLset.reduceU(d.data, acc, cb);
}

function reduce(d, acc, cb) {
  return reduceU(d, acc, Curry.__2(cb));
}

function everyU(d, p) {
  return Belt__Belt_internalAVLset.everyU(d.data, p);
}

function every(d, p) {
  return Belt__Belt_internalAVLset.everyU(d.data, Curry.__1(p));
}

function someU(d, p) {
  return Belt__Belt_internalAVLset.someU(d.data, p);
}

function some(d, p) {
  return Belt__Belt_internalAVLset.someU(d.data, Curry.__1(p));
}

function size(d) {
  return Belt__Belt_internalAVLset.size(d.data);
}

function toList(d) {
  return Belt__Belt_internalAVLset.toList(d.data);
}

function toArray(d) {
  return Belt__Belt_internalAVLset.toArray(d.data);
}

function fromSortedArrayUnsafe(xs, id) {
  return {
    cmp: id.cmp,
    data: Belt__Belt_internalAVLset.fromSortedArrayUnsafe(xs)
  };
}

function checkInvariantInternal(d) {
  Belt__Belt_internalAVLset.checkInvariantInternal(d.data);
}

function fromArray(data, id) {
  const cmp = id.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_internalAVLset.fromArray(data, cmp)
  };
}

function cmp(d0, d1) {
  return Belt__Belt_internalAVLset.cmp(d0.data, d1.data, d0.cmp);
}

function eq(d0, d1) {
  return Belt__Belt_internalAVLset.eq(d0.data, d1.data, d0.cmp);
}

function get(d, x) {
  return Belt__Belt_internalAVLset.get(d.data, x, d.cmp);
}

function getUndefined(d, x) {
  return Belt__Belt_internalAVLset.getUndefined(d.data, x, d.cmp);
}

function getExn(d, x) {
  return Belt__Belt_internalAVLset.getExn(d.data, x, d.cmp);
}

function split(d, key) {
  const arr = Belt__Belt_internalAVLset.toArray(d.data);
  const cmp = d.cmp;
  const i = Belt__Belt_SortArray.binarySearchByU(arr, key, cmp);
  const len = arr.length;
  if (i >= 0) {
    return [
      [
        {
          cmp: cmp,
          data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, 0, i)
        },
        {
          cmp: cmp,
          data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, i + 1 | 0, (len - i | 0) - 1 | 0)
        }
      ],
      true
    ];
  }
  const next = (-i | 0) - 1 | 0;
  return [
    [
      {
        cmp: cmp,
        data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, 0, next)
      },
      {
        cmp: cmp,
        data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, next, len - next | 0)
      }
    ],
    false
  ];
}

function keepU(d, p) {
  return {
    cmp: d.cmp,
    data: Belt__Belt_internalAVLset.keepCopyU(d.data, p)
  };
}

function keep(d, p) {
  return keepU(d, Curry.__1(p));
}

function partitionU(d, p) {
  const cmp = d.cmp;
  const match = Belt__Belt_internalAVLset.partitionCopyU(d.data, p);
  return [
    {
      cmp: cmp,
      data: match[0]
    },
    {
      cmp: cmp,
      data: match[1]
    }
  ];
}

function partition(d, p) {
  return partitionU(d, Curry.__1(p));
}

function subset(a, b) {
  return Belt__Belt_internalAVLset.subset(a.data, b.data, a.cmp);
}

function intersect(a, b) {
  const cmp = a.cmp;
  const match = a.data;
  const match$1 = b.data;
  if (match === undefined) {
    return {
      cmp: cmp,
      data: undefined
    };
  }
  if (match$1 === undefined) {
    return {
      cmp: cmp,
      data: undefined
    };
  }
  const datab0 = Caml_option.valFromOption(match$1);
  const dataa0 = Caml_option.valFromOption(match);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (cmp(tmp[sizea - 1 | 0], tmp[sizea]) < 0 || cmp(tmp[totalSize - 1 | 0], tmp[0]) < 0) {
    return {
      cmp: cmp,
      data: undefined
    };
  }
  const tmp2 = new Array(sizea < sizeb ? sizea : sizeb);
  const k = Belt__Belt_SortArray.intersectU(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0, cmp);
  return {
    cmp: cmp,
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function diff(a, b) {
  const cmp = a.cmp;
  const dataa = a.data;
  const match = b.data;
  if (dataa === undefined) {
    return {
      cmp: cmp,
      data: undefined
    };
  }
  if (match === undefined) {
    return {
      cmp: cmp,
      data: Belt__Belt_internalAVLset.copy(dataa)
    };
  }
  const datab0 = Caml_option.valFromOption(match);
  const dataa0 = Caml_option.valFromOption(dataa);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (cmp(tmp[sizea - 1 | 0], tmp[sizea]) < 0 || cmp(tmp[totalSize - 1 | 0], tmp[0]) < 0) {
    return {
      cmp: cmp,
      data: Belt__Belt_internalAVLset.copy(dataa)
    };
  }
  const tmp2 = new Array(sizea);
  const k = Belt__Belt_SortArray.diffU(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0, cmp);
  return {
    cmp: cmp,
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function union(a, b) {
  const cmp = a.cmp;
  const dataa = a.data;
  const datab = b.data;
  if (dataa === undefined) {
    return {
      cmp: cmp,
      data: Belt__Belt_internalAVLset.copy(datab)
    };
  }
  if (datab === undefined) {
    return {
      cmp: cmp,
      data: Belt__Belt_internalAVLset.copy(dataa)
    };
  }
  const datab0 = Caml_option.valFromOption(datab);
  const dataa0 = Caml_option.valFromOption(dataa);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (cmp(tmp[sizea - 1 | 0], tmp[sizea]) < 0) {
    return {
      cmp: cmp,
      data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp, 0, totalSize)
    };
  }
  const tmp2 = new Array(totalSize);
  const k = Belt__Belt_SortArray.unionU(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0, cmp);
  return {
    cmp: cmp,
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function has(d, x) {
  return Belt__Belt_internalAVLset.has(d.data, x, d.cmp);
}

function copy(d) {
  return {
    cmp: d.cmp,
    data: Belt__Belt_internalAVLset.copy(d.data)
  };
}

export {
  make,
  fromArray,
  fromSortedArrayUnsafe,
  copy,
  isEmpty,
  has,
  add,
  addCheck,
  mergeMany,
  remove,
  removeCheck,
  removeMany,
  union,
  intersect,
  diff,
  subset,
  cmp,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  keepU,
  keep,
  partitionU,
  partition,
  size,
  toList,
  toArray,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getExn,
  split,
  checkInvariantInternal,
}
/* No side effect */
`,C_=`// Generated by Melange

import * as Belt__Belt_SortArrayInt from "./belt_SortArrayInt.js";
import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Belt__Belt_internalSetInt from "./belt_internalSetInt.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function remove0(nt, x) {
  const k = nt.v;
  if (x === k) {
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLset.removeMinAuxWithRootMutate(nt, r);
        return Belt__Belt_internalAVLset.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (x < k) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = remove0(l$1, x);
      return Belt__Belt_internalAVLset.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = remove0(r$1, x);
    return Belt__Belt_internalAVLset.balMutate(nt);
  } else {
    return nt;
  }
}

function remove(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const newRoot = remove0(Caml_option.valFromOption(oldRoot), v);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function removeMany0(_t, xs, _i, len) {
  while (true) {
    const i = _i;
    const t = _t;
    if (i >= len) {
      return t;
    }
    const ele = xs[i];
    const u = remove0(t, ele);
    if (u === undefined) {
      return;
    }
    _i = i + 1 | 0;
    _t = u;
    continue;
  };
}

function removeMany(d, xs) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const len = xs.length;
  d.data = removeMany0(Caml_option.valFromOption(oldRoot), xs, 0, len);
}

function removeCheck0(nt, x, removed) {
  const k = nt.v;
  if (x === k) {
    removed.contents = true;
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLset.removeMinAuxWithRootMutate(nt, r);
        return Belt__Belt_internalAVLset.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (x < k) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = removeCheck0(l$1, x, removed);
      return Belt__Belt_internalAVLset.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = removeCheck0(r$1, x, removed);
    return Belt__Belt_internalAVLset.balMutate(nt);
  } else {
    return nt;
  }
}

function removeCheck(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return false;
  }
  const removed = {
    contents: false
  };
  const newRoot = removeCheck0(Caml_option.valFromOption(oldRoot), v, removed);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
  }
  return removed.contents;
}

function addCheck0(t, x, added) {
  if (t !== undefined) {
    const k = t.v;
    if (x === k) {
      return t;
    }
    const l = t.l;
    const r = t.r;
    if (x < k) {
      const ll = addCheck0(l, x, added);
      t.l = ll;
    } else {
      t.r = addCheck0(r, x, added);
    }
    return Belt__Belt_internalAVLset.balMutate(t);
  }
  added.contents = true;
  return Belt__Belt_internalAVLset.singleton(x);
}

function addCheck(m, e) {
  const oldRoot = m.data;
  const added = {
    contents: false
  };
  const newRoot = addCheck0(oldRoot, e, added);
  if (newRoot !== oldRoot) {
    m.data = newRoot;
  }
  return added.contents;
}

function add(d, k) {
  const oldRoot = d.data;
  const v = Belt__Belt_internalSetInt.addMutate(oldRoot, k);
  if (v !== oldRoot) {
    d.data = v;
    return;
  }
  
}

function addArrayMutate(t, xs) {
  let v = t;
  for (let i = 0, i_finish = xs.length; i < i_finish; ++i) {
    v = Belt__Belt_internalSetInt.addMutate(v, xs[i]);
  }
  return v;
}

function mergeMany(d, arr) {
  d.data = addArrayMutate(d.data, arr);
}

function make(param) {
  return {
    data: undefined
  };
}

function isEmpty(d) {
  const n = d.data;
  return n === undefined;
}

function minimum(d) {
  return Belt__Belt_internalAVLset.minimum(d.data);
}

function minUndefined(d) {
  return Belt__Belt_internalAVLset.minUndefined(d.data);
}

function maximum(d) {
  return Belt__Belt_internalAVLset.maximum(d.data);
}

function maxUndefined(d) {
  return Belt__Belt_internalAVLset.maxUndefined(d.data);
}

function forEachU(d, f) {
  Belt__Belt_internalAVLset.forEachU(d.data, f);
}

function forEach(d, f) {
  Belt__Belt_internalAVLset.forEachU(d.data, Curry.__1(f));
}

function reduceU(d, acc, cb) {
  return Belt__Belt_internalAVLset.reduceU(d.data, acc, cb);
}

function reduce(d, acc, cb) {
  return reduceU(d, acc, Curry.__2(cb));
}

function everyU(d, p) {
  return Belt__Belt_internalAVLset.everyU(d.data, p);
}

function every(d, p) {
  return Belt__Belt_internalAVLset.everyU(d.data, Curry.__1(p));
}

function someU(d, p) {
  return Belt__Belt_internalAVLset.someU(d.data, p);
}

function some(d, p) {
  return Belt__Belt_internalAVLset.someU(d.data, Curry.__1(p));
}

function size(d) {
  return Belt__Belt_internalAVLset.size(d.data);
}

function toList(d) {
  return Belt__Belt_internalAVLset.toList(d.data);
}

function toArray(d) {
  return Belt__Belt_internalAVLset.toArray(d.data);
}

function fromSortedArrayUnsafe(xs) {
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayUnsafe(xs)
  };
}

function checkInvariantInternal(d) {
  Belt__Belt_internalAVLset.checkInvariantInternal(d.data);
}

function fromArray(xs) {
  return {
    data: Belt__Belt_internalSetInt.fromArray(xs)
  };
}

function cmp(d0, d1) {
  return Belt__Belt_internalSetInt.cmp(d0.data, d1.data);
}

function eq(d0, d1) {
  return Belt__Belt_internalSetInt.eq(d0.data, d1.data);
}

function get(d, x) {
  return Belt__Belt_internalSetInt.get(d.data, x);
}

function getUndefined(d, x) {
  return Belt__Belt_internalSetInt.getUndefined(d.data, x);
}

function getExn(d, x) {
  return Belt__Belt_internalSetInt.getExn(d.data, x);
}

function split(d, key) {
  const arr = Belt__Belt_internalAVLset.toArray(d.data);
  const i = Belt__Belt_SortArrayInt.binarySearch(arr, key);
  const len = arr.length;
  if (i >= 0) {
    return [
      [
        {
          data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, 0, i)
        },
        {
          data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, i + 1 | 0, (len - i | 0) - 1 | 0)
        }
      ],
      true
    ];
  }
  const next = (-i | 0) - 1 | 0;
  return [
    [
      {
        data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, 0, next)
      },
      {
        data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, next, len - next | 0)
      }
    ],
    false
  ];
}

function keepU(d, p) {
  return {
    data: Belt__Belt_internalAVLset.keepCopyU(d.data, p)
  };
}

function keep(d, p) {
  return keepU(d, Curry.__1(p));
}

function partitionU(d, p) {
  const match = Belt__Belt_internalAVLset.partitionCopyU(d.data, p);
  return [
    {
      data: match[0]
    },
    {
      data: match[1]
    }
  ];
}

function partition(d, p) {
  return partitionU(d, Curry.__1(p));
}

function subset(a, b) {
  return Belt__Belt_internalSetInt.subset(a.data, b.data);
}

function intersect(dataa, datab) {
  const dataa$1 = dataa.data;
  const datab$1 = datab.data;
  if (dataa$1 === undefined) {
    return {
      data: undefined
    };
  }
  if (datab$1 === undefined) {
    return {
      data: undefined
    };
  }
  const datab0 = Caml_option.valFromOption(datab$1);
  const dataa0 = Caml_option.valFromOption(dataa$1);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (tmp[sizea - 1 | 0] < tmp[sizea] || tmp[totalSize - 1 | 0] < tmp[0]) {
    return {
      data: undefined
    };
  }
  const tmp2 = new Array(sizea < sizeb ? sizea : sizeb);
  const k = Belt__Belt_SortArrayInt.intersect(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0);
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function diff(dataa, datab) {
  const dataa$1 = dataa.data;
  const datab$1 = datab.data;
  if (dataa$1 === undefined) {
    return {
      data: undefined
    };
  }
  if (datab$1 === undefined) {
    return {
      data: Belt__Belt_internalAVLset.copy(dataa$1)
    };
  }
  const datab0 = Caml_option.valFromOption(datab$1);
  const dataa0 = Caml_option.valFromOption(dataa$1);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (tmp[sizea - 1 | 0] < tmp[sizea] || tmp[totalSize - 1 | 0] < tmp[0]) {
    return {
      data: Belt__Belt_internalAVLset.copy(dataa$1)
    };
  }
  const tmp2 = new Array(sizea);
  const k = Belt__Belt_SortArrayInt.diff(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0);
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function union(dataa, datab) {
  const dataa$1 = dataa.data;
  const datab$1 = datab.data;
  if (dataa$1 === undefined) {
    return {
      data: Belt__Belt_internalAVLset.copy(datab$1)
    };
  }
  if (datab$1 === undefined) {
    return {
      data: Belt__Belt_internalAVLset.copy(dataa$1)
    };
  }
  const datab0 = Caml_option.valFromOption(datab$1);
  const dataa0 = Caml_option.valFromOption(dataa$1);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (tmp[sizea - 1 | 0] < tmp[sizea]) {
    return {
      data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp, 0, totalSize)
    };
  }
  const tmp2 = new Array(totalSize);
  const k = Belt__Belt_SortArrayInt.union(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0);
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function has(d, x) {
  return Belt__Belt_internalSetInt.has(d.data, x);
}

function copy(d) {
  return {
    data: Belt__Belt_internalAVLset.copy(d.data)
  };
}

export {
  make,
  fromArray,
  fromSortedArrayUnsafe,
  copy,
  isEmpty,
  has,
  add,
  addCheck,
  mergeMany,
  remove,
  removeCheck,
  removeMany,
  union,
  intersect,
  diff,
  subset,
  cmp,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  keepU,
  keep,
  partitionU,
  partition,
  size,
  toList,
  toArray,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getExn,
  split,
  checkInvariantInternal,
}
/* No side effect */
`,E_=`// Generated by Melange

import * as Belt__Belt_SortArrayString from "./belt_SortArrayString.js";
import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Belt__Belt_internalSetString from "./belt_internalSetString.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function remove0(nt, x) {
  const k = nt.v;
  if (x === k) {
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLset.removeMinAuxWithRootMutate(nt, r);
        return Belt__Belt_internalAVLset.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (x < k) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = remove0(l$1, x);
      return Belt__Belt_internalAVLset.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = remove0(r$1, x);
    return Belt__Belt_internalAVLset.balMutate(nt);
  } else {
    return nt;
  }
}

function remove(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const newRoot = remove0(Caml_option.valFromOption(oldRoot), v);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
    return;
  }
  
}

function removeMany0(_t, xs, _i, len) {
  while (true) {
    const i = _i;
    const t = _t;
    if (i >= len) {
      return t;
    }
    const ele = xs[i];
    const u = remove0(t, ele);
    if (u === undefined) {
      return;
    }
    _i = i + 1 | 0;
    _t = u;
    continue;
  };
}

function removeMany(d, xs) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return;
  }
  const len = xs.length;
  d.data = removeMany0(Caml_option.valFromOption(oldRoot), xs, 0, len);
}

function removeCheck0(nt, x, removed) {
  const k = nt.v;
  if (x === k) {
    removed.contents = true;
    const l = nt.l;
    const r = nt.r;
    if (l !== undefined) {
      if (r !== undefined) {
        nt.r = Belt__Belt_internalAVLset.removeMinAuxWithRootMutate(nt, r);
        return Belt__Belt_internalAVLset.balMutate(nt);
      } else {
        return l;
      }
    } else {
      return r;
    }
  }
  if (x < k) {
    const l$1 = nt.l;
    if (l$1 !== undefined) {
      nt.l = removeCheck0(l$1, x, removed);
      return Belt__Belt_internalAVLset.balMutate(nt);
    } else {
      return nt;
    }
  }
  const r$1 = nt.r;
  if (r$1 !== undefined) {
    nt.r = removeCheck0(r$1, x, removed);
    return Belt__Belt_internalAVLset.balMutate(nt);
  } else {
    return nt;
  }
}

function removeCheck(d, v) {
  const oldRoot = d.data;
  if (oldRoot === undefined) {
    return false;
  }
  const removed = {
    contents: false
  };
  const newRoot = removeCheck0(Caml_option.valFromOption(oldRoot), v, removed);
  if (newRoot !== oldRoot) {
    d.data = newRoot;
  }
  return removed.contents;
}

function addCheck0(t, x, added) {
  if (t !== undefined) {
    const k = t.v;
    if (x === k) {
      return t;
    }
    const l = t.l;
    const r = t.r;
    if (x < k) {
      const ll = addCheck0(l, x, added);
      t.l = ll;
    } else {
      t.r = addCheck0(r, x, added);
    }
    return Belt__Belt_internalAVLset.balMutate(t);
  }
  added.contents = true;
  return Belt__Belt_internalAVLset.singleton(x);
}

function addCheck(m, e) {
  const oldRoot = m.data;
  const added = {
    contents: false
  };
  const newRoot = addCheck0(oldRoot, e, added);
  if (newRoot !== oldRoot) {
    m.data = newRoot;
  }
  return added.contents;
}

function add(d, k) {
  const oldRoot = d.data;
  const v = Belt__Belt_internalSetString.addMutate(oldRoot, k);
  if (v !== oldRoot) {
    d.data = v;
    return;
  }
  
}

function addArrayMutate(t, xs) {
  let v = t;
  for (let i = 0, i_finish = xs.length; i < i_finish; ++i) {
    v = Belt__Belt_internalSetString.addMutate(v, xs[i]);
  }
  return v;
}

function mergeMany(d, arr) {
  d.data = addArrayMutate(d.data, arr);
}

function make(param) {
  return {
    data: undefined
  };
}

function isEmpty(d) {
  const n = d.data;
  return n === undefined;
}

function minimum(d) {
  return Belt__Belt_internalAVLset.minimum(d.data);
}

function minUndefined(d) {
  return Belt__Belt_internalAVLset.minUndefined(d.data);
}

function maximum(d) {
  return Belt__Belt_internalAVLset.maximum(d.data);
}

function maxUndefined(d) {
  return Belt__Belt_internalAVLset.maxUndefined(d.data);
}

function forEachU(d, f) {
  Belt__Belt_internalAVLset.forEachU(d.data, f);
}

function forEach(d, f) {
  Belt__Belt_internalAVLset.forEachU(d.data, Curry.__1(f));
}

function reduceU(d, acc, cb) {
  return Belt__Belt_internalAVLset.reduceU(d.data, acc, cb);
}

function reduce(d, acc, cb) {
  return reduceU(d, acc, Curry.__2(cb));
}

function everyU(d, p) {
  return Belt__Belt_internalAVLset.everyU(d.data, p);
}

function every(d, p) {
  return Belt__Belt_internalAVLset.everyU(d.data, Curry.__1(p));
}

function someU(d, p) {
  return Belt__Belt_internalAVLset.someU(d.data, p);
}

function some(d, p) {
  return Belt__Belt_internalAVLset.someU(d.data, Curry.__1(p));
}

function size(d) {
  return Belt__Belt_internalAVLset.size(d.data);
}

function toList(d) {
  return Belt__Belt_internalAVLset.toList(d.data);
}

function toArray(d) {
  return Belt__Belt_internalAVLset.toArray(d.data);
}

function fromSortedArrayUnsafe(xs) {
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayUnsafe(xs)
  };
}

function checkInvariantInternal(d) {
  Belt__Belt_internalAVLset.checkInvariantInternal(d.data);
}

function fromArray(xs) {
  return {
    data: Belt__Belt_internalSetString.fromArray(xs)
  };
}

function cmp(d0, d1) {
  return Belt__Belt_internalSetString.cmp(d0.data, d1.data);
}

function eq(d0, d1) {
  return Belt__Belt_internalSetString.eq(d0.data, d1.data);
}

function get(d, x) {
  return Belt__Belt_internalSetString.get(d.data, x);
}

function getUndefined(d, x) {
  return Belt__Belt_internalSetString.getUndefined(d.data, x);
}

function getExn(d, x) {
  return Belt__Belt_internalSetString.getExn(d.data, x);
}

function split(d, key) {
  const arr = Belt__Belt_internalAVLset.toArray(d.data);
  const i = Belt__Belt_SortArrayString.binarySearch(arr, key);
  const len = arr.length;
  if (i >= 0) {
    return [
      [
        {
          data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, 0, i)
        },
        {
          data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, i + 1 | 0, (len - i | 0) - 1 | 0)
        }
      ],
      true
    ];
  }
  const next = (-i | 0) - 1 | 0;
  return [
    [
      {
        data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, 0, next)
      },
      {
        data: Belt__Belt_internalAVLset.fromSortedArrayAux(arr, next, len - next | 0)
      }
    ],
    false
  ];
}

function keepU(d, p) {
  return {
    data: Belt__Belt_internalAVLset.keepCopyU(d.data, p)
  };
}

function keep(d, p) {
  return keepU(d, Curry.__1(p));
}

function partitionU(d, p) {
  const match = Belt__Belt_internalAVLset.partitionCopyU(d.data, p);
  return [
    {
      data: match[0]
    },
    {
      data: match[1]
    }
  ];
}

function partition(d, p) {
  return partitionU(d, Curry.__1(p));
}

function subset(a, b) {
  return Belt__Belt_internalSetString.subset(a.data, b.data);
}

function intersect(dataa, datab) {
  const dataa$1 = dataa.data;
  const datab$1 = datab.data;
  if (dataa$1 === undefined) {
    return {
      data: undefined
    };
  }
  if (datab$1 === undefined) {
    return {
      data: undefined
    };
  }
  const datab0 = Caml_option.valFromOption(datab$1);
  const dataa0 = Caml_option.valFromOption(dataa$1);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (tmp[sizea - 1 | 0] < tmp[sizea] || tmp[totalSize - 1 | 0] < tmp[0]) {
    return {
      data: undefined
    };
  }
  const tmp2 = new Array(sizea < sizeb ? sizea : sizeb);
  const k = Belt__Belt_SortArrayString.intersect(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0);
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function diff(dataa, datab) {
  const dataa$1 = dataa.data;
  const datab$1 = datab.data;
  if (dataa$1 === undefined) {
    return {
      data: undefined
    };
  }
  if (datab$1 === undefined) {
    return {
      data: Belt__Belt_internalAVLset.copy(dataa$1)
    };
  }
  const datab0 = Caml_option.valFromOption(datab$1);
  const dataa0 = Caml_option.valFromOption(dataa$1);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (tmp[sizea - 1 | 0] < tmp[sizea] || tmp[totalSize - 1 | 0] < tmp[0]) {
    return {
      data: Belt__Belt_internalAVLset.copy(dataa$1)
    };
  }
  const tmp2 = new Array(sizea);
  const k = Belt__Belt_SortArrayString.diff(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0);
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function union(dataa, datab) {
  const dataa$1 = dataa.data;
  const datab$1 = datab.data;
  if (dataa$1 === undefined) {
    return {
      data: Belt__Belt_internalAVLset.copy(datab$1)
    };
  }
  if (datab$1 === undefined) {
    return {
      data: Belt__Belt_internalAVLset.copy(dataa$1)
    };
  }
  const datab0 = Caml_option.valFromOption(datab$1);
  const dataa0 = Caml_option.valFromOption(dataa$1);
  const sizea = Belt__Belt_internalAVLset.lengthNode(dataa0);
  const sizeb = Belt__Belt_internalAVLset.lengthNode(datab0);
  const totalSize = sizea + sizeb | 0;
  const tmp = new Array(totalSize);
  Belt__Belt_internalAVLset.fillArray(dataa0, 0, tmp);
  Belt__Belt_internalAVLset.fillArray(datab0, sizea, tmp);
  if (tmp[sizea - 1 | 0] < tmp[sizea]) {
    return {
      data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp, 0, totalSize)
    };
  }
  const tmp2 = new Array(totalSize);
  const k = Belt__Belt_SortArrayString.union(tmp, 0, sizea, tmp, sizea, sizeb, tmp2, 0);
  return {
    data: Belt__Belt_internalAVLset.fromSortedArrayAux(tmp2, 0, k)
  };
}

function has(d, x) {
  return Belt__Belt_internalSetString.has(d.data, x);
}

function copy(d) {
  return {
    data: Belt__Belt_internalAVLset.copy(d.data)
  };
}

export {
  make,
  fromArray,
  fromSortedArrayUnsafe,
  copy,
  isEmpty,
  has,
  add,
  addCheck,
  mergeMany,
  remove,
  removeCheck,
  removeMany,
  union,
  intersect,
  diff,
  subset,
  cmp,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  keepU,
  keep,
  partitionU,
  partition,
  size,
  toList,
  toArray,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getExn,
  split,
  checkInvariantInternal,
}
/* No side effect */
`,A_=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function make(param) {
  return {
    root: undefined
  };
}

function clear(s) {
  s.root = undefined;
}

function copy(s) {
  return {
    root: s.root
  };
}

function push(s, x) {
  s.root = {
    head: x,
    tail: s.root
  };
}

function topUndefined(s) {
  const x = s.root;
  if (x !== undefined) {
    return Caml_option.valFromOption(x).head;
  }
  
}

function top(s) {
  const x = s.root;
  if (x !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(x).head);
  }
  
}

function isEmpty(s) {
  return s.root === undefined;
}

function popUndefined(s) {
  const x = s.root;
  if (x === undefined) {
    return;
  }
  const x$1 = Caml_option.valFromOption(x);
  s.root = x$1.tail;
  return x$1.head;
}

function pop(s) {
  const x = s.root;
  if (x === undefined) {
    return;
  }
  const x$1 = Caml_option.valFromOption(x);
  s.root = x$1.tail;
  return Caml_option.some(x$1.head);
}

function size(s) {
  const x = s.root;
  if (x !== undefined) {
    let _x = Caml_option.valFromOption(x);
    let _acc = 0;
    while (true) {
      const acc = _acc;
      const x$1 = _x;
      const x$2 = x$1.tail;
      if (x$2 === undefined) {
        return acc + 1 | 0;
      }
      _acc = acc + 1 | 0;
      _x = Caml_option.valFromOption(x$2);
      continue;
    };
  } else {
    return 0;
  }
}

function forEachU(s, f) {
  let _s = s.root;
  while (true) {
    const s$1 = _s;
    if (s$1 === undefined) {
      return;
    }
    const x = Caml_option.valFromOption(s$1);
    f(x.head);
    _s = x.tail;
    continue;
  };
}

function forEach(s, f) {
  forEachU(s, Curry.__1(f));
}

function dynamicPopIterU(s, f) {
  while (true) {
    const match = s.root;
    if (match === undefined) {
      return;
    }
    const match$1 = Caml_option.valFromOption(match);
    s.root = match$1.tail;
    f(match$1.head);
    continue;
  };
}

function dynamicPopIter(s, f) {
  dynamicPopIterU(s, Curry.__1(f));
}

export {
  make,
  clear,
  copy,
  push,
  popUndefined,
  pop,
  topUndefined,
  top,
  isEmpty,
  size,
  forEachU,
  forEach,
  dynamicPopIterU,
  dynamicPopIter,
}
/* No side effect */
`,w_=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function keepU(opt, p) {
  if (opt !== undefined && p(Caml_option.valFromOption(opt))) {
    return opt;
  }
  
}

function keep(opt, p) {
  return keepU(opt, Curry.__1(p));
}

function forEachU(opt, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  }
  
}

function forEach(opt, f) {
  forEachU(opt, Curry.__1(f));
}

function getExn(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
}

function mapWithDefaultU(opt, $$default, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  } else {
    return $$default;
  }
}

function mapWithDefault(opt, $$default, f) {
  return mapWithDefaultU(opt, $$default, Curry.__1(f));
}

function mapU(opt, f) {
  if (opt !== undefined) {
    return Caml_option.some(f(Caml_option.valFromOption(opt)));
  }
  
}

function map(opt, f) {
  return mapU(opt, Curry.__1(f));
}

function flatMapU(opt, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  }
  
}

function flatMap(opt, f) {
  return flatMapU(opt, Curry.__1(f));
}

function getWithDefault(opt, $$default) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    return $$default;
  }
}

function orElse(opt, other) {
  if (opt !== undefined) {
    return opt;
  } else {
    return other;
  }
}

function isSome(param) {
  return param !== undefined;
}

function isNone(x) {
  return x === undefined;
}

function eqU(a, b, f) {
  if (a !== undefined) {
    if (b !== undefined) {
      return f(Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return false;
    }
  } else {
    return b === undefined;
  }
}

function eq(a, b, f) {
  return eqU(a, b, Curry.__2(f));
}

function cmpU(a, b, f) {
  if (a !== undefined) {
    if (b !== undefined) {
      return f(Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return 1;
    }
  } else if (b !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function cmp(a, b, f) {
  return cmpU(a, b, Curry.__2(f));
}

export {
  keepU,
  keep,
  forEachU,
  forEach,
  getExn,
  mapWithDefaultU,
  mapWithDefault,
  mapU,
  map,
  flatMapU,
  flatMap,
  getWithDefault,
  orElse,
  isSome,
  isNone,
  eqU,
  eq,
  cmpU,
  cmp,
}
/* No side effect */
`,S_=`// Generated by Melange

import * as Curry from "melange.js/curry.js";

function forEachU(s, f, action) {
  for (let i = s; i <= f; ++i) {
    action(i);
  }
}

function forEach(s, f, action) {
  forEachU(s, f, Curry.__1(action));
}

function everyU(_s, f, p) {
  while (true) {
    const s = _s;
    if (s > f) {
      return true;
    }
    if (!p(s)) {
      return false;
    }
    _s = s + 1 | 0;
    continue;
  };
}

function every(s, f, p) {
  return everyU(s, f, Curry.__1(p));
}

function everyByU(s, f, step, p) {
  if (step > 0) {
    let _s = s;
    while (true) {
      const s$1 = _s;
      if (s$1 > f) {
        return true;
      }
      if (!p(s$1)) {
        return false;
      }
      _s = s$1 + step | 0;
      continue;
    };
  } else {
    return true;
  }
}

function everyBy(s, f, step, p) {
  return everyByU(s, f, step, Curry.__1(p));
}

function someU(_s, f, p) {
  while (true) {
    const s = _s;
    if (s > f) {
      return false;
    }
    if (p(s)) {
      return true;
    }
    _s = s + 1 | 0;
    continue;
  };
}

function some(s, f, p) {
  return someU(s, f, Curry.__1(p));
}

function someByU(s, f, step, p) {
  if (step > 0) {
    let _s = s;
    while (true) {
      const s$1 = _s;
      if (s$1 > f) {
        return false;
      }
      if (p(s$1)) {
        return true;
      }
      _s = s$1 + step | 0;
      continue;
    };
  } else {
    return false;
  }
}

function someBy(s, f, step, p) {
  return someByU(s, f, step, Curry.__1(p));
}

export {
  forEachU,
  forEach,
  everyU,
  every,
  everyByU,
  everyBy,
  someU,
  some,
  someByU,
  someBy,
}
/* No side effect */
`,B_=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function getExn(x) {
  if (x.TAG === /* Ok */ 0) {
    return x._0;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
}

function mapWithDefaultU(opt, $$default, f) {
  if (opt.TAG === /* Ok */ 0) {
    return f(opt._0);
  } else {
    return $$default;
  }
}

function mapWithDefault(opt, $$default, f) {
  return mapWithDefaultU(opt, $$default, Curry.__1(f));
}

function mapU(opt, f) {
  if (opt.TAG === /* Ok */ 0) {
    return {
      TAG: /* Ok */ 0,
      _0: f(opt._0)
    };
  } else {
    return {
      TAG: /* Error */ 1,
      _0: opt._0
    };
  }
}

function map(opt, f) {
  return mapU(opt, Curry.__1(f));
}

function flatMapU(opt, f) {
  if (opt.TAG === /* Ok */ 0) {
    return f(opt._0);
  } else {
    return {
      TAG: /* Error */ 1,
      _0: opt._0
    };
  }
}

function flatMap(opt, f) {
  return flatMapU(opt, Curry.__1(f));
}

function getWithDefault(opt, $$default) {
  if (opt.TAG === /* Ok */ 0) {
    return opt._0;
  } else {
    return $$default;
  }
}

function isOk(param) {
  if (param.TAG === /* Ok */ 0) {
    return true;
  } else {
    return false;
  }
}

function isError(param) {
  if (param.TAG === /* Ok */ 0) {
    return false;
  } else {
    return true;
  }
}

function eqU(a, b, f) {
  if (a.TAG === /* Ok */ 0) {
    if (b.TAG === /* Ok */ 0) {
      return f(a._0, b._0);
    } else {
      return false;
    }
  } else if (b.TAG === /* Ok */ 0) {
    return false;
  } else {
    return true;
  }
}

function eq(a, b, f) {
  return eqU(a, b, Curry.__2(f));
}

function cmpU(a, b, f) {
  if (a.TAG === /* Ok */ 0) {
    if (b.TAG === /* Ok */ 0) {
      return f(a._0, b._0);
    } else {
      return 1;
    }
  } else if (b.TAG === /* Ok */ 0) {
    return -1;
  } else {
    return 0;
  }
}

function cmp(a, b, f) {
  return cmpU(a, b, Curry.__2(f));
}

export {
  getExn,
  mapWithDefaultU,
  mapWithDefault,
  mapU,
  map,
  flatMapU,
  flatMap,
  getWithDefault,
  isOk,
  isError,
  eqU,
  eq,
  cmpU,
  cmp,
}
/* No side effect */
`,I_=`// Generated by Melange

import * as Belt__Belt_SetDict from "./belt_SetDict.js";
import * as Curry from "melange.js/curry.js";

function fromArray(data, id) {
  const cmp = id.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_SetDict.fromArray(data, cmp)
  };
}

function remove(m, e) {
  const data = m.data;
  const cmp = m.cmp;
  const newData = Belt__Belt_SetDict.remove(data, e, cmp);
  if (newData === data) {
    return m;
  } else {
    return {
      cmp: cmp,
      data: newData
    };
  }
}

function add(m, e) {
  const data = m.data;
  const cmp = m.cmp;
  const newData = Belt__Belt_SetDict.add(data, e, cmp);
  if (newData === data) {
    return m;
  } else {
    return {
      cmp: cmp,
      data: newData
    };
  }
}

function mergeMany(m, e) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_SetDict.mergeMany(m.data, e, cmp)
  };
}

function removeMany(m, e) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_SetDict.removeMany(m.data, e, cmp)
  };
}

function union(m, n) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_SetDict.union(m.data, n.data, cmp)
  };
}

function intersect(m, n) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_SetDict.intersect(m.data, n.data, cmp)
  };
}

function diff(m, n) {
  const cmp = m.cmp;
  return {
    cmp: cmp,
    data: Belt__Belt_SetDict.diff(m.data, n.data, cmp)
  };
}

function subset(m, n) {
  const cmp = m.cmp;
  return Belt__Belt_SetDict.subset(m.data, n.data, cmp);
}

function split(m, e) {
  const cmp = m.cmp;
  const match = Belt__Belt_SetDict.split(m.data, e, cmp);
  const match$1 = match[0];
  return [
    [
      {
        cmp: cmp,
        data: match$1[0]
      },
      {
        cmp: cmp,
        data: match$1[1]
      }
    ],
    match[1]
  ];
}

function make(id) {
  return {
    cmp: id.cmp,
    data: undefined
  };
}

function isEmpty(m) {
  return Belt__Belt_SetDict.isEmpty(m.data);
}

function cmp(m, n) {
  const cmp$1 = m.cmp;
  return Belt__Belt_SetDict.cmp(m.data, n.data, cmp$1);
}

function eq(m, n) {
  return Belt__Belt_SetDict.eq(m.data, n.data, m.cmp);
}

function forEachU(m, f) {
  Belt__Belt_SetDict.forEachU(m.data, f);
}

function forEach(m, f) {
  Belt__Belt_SetDict.forEachU(m.data, Curry.__1(f));
}

function reduceU(m, acc, f) {
  return Belt__Belt_SetDict.reduceU(m.data, acc, f);
}

function reduce(m, acc, f) {
  return reduceU(m, acc, Curry.__2(f));
}

function everyU(m, f) {
  return Belt__Belt_SetDict.everyU(m.data, f);
}

function every(m, f) {
  return Belt__Belt_SetDict.everyU(m.data, Curry.__1(f));
}

function someU(m, f) {
  return Belt__Belt_SetDict.someU(m.data, f);
}

function some(m, f) {
  return Belt__Belt_SetDict.someU(m.data, Curry.__1(f));
}

function keepU(m, f) {
  return {
    cmp: m.cmp,
    data: Belt__Belt_SetDict.keepU(m.data, f)
  };
}

function keep(m, f) {
  return keepU(m, Curry.__1(f));
}

function partitionU(m, f) {
  const match = Belt__Belt_SetDict.partitionU(m.data, f);
  const cmp = m.cmp;
  return [
    {
      cmp: cmp,
      data: match[0]
    },
    {
      cmp: cmp,
      data: match[1]
    }
  ];
}

function partition(m, f) {
  return partitionU(m, Curry.__1(f));
}

function size(m) {
  return Belt__Belt_SetDict.size(m.data);
}

function toList(m) {
  return Belt__Belt_SetDict.toList(m.data);
}

function toArray(m) {
  return Belt__Belt_SetDict.toArray(m.data);
}

function minimum(m) {
  return Belt__Belt_SetDict.minimum(m.data);
}

function minUndefined(m) {
  return Belt__Belt_SetDict.minUndefined(m.data);
}

function maximum(m) {
  return Belt__Belt_SetDict.maximum(m.data);
}

function maxUndefined(m) {
  return Belt__Belt_SetDict.maxUndefined(m.data);
}

function get(m, e) {
  return Belt__Belt_SetDict.get(m.data, e, m.cmp);
}

function getUndefined(m, e) {
  return Belt__Belt_SetDict.getUndefined(m.data, e, m.cmp);
}

function getExn(m, e) {
  return Belt__Belt_SetDict.getExn(m.data, e, m.cmp);
}

function has(m, e) {
  return Belt__Belt_SetDict.has(m.data, e, m.cmp);
}

function fromSortedArrayUnsafe(xs, id) {
  return {
    cmp: id.cmp,
    data: Belt__Belt_SetDict.fromSortedArrayUnsafe(xs)
  };
}

function getData(m) {
  return m.data;
}

function getId(m) {
  const cmp = m.cmp;
  return {
    cmp: cmp
  };
}

function packIdData(id, data) {
  return {
    cmp: id.cmp,
    data: data
  };
}

function checkInvariantInternal(d) {
  Belt__Belt_SetDict.checkInvariantInternal(d.data);
}

export {
  make,
  fromArray,
  fromSortedArrayUnsafe,
  isEmpty,
  has,
  add,
  mergeMany,
  remove,
  removeMany,
  union,
  intersect,
  diff,
  subset,
  cmp,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  keepU,
  keep,
  partitionU,
  partition,
  size,
  toArray,
  toList,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getExn,
  split,
  checkInvariantInternal,
  getData,
  getId,
  packIdData,
}
/* No side effect */
`,j_=`// Generated by Melange

import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Caml_option from "melange.js/caml_option.js";

function add(t, x, cmp) {
  if (t === undefined) {
    return Belt__Belt_internalAVLset.singleton(x);
  }
  const nt = Caml_option.valFromOption(t);
  const k = nt.v;
  const c = cmp(x, k);
  if (c === 0) {
    return t;
  }
  const l = nt.l;
  const r = nt.r;
  if (c < 0) {
    const ll = add(l, x, cmp);
    if (ll === l) {
      return t;
    } else {
      return Belt__Belt_internalAVLset.bal(ll, k, r);
    }
  }
  const rr = add(r, x, cmp);
  if (rr === r) {
    return t;
  } else {
    return Belt__Belt_internalAVLset.bal(l, k, rr);
  }
}

function remove(t, x, cmp) {
  if (t === undefined) {
    return t;
  }
  const n = Caml_option.valFromOption(t);
  const v = n.v;
  const l = n.l;
  const r = n.r;
  const c = cmp(x, v);
  if (c === 0) {
    if (l === undefined) {
      return r;
    }
    if (r === undefined) {
      return l;
    }
    const rn = Caml_option.valFromOption(r);
    const v$1 = {
      contents: rn.v
    };
    const r$1 = Belt__Belt_internalAVLset.removeMinAuxWithRef(rn, v$1);
    return Belt__Belt_internalAVLset.bal(l, v$1.contents, r$1);
  }
  if (c < 0) {
    const ll = remove(l, x, cmp);
    if (ll === l) {
      return t;
    } else {
      return Belt__Belt_internalAVLset.bal(ll, v, r);
    }
  }
  const rr = remove(r, x, cmp);
  if (rr === r) {
    return t;
  } else {
    return Belt__Belt_internalAVLset.bal(l, v, rr);
  }
}

function mergeMany(h, arr, cmp) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const key = arr[i];
    v = add(v, key, cmp);
  }
  return v;
}

function removeMany(h, arr, cmp) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const key = arr[i];
    v = remove(v, key, cmp);
  }
  return v;
}

function splitAuxNoPivot(cmp, n, x) {
  const v = n.v;
  const l = n.l;
  const r = n.r;
  const c = cmp(x, v);
  if (c === 0) {
    return [
      l,
      r
    ];
  }
  if (c < 0) {
    if (l === undefined) {
      return [
        undefined,
        n
      ];
    }
    const match = splitAuxNoPivot(cmp, Caml_option.valFromOption(l), x);
    return [
      match[0],
      Belt__Belt_internalAVLset.joinShared(match[1], v, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined
    ];
  }
  const match$1 = splitAuxNoPivot(cmp, Caml_option.valFromOption(r), x);
  return [
    Belt__Belt_internalAVLset.joinShared(l, v, match$1[0]),
    match$1[1]
  ];
}

function splitAuxPivot(cmp, n, x, pres) {
  const v = n.v;
  const l = n.l;
  const r = n.r;
  const c = cmp(x, v);
  if (c === 0) {
    pres.contents = true;
    return [
      l,
      r
    ];
  }
  if (c < 0) {
    if (l === undefined) {
      return [
        undefined,
        n
      ];
    }
    const match = splitAuxPivot(cmp, Caml_option.valFromOption(l), x, pres);
    return [
      match[0],
      Belt__Belt_internalAVLset.joinShared(match[1], v, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined
    ];
  }
  const match$1 = splitAuxPivot(cmp, Caml_option.valFromOption(r), x, pres);
  return [
    Belt__Belt_internalAVLset.joinShared(l, v, match$1[0]),
    match$1[1]
  ];
}

function split(t, x, cmp) {
  if (t === undefined) {
    return [
      [
        undefined,
        undefined
      ],
      false
    ];
  }
  const pres = {
    contents: false
  };
  const v = splitAuxPivot(cmp, Caml_option.valFromOption(t), x, pres);
  return [
    v,
    pres.contents
  ];
}

function union(s1, s2, cmp) {
  if (s1 === undefined) {
    return s2;
  }
  if (s2 === undefined) {
    return s1;
  }
  const n2 = Caml_option.valFromOption(s2);
  const n1 = Caml_option.valFromOption(s1);
  const h1 = n1.h;
  const h2 = n2.h;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add(s1, n2.v, cmp);
    }
    const v1 = n1.v;
    const l1 = n1.l;
    const r1 = n1.r;
    const match = splitAuxNoPivot(cmp, n2, v1);
    return Belt__Belt_internalAVLset.joinShared(union(l1, match[0], cmp), v1, union(r1, match[1], cmp));
  }
  if (h1 === 1) {
    return add(s2, n1.v, cmp);
  }
  const v2 = n2.v;
  const l2 = n2.l;
  const r2 = n2.r;
  const match$1 = splitAuxNoPivot(cmp, n1, v2);
  return Belt__Belt_internalAVLset.joinShared(union(match$1[0], l2, cmp), v2, union(match$1[1], r2, cmp));
}

function intersect(s1, s2, cmp) {
  if (s1 === undefined) {
    return;
  }
  if (s2 === undefined) {
    return;
  }
  const n1 = Caml_option.valFromOption(s1);
  const v1 = n1.v;
  const l1 = n1.l;
  const r1 = n1.r;
  const pres = {
    contents: false
  };
  const match = splitAuxPivot(cmp, Caml_option.valFromOption(s2), v1, pres);
  const ll = intersect(l1, match[0], cmp);
  const rr = intersect(r1, match[1], cmp);
  if (pres.contents) {
    return Belt__Belt_internalAVLset.joinShared(ll, v1, rr);
  } else {
    return Belt__Belt_internalAVLset.concatShared(ll, rr);
  }
}

function diff(s1, s2, cmp) {
  if (s1 === undefined) {
    return s1;
  }
  if (s2 === undefined) {
    return s1;
  }
  const n1 = Caml_option.valFromOption(s1);
  const v1 = n1.v;
  const l1 = n1.l;
  const r1 = n1.r;
  const pres = {
    contents: false
  };
  const match = splitAuxPivot(cmp, Caml_option.valFromOption(s2), v1, pres);
  const ll = diff(l1, match[0], cmp);
  const rr = diff(r1, match[1], cmp);
  if (pres.contents) {
    return Belt__Belt_internalAVLset.concatShared(ll, rr);
  } else {
    return Belt__Belt_internalAVLset.joinShared(ll, v1, rr);
  }
}

let empty;

const fromArray = Belt__Belt_internalAVLset.fromArray;

const fromSortedArrayUnsafe = Belt__Belt_internalAVLset.fromSortedArrayUnsafe;

const isEmpty = Belt__Belt_internalAVLset.isEmpty;

const has = Belt__Belt_internalAVLset.has;

const subset = Belt__Belt_internalAVLset.subset;

const cmp = Belt__Belt_internalAVLset.cmp;

const eq = Belt__Belt_internalAVLset.eq;

const forEachU = Belt__Belt_internalAVLset.forEachU;

const forEach = Belt__Belt_internalAVLset.forEach;

const reduceU = Belt__Belt_internalAVLset.reduceU;

const reduce = Belt__Belt_internalAVLset.reduce;

const everyU = Belt__Belt_internalAVLset.everyU;

const every = Belt__Belt_internalAVLset.every;

const someU = Belt__Belt_internalAVLset.someU;

const some = Belt__Belt_internalAVLset.some;

const keepU = Belt__Belt_internalAVLset.keepSharedU;

const keep = Belt__Belt_internalAVLset.keepShared;

const partitionU = Belt__Belt_internalAVLset.partitionSharedU;

const partition = Belt__Belt_internalAVLset.partitionShared;

const size = Belt__Belt_internalAVLset.size;

const toList = Belt__Belt_internalAVLset.toList;

const toArray = Belt__Belt_internalAVLset.toArray;

const minimum = Belt__Belt_internalAVLset.minimum;

const minUndefined = Belt__Belt_internalAVLset.minUndefined;

const maximum = Belt__Belt_internalAVLset.maximum;

const maxUndefined = Belt__Belt_internalAVLset.maxUndefined;

const get = Belt__Belt_internalAVLset.get;

const getUndefined = Belt__Belt_internalAVLset.getUndefined;

const getExn = Belt__Belt_internalAVLset.getExn;

const checkInvariantInternal = Belt__Belt_internalAVLset.checkInvariantInternal;

export {
  empty,
  fromArray,
  fromSortedArrayUnsafe,
  isEmpty,
  has,
  add,
  mergeMany,
  remove,
  removeMany,
  union,
  intersect,
  diff,
  subset,
  cmp,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  keepU,
  keep,
  partitionU,
  partition,
  size,
  toList,
  toArray,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getExn,
  split,
  checkInvariantInternal,
}
/* No side effect */
`,M_=`// Generated by Melange

import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Belt__Belt_internalSetInt from "./belt_internalSetInt.js";
import * as Caml_option from "melange.js/caml_option.js";

function add(t, x) {
  if (t === undefined) {
    return Belt__Belt_internalAVLset.singleton(x);
  }
  const nt = Caml_option.valFromOption(t);
  const v = nt.v;
  if (x === v) {
    return t;
  }
  const l = nt.l;
  const r = nt.r;
  if (x < v) {
    const ll = add(l, x);
    if (ll === l) {
      return t;
    } else {
      return Belt__Belt_internalAVLset.bal(ll, v, r);
    }
  }
  const rr = add(r, x);
  if (rr === r) {
    return t;
  } else {
    return Belt__Belt_internalAVLset.bal(l, v, rr);
  }
}

function mergeMany(h, arr) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const key = arr[i];
    v = add(v, key);
  }
  return v;
}

function remove(t, x) {
  if (t === undefined) {
    return t;
  }
  const n = Caml_option.valFromOption(t);
  const v = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    if (l === undefined) {
      return r;
    }
    if (r === undefined) {
      return l;
    }
    const v$1 = {
      contents: r.v
    };
    const r$1 = Belt__Belt_internalAVLset.removeMinAuxWithRef(r, v$1);
    return Belt__Belt_internalAVLset.bal(l, v$1.contents, r$1);
  }
  if (x < v) {
    const ll = remove(l, x);
    if (ll === l) {
      return t;
    } else {
      return Belt__Belt_internalAVLset.bal(ll, v, r);
    }
  }
  const rr = remove(r, x);
  if (rr === r) {
    return t;
  } else {
    return Belt__Belt_internalAVLset.bal(l, v, rr);
  }
}

function removeMany(h, arr) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const key = arr[i];
    v = remove(v, key);
  }
  return v;
}

function splitAuxNoPivot(n, x) {
  const v = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    return [
      l,
      r
    ];
  }
  if (x < v) {
    if (l === undefined) {
      return [
        undefined,
        n
      ];
    }
    const match = splitAuxNoPivot(l, x);
    return [
      match[0],
      Belt__Belt_internalAVLset.joinShared(match[1], v, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined
    ];
  }
  const match$1 = splitAuxNoPivot(r, x);
  return [
    Belt__Belt_internalAVLset.joinShared(l, v, match$1[0]),
    match$1[1]
  ];
}

function splitAuxPivot(n, x, pres) {
  const v = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    pres.contents = true;
    return [
      l,
      r
    ];
  }
  if (x < v) {
    if (l === undefined) {
      return [
        undefined,
        n
      ];
    }
    const match = splitAuxPivot(l, x, pres);
    return [
      match[0],
      Belt__Belt_internalAVLset.joinShared(match[1], v, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined
    ];
  }
  const match$1 = splitAuxPivot(r, x, pres);
  return [
    Belt__Belt_internalAVLset.joinShared(l, v, match$1[0]),
    match$1[1]
  ];
}

function split(t, x) {
  if (t === undefined) {
    return [
      [
        undefined,
        undefined
      ],
      false
    ];
  }
  const pres = {
    contents: false
  };
  const v = splitAuxPivot(Caml_option.valFromOption(t), x, pres);
  return [
    v,
    pres.contents
  ];
}

function union(s1, s2) {
  if (s1 === undefined) {
    return s2;
  }
  if (s2 === undefined) {
    return s1;
  }
  const n2 = Caml_option.valFromOption(s2);
  const n1 = Caml_option.valFromOption(s1);
  const h1 = n1.h;
  const h2 = n2.h;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add(s1, n2.v);
    }
    const v1 = n1.v;
    const l1 = n1.l;
    const r1 = n1.r;
    const match = splitAuxNoPivot(n2, v1);
    return Belt__Belt_internalAVLset.joinShared(union(l1, match[0]), v1, union(r1, match[1]));
  }
  if (h1 === 1) {
    return add(s2, n1.v);
  }
  const v2 = n2.v;
  const l2 = n2.l;
  const r2 = n2.r;
  const match$1 = splitAuxNoPivot(n1, v2);
  return Belt__Belt_internalAVLset.joinShared(union(match$1[0], l2), v2, union(match$1[1], r2));
}

function intersect(s1, s2) {
  if (s1 === undefined) {
    return;
  }
  if (s2 === undefined) {
    return;
  }
  const n1 = Caml_option.valFromOption(s1);
  const v1 = n1.v;
  const l1 = n1.l;
  const r1 = n1.r;
  const pres = {
    contents: false
  };
  const match = splitAuxPivot(Caml_option.valFromOption(s2), v1, pres);
  const ll = intersect(l1, match[0]);
  const rr = intersect(r1, match[1]);
  if (pres.contents) {
    return Belt__Belt_internalAVLset.joinShared(ll, v1, rr);
  } else {
    return Belt__Belt_internalAVLset.concatShared(ll, rr);
  }
}

function diff(s1, s2) {
  if (s1 === undefined) {
    return s1;
  }
  if (s2 === undefined) {
    return s1;
  }
  const n1 = Caml_option.valFromOption(s1);
  const v1 = n1.v;
  const l1 = n1.l;
  const r1 = n1.r;
  const pres = {
    contents: false
  };
  const match = splitAuxPivot(Caml_option.valFromOption(s2), v1, pres);
  const ll = diff(l1, match[0]);
  const rr = diff(r1, match[1]);
  if (pres.contents) {
    return Belt__Belt_internalAVLset.concatShared(ll, rr);
  } else {
    return Belt__Belt_internalAVLset.joinShared(ll, v1, rr);
  }
}

let empty;

const fromArray = Belt__Belt_internalSetInt.fromArray;

const fromSortedArrayUnsafe = Belt__Belt_internalAVLset.fromSortedArrayUnsafe;

const isEmpty = Belt__Belt_internalAVLset.isEmpty;

const has = Belt__Belt_internalSetInt.has;

const subset = Belt__Belt_internalSetInt.subset;

const cmp = Belt__Belt_internalSetInt.cmp;

const eq = Belt__Belt_internalSetInt.eq;

const forEachU = Belt__Belt_internalAVLset.forEachU;

const forEach = Belt__Belt_internalAVLset.forEach;

const reduceU = Belt__Belt_internalAVLset.reduceU;

const reduce = Belt__Belt_internalAVLset.reduce;

const everyU = Belt__Belt_internalAVLset.everyU;

const every = Belt__Belt_internalAVLset.every;

const someU = Belt__Belt_internalAVLset.someU;

const some = Belt__Belt_internalAVLset.some;

const keepU = Belt__Belt_internalAVLset.keepSharedU;

const keep = Belt__Belt_internalAVLset.keepShared;

const partitionU = Belt__Belt_internalAVLset.partitionSharedU;

const partition = Belt__Belt_internalAVLset.partitionShared;

const size = Belt__Belt_internalAVLset.size;

const toList = Belt__Belt_internalAVLset.toList;

const toArray = Belt__Belt_internalAVLset.toArray;

const minimum = Belt__Belt_internalAVLset.minimum;

const minUndefined = Belt__Belt_internalAVLset.minUndefined;

const maximum = Belt__Belt_internalAVLset.maximum;

const maxUndefined = Belt__Belt_internalAVLset.maxUndefined;

const get = Belt__Belt_internalSetInt.get;

const getUndefined = Belt__Belt_internalSetInt.getUndefined;

const getExn = Belt__Belt_internalSetInt.getExn;

const checkInvariantInternal = Belt__Belt_internalAVLset.checkInvariantInternal;

export {
  empty,
  fromArray,
  fromSortedArrayUnsafe,
  isEmpty,
  has,
  add,
  mergeMany,
  remove,
  removeMany,
  union,
  intersect,
  diff,
  subset,
  cmp,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  keepU,
  keep,
  partitionU,
  partition,
  size,
  toList,
  toArray,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getExn,
  split,
  checkInvariantInternal,
}
/* No side effect */
`,L_=`// Generated by Melange

import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Belt__Belt_internalSetString from "./belt_internalSetString.js";
import * as Caml_option from "melange.js/caml_option.js";

function add(t, x) {
  if (t === undefined) {
    return Belt__Belt_internalAVLset.singleton(x);
  }
  const nt = Caml_option.valFromOption(t);
  const v = nt.v;
  if (x === v) {
    return t;
  }
  const l = nt.l;
  const r = nt.r;
  if (x < v) {
    const ll = add(l, x);
    if (ll === l) {
      return t;
    } else {
      return Belt__Belt_internalAVLset.bal(ll, v, r);
    }
  }
  const rr = add(r, x);
  if (rr === r) {
    return t;
  } else {
    return Belt__Belt_internalAVLset.bal(l, v, rr);
  }
}

function mergeMany(h, arr) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const key = arr[i];
    v = add(v, key);
  }
  return v;
}

function remove(t, x) {
  if (t === undefined) {
    return t;
  }
  const n = Caml_option.valFromOption(t);
  const v = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    if (l === undefined) {
      return r;
    }
    if (r === undefined) {
      return l;
    }
    const v$1 = {
      contents: r.v
    };
    const r$1 = Belt__Belt_internalAVLset.removeMinAuxWithRef(r, v$1);
    return Belt__Belt_internalAVLset.bal(l, v$1.contents, r$1);
  }
  if (x < v) {
    const ll = remove(l, x);
    if (ll === l) {
      return t;
    } else {
      return Belt__Belt_internalAVLset.bal(ll, v, r);
    }
  }
  const rr = remove(r, x);
  if (rr === r) {
    return t;
  } else {
    return Belt__Belt_internalAVLset.bal(l, v, rr);
  }
}

function removeMany(h, arr) {
  const len = arr.length;
  let v = h;
  for (let i = 0; i < len; ++i) {
    const key = arr[i];
    v = remove(v, key);
  }
  return v;
}

function splitAuxNoPivot(n, x) {
  const v = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    return [
      l,
      r
    ];
  }
  if (x < v) {
    if (l === undefined) {
      return [
        undefined,
        n
      ];
    }
    const match = splitAuxNoPivot(l, x);
    return [
      match[0],
      Belt__Belt_internalAVLset.joinShared(match[1], v, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined
    ];
  }
  const match$1 = splitAuxNoPivot(r, x);
  return [
    Belt__Belt_internalAVLset.joinShared(l, v, match$1[0]),
    match$1[1]
  ];
}

function splitAuxPivot(n, x, pres) {
  const v = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    pres.contents = true;
    return [
      l,
      r
    ];
  }
  if (x < v) {
    if (l === undefined) {
      return [
        undefined,
        n
      ];
    }
    const match = splitAuxPivot(l, x, pres);
    return [
      match[0],
      Belt__Belt_internalAVLset.joinShared(match[1], v, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined
    ];
  }
  const match$1 = splitAuxPivot(r, x, pres);
  return [
    Belt__Belt_internalAVLset.joinShared(l, v, match$1[0]),
    match$1[1]
  ];
}

function split(t, x) {
  if (t === undefined) {
    return [
      [
        undefined,
        undefined
      ],
      false
    ];
  }
  const pres = {
    contents: false
  };
  const v = splitAuxPivot(Caml_option.valFromOption(t), x, pres);
  return [
    v,
    pres.contents
  ];
}

function union(s1, s2) {
  if (s1 === undefined) {
    return s2;
  }
  if (s2 === undefined) {
    return s1;
  }
  const n2 = Caml_option.valFromOption(s2);
  const n1 = Caml_option.valFromOption(s1);
  const h1 = n1.h;
  const h2 = n2.h;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add(s1, n2.v);
    }
    const v1 = n1.v;
    const l1 = n1.l;
    const r1 = n1.r;
    const match = splitAuxNoPivot(n2, v1);
    return Belt__Belt_internalAVLset.joinShared(union(l1, match[0]), v1, union(r1, match[1]));
  }
  if (h1 === 1) {
    return add(s2, n1.v);
  }
  const v2 = n2.v;
  const l2 = n2.l;
  const r2 = n2.r;
  const match$1 = splitAuxNoPivot(n1, v2);
  return Belt__Belt_internalAVLset.joinShared(union(match$1[0], l2), v2, union(match$1[1], r2));
}

function intersect(s1, s2) {
  if (s1 === undefined) {
    return;
  }
  if (s2 === undefined) {
    return;
  }
  const n1 = Caml_option.valFromOption(s1);
  const v1 = n1.v;
  const l1 = n1.l;
  const r1 = n1.r;
  const pres = {
    contents: false
  };
  const match = splitAuxPivot(Caml_option.valFromOption(s2), v1, pres);
  const ll = intersect(l1, match[0]);
  const rr = intersect(r1, match[1]);
  if (pres.contents) {
    return Belt__Belt_internalAVLset.joinShared(ll, v1, rr);
  } else {
    return Belt__Belt_internalAVLset.concatShared(ll, rr);
  }
}

function diff(s1, s2) {
  if (s1 === undefined) {
    return s1;
  }
  if (s2 === undefined) {
    return s1;
  }
  const n1 = Caml_option.valFromOption(s1);
  const v1 = n1.v;
  const l1 = n1.l;
  const r1 = n1.r;
  const pres = {
    contents: false
  };
  const match = splitAuxPivot(Caml_option.valFromOption(s2), v1, pres);
  const ll = diff(l1, match[0]);
  const rr = diff(r1, match[1]);
  if (pres.contents) {
    return Belt__Belt_internalAVLset.concatShared(ll, rr);
  } else {
    return Belt__Belt_internalAVLset.joinShared(ll, v1, rr);
  }
}

let empty;

const fromArray = Belt__Belt_internalSetString.fromArray;

const fromSortedArrayUnsafe = Belt__Belt_internalAVLset.fromSortedArrayUnsafe;

const isEmpty = Belt__Belt_internalAVLset.isEmpty;

const has = Belt__Belt_internalSetString.has;

const subset = Belt__Belt_internalSetString.subset;

const cmp = Belt__Belt_internalSetString.cmp;

const eq = Belt__Belt_internalSetString.eq;

const forEachU = Belt__Belt_internalAVLset.forEachU;

const forEach = Belt__Belt_internalAVLset.forEach;

const reduceU = Belt__Belt_internalAVLset.reduceU;

const reduce = Belt__Belt_internalAVLset.reduce;

const everyU = Belt__Belt_internalAVLset.everyU;

const every = Belt__Belt_internalAVLset.every;

const someU = Belt__Belt_internalAVLset.someU;

const some = Belt__Belt_internalAVLset.some;

const keepU = Belt__Belt_internalAVLset.keepSharedU;

const keep = Belt__Belt_internalAVLset.keepShared;

const partitionU = Belt__Belt_internalAVLset.partitionSharedU;

const partition = Belt__Belt_internalAVLset.partitionShared;

const size = Belt__Belt_internalAVLset.size;

const toList = Belt__Belt_internalAVLset.toList;

const toArray = Belt__Belt_internalAVLset.toArray;

const minimum = Belt__Belt_internalAVLset.minimum;

const minUndefined = Belt__Belt_internalAVLset.minUndefined;

const maximum = Belt__Belt_internalAVLset.maximum;

const maxUndefined = Belt__Belt_internalAVLset.maxUndefined;

const get = Belt__Belt_internalSetString.get;

const getUndefined = Belt__Belt_internalSetString.getUndefined;

const getExn = Belt__Belt_internalSetString.getExn;

const checkInvariantInternal = Belt__Belt_internalAVLset.checkInvariantInternal;

export {
  empty,
  fromArray,
  fromSortedArrayUnsafe,
  isEmpty,
  has,
  add,
  mergeMany,
  remove,
  removeMany,
  union,
  intersect,
  diff,
  subset,
  cmp,
  eq,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  keepU,
  keep,
  partitionU,
  partition,
  size,
  toList,
  toArray,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  get,
  getUndefined,
  getExn,
  split,
  checkInvariantInternal,
}
/* No side effect */
`,T_=`// Generated by Melange

import * as Belt__Belt_Array from "./belt_Array.js";
import * as Curry from "melange.js/curry.js";

function sortedLengthAuxMore(xs, _prec, _acc, len, lt) {
  while (true) {
    const acc = _acc;
    const prec = _prec;
    if (acc >= len) {
      return acc;
    }
    const v = xs[acc];
    if (!lt(v, prec)) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _prec = v;
    continue;
  };
}

function strictlySortedLengthU(xs, lt) {
  const len = xs.length;
  if (len === 0 || len === 1) {
    return len;
  }
  const x0 = xs[0];
  const x1 = xs[1];
  if (lt(x0, x1)) {
    let _prec = x1;
    let _acc = 2;
    while (true) {
      const acc = _acc;
      const prec = _prec;
      if (acc >= len) {
        return acc;
      }
      const v = xs[acc];
      if (!lt(prec, v)) {
        return acc;
      }
      _acc = acc + 1 | 0;
      _prec = v;
      continue;
    };
  } else if (lt(x1, x0)) {
    return -sortedLengthAuxMore(xs, x1, 2, len, lt) | 0;
  } else {
    return 1;
  }
}

function strictlySortedLength(xs, lt) {
  return strictlySortedLengthU(xs, Curry.__2(lt));
}

function isSortedU(a, cmp) {
  const len = a.length;
  if (len === 0) {
    return true;
  } else {
    let _i = 0;
    let last_bound = len - 1 | 0;
    while (true) {
      const i = _i;
      if (i === last_bound) {
        return true;
      }
      if (cmp(a[i], a[i + 1 | 0]) > 0) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  }
}

function isSorted(a, cmp) {
  return isSortedU(a, Curry.__2(cmp));
}

function merge(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (cmp(s1, s2) <= 0) {
      dst[d] = s1;
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return Belt__Belt_Array.blitUnsafe(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
      }
      _d = d + 1 | 0;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    dst[d] = s2;
    const i2$1 = i2 + 1 | 0;
    if (i2$1 >= src2r) {
      return Belt__Belt_Array.blitUnsafe(src, i1, dst, d + 1 | 0, src1r - i1 | 0);
    }
    _d = d + 1 | 0;
    _s2 = src2[i2$1];
    _i2 = i2$1;
    continue;
  };
}

function unionU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    const c = cmp(s1, s2);
    if (c < 0) {
      dst[d] = s1;
      const i1$1 = i1 + 1 | 0;
      const d$1 = d + 1 | 0;
      if (i1$1 < src1r) {
        _d = d$1;
        _s1 = src[i1$1];
        _i1 = i1$1;
        continue;
      }
      Belt__Belt_Array.blitUnsafe(src2, i2, dst, d$1, src2r - i2 | 0);
      return (d$1 + src2r | 0) - i2 | 0;
    }
    if (c === 0) {
      dst[d] = s1;
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      const d$2 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          Belt__Belt_Array.blitUnsafe(src2, i2$1, dst, d$2, src2r - i2$1 | 0);
          return (d$2 + src2r | 0) - i2$1 | 0;
        } else {
          Belt__Belt_Array.blitUnsafe(src, i1$2, dst, d$2, src1r - i1$2 | 0);
          return (d$2 + src1r | 0) - i1$2 | 0;
        }
      }
      _d = d$2;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    dst[d] = s2;
    const i2$2 = i2 + 1 | 0;
    const d$3 = d + 1 | 0;
    if (i2$2 < src2r) {
      _d = d$3;
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue;
    }
    Belt__Belt_Array.blitUnsafe(src, i1, dst, d$3, src1r - i1 | 0);
    return (d$3 + src1r | 0) - i1 | 0;
  };
}

function union(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return unionU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function intersectU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    const c = cmp(s1, s2);
    if (c < 0) {
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d;
      }
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    if (c === 0) {
      dst[d] = s1;
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      const d$1 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        return d$1;
      }
      _d = d$1;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    const i2$2 = i2 + 1 | 0;
    if (i2$2 >= src2r) {
      return d;
    }
    _s2 = src2[i2$2];
    _i2 = i2$2;
    continue;
  };
}

function intersect(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return intersectU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function diffU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    const c = cmp(s1, s2);
    if (c < 0) {
      dst[d] = s1;
      const d$1 = d + 1 | 0;
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d$1;
      }
      _d = d$1;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    if (c === 0) {
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          return d;
        } else {
          Belt__Belt_Array.blitUnsafe(src, i1$2, dst, d, src1r - i1$2 | 0);
          return (d + src1r | 0) - i1$2 | 0;
        }
      }
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    const i2$2 = i2 + 1 | 0;
    if (i2$2 < src2r) {
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue;
    }
    Belt__Belt_Array.blitUnsafe(src, i1, dst, d, src1r - i1 | 0);
    return (d + src1r | 0) - i1 | 0;
  };
}

function diff(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return diffU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function insertionSort(src, srcofs, dst, dstofs, len, cmp) {
  for (let i = 0; i < len; ++i) {
    const e = src[srcofs + i | 0];
    let j = (dstofs + i | 0) - 1 | 0;
    while (j >= dstofs && cmp(dst[j], e) > 0) {
      dst[j + 1 | 0] = dst[j];
      j = j - 1 | 0;
    };
    dst[j + 1 | 0] = e;
  }
}

function sortTo(src, srcofs, dst, dstofs, len, cmp) {
  if (len <= 5) {
    return insertionSort(src, srcofs, dst, dstofs, len, cmp);
  }
  const l1 = len / 2 | 0;
  const l2 = len - l1 | 0;
  sortTo(src, srcofs + l1 | 0, dst, dstofs + l1 | 0, l2, cmp);
  sortTo(src, srcofs, src, srcofs + l2 | 0, l1, cmp);
  merge(src, srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs, cmp);
}

function stableSortInPlaceByU(a, cmp) {
  const l = a.length;
  if (l <= 5) {
    return insertionSort(a, 0, a, 0, l, cmp);
  }
  const l1 = l / 2 | 0;
  const l2 = l - l1 | 0;
  const t = new Array(l2);
  sortTo(a, l1, t, 0, l2, cmp);
  sortTo(a, 0, a, l2, l1, cmp);
  merge(a, l2, l1, t, 0, l2, a, 0, cmp);
}

function stableSortInPlaceBy(a, cmp) {
  stableSortInPlaceByU(a, Curry.__2(cmp));
}

function stableSortByU(a, cmp) {
  const b = a.slice(0);
  stableSortInPlaceByU(b, cmp);
  return b;
}

function stableSortBy(a, cmp) {
  return stableSortByU(a, Curry.__2(cmp));
}

function binarySearchByU(sorted, key, cmp) {
  const len = sorted.length;
  if (len === 0) {
    return -1;
  }
  const lo = sorted[0];
  const c = cmp(key, lo);
  if (c < 0) {
    return -1;
  }
  const hi = sorted[len - 1 | 0];
  const c2 = cmp(key, hi);
  if (c2 > 0) {
    return -(len + 1 | 0) | 0;
  } else {
    let _lo = 0;
    let _hi = len - 1 | 0;
    while (true) {
      const hi$1 = _hi;
      const lo$1 = _lo;
      const mid = (lo$1 + hi$1 | 0) / 2 | 0;
      const midVal = sorted[mid];
      const c$1 = cmp(key, midVal);
      if (c$1 === 0) {
        return mid;
      }
      if (c$1 < 0) {
        if (hi$1 === mid) {
          if (cmp(sorted[lo$1], key) === 0) {
            return lo$1;
          } else {
            return -(hi$1 + 1 | 0) | 0;
          }
        }
        _hi = mid;
        continue;
      }
      if (lo$1 === mid) {
        if (cmp(sorted[hi$1], key) === 0) {
          return hi$1;
        } else {
          return -(hi$1 + 1 | 0) | 0;
        }
      }
      _lo = mid;
      continue;
    };
  }
}

function binarySearchBy(sorted, key, cmp) {
  return binarySearchByU(sorted, key, Curry.__2(cmp));
}

export {
  strictlySortedLengthU,
  strictlySortedLength,
  isSortedU,
  isSorted,
  stableSortInPlaceByU,
  stableSortInPlaceBy,
  stableSortByU,
  stableSortBy,
  binarySearchByU,
  binarySearchBy,
  unionU,
  union,
  intersectU,
  intersect,
  diffU,
  diff,
}
/* No side effect */
`,N_=`// Generated by Melange

import * as Belt__Belt_Array from "./belt_Array.js";

function sortedLengthAuxMore(xs, _prec, _acc, len) {
  while (true) {
    const acc = _acc;
    const prec = _prec;
    if (acc >= len) {
      return acc;
    }
    const v = xs[acc];
    if (prec <= v) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _prec = v;
    continue;
  };
}

function strictlySortedLength(xs) {
  const len = xs.length;
  if (len === 0 || len === 1) {
    return len;
  }
  const x0 = xs[0];
  const x1 = xs[1];
  if (x0 < x1) {
    let _prec = x1;
    let _acc = 2;
    while (true) {
      const acc = _acc;
      const prec = _prec;
      if (acc >= len) {
        return acc;
      }
      const v = xs[acc];
      if (prec >= v) {
        return acc;
      }
      _acc = acc + 1 | 0;
      _prec = v;
      continue;
    };
  } else if (x0 > x1) {
    return -sortedLengthAuxMore(xs, x1, 2, len) | 0;
  } else {
    return 1;
  }
}

function isSorted(a) {
  const len = a.length;
  if (len === 0) {
    return true;
  } else {
    let _i = 0;
    let last_bound = len - 1 | 0;
    while (true) {
      const i = _i;
      if (i === last_bound) {
        return true;
      }
      if (a[i] > a[i + 1 | 0]) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  }
}

function merge(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 <= s2) {
      dst[d] = s1;
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return Belt__Belt_Array.blitUnsafe(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
      }
      _d = d + 1 | 0;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    dst[d] = s2;
    const i2$1 = i2 + 1 | 0;
    if (i2$1 >= src2r) {
      return Belt__Belt_Array.blitUnsafe(src, i1, dst, d + 1 | 0, src1r - i1 | 0);
    }
    _d = d + 1 | 0;
    _s2 = src2[i2$1];
    _i2 = i2$1;
    continue;
  };
}

function union(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 < s2) {
      dst[d] = s1;
      const i1$1 = i1 + 1 | 0;
      const d$1 = d + 1 | 0;
      if (i1$1 < src1r) {
        _d = d$1;
        _s1 = src[i1$1];
        _i1 = i1$1;
        continue;
      }
      Belt__Belt_Array.blitUnsafe(src2, i2, dst, d$1, src2r - i2 | 0);
      return (d$1 + src2r | 0) - i2 | 0;
    }
    if (s1 === s2) {
      dst[d] = s1;
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      const d$2 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          Belt__Belt_Array.blitUnsafe(src2, i2$1, dst, d$2, src2r - i2$1 | 0);
          return (d$2 + src2r | 0) - i2$1 | 0;
        } else {
          Belt__Belt_Array.blitUnsafe(src, i1$2, dst, d$2, src1r - i1$2 | 0);
          return (d$2 + src1r | 0) - i1$2 | 0;
        }
      }
      _d = d$2;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    dst[d] = s2;
    const i2$2 = i2 + 1 | 0;
    const d$3 = d + 1 | 0;
    if (i2$2 < src2r) {
      _d = d$3;
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue;
    }
    Belt__Belt_Array.blitUnsafe(src, i1, dst, d$3, src1r - i1 | 0);
    return (d$3 + src1r | 0) - i1 | 0;
  };
}

function intersect(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 < s2) {
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d;
      }
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    if (s1 === s2) {
      dst[d] = s1;
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      const d$1 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        return d$1;
      }
      _d = d$1;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    const i2$2 = i2 + 1 | 0;
    if (i2$2 >= src2r) {
      return d;
    }
    _s2 = src2[i2$2];
    _i2 = i2$2;
    continue;
  };
}

function diff(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 < s2) {
      dst[d] = s1;
      const d$1 = d + 1 | 0;
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d$1;
      }
      _d = d$1;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    if (s1 === s2) {
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          return d;
        } else {
          Belt__Belt_Array.blitUnsafe(src, i1$2, dst, d, src1r - i1$2 | 0);
          return (d + src1r | 0) - i1$2 | 0;
        }
      }
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    const i2$2 = i2 + 1 | 0;
    if (i2$2 < src2r) {
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue;
    }
    Belt__Belt_Array.blitUnsafe(src, i1, dst, d, src1r - i1 | 0);
    return (d + src1r | 0) - i1 | 0;
  };
}

function insertionSort(src, srcofs, dst, dstofs, len) {
  for (let i = 0; i < len; ++i) {
    const e = src[srcofs + i | 0];
    let j = (dstofs + i | 0) - 1 | 0;
    while (j >= dstofs && dst[j] > e) {
      dst[j + 1 | 0] = dst[j];
      j = j - 1 | 0;
    };
    dst[j + 1 | 0] = e;
  }
}

function sortTo(src, srcofs, dst, dstofs, len) {
  if (len <= 5) {
    return insertionSort(src, srcofs, dst, dstofs, len);
  }
  const l1 = len / 2 | 0;
  const l2 = len - l1 | 0;
  sortTo(src, srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
  sortTo(src, srcofs, src, srcofs + l2 | 0, l1);
  merge(src, srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
}

function stableSortInPlace(a) {
  const l = a.length;
  if (l <= 5) {
    return insertionSort(a, 0, a, 0, l);
  }
  const l1 = l / 2 | 0;
  const l2 = l - l1 | 0;
  const t = new Array(l2);
  sortTo(a, l1, t, 0, l2);
  sortTo(a, 0, a, l2, l1);
  merge(a, l2, l1, t, 0, l2, a, 0);
}

function stableSort(a) {
  const b = a.slice(0);
  stableSortInPlace(b);
  return b;
}

function binarySearch(sorted, key) {
  const len = sorted.length;
  if (len === 0) {
    return -1;
  }
  const lo = sorted[0];
  if (key < lo) {
    return -1;
  }
  const hi = sorted[len - 1 | 0];
  if (key > hi) {
    return -(len + 1 | 0) | 0;
  } else {
    let _lo = 0;
    let _hi = len - 1 | 0;
    while (true) {
      const hi$1 = _hi;
      const lo$1 = _lo;
      const mid = (lo$1 + hi$1 | 0) / 2 | 0;
      const midVal = sorted[mid];
      if (key === midVal) {
        return mid;
      }
      if (key < midVal) {
        if (hi$1 === mid) {
          if (sorted[lo$1] === key) {
            return lo$1;
          } else {
            return -(hi$1 + 1 | 0) | 0;
          }
        }
        _hi = mid;
        continue;
      }
      if (lo$1 === mid) {
        if (sorted[hi$1] === key) {
          return hi$1;
        } else {
          return -(hi$1 + 1 | 0) | 0;
        }
      }
      _lo = mid;
      continue;
    };
  }
}

export {
  strictlySortedLength,
  isSorted,
  stableSortInPlace,
  stableSort,
  binarySearch,
  union,
  intersect,
  diff,
}
/* No side effect */
`,D_=`// Generated by Melange

import * as Belt__Belt_Array from "./belt_Array.js";

function sortedLengthAuxMore(xs, _prec, _acc, len) {
  while (true) {
    const acc = _acc;
    const prec = _prec;
    if (acc >= len) {
      return acc;
    }
    const v = xs[acc];
    if (prec <= v) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _prec = v;
    continue;
  };
}

function strictlySortedLength(xs) {
  const len = xs.length;
  if (len === 0 || len === 1) {
    return len;
  }
  const x0 = xs[0];
  const x1 = xs[1];
  if (x0 < x1) {
    let _prec = x1;
    let _acc = 2;
    while (true) {
      const acc = _acc;
      const prec = _prec;
      if (acc >= len) {
        return acc;
      }
      const v = xs[acc];
      if (prec >= v) {
        return acc;
      }
      _acc = acc + 1 | 0;
      _prec = v;
      continue;
    };
  } else if (x0 > x1) {
    return -sortedLengthAuxMore(xs, x1, 2, len) | 0;
  } else {
    return 1;
  }
}

function isSorted(a) {
  const len = a.length;
  if (len === 0) {
    return true;
  } else {
    let _i = 0;
    let last_bound = len - 1 | 0;
    while (true) {
      const i = _i;
      if (i === last_bound) {
        return true;
      }
      if (a[i] > a[i + 1 | 0]) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  }
}

function merge(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 <= s2) {
      dst[d] = s1;
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return Belt__Belt_Array.blitUnsafe(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
      }
      _d = d + 1 | 0;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    dst[d] = s2;
    const i2$1 = i2 + 1 | 0;
    if (i2$1 >= src2r) {
      return Belt__Belt_Array.blitUnsafe(src, i1, dst, d + 1 | 0, src1r - i1 | 0);
    }
    _d = d + 1 | 0;
    _s2 = src2[i2$1];
    _i2 = i2$1;
    continue;
  };
}

function union(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 < s2) {
      dst[d] = s1;
      const i1$1 = i1 + 1 | 0;
      const d$1 = d + 1 | 0;
      if (i1$1 < src1r) {
        _d = d$1;
        _s1 = src[i1$1];
        _i1 = i1$1;
        continue;
      }
      Belt__Belt_Array.blitUnsafe(src2, i2, dst, d$1, src2r - i2 | 0);
      return (d$1 + src2r | 0) - i2 | 0;
    }
    if (s1 === s2) {
      dst[d] = s1;
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      const d$2 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          Belt__Belt_Array.blitUnsafe(src2, i2$1, dst, d$2, src2r - i2$1 | 0);
          return (d$2 + src2r | 0) - i2$1 | 0;
        } else {
          Belt__Belt_Array.blitUnsafe(src, i1$2, dst, d$2, src1r - i1$2 | 0);
          return (d$2 + src1r | 0) - i1$2 | 0;
        }
      }
      _d = d$2;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    dst[d] = s2;
    const i2$2 = i2 + 1 | 0;
    const d$3 = d + 1 | 0;
    if (i2$2 < src2r) {
      _d = d$3;
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue;
    }
    Belt__Belt_Array.blitUnsafe(src, i1, dst, d$3, src1r - i1 | 0);
    return (d$3 + src1r | 0) - i1 | 0;
  };
}

function intersect(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 < s2) {
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d;
      }
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    if (s1 === s2) {
      dst[d] = s1;
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      const d$1 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        return d$1;
      }
      _d = d$1;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    const i2$2 = i2 + 1 | 0;
    if (i2$2 >= src2r) {
      return d;
    }
    _s2 = src2[i2$2];
    _i2 = i2$2;
    continue;
  };
}

function diff(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
  const src1r = src1ofs + src1len | 0;
  const src2r = src2ofs + src2len | 0;
  let _i1 = src1ofs;
  let _s1 = src[src1ofs];
  let _i2 = src2ofs;
  let _s2 = src2[src2ofs];
  let _d = dstofs;
  while (true) {
    const d = _d;
    const s2 = _s2;
    const i2 = _i2;
    const s1 = _s1;
    const i1 = _i1;
    if (s1 < s2) {
      dst[d] = s1;
      const d$1 = d + 1 | 0;
      const i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d$1;
      }
      _d = d$1;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue;
    }
    if (s1 === s2) {
      const i1$2 = i1 + 1 | 0;
      const i2$1 = i2 + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          return d;
        } else {
          Belt__Belt_Array.blitUnsafe(src, i1$2, dst, d, src1r - i1$2 | 0);
          return (d + src1r | 0) - i1$2 | 0;
        }
      }
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue;
    }
    const i2$2 = i2 + 1 | 0;
    if (i2$2 < src2r) {
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue;
    }
    Belt__Belt_Array.blitUnsafe(src, i1, dst, d, src1r - i1 | 0);
    return (d + src1r | 0) - i1 | 0;
  };
}

function insertionSort(src, srcofs, dst, dstofs, len) {
  for (let i = 0; i < len; ++i) {
    const e = src[srcofs + i | 0];
    let j = (dstofs + i | 0) - 1 | 0;
    while (j >= dstofs && dst[j] > e) {
      dst[j + 1 | 0] = dst[j];
      j = j - 1 | 0;
    };
    dst[j + 1 | 0] = e;
  }
}

function sortTo(src, srcofs, dst, dstofs, len) {
  if (len <= 5) {
    return insertionSort(src, srcofs, dst, dstofs, len);
  }
  const l1 = len / 2 | 0;
  const l2 = len - l1 | 0;
  sortTo(src, srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
  sortTo(src, srcofs, src, srcofs + l2 | 0, l1);
  merge(src, srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
}

function stableSortInPlace(a) {
  const l = a.length;
  if (l <= 5) {
    return insertionSort(a, 0, a, 0, l);
  }
  const l1 = l / 2 | 0;
  const l2 = l - l1 | 0;
  const t = new Array(l2);
  sortTo(a, l1, t, 0, l2);
  sortTo(a, 0, a, l2, l1);
  merge(a, l2, l1, t, 0, l2, a, 0);
}

function stableSort(a) {
  const b = a.slice(0);
  stableSortInPlace(b);
  return b;
}

function binarySearch(sorted, key) {
  const len = sorted.length;
  if (len === 0) {
    return -1;
  }
  const lo = sorted[0];
  if (key < lo) {
    return -1;
  }
  const hi = sorted[len - 1 | 0];
  if (key > hi) {
    return -(len + 1 | 0) | 0;
  } else {
    let _lo = 0;
    let _hi = len - 1 | 0;
    while (true) {
      const hi$1 = _hi;
      const lo$1 = _lo;
      const mid = (lo$1 + hi$1 | 0) / 2 | 0;
      const midVal = sorted[mid];
      if (key === midVal) {
        return mid;
      }
      if (key < midVal) {
        if (hi$1 === mid) {
          if (sorted[lo$1] === key) {
            return lo$1;
          } else {
            return -(hi$1 + 1 | 0) | 0;
          }
        }
        _hi = mid;
        continue;
      }
      if (lo$1 === mid) {
        if (sorted[hi$1] === key) {
          return hi$1;
        } else {
          return -(hi$1 + 1 | 0) | 0;
        }
      }
      _lo = mid;
      continue;
    };
  }
}

export {
  strictlySortedLength,
  isSorted,
  stableSortInPlace,
  stableSort,
  binarySearch,
  union,
  intersect,
  diff,
}
/* No side effect */
`,O_=`// Generated by Melange


const Belt__ = {};

export {
  Belt__,
}
/* No side effect */
`,z_=`// Generated by Melange

import * as Belt__Belt_SortArray from "./belt_SortArray.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function copy(n) {
  if (n === undefined) {
    return n;
  }
  const n$1 = Caml_option.valFromOption(n);
  return {
    v: n$1.v,
    h: n$1.h,
    l: copy(n$1.l),
    r: copy(n$1.r)
  };
}

function create(l, v, r) {
  const hl = l !== undefined ? Caml_option.valFromOption(l).h : 0;
  const hr = r !== undefined ? Caml_option.valFromOption(r).h : 0;
  return {
    v: v,
    h: (
      hl >= hr ? hl : hr
    ) + 1 | 0,
    l: l,
    r: r
  };
}

function singleton(x) {
  return {
    v: x,
    h: 1,
    l: undefined,
    r: undefined
  };
}

function heightGe(l, r) {
  if (r !== undefined) {
    if (l !== undefined) {
      return l.h >= r.h;
    } else {
      return false;
    }
  } else {
    return true;
  }
}

function bal(l, v, r) {
  const hl = l !== undefined ? Caml_option.valFromOption(l).h : 0;
  const hr = r !== undefined ? Caml_option.valFromOption(r).h : 0;
  if (hl > (hr + 2 | 0)) {
    const l$1 = Caml_option.valFromOption(l);
    const ll = l$1.l;
    const lr = l$1.r;
    if (heightGe(ll, lr)) {
      return create(ll, l$1.v, create(lr, v, r));
    }
    const lr$1 = Caml_option.valFromOption(lr);
    return create(create(ll, l$1.v, lr$1.l), lr$1.v, create(lr$1.r, v, r));
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      v: v,
      h: (
        hl >= hr ? hl : hr
      ) + 1 | 0,
      l: l,
      r: r
    };
  }
  const r$1 = Caml_option.valFromOption(r);
  const rl = r$1.l;
  const rr = r$1.r;
  if (heightGe(rr, rl)) {
    return create(create(l, v, rl), r$1.v, rr);
  }
  const rl$1 = Caml_option.valFromOption(rl);
  return create(create(l, v, rl$1.l), rl$1.v, create(rl$1.r, r$1.v, rr));
}

function min0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.l;
    if (n$1 === undefined) {
      return n.v;
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function minimum(n) {
  if (n !== undefined) {
    return Caml_option.some(min0Aux(n));
  }
  
}

function minUndefined(n) {
  if (n !== undefined) {
    return min0Aux(n);
  }
  
}

function max0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.r;
    if (n$1 === undefined) {
      return n.v;
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function maximum(n) {
  if (n !== undefined) {
    return Caml_option.some(max0Aux(n));
  }
  
}

function maxUndefined(n) {
  if (n !== undefined) {
    return max0Aux(n);
  }
  
}

function removeMinAuxWithRef(n, v) {
  const ln = n.l;
  if (ln !== undefined) {
    return bal(removeMinAuxWithRef(Caml_option.valFromOption(ln), v), n.v, n.r);
  } else {
    v.contents = n.v;
    return n.r;
  }
}

function isEmpty(n) {
  return n === undefined;
}

function stackAllLeft(_v, _s) {
  while (true) {
    const s = _s;
    const v = _v;
    if (v === undefined) {
      return s;
    }
    const x = Caml_option.valFromOption(v);
    _s = {
      hd: x,
      tl: s
    };
    _v = x.l;
    continue;
  };
}

function forEachU(_n, f) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    forEachU(n$1.l, f);
    f(n$1.v);
    _n = n$1.r;
    continue;
  };
}

function forEach(n, f) {
  forEachU(n, Curry.__1(f));
}

function reduceU(_s, _accu, f) {
  while (true) {
    const accu = _accu;
    const s = _s;
    if (s === undefined) {
      return accu;
    }
    const n = Caml_option.valFromOption(s);
    _accu = f(reduceU(n.l, accu, f), n.v);
    _s = n.r;
    continue;
  };
}

function reduce(s, accu, f) {
  return reduceU(s, accu, Curry.__2(f));
}

function everyU(_n, p) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return true;
    }
    const n$1 = Caml_option.valFromOption(n);
    if (!p(n$1.v)) {
      return false;
    }
    if (!everyU(n$1.l, p)) {
      return false;
    }
    _n = n$1.r;
    continue;
  };
}

function every(n, p) {
  return everyU(n, Curry.__1(p));
}

function someU(_n, p) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return false;
    }
    const n$1 = Caml_option.valFromOption(n);
    if (p(n$1.v)) {
      return true;
    }
    if (someU(n$1.l, p)) {
      return true;
    }
    _n = n$1.r;
    continue;
  };
}

function some(n, p) {
  return someU(n, Curry.__1(p));
}

function addMinElement(n, v) {
  if (n === undefined) {
    return singleton(v);
  }
  const n$1 = Caml_option.valFromOption(n);
  return bal(addMinElement(n$1.l, v), n$1.v, n$1.r);
}

function addMaxElement(n, v) {
  if (n === undefined) {
    return singleton(v);
  }
  const n$1 = Caml_option.valFromOption(n);
  return bal(n$1.l, n$1.v, addMaxElement(n$1.r, v));
}

function joinShared(ln, v, rn) {
  if (ln === undefined) {
    return addMinElement(rn, v);
  }
  if (rn === undefined) {
    return addMaxElement(ln, v);
  }
  const r = Caml_option.valFromOption(rn);
  const l = Caml_option.valFromOption(ln);
  const lh = l.h;
  const rh = r.h;
  if (lh > (rh + 2 | 0)) {
    return bal(l.l, l.v, joinShared(l.r, v, rn));
  } else if (rh > (lh + 2 | 0)) {
    return bal(joinShared(ln, v, r.l), r.v, r.r);
  } else {
    return create(ln, v, rn);
  }
}

function concatShared(t1, t2) {
  if (t1 === undefined) {
    return t2;
  }
  if (t2 === undefined) {
    return t1;
  }
  const t2n = Caml_option.valFromOption(t2);
  const v = {
    contents: t2n.v
  };
  const t2r = removeMinAuxWithRef(t2n, v);
  return joinShared(t1, v.contents, t2r);
}

function partitionSharedU(n, p) {
  if (n === undefined) {
    return [
      undefined,
      undefined
    ];
  }
  const n$1 = Caml_option.valFromOption(n);
  const value = n$1.v;
  const match = partitionSharedU(n$1.l, p);
  const lf = match[1];
  const lt = match[0];
  const pv = p(value);
  const match$1 = partitionSharedU(n$1.r, p);
  const rf = match$1[1];
  const rt = match$1[0];
  if (pv) {
    return [
      joinShared(lt, value, rt),
      concatShared(lf, rf)
    ];
  } else {
    return [
      concatShared(lt, rt),
      joinShared(lf, value, rf)
    ];
  }
}

function partitionShared(n, p) {
  return partitionSharedU(n, Curry.__1(p));
}

function lengthNode(n) {
  const l = n.l;
  const r = n.r;
  const sizeL = l !== undefined ? lengthNode(Caml_option.valFromOption(l)) : 0;
  const sizeR = r !== undefined ? lengthNode(Caml_option.valFromOption(r)) : 0;
  return (1 + sizeL | 0) + sizeR | 0;
}

function size(n) {
  if (n !== undefined) {
    return lengthNode(n);
  } else {
    return 0;
  }
}

function toListAux(_n, _accu) {
  while (true) {
    const accu = _accu;
    const n = _n;
    if (n === undefined) {
      return accu;
    }
    const n$1 = Caml_option.valFromOption(n);
    _accu = {
      hd: n$1.v,
      tl: toListAux(n$1.r, accu)
    };
    _n = n$1.l;
    continue;
  };
}

function toList(s) {
  return toListAux(s, /* [] */ 0);
}

function checkInvariantInternal(_v) {
  while (true) {
    const v = _v;
    if (v === undefined) {
      return;
    }
    const n = Caml_option.valFromOption(v);
    const l = n.l;
    const r = n.r;
    const diff = (
      l !== undefined ? Caml_option.valFromOption(l).h : 0
    ) - (
      r !== undefined ? Caml_option.valFromOption(r).h : 0
    ) | 0;
    if (!(diff <= 2 && diff >= -2)) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "belt/belt_internalAVLset.ml",
              244,
              6
            ]
          });
    }
    checkInvariantInternal(l);
    _v = r;
    continue;
  };
}

function fillArray(_n, _i, arr) {
  while (true) {
    const i = _i;
    const n = _n;
    const v = n.v;
    const l = n.l;
    const r = n.r;
    const next = l !== undefined ? fillArray(Caml_option.valFromOption(l), i, arr) : i;
    arr[next] = v;
    const rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function fillArrayWithPartition(_n, cursor, arr, p) {
  while (true) {
    const n = _n;
    const v = n.v;
    const l = n.l;
    const r = n.r;
    if (l !== undefined) {
      fillArrayWithPartition(Caml_option.valFromOption(l), cursor, arr, p);
    }
    if (p(v)) {
      const c = cursor.forward;
      arr[c] = v;
      cursor.forward = c + 1 | 0;
    } else {
      const c$1 = cursor.backward;
      arr[c$1] = v;
      cursor.backward = c$1 - 1 | 0;
    }
    if (r === undefined) {
      return;
    }
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function fillArrayWithFilter(_n, _i, arr, p) {
  while (true) {
    const i = _i;
    const n = _n;
    const v = n.v;
    const l = n.l;
    const r = n.r;
    const next = l !== undefined ? fillArrayWithFilter(Caml_option.valFromOption(l), i, arr, p) : i;
    const rnext = p(v) ? (arr[next] = v, next + 1 | 0) : next;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function toArray(n) {
  if (n === undefined) {
    return [];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  fillArray(n, 0, v);
  return v;
}

function fromSortedArrayRevAux(arr, off, len) {
  switch (len) {
    case 0 :
      return;
    case 1 :
      return singleton(arr[off]);
    case 2 :
      const x0 = arr[off];
      const x1 = arr[off - 1 | 0];
      return {
        v: x1,
        h: 2,
        l: singleton(x0),
        r: undefined
      };
    case 3 :
      const x0$1 = arr[off];
      const x1$1 = arr[off - 1 | 0];
      const x2 = arr[off - 2 | 0];
      return {
        v: x1$1,
        h: 2,
        l: singleton(x0$1),
        r: singleton(x2)
      };
    default:
      const nl = len / 2 | 0;
      const left = fromSortedArrayRevAux(arr, off, nl);
      const mid = arr[off - nl | 0];
      const right = fromSortedArrayRevAux(arr, (off - nl | 0) - 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, mid, right);
  }
}

function fromSortedArrayAux(arr, off, len) {
  switch (len) {
    case 0 :
      return;
    case 1 :
      return singleton(arr[off]);
    case 2 :
      const x0 = arr[off];
      const x1 = arr[off + 1 | 0];
      return {
        v: x1,
        h: 2,
        l: singleton(x0),
        r: undefined
      };
    case 3 :
      const x0$1 = arr[off];
      const x1$1 = arr[off + 1 | 0];
      const x2 = arr[off + 2 | 0];
      return {
        v: x1$1,
        h: 2,
        l: singleton(x0$1),
        r: singleton(x2)
      };
    default:
      const nl = len / 2 | 0;
      const left = fromSortedArrayAux(arr, off, nl);
      const mid = arr[off + nl | 0];
      const right = fromSortedArrayAux(arr, (off + nl | 0) + 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, mid, right);
  }
}

function fromSortedArrayUnsafe(arr) {
  return fromSortedArrayAux(arr, 0, arr.length);
}

function keepSharedU(n, p) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const v = n$1.v;
  const l = n$1.l;
  const r = n$1.r;
  const newL = keepSharedU(l, p);
  const pv = p(v);
  const newR = keepSharedU(r, p);
  if (pv) {
    if (l === newL && r === newR) {
      return n$1;
    } else {
      return joinShared(newL, v, newR);
    }
  } else {
    return concatShared(newL, newR);
  }
}

function keepShared(n, p) {
  return keepSharedU(n, Curry.__1(p));
}

function keepCopyU(n, p) {
  if (n === undefined) {
    return;
  }
  const size = lengthNode(n);
  const v = new Array(size);
  const last = fillArrayWithFilter(n, 0, v, p);
  return fromSortedArrayAux(v, 0, last);
}

function keepCopy(n, p) {
  return keepCopyU(n, Curry.__1(p));
}

function partitionCopyU(n, p) {
  if (n === undefined) {
    return [
      undefined,
      undefined
    ];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  const backward = size - 1 | 0;
  const cursor = {
    forward: 0,
    backward: backward
  };
  fillArrayWithPartition(n, cursor, v, p);
  const forwardLen = cursor.forward;
  return [
    fromSortedArrayAux(v, 0, forwardLen),
    fromSortedArrayRevAux(v, backward, size - forwardLen | 0)
  ];
}

function partitionCopy(n, p) {
  return partitionCopyU(n, Curry.__1(p));
}

function has(_t, x, cmp) {
  while (true) {
    const t = _t;
    if (t === undefined) {
      return false;
    }
    const n = Caml_option.valFromOption(t);
    const v = n.v;
    const c = cmp(x, v);
    if (c === 0) {
      return true;
    }
    _t = c < 0 ? n.l : n.r;
    continue;
  };
}

function cmp(s1, s2, cmp$1) {
  const len1 = size(s1);
  const len2 = size(s2);
  if (len1 === len2) {
    let _e1 = stackAllLeft(s1, /* [] */ 0);
    let _e2 = stackAllLeft(s2, /* [] */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (!e1) {
        return 0;
      }
      if (!e2) {
        return 0;
      }
      const h2 = e2.hd;
      const h1 = e1.hd;
      const c = cmp$1(h1.v, h2.v);
      if (c !== 0) {
        return c;
      }
      _e2 = stackAllLeft(h2.r, e2.tl);
      _e1 = stackAllLeft(h1.r, e1.tl);
      continue;
    };
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function eq(s1, s2, c) {
  return cmp(s1, s2, c) === 0;
}

function subset(_s1, _s2, cmp) {
  while (true) {
    const s2 = _s2;
    const s1 = _s1;
    if (s1 === undefined) {
      return true;
    }
    if (s2 === undefined) {
      return false;
    }
    const t2 = Caml_option.valFromOption(s2);
    const t1 = Caml_option.valFromOption(s1);
    const v1 = t1.v;
    const l1 = t1.l;
    const r1 = t1.r;
    const v2 = t2.v;
    const l2 = t2.l;
    const r2 = t2.r;
    const c = cmp(v1, v2);
    if (c === 0) {
      if (!subset(l1, l2, cmp)) {
        return false;
      }
      _s2 = r2;
      _s1 = r1;
      continue;
    }
    if (c < 0) {
      if (!subset(create(l1, v1, undefined), l2, cmp)) {
        return false;
      }
      _s1 = r1;
      continue;
    }
    if (!subset(create(undefined, v1, r1), r2, cmp)) {
      return false;
    }
    _s1 = l1;
    continue;
  };
}

function get(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const t = Caml_option.valFromOption(n);
    const v = t.v;
    const c = cmp(x, v);
    if (c === 0) {
      return Caml_option.some(v);
    }
    _n = c < 0 ? t.l : t.r;
    continue;
  };
}

function getUndefined(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const t = Caml_option.valFromOption(n);
    const v = t.v;
    const c = cmp(x, v);
    if (c === 0) {
      return v;
    }
    _n = c < 0 ? t.l : t.r;
    continue;
  };
}

function getExn(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n !== undefined) {
      const t = Caml_option.valFromOption(n);
      const v = t.v;
      const c = cmp(x, v);
      if (c === 0) {
        return v;
      }
      _n = c < 0 ? t.l : t.r;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function rotateWithLeftChild(k2) {
  const k1 = k2.l;
  const k1$1 = Caml_option.valFromOption(k1);
  k2.l = k1$1.r;
  k1$1.r = k2;
  const n = k2.l;
  const hlk2 = n !== undefined ? Caml_option.valFromOption(n).h : 0;
  const n$1 = k2.r;
  const hrk2 = n$1 !== undefined ? Caml_option.valFromOption(n$1).h : 0;
  k2.h = (
    hlk2 > hrk2 ? hlk2 : hrk2
  ) + 1 | 0;
  const n$2 = k1$1.l;
  const hlk1 = n$2 !== undefined ? Caml_option.valFromOption(n$2).h : 0;
  const hk2 = k2.h;
  k1$1.h = (
    hlk1 > hk2 ? hlk1 : hk2
  ) + 1 | 0;
  return k1$1;
}

function rotateWithRightChild(k1) {
  const k2 = k1.r;
  const k2$1 = Caml_option.valFromOption(k2);
  k1.r = k2$1.l;
  k2$1.l = k1;
  const n = k1.l;
  const hlk1 = n !== undefined ? Caml_option.valFromOption(n).h : 0;
  const n$1 = k1.r;
  const hrk1 = n$1 !== undefined ? Caml_option.valFromOption(n$1).h : 0;
  k1.h = (
    hlk1 > hrk1 ? hlk1 : hrk1
  ) + 1 | 0;
  const n$2 = k2$1.r;
  const hrk2 = n$2 !== undefined ? Caml_option.valFromOption(n$2).h : 0;
  const hk1 = k1.h;
  k2$1.h = (
    hrk2 > hk1 ? hrk2 : hk1
  ) + 1 | 0;
  return k2$1;
}

function doubleWithLeftChild(k3) {
  const k3l = k3.l;
  const v = rotateWithRightChild(Caml_option.valFromOption(k3l));
  k3.l = v;
  return rotateWithLeftChild(k3);
}

function doubleWithRightChild(k2) {
  const k2r = k2.r;
  const v = rotateWithLeftChild(Caml_option.valFromOption(k2r));
  k2.r = v;
  return rotateWithRightChild(k2);
}

function heightUpdateMutate(t) {
  const n = t.l;
  const hlt = n !== undefined ? Caml_option.valFromOption(n).h : 0;
  const n$1 = t.r;
  const hrt = n$1 !== undefined ? Caml_option.valFromOption(n$1).h : 0;
  t.h = (
    hlt > hrt ? hlt : hrt
  ) + 1 | 0;
  return t;
}

function balMutate(nt) {
  const l = nt.l;
  const r = nt.r;
  const hl = l !== undefined ? Caml_option.valFromOption(l).h : 0;
  const hr = r !== undefined ? Caml_option.valFromOption(r).h : 0;
  if (hl > (2 + hr | 0)) {
    const match = Caml_option.valFromOption(l);
    const ll = match.l;
    const lr = match.r;
    if (heightGe(ll, lr)) {
      return heightUpdateMutate(rotateWithLeftChild(nt));
    } else {
      return heightUpdateMutate(doubleWithLeftChild(nt));
    }
  }
  if (hr > (2 + hl | 0)) {
    const match$1 = Caml_option.valFromOption(r);
    const rl = match$1.l;
    const rr = match$1.r;
    if (heightGe(rr, rl)) {
      return heightUpdateMutate(rotateWithRightChild(nt));
    } else {
      return heightUpdateMutate(doubleWithRightChild(nt));
    }
  }
  nt.h = (
    hl > hr ? hl : hr
  ) + 1 | 0;
  return nt;
}

function addMutate(cmp, t, x) {
  if (t === undefined) {
    return singleton(x);
  }
  const nt = Caml_option.valFromOption(t);
  const k = nt.v;
  const c = cmp(x, k);
  if (c === 0) {
    return t;
  }
  const l = nt.l;
  const r = nt.r;
  if (c < 0) {
    const ll = addMutate(cmp, l, x);
    nt.l = ll;
  } else {
    nt.r = addMutate(cmp, r, x);
  }
  return balMutate(nt);
}

function fromArray(xs, cmp) {
  const len = xs.length;
  if (len === 0) {
    return;
  }
  let next = Belt__Belt_SortArray.strictlySortedLengthU(xs, (function (x, y) {
    return cmp(x, y) < 0;
  }));
  let result;
  if (next >= 0) {
    result = fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for (let i = next; i < len; ++i) {
    result = addMutate(cmp, result, xs[i]);
  }
  return result;
}

function removeMinAuxWithRootMutate(nt, n) {
  const ln = n.l;
  const rn = n.r;
  if (ln !== undefined) {
    n.l = removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(ln));
    return balMutate(n);
  } else {
    nt.v = n.v;
    return rn;
  }
}

export {
  copy,
  create,
  bal,
  singleton,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  removeMinAuxWithRef,
  isEmpty,
  stackAllLeft,
  forEachU,
  forEach,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  joinShared,
  concatShared,
  keepSharedU,
  keepShared,
  keepCopyU,
  keepCopy,
  partitionSharedU,
  partitionShared,
  partitionCopyU,
  partitionCopy,
  lengthNode,
  size,
  toList,
  checkInvariantInternal,
  fillArray,
  toArray,
  fromSortedArrayAux,
  fromSortedArrayRevAux,
  fromSortedArrayUnsafe,
  has,
  cmp,
  eq,
  subset,
  get,
  getUndefined,
  getExn,
  fromArray,
  addMutate,
  balMutate,
  removeMinAuxWithRootMutate,
}
/* No side effect */
`,G_=`// Generated by Melange

import * as Belt__Belt_SortArray from "./belt_SortArray.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function treeHeight(n) {
  if (n !== undefined) {
    return Caml_option.valFromOption(n).h;
  } else {
    return 0;
  }
}

function copy(n) {
  if (n === undefined) {
    return n;
  }
  const n$1 = Caml_option.valFromOption(n);
  return {
    k: n$1.k,
    v: n$1.v,
    h: n$1.h,
    l: copy(n$1.l),
    r: copy(n$1.r)
  };
}

function create(l, x, d, r) {
  const hl = treeHeight(l);
  const hr = treeHeight(r);
  return {
    k: x,
    v: d,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,
    l: l,
    r: r
  };
}

function singleton(x, d) {
  return {
    k: x,
    v: d,
    h: 1,
    l: undefined,
    r: undefined
  };
}

function heightGe(l, r) {
  if (r !== undefined) {
    if (l !== undefined) {
      return l.h >= r.h;
    } else {
      return false;
    }
  } else {
    return true;
  }
}

function updateValue(n, newValue) {
  if (n.v === newValue) {
    return n;
  } else {
    return {
      k: n.k,
      v: newValue,
      h: n.h,
      l: n.l,
      r: n.r
    };
  }
}

function bal(l, x, d, r) {
  const hl = l !== undefined ? Caml_option.valFromOption(l).h : 0;
  const hr = r !== undefined ? Caml_option.valFromOption(r).h : 0;
  if (hl > (hr + 2 | 0)) {
    const ll = l.l;
    const lr = l.r;
    if (treeHeight(ll) >= treeHeight(lr)) {
      return create(ll, l.k, l.v, create(lr, x, d, r));
    }
    const lr$1 = Caml_option.valFromOption(lr);
    return create(create(ll, l.k, l.v, lr$1.l), lr$1.k, lr$1.v, create(lr$1.r, x, d, r));
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      k: x,
      v: d,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,
      l: l,
      r: r
    };
  }
  const r$1 = Caml_option.valFromOption(r);
  const rl = r$1.l;
  const rr = r$1.r;
  if (treeHeight(rr) >= treeHeight(rl)) {
    return create(create(l, x, d, rl), r$1.k, r$1.v, rr);
  }
  const rl$1 = Caml_option.valFromOption(rl);
  return create(create(l, x, d, rl$1.l), rl$1.k, rl$1.v, create(rl$1.r, r$1.k, r$1.v, rr));
}

function minKey0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.l;
    if (n$1 === undefined) {
      return n.k;
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function minKey(n) {
  if (n !== undefined) {
    return Caml_option.some(minKey0Aux(n));
  }
  
}

function minKeyUndefined(n) {
  if (n !== undefined) {
    return minKey0Aux(n);
  }
  
}

function maxKey0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.r;
    if (n$1 === undefined) {
      return n.k;
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function maxKey(n) {
  if (n !== undefined) {
    return Caml_option.some(maxKey0Aux(n));
  }
  
}

function maxKeyUndefined(n) {
  if (n !== undefined) {
    return maxKey0Aux(n);
  }
  
}

function minKV0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.l;
    if (n$1 === undefined) {
      return [
        n.k,
        n.v
      ];
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function minimum(n) {
  if (n !== undefined) {
    return minKV0Aux(n);
  }
  
}

function minUndefined(n) {
  if (n !== undefined) {
    return minKV0Aux(n);
  }
  
}

function maxKV0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.r;
    if (n$1 === undefined) {
      return [
        n.k,
        n.v
      ];
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function maximum(n) {
  if (n !== undefined) {
    return maxKV0Aux(n);
  }
  
}

function maxUndefined(n) {
  if (n !== undefined) {
    return maxKV0Aux(n);
  }
  
}

function removeMinAuxWithRef(n, kr, vr) {
  const ln = n.l;
  if (ln !== undefined) {
    return bal(removeMinAuxWithRef(Caml_option.valFromOption(ln), kr, vr), n.k, n.v, n.r);
  } else {
    kr.contents = n.k;
    vr.contents = n.v;
    return n.r;
  }
}

function isEmpty(x) {
  return x === undefined;
}

function stackAllLeft(_v, _s) {
  while (true) {
    const s = _s;
    const v = _v;
    if (v === undefined) {
      return s;
    }
    const x = Caml_option.valFromOption(v);
    _s = {
      hd: x,
      tl: s
    };
    _v = x.l;
    continue;
  };
}

function findFirstByU(n, p) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const left = findFirstByU(n$1.l, p);
  if (left !== undefined) {
    return left;
  }
  const v = n$1.k;
  const d = n$1.v;
  const pvd = p(v, d);
  if (pvd) {
    return [
      v,
      d
    ];
  }
  const right = findFirstByU(n$1.r, p);
  if (right !== undefined) {
    return right;
  }
  
}

function findFirstBy(n, p) {
  return findFirstByU(n, Curry.__2(p));
}

function forEachU(_n, f) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    forEachU(n$1.l, f);
    f(n$1.k, n$1.v);
    _n = n$1.r;
    continue;
  };
}

function forEach(n, f) {
  forEachU(n, Curry.__2(f));
}

function mapU(n, f) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const newLeft = mapU(n$1.l, f);
  const newD = f(n$1.v);
  const newRight = mapU(n$1.r, f);
  return {
    k: n$1.k,
    v: newD,
    h: n$1.h,
    l: newLeft,
    r: newRight
  };
}

function map(n, f) {
  return mapU(n, Curry.__1(f));
}

function mapWithKeyU(n, f) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const key = n$1.k;
  const newLeft = mapWithKeyU(n$1.l, f);
  const newD = f(key, n$1.v);
  const newRight = mapWithKeyU(n$1.r, f);
  return {
    k: key,
    v: newD,
    h: n$1.h,
    l: newLeft,
    r: newRight
  };
}

function mapWithKey(n, f) {
  return mapWithKeyU(n, Curry.__2(f));
}

function reduceU(_m, _accu, f) {
  while (true) {
    const accu = _accu;
    const m = _m;
    if (m === undefined) {
      return accu;
    }
    const n = Caml_option.valFromOption(m);
    const v = n.k;
    const d = n.v;
    const l = n.l;
    const r = n.r;
    _accu = f(reduceU(l, accu, f), v, d);
    _m = r;
    continue;
  };
}

function reduce(m, accu, f) {
  return reduceU(m, accu, Curry.__3(f));
}

function everyU(_n, p) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return true;
    }
    const n$1 = Caml_option.valFromOption(n);
    if (!p(n$1.k, n$1.v)) {
      return false;
    }
    if (!everyU(n$1.l, p)) {
      return false;
    }
    _n = n$1.r;
    continue;
  };
}

function every(n, p) {
  return everyU(n, Curry.__2(p));
}

function someU(_n, p) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return false;
    }
    const n$1 = Caml_option.valFromOption(n);
    if (p(n$1.k, n$1.v)) {
      return true;
    }
    if (someU(n$1.l, p)) {
      return true;
    }
    _n = n$1.r;
    continue;
  };
}

function some(n, p) {
  return someU(n, Curry.__2(p));
}

function addMinElement(n, k, v) {
  if (n === undefined) {
    return singleton(k, v);
  }
  const n$1 = Caml_option.valFromOption(n);
  return bal(addMinElement(n$1.l, k, v), n$1.k, n$1.v, n$1.r);
}

function addMaxElement(n, k, v) {
  if (n === undefined) {
    return singleton(k, v);
  }
  const n$1 = Caml_option.valFromOption(n);
  return bal(n$1.l, n$1.k, n$1.v, addMaxElement(n$1.r, k, v));
}

function join(ln, v, d, rn) {
  if (ln === undefined) {
    return addMinElement(rn, v, d);
  }
  if (rn === undefined) {
    return addMaxElement(ln, v, d);
  }
  const r = Caml_option.valFromOption(rn);
  const l = Caml_option.valFromOption(ln);
  const lv = l.k;
  const ld = l.v;
  const lh = l.h;
  const ll = l.l;
  const lr = l.r;
  const rv = r.k;
  const rd = r.v;
  const rh = r.h;
  const rl = r.l;
  const rr = r.r;
  if (lh > (rh + 2 | 0)) {
    return bal(ll, lv, ld, join(lr, v, d, rn));
  } else if (rh > (lh + 2 | 0)) {
    return bal(join(ln, v, d, rl), rv, rd, rr);
  } else {
    return create(ln, v, d, rn);
  }
}

function concat(t1, t2) {
  if (t1 === undefined) {
    return t2;
  }
  if (t2 === undefined) {
    return t1;
  }
  const t2n = Caml_option.valFromOption(t2);
  const kr = {
    contents: t2n.k
  };
  const vr = {
    contents: t2n.v
  };
  const t2r = removeMinAuxWithRef(t2n, kr, vr);
  return join(t1, kr.contents, vr.contents, t2r);
}

function concatOrJoin(t1, v, d, t2) {
  if (d !== undefined) {
    return join(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat(t1, t2);
  }
}

function keepSharedU(n, p) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const v = n$1.k;
  const d = n$1.v;
  const newLeft = keepSharedU(n$1.l, p);
  const pvd = p(v, d);
  const newRight = keepSharedU(n$1.r, p);
  if (pvd) {
    return join(newLeft, v, d, newRight);
  } else {
    return concat(newLeft, newRight);
  }
}

function keepShared(n, p) {
  return keepSharedU(n, Curry.__2(p));
}

function keepMapU(n, p) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const v = n$1.k;
  const d = n$1.v;
  const newLeft = keepMapU(n$1.l, p);
  const pvd = p(v, d);
  const newRight = keepMapU(n$1.r, p);
  if (pvd !== undefined) {
    return join(newLeft, v, Caml_option.valFromOption(pvd), newRight);
  } else {
    return concat(newLeft, newRight);
  }
}

function keepMap(n, p) {
  return keepMapU(n, Curry.__2(p));
}

function partitionSharedU(n, p) {
  if (n === undefined) {
    return [
      undefined,
      undefined
    ];
  }
  const n$1 = Caml_option.valFromOption(n);
  const key = n$1.k;
  const value = n$1.v;
  const match = partitionSharedU(n$1.l, p);
  const lf = match[1];
  const lt = match[0];
  const pvd = p(key, value);
  const match$1 = partitionSharedU(n$1.r, p);
  const rf = match$1[1];
  const rt = match$1[0];
  if (pvd) {
    return [
      join(lt, key, value, rt),
      concat(lf, rf)
    ];
  } else {
    return [
      concat(lt, rt),
      join(lf, key, value, rf)
    ];
  }
}

function partitionShared(n, p) {
  return partitionSharedU(n, Curry.__2(p));
}

function lengthNode(n) {
  const l = n.l;
  const r = n.r;
  const sizeL = l !== undefined ? lengthNode(Caml_option.valFromOption(l)) : 0;
  const sizeR = r !== undefined ? lengthNode(Caml_option.valFromOption(r)) : 0;
  return (1 + sizeL | 0) + sizeR | 0;
}

function size(n) {
  if (n !== undefined) {
    return lengthNode(n);
  } else {
    return 0;
  }
}

function toListAux(_n, _accu) {
  while (true) {
    const accu = _accu;
    const n = _n;
    if (n === undefined) {
      return accu;
    }
    const n$1 = Caml_option.valFromOption(n);
    const k = n$1.k;
    const v = n$1.v;
    const l = n$1.l;
    const r = n$1.r;
    _accu = {
      hd: [
        k,
        v
      ],
      tl: toListAux(r, accu)
    };
    _n = l;
    continue;
  };
}

function toList(s) {
  return toListAux(s, /* [] */ 0);
}

function checkInvariantInternal(_v) {
  while (true) {
    const v = _v;
    if (v === undefined) {
      return;
    }
    const n = Caml_option.valFromOption(v);
    const l = n.l;
    const r = n.r;
    const diff = treeHeight(l) - treeHeight(r) | 0;
    if (!(diff <= 2 && diff >= -2)) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "belt/belt_internalAVLtree.ml",
              360,
              6
            ]
          });
    }
    checkInvariantInternal(l);
    _v = r;
    continue;
  };
}

function fillArrayKey(_n, _i, arr) {
  while (true) {
    const i = _i;
    const n = _n;
    const v = n.k;
    const l = n.l;
    const r = n.r;
    const next = l !== undefined ? fillArrayKey(Caml_option.valFromOption(l), i, arr) : i;
    arr[next] = v;
    const rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function fillArrayValue(_n, _i, arr) {
  while (true) {
    const i = _i;
    const n = _n;
    const l = n.l;
    const r = n.r;
    const next = l !== undefined ? fillArrayValue(Caml_option.valFromOption(l), i, arr) : i;
    arr[next] = n.v;
    const rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function fillArray(_n, _i, arr) {
  while (true) {
    const i = _i;
    const n = _n;
    const l = n.l;
    const v = n.k;
    const r = n.r;
    const next = l !== undefined ? fillArray(Caml_option.valFromOption(l), i, arr) : i;
    arr[next] = [
      v,
      n.v
    ];
    const rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function toArray(n) {
  if (n === undefined) {
    return [];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  fillArray(n, 0, v);
  return v;
}

function keysToArray(n) {
  if (n === undefined) {
    return [];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  fillArrayKey(n, 0, v);
  return v;
}

function valuesToArray(n) {
  if (n === undefined) {
    return [];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  fillArrayValue(n, 0, v);
  return v;
}

function fromSortedArrayRevAux(arr, off, len) {
  switch (len) {
    case 0 :
      return;
    case 1 :
      const match = arr[off];
      return singleton(match[0], match[1]);
    case 2 :
      const match_0 = arr[off];
      const match_1 = arr[off - 1 | 0];
      const match$1 = match_1;
      const match$2 = match_0;
      return {
        k: match$1[0],
        v: match$1[1],
        h: 2,
        l: singleton(match$2[0], match$2[1]),
        r: undefined
      };
    case 3 :
      const match_0$1 = arr[off];
      const match_1$1 = arr[off - 1 | 0];
      const match_2 = arr[off - 2 | 0];
      const match$3 = match_2;
      const match$4 = match_1$1;
      const match$5 = match_0$1;
      return {
        k: match$4[0],
        v: match$4[1],
        h: 2,
        l: singleton(match$5[0], match$5[1]),
        r: singleton(match$3[0], match$3[1])
      };
    default:
      const nl = len / 2 | 0;
      const left = fromSortedArrayRevAux(arr, off, nl);
      const match$6 = arr[off - nl | 0];
      const right = fromSortedArrayRevAux(arr, (off - nl | 0) - 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, match$6[0], match$6[1], right);
  }
}

function fromSortedArrayAux(arr, off, len) {
  switch (len) {
    case 0 :
      return;
    case 1 :
      const match = arr[off];
      return singleton(match[0], match[1]);
    case 2 :
      const match_0 = arr[off];
      const match_1 = arr[off + 1 | 0];
      const match$1 = match_1;
      const match$2 = match_0;
      return {
        k: match$1[0],
        v: match$1[1],
        h: 2,
        l: singleton(match$2[0], match$2[1]),
        r: undefined
      };
    case 3 :
      const match_0$1 = arr[off];
      const match_1$1 = arr[off + 1 | 0];
      const match_2 = arr[off + 2 | 0];
      const match$3 = match_2;
      const match$4 = match_1$1;
      const match$5 = match_0$1;
      return {
        k: match$4[0],
        v: match$4[1],
        h: 2,
        l: singleton(match$5[0], match$5[1]),
        r: singleton(match$3[0], match$3[1])
      };
    default:
      const nl = len / 2 | 0;
      const left = fromSortedArrayAux(arr, off, nl);
      const match$6 = arr[off + nl | 0];
      const right = fromSortedArrayAux(arr, (off + nl | 0) + 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, match$6[0], match$6[1], right);
  }
}

function fromSortedArrayUnsafe(arr) {
  return fromSortedArrayAux(arr, 0, arr.length);
}

function cmpU(s1, s2, kcmp, vcmp) {
  const len1 = size(s1);
  const len2 = size(s2);
  if (len1 === len2) {
    let _e1 = stackAllLeft(s1, /* [] */ 0);
    let _e2 = stackAllLeft(s2, /* [] */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (!e1) {
        return 0;
      }
      if (!e2) {
        return 0;
      }
      const h2 = e2.hd;
      const h1 = e1.hd;
      const c = kcmp(h1.k, h2.k);
      if (c !== 0) {
        return c;
      }
      const cx = vcmp(h1.v, h2.v);
      if (cx !== 0) {
        return cx;
      }
      _e2 = stackAllLeft(h2.r, e2.tl);
      _e1 = stackAllLeft(h1.r, e1.tl);
      continue;
    };
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function cmp(s1, s2, kcmp, vcmp) {
  return cmpU(s1, s2, kcmp, Curry.__2(vcmp));
}

function eqU(s1, s2, kcmp, veq) {
  const len1 = size(s1);
  const len2 = size(s2);
  if (len1 === len2) {
    let _e1 = stackAllLeft(s1, /* [] */ 0);
    let _e2 = stackAllLeft(s2, /* [] */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (!e1) {
        return true;
      }
      if (!e2) {
        return true;
      }
      const h2 = e2.hd;
      const h1 = e1.hd;
      if (!(kcmp(h1.k, h2.k) === 0 && veq(h1.v, h2.v))) {
        return false;
      }
      _e2 = stackAllLeft(h2.r, e2.tl);
      _e1 = stackAllLeft(h1.r, e1.tl);
      continue;
    };
  } else {
    return false;
  }
}

function eq(s1, s2, kcmp, veq) {
  return eqU(s1, s2, kcmp, Curry.__2(veq));
}

function get(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return Caml_option.some(n$1.v);
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function getUndefined(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return n$1.v;
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function getExn(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n !== undefined) {
      const n$1 = Caml_option.valFromOption(n);
      const v = n$1.k;
      const c = cmp(x, v);
      if (c === 0) {
        return n$1.v;
      }
      _n = c < 0 ? n$1.l : n$1.r;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function getWithDefault(_n, x, def, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return def;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return n$1.v;
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function has(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return false;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return true;
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function rotateWithLeftChild(k2) {
  const k1 = k2.l;
  const k1$1 = Caml_option.valFromOption(k1);
  k2.l = k1$1.r;
  k1$1.r = k2;
  const hlk2 = treeHeight(k2.l);
  const hrk2 = treeHeight(k2.r);
  k2.h = (
    hlk2 > hrk2 ? hlk2 : hrk2
  ) + 1 | 0;
  const hlk1 = treeHeight(k1$1.l);
  const hk2 = k2.h;
  k1$1.h = (
    hlk1 > hk2 ? hlk1 : hk2
  ) + 1 | 0;
  return k1$1;
}

function rotateWithRightChild(k1) {
  const k2 = k1.r;
  const k2$1 = Caml_option.valFromOption(k2);
  k1.r = k2$1.l;
  k2$1.l = k1;
  const hlk1 = treeHeight(k1.l);
  const hrk1 = treeHeight(k1.r);
  k1.h = (
    hlk1 > hrk1 ? hlk1 : hrk1
  ) + 1 | 0;
  const hrk2 = treeHeight(k2$1.r);
  const hk1 = k1.h;
  k2$1.h = (
    hrk2 > hk1 ? hrk2 : hk1
  ) + 1 | 0;
  return k2$1;
}

function doubleWithLeftChild(k3) {
  const x = k3.l;
  const v = rotateWithRightChild(Caml_option.valFromOption(x));
  k3.l = v;
  return rotateWithLeftChild(k3);
}

function doubleWithRightChild(k2) {
  const x = k2.r;
  const v = rotateWithLeftChild(Caml_option.valFromOption(x));
  k2.r = v;
  return rotateWithRightChild(k2);
}

function heightUpdateMutate(t) {
  const hlt = treeHeight(t.l);
  const hrt = treeHeight(t.r);
  t.h = (
    hlt > hrt ? hlt : hrt
  ) + 1 | 0;
  return t;
}

function balMutate(nt) {
  const l = nt.l;
  const r = nt.r;
  const hl = treeHeight(l);
  const hr = treeHeight(r);
  if (hl > (2 + hr | 0)) {
    const match = Caml_option.valFromOption(l);
    const ll = match.l;
    const lr = match.r;
    if (heightGe(ll, lr)) {
      return heightUpdateMutate(rotateWithLeftChild(nt));
    } else {
      return heightUpdateMutate(doubleWithLeftChild(nt));
    }
  }
  if (hr > (2 + hl | 0)) {
    const match$1 = Caml_option.valFromOption(r);
    const rl = match$1.l;
    const rr = match$1.r;
    if (heightGe(rr, rl)) {
      return heightUpdateMutate(rotateWithRightChild(nt));
    } else {
      return heightUpdateMutate(doubleWithRightChild(nt));
    }
  }
  nt.h = (
    hl > hr ? hl : hr
  ) + 1 | 0;
  return nt;
}

function updateMutate(t, x, data, cmp) {
  if (t === undefined) {
    return singleton(x, data);
  }
  const nt = Caml_option.valFromOption(t);
  const k = nt.k;
  const c = cmp(x, k);
  if (c === 0) {
    nt.v = data;
    return nt;
  }
  const l = nt.l;
  const r = nt.r;
  if (c < 0) {
    const ll = updateMutate(l, x, data, cmp);
    nt.l = ll;
  } else {
    nt.r = updateMutate(r, x, data, cmp);
  }
  return balMutate(nt);
}

function fromArray(xs, cmp) {
  const len = xs.length;
  if (len === 0) {
    return;
  }
  let next = Belt__Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {
    return cmp(param[0], param$1[0]) < 0;
  }));
  let result;
  if (next >= 0) {
    result = fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for (let i = next; i < len; ++i) {
    const match = xs[i];
    result = updateMutate(result, match[0], match[1], cmp);
  }
  return result;
}

function removeMinAuxWithRootMutate(nt, n) {
  const rn = n.r;
  const ln = n.l;
  if (ln !== undefined) {
    n.l = removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(ln));
    return balMutate(n);
  } else {
    nt.k = n.k;
    nt.v = n.v;
    return rn;
  }
}

export {
  copy,
  create,
  bal,
  singleton,
  updateValue,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  removeMinAuxWithRef,
  isEmpty,
  stackAllLeft,
  findFirstByU,
  findFirstBy,
  forEachU,
  forEach,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  join,
  concat,
  concatOrJoin,
  keepSharedU,
  keepShared,
  keepMapU,
  keepMap,
  partitionSharedU,
  partitionShared,
  lengthNode,
  size,
  toList,
  checkInvariantInternal,
  fillArray,
  toArray,
  keysToArray,
  valuesToArray,
  fromSortedArrayAux,
  fromSortedArrayRevAux,
  fromSortedArrayUnsafe,
  cmpU,
  cmp,
  eqU,
  eq,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  has,
  fromArray,
  updateMutate,
  balMutate,
  removeMinAuxWithRootMutate,
}
/* No side effect */
`,F_=`// Generated by Melange

import * as Belt__Belt_Array from "./belt_Array.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function copyBucket(c) {
  if (c === undefined) {
    return c;
  }
  const head = {
    key: c.key,
    value: c.value,
    next: undefined
  };
  copyAuxCont(c.next, head);
  return head;
}

function copyAuxCont(_c, _prec) {
  while (true) {
    const prec = _prec;
    const c = _c;
    if (c === undefined) {
      return;
    }
    const ncopy = {
      key: c.key,
      value: c.value,
      next: undefined
    };
    prec.next = ncopy;
    _prec = ncopy;
    _c = c.next;
    continue;
  };
}

function copyBuckets(buckets) {
  const len = buckets.length;
  const newBuckets = new Array(len);
  for (let i = 0; i < len; ++i) {
    newBuckets[i] = copyBucket(buckets[i]);
  }
  return newBuckets;
}

function copy(x) {
  return {
    size: x.size,
    buckets: copyBuckets(x.buckets),
    hash: x.hash,
    eq: x.eq
  };
}

function bucketLength(_accu, _buckets) {
  while (true) {
    const buckets = _buckets;
    const accu = _accu;
    if (buckets === undefined) {
      return accu;
    }
    _buckets = buckets.next;
    _accu = accu + 1 | 0;
    continue;
  };
}

function do_bucket_iter(f, _buckets) {
  while (true) {
    const buckets = _buckets;
    if (buckets === undefined) {
      return;
    }
    f(buckets.key, buckets.value);
    _buckets = buckets.next;
    continue;
  };
}

function forEachU(h, f) {
  const d = h.buckets;
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    do_bucket_iter(f, d[i]);
  }
}

function forEach(h, f) {
  forEachU(h, Curry.__2(f));
}

function do_bucket_fold(f, _b, _accu) {
  while (true) {
    const accu = _accu;
    const b = _b;
    if (b === undefined) {
      return accu;
    }
    _accu = f(accu, b.key, b.value);
    _b = b.next;
    continue;
  };
}

function reduceU(h, init, f) {
  const d = h.buckets;
  let accu = init;
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    accu = do_bucket_fold(f, d[i], accu);
  }
  return accu;
}

function reduce(h, init, f) {
  return reduceU(h, init, Curry.__3(f));
}

function getMaxBucketLength(h) {
  return Belt__Belt_Array.reduceU(h.buckets, 0, (function (m, b) {
    const len = bucketLength(0, b);
    if (m > len) {
      return m;
    } else {
      return len;
    }
  }));
}

function getBucketHistogram(h) {
  const mbl = getMaxBucketLength(h);
  const histo = Belt__Belt_Array.makeByU(mbl + 1 | 0, (function (param) {
    return 0;
  }));
  Belt__Belt_Array.forEachU(h.buckets, (function (b) {
    const l = bucketLength(0, b);
    histo[l] = histo[l] + 1 | 0;
  }));
  return histo;
}

function logStats(h) {
  const histogram = getBucketHistogram(h);
  console.log({
    bindings: h.size,
    buckets: h.buckets.length,
    histogram: histogram
  });
}

function filterMapInplaceBucket(f, h, i, _prec, _cell) {
  while (true) {
    const cell = _cell;
    const prec = _prec;
    const n = cell.next;
    const data = f(cell.key, cell.value);
    if (data !== undefined) {
      if (prec !== undefined) {
        cell.next = cell;
      } else {
        h.buckets[i] = cell;
      }
      cell.value = Caml_option.valFromOption(data);
      if (n === undefined) {
        cell.next = n;
        return;
      }
      _cell = n;
      _prec = cell;
      continue;
    }
    h.size = h.size - 1 | 0;
    if (n === undefined) {
      if (prec !== undefined) {
        prec.next = n;
      } else {
        h.buckets[i] = prec;
      }
      return;
    }
    _cell = n;
    continue;
  };
}

function keepMapInPlaceU(h, f) {
  const h_buckets = h.buckets;
  for (let i = 0, i_finish = h_buckets.length; i < i_finish; ++i) {
    const v = h_buckets[i];
    if (v !== undefined) {
      filterMapInplaceBucket(f, h, i, undefined, v);
    }
    
  }
}

function keepMapInPlace(h, f) {
  keepMapInPlaceU(h, Curry.__2(f));
}

function fillArray(_i, arr, _cell) {
  while (true) {
    const cell = _cell;
    const i = _i;
    arr[i] = [
      cell.key,
      cell.value
    ];
    const v = cell.next;
    if (v === undefined) {
      return i + 1 | 0;
    }
    _cell = v;
    _i = i + 1 | 0;
    continue;
  };
}

function fillArrayMap(_i, arr, _cell, f) {
  while (true) {
    const cell = _cell;
    const i = _i;
    arr[i] = f(cell);
    const v = cell.next;
    if (v === undefined) {
      return i + 1 | 0;
    }
    _cell = v;
    _i = i + 1 | 0;
    continue;
  };
}

function linear(h, f) {
  const d = h.buckets;
  let current = 0;
  const arr = new Array(h.size);
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    const cell = d[i];
    if (cell !== undefined) {
      current = fillArrayMap(current, arr, cell, f);
    }
    
  }
  return arr;
}

function keysToArray(h) {
  return linear(h, (function (x) {
    return x.key;
  }));
}

function valuesToArray(h) {
  return linear(h, (function (x) {
    return x.value;
  }));
}

function toArray(h) {
  return linear(h, (function (x) {
    return [
      x.key,
      x.value
    ];
  }));
}

export {
  copy,
  forEachU,
  forEach,
  reduceU,
  reduce,
  logStats,
  keepMapInPlaceU,
  keepMapInPlace,
  fillArray,
  keysToArray,
  valuesToArray,
  toArray,
  getBucketHistogram,
}
/* No side effect */
`,P_=`// Generated by Melange


function power_2_above(_x, n) {
  while (true) {
    const x = _x;
    if (x >= n) {
      return x;
    }
    if ((x << 1) < x) {
      return x;
    }
    _x = (x << 1);
    continue;
  };
}

function make(hash, eq, hintSize) {
  const s = power_2_above(16, hintSize);
  return {
    size: 0,
    buckets: new Array(s),
    hash: hash,
    eq: eq
  };
}

function clear(h) {
  h.size = 0;
  const h_buckets = h.buckets;
  const len = h_buckets.length;
  for (let i = 0; i < len; ++i) {
    h_buckets[i] = undefined;
  }
}

function isEmpty(h) {
  return h.size === 0;
}

let emptyOpt;

export {
  emptyOpt,
  make,
  clear,
  isEmpty,
}
/* No side effect */
`,U_=`// Generated by Melange

import * as Belt__Belt_SortArray from "./belt_SortArray.js";
import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Caml from "melange.js/caml.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function add(t, x, data) {
  if (t === undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, data);
  }
  const n = Caml_option.valFromOption(t);
  const k = n.k;
  if (x === k) {
    return Belt__Belt_internalAVLtree.updateValue(n, data);
  }
  const v = n.v;
  if (x < k) {
    return Belt__Belt_internalAVLtree.bal(add(n.l, x, data), k, v, n.r);
  } else {
    return Belt__Belt_internalAVLtree.bal(n.l, k, v, add(n.r, x, data));
  }
}

function get(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return Caml_option.some(n$1.v);
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function getUndefined(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return n$1.v;
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function getExn(_n, x) {
  while (true) {
    const n = _n;
    if (n !== undefined) {
      const n$1 = Caml_option.valFromOption(n);
      const v = n$1.k;
      if (x === v) {
        return n$1.v;
      }
      _n = x < v ? n$1.l : n$1.r;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function getWithDefault(_n, x, def) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return def;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return n$1.v;
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function has(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return false;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return true;
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function remove(n, x) {
  if (n === undefined) {
    return n;
  }
  const n$1 = Caml_option.valFromOption(n);
  const v = n$1.k;
  const l = n$1.l;
  const r = n$1.r;
  if (x !== v) {
    if (x < v) {
      return Belt__Belt_internalAVLtree.bal(remove(l, x), v, n$1.v, r);
    } else {
      return Belt__Belt_internalAVLtree.bal(l, v, n$1.v, remove(r, x));
    }
  }
  if (l === undefined) {
    return r;
  }
  if (r === undefined) {
    return l;
  }
  const rn = Caml_option.valFromOption(r);
  const kr = {
    contents: rn.k
  };
  const vr = {
    contents: rn.v
  };
  const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
  return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
}

function splitAux(x, n) {
  const v = n.k;
  const d = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    return [
      l,
      Caml_option.some(d),
      r
    ];
  }
  if (x < v) {
    if (l === undefined) {
      return [
        undefined,
        undefined,
        n
      ];
    }
    const match = splitAux(x, Caml_option.valFromOption(l));
    return [
      match[0],
      match[1],
      Belt__Belt_internalAVLtree.join(match[2], v, d, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined,
      undefined
    ];
  }
  const match$1 = splitAux(x, Caml_option.valFromOption(r));
  return [
    Belt__Belt_internalAVLtree.join(l, v, d, match$1[0]),
    match$1[1],
    match$1[2]
  ];
}

function split(x, n) {
  if (n !== undefined) {
    return splitAux(x, n);
  } else {
    return [
      undefined,
      undefined,
      undefined
    ];
  }
}

function mergeU(s1, s2, f) {
  if (s1 !== undefined) {
    const n = Caml_option.valFromOption(s1);
    if (n.h >= (
        s2 !== undefined ? s2.h : 0
      )) {
      const v1 = n.k;
      const d1 = n.v;
      const l1 = n.l;
      const r1 = n.r;
      const match = split(v1, s2);
      return Belt__Belt_internalAVLtree.concatOrJoin(mergeU(l1, match[0], f), v1, f(v1, Caml_option.some(d1), match[1]), mergeU(r1, match[2], f));
    }
    
  } else if (s2 === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(s2);
  const v2 = n$1.k;
  const d2 = n$1.v;
  const l2 = n$1.l;
  const r2 = n$1.r;
  const match$1 = split(v2, s1);
  return Belt__Belt_internalAVLtree.concatOrJoin(mergeU(match$1[0], l2, f), v2, f(v2, match$1[1], Caml_option.some(d2)), mergeU(match$1[2], r2, f));
}

function merge(s1, s2, f) {
  return mergeU(s1, s2, Curry.__3(f));
}

function compareAux(_e1, _e2, vcmp) {
  while (true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      return 0;
    }
    if (!e2) {
      return 0;
    }
    const h2 = e2.hd;
    const h1 = e1.hd;
    const c = Caml.caml_int_compare(h1.k, h2.k);
    if (c !== 0) {
      return c;
    }
    const cx = vcmp(h1.v, h2.v);
    if (cx !== 0) {
      return cx;
    }
    _e2 = Belt__Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt__Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);
    continue;
  };
}

function cmpU(s1, s2, cmp) {
  const len1 = Belt__Belt_internalAVLtree.size(s1);
  const len2 = Belt__Belt_internalAVLtree.size(s2);
  if (len1 === len2) {
    return compareAux(Belt__Belt_internalAVLtree.stackAllLeft(s1, /* [] */ 0), Belt__Belt_internalAVLtree.stackAllLeft(s2, /* [] */ 0), cmp);
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function cmp(s1, s2, f) {
  return cmpU(s1, s2, Curry.__2(f));
}

function eqAux(_e1, _e2, eq) {
  while (true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      return true;
    }
    if (!e2) {
      return true;
    }
    const h2 = e2.hd;
    const h1 = e1.hd;
    if (!(h1.k === h2.k && eq(h1.v, h2.v))) {
      return false;
    }
    _e2 = Belt__Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt__Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);
    continue;
  };
}

function eqU(s1, s2, eq) {
  const len1 = Belt__Belt_internalAVLtree.size(s1);
  const len2 = Belt__Belt_internalAVLtree.size(s2);
  if (len1 === len2) {
    return eqAux(Belt__Belt_internalAVLtree.stackAllLeft(s1, /* [] */ 0), Belt__Belt_internalAVLtree.stackAllLeft(s2, /* [] */ 0), eq);
  } else {
    return false;
  }
}

function eq(s1, s2, f) {
  return eqU(s1, s2, Curry.__2(f));
}

function addMutate(t, x, data) {
  if (t === undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, data);
  }
  const nt = Caml_option.valFromOption(t);
  const k = nt.k;
  if (x === k) {
    nt.k = x;
    nt.v = data;
    return nt;
  }
  const l = nt.l;
  const r = nt.r;
  if (x < k) {
    const ll = addMutate(l, x, data);
    nt.l = ll;
  } else {
    nt.r = addMutate(r, x, data);
  }
  return Belt__Belt_internalAVLtree.balMutate(nt);
}

function fromArray(xs) {
  const len = xs.length;
  if (len === 0) {
    return;
  }
  let next = Belt__Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {
    return param[0] < param$1[0];
  }));
  let result;
  if (next >= 0) {
    result = Belt__Belt_internalAVLtree.fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = Belt__Belt_internalAVLtree.fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for (let i = next; i < len; ++i) {
    const match = xs[i];
    result = addMutate(result, match[0], match[1]);
  }
  return result;
}

export {
  add,
  get,
  getUndefined,
  getExn,
  getWithDefault,
  has,
  remove,
  splitAux,
  split,
  mergeU,
  merge,
  compareAux,
  cmpU,
  cmp,
  eqAux,
  eqU,
  eq,
  addMutate,
  fromArray,
}
/* No side effect */
`,R_=`// Generated by Melange

import * as Belt__Belt_SortArray from "./belt_SortArray.js";
import * as Belt__Belt_internalAVLtree from "./belt_internalAVLtree.js";
import * as Caml from "melange.js/caml.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function add(t, x, data) {
  if (t === undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, data);
  }
  const n = Caml_option.valFromOption(t);
  const k = n.k;
  if (x === k) {
    return Belt__Belt_internalAVLtree.updateValue(n, data);
  }
  const v = n.v;
  if (x < k) {
    return Belt__Belt_internalAVLtree.bal(add(n.l, x, data), k, v, n.r);
  } else {
    return Belt__Belt_internalAVLtree.bal(n.l, k, v, add(n.r, x, data));
  }
}

function get(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return Caml_option.some(n$1.v);
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function getUndefined(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return n$1.v;
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function getExn(_n, x) {
  while (true) {
    const n = _n;
    if (n !== undefined) {
      const n$1 = Caml_option.valFromOption(n);
      const v = n$1.k;
      if (x === v) {
        return n$1.v;
      }
      _n = x < v ? n$1.l : n$1.r;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function getWithDefault(_n, x, def) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return def;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return n$1.v;
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function has(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return false;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    if (x === v) {
      return true;
    }
    _n = x < v ? n$1.l : n$1.r;
    continue;
  };
}

function remove(n, x) {
  if (n === undefined) {
    return n;
  }
  const n$1 = Caml_option.valFromOption(n);
  const v = n$1.k;
  const l = n$1.l;
  const r = n$1.r;
  if (x !== v) {
    if (x < v) {
      return Belt__Belt_internalAVLtree.bal(remove(l, x), v, n$1.v, r);
    } else {
      return Belt__Belt_internalAVLtree.bal(l, v, n$1.v, remove(r, x));
    }
  }
  if (l === undefined) {
    return r;
  }
  if (r === undefined) {
    return l;
  }
  const rn = Caml_option.valFromOption(r);
  const kr = {
    contents: rn.k
  };
  const vr = {
    contents: rn.v
  };
  const r$1 = Belt__Belt_internalAVLtree.removeMinAuxWithRef(rn, kr, vr);
  return Belt__Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
}

function splitAux(x, n) {
  const v = n.k;
  const d = n.v;
  const l = n.l;
  const r = n.r;
  if (x === v) {
    return [
      l,
      Caml_option.some(d),
      r
    ];
  }
  if (x < v) {
    if (l === undefined) {
      return [
        undefined,
        undefined,
        n
      ];
    }
    const match = splitAux(x, Caml_option.valFromOption(l));
    return [
      match[0],
      match[1],
      Belt__Belt_internalAVLtree.join(match[2], v, d, r)
    ];
  }
  if (r === undefined) {
    return [
      n,
      undefined,
      undefined
    ];
  }
  const match$1 = splitAux(x, Caml_option.valFromOption(r));
  return [
    Belt__Belt_internalAVLtree.join(l, v, d, match$1[0]),
    match$1[1],
    match$1[2]
  ];
}

function split(x, n) {
  if (n !== undefined) {
    return splitAux(x, n);
  } else {
    return [
      undefined,
      undefined,
      undefined
    ];
  }
}

function mergeU(s1, s2, f) {
  if (s1 !== undefined) {
    const n = Caml_option.valFromOption(s1);
    if (n.h >= (
        s2 !== undefined ? s2.h : 0
      )) {
      const v1 = n.k;
      const d1 = n.v;
      const l1 = n.l;
      const r1 = n.r;
      const match = split(v1, s2);
      return Belt__Belt_internalAVLtree.concatOrJoin(mergeU(l1, match[0], f), v1, f(v1, Caml_option.some(d1), match[1]), mergeU(r1, match[2], f));
    }
    
  } else if (s2 === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(s2);
  const v2 = n$1.k;
  const d2 = n$1.v;
  const l2 = n$1.l;
  const r2 = n$1.r;
  const match$1 = split(v2, s1);
  return Belt__Belt_internalAVLtree.concatOrJoin(mergeU(match$1[0], l2, f), v2, f(v2, match$1[1], Caml_option.some(d2)), mergeU(match$1[2], r2, f));
}

function merge(s1, s2, f) {
  return mergeU(s1, s2, Curry.__3(f));
}

function compareAux(_e1, _e2, vcmp) {
  while (true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      return 0;
    }
    if (!e2) {
      return 0;
    }
    const h2 = e2.hd;
    const h1 = e1.hd;
    const c = Caml.caml_string_compare(h1.k, h2.k);
    if (c !== 0) {
      return c;
    }
    const cx = vcmp(h1.v, h2.v);
    if (cx !== 0) {
      return cx;
    }
    _e2 = Belt__Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt__Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);
    continue;
  };
}

function cmpU(s1, s2, cmp) {
  const len1 = Belt__Belt_internalAVLtree.size(s1);
  const len2 = Belt__Belt_internalAVLtree.size(s2);
  if (len1 === len2) {
    return compareAux(Belt__Belt_internalAVLtree.stackAllLeft(s1, /* [] */ 0), Belt__Belt_internalAVLtree.stackAllLeft(s2, /* [] */ 0), cmp);
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function cmp(s1, s2, f) {
  return cmpU(s1, s2, Curry.__2(f));
}

function eqAux(_e1, _e2, eq) {
  while (true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      return true;
    }
    if (!e2) {
      return true;
    }
    const h2 = e2.hd;
    const h1 = e1.hd;
    if (!(h1.k === h2.k && eq(h1.v, h2.v))) {
      return false;
    }
    _e2 = Belt__Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt__Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);
    continue;
  };
}

function eqU(s1, s2, eq) {
  const len1 = Belt__Belt_internalAVLtree.size(s1);
  const len2 = Belt__Belt_internalAVLtree.size(s2);
  if (len1 === len2) {
    return eqAux(Belt__Belt_internalAVLtree.stackAllLeft(s1, /* [] */ 0), Belt__Belt_internalAVLtree.stackAllLeft(s2, /* [] */ 0), eq);
  } else {
    return false;
  }
}

function eq(s1, s2, f) {
  return eqU(s1, s2, Curry.__2(f));
}

function addMutate(t, x, data) {
  if (t === undefined) {
    return Belt__Belt_internalAVLtree.singleton(x, data);
  }
  const nt = Caml_option.valFromOption(t);
  const k = nt.k;
  if (x === k) {
    nt.k = x;
    nt.v = data;
    return nt;
  }
  const l = nt.l;
  const r = nt.r;
  if (x < k) {
    const ll = addMutate(l, x, data);
    nt.l = ll;
  } else {
    nt.r = addMutate(r, x, data);
  }
  return Belt__Belt_internalAVLtree.balMutate(nt);
}

function fromArray(xs) {
  const len = xs.length;
  if (len === 0) {
    return;
  }
  let next = Belt__Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {
    return param[0] < param$1[0];
  }));
  let result;
  if (next >= 0) {
    result = Belt__Belt_internalAVLtree.fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = Belt__Belt_internalAVLtree.fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for (let i = next; i < len; ++i) {
    const match = xs[i];
    result = addMutate(result, match[0], match[1]);
  }
  return result;
}

export {
  add,
  get,
  getUndefined,
  getExn,
  getWithDefault,
  has,
  remove,
  splitAux,
  split,
  mergeU,
  merge,
  compareAux,
  cmpU,
  cmp,
  eqAux,
  eqU,
  eq,
  addMutate,
  fromArray,
}
/* No side effect */
`,V_=`// Generated by Melange

import * as Belt__Belt_Array from "./belt_Array.js";
import * as Curry from "melange.js/curry.js";

function copyBucket(c) {
  if (c === undefined) {
    return c;
  }
  const head = {
    key: c.key,
    next: undefined
  };
  copyAuxCont(c.next, head);
  return head;
}

function copyAuxCont(_c, _prec) {
  while (true) {
    const prec = _prec;
    const c = _c;
    if (c === undefined) {
      return;
    }
    const ncopy = {
      key: c.key,
      next: undefined
    };
    prec.next = ncopy;
    _prec = ncopy;
    _c = c.next;
    continue;
  };
}

function copyBuckets(buckets) {
  const len = buckets.length;
  const newBuckets = new Array(len);
  for (let i = 0; i < len; ++i) {
    newBuckets[i] = copyBucket(buckets[i]);
  }
  return newBuckets;
}

function copy(x) {
  return {
    size: x.size,
    buckets: copyBuckets(x.buckets),
    hash: x.hash,
    eq: x.eq
  };
}

function bucketLength(_accu, _buckets) {
  while (true) {
    const buckets = _buckets;
    const accu = _accu;
    if (buckets === undefined) {
      return accu;
    }
    _buckets = buckets.next;
    _accu = accu + 1 | 0;
    continue;
  };
}

function doBucketIter(f, _buckets) {
  while (true) {
    const buckets = _buckets;
    if (buckets === undefined) {
      return;
    }
    f(buckets.key);
    _buckets = buckets.next;
    continue;
  };
}

function forEachU(h, f) {
  const d = h.buckets;
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    doBucketIter(f, d[i]);
  }
}

function forEach(h, f) {
  forEachU(h, Curry.__1(f));
}

function fillArray(_i, arr, _cell) {
  while (true) {
    const cell = _cell;
    const i = _i;
    arr[i] = cell.key;
    const v = cell.next;
    if (v === undefined) {
      return i + 1 | 0;
    }
    _cell = v;
    _i = i + 1 | 0;
    continue;
  };
}

function toArray(h) {
  const d = h.buckets;
  let current = 0;
  const arr = new Array(h.size);
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    const cell = d[i];
    if (cell !== undefined) {
      current = fillArray(current, arr, cell);
    }
    
  }
  return arr;
}

function doBucketFold(f, _b, _accu) {
  while (true) {
    const accu = _accu;
    const b = _b;
    if (b === undefined) {
      return accu;
    }
    _accu = f(accu, b.key);
    _b = b.next;
    continue;
  };
}

function reduceU(h, init, f) {
  const d = h.buckets;
  let accu = init;
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    accu = doBucketFold(f, d[i], accu);
  }
  return accu;
}

function reduce(h, init, f) {
  return reduceU(h, init, Curry.__2(f));
}

function getMaxBucketLength(h) {
  return Belt__Belt_Array.reduceU(h.buckets, 0, (function (m, b) {
    const len = bucketLength(0, b);
    if (m > len) {
      return m;
    } else {
      return len;
    }
  }));
}

function getBucketHistogram(h) {
  const mbl = getMaxBucketLength(h);
  const histo = Belt__Belt_Array.makeByU(mbl + 1 | 0, (function (param) {
    return 0;
  }));
  Belt__Belt_Array.forEachU(h.buckets, (function (b) {
    const l = bucketLength(0, b);
    histo[l] = histo[l] + 1 | 0;
  }));
  return histo;
}

function logStats(h) {
  const histogram = getBucketHistogram(h);
  console.log({
    bindings: h.size,
    buckets: h.buckets.length,
    histogram: histogram
  });
}

export {
  copy,
  forEachU,
  forEach,
  fillArray,
  toArray,
  reduceU,
  reduce,
  logStats,
  getBucketHistogram,
}
/* No side effect */
`,q_=`// Generated by Melange

import * as Belt__Belt_SortArrayInt from "./belt_SortArrayInt.js";
import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Stdlib from "melange/stdlib.js";

function has(_t, x) {
  while (true) {
    const t = _t;
    if (t === undefined) {
      return false;
    }
    const n = Caml_option.valFromOption(t);
    const v = n.v;
    if (x === v) {
      return true;
    }
    _t = x < v ? n.l : n.r;
    continue;
  };
}

function compareAux(_e1, _e2) {
  while (true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      return 0;
    }
    if (!e2) {
      return 0;
    }
    const h2 = e2.hd;
    const h1 = e1.hd;
    const k1 = h1.v;
    const k2 = h2.v;
    if (k1 !== k2) {
      if (k1 < k2) {
        return -1;
      } else {
        return 1;
      }
    }
    _e2 = Belt__Belt_internalAVLset.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt__Belt_internalAVLset.stackAllLeft(h1.r, e1.tl);
    continue;
  };
}

function cmp(s1, s2) {
  const len1 = Belt__Belt_internalAVLset.size(s1);
  const len2 = Belt__Belt_internalAVLset.size(s2);
  if (len1 === len2) {
    return compareAux(Belt__Belt_internalAVLset.stackAllLeft(s1, /* [] */ 0), Belt__Belt_internalAVLset.stackAllLeft(s2, /* [] */ 0));
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function eq(s1, s2) {
  return cmp(s1, s2) === 0;
}

function subset(_s1, _s2) {
  while (true) {
    const s2 = _s2;
    const s1 = _s1;
    if (s1 === undefined) {
      return true;
    }
    if (s2 === undefined) {
      return false;
    }
    const t2 = Caml_option.valFromOption(s2);
    const t1 = Caml_option.valFromOption(s1);
    const v1 = t1.v;
    const l1 = t1.l;
    const r1 = t1.r;
    const v2 = t2.v;
    const l2 = t2.l;
    const r2 = t2.r;
    if (v1 === v2) {
      if (!subset(l1, l2)) {
        return false;
      }
      _s2 = r2;
      _s1 = r1;
      continue;
    }
    if (v1 < v2) {
      if (!subset(Belt__Belt_internalAVLset.create(l1, v1, undefined), l2)) {
        return false;
      }
      _s1 = r1;
      continue;
    }
    if (!subset(Belt__Belt_internalAVLset.create(undefined, v1, r1), r2)) {
      return false;
    }
    _s1 = l1;
    continue;
  };
}

function get(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const t = Caml_option.valFromOption(n);
    const v = t.v;
    if (x === v) {
      return v;
    }
    _n = x < v ? t.l : t.r;
    continue;
  };
}

function getUndefined(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const t = Caml_option.valFromOption(n);
    const v = t.v;
    if (x === v) {
      return v;
    }
    _n = x < v ? t.l : t.r;
    continue;
  };
}

function getExn(_n, x) {
  while (true) {
    const n = _n;
    if (n !== undefined) {
      const t = Caml_option.valFromOption(n);
      const v = t.v;
      if (x === v) {
        return v;
      }
      _n = x < v ? t.l : t.r;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function addMutate(t, x) {
  if (t === undefined) {
    return Belt__Belt_internalAVLset.singleton(x);
  }
  const k = t.v;
  if (x === k) {
    return t;
  }
  const l = t.l;
  const r = t.r;
  if (x < k) {
    t.l = addMutate(l, x);
  } else {
    t.r = addMutate(r, x);
  }
  return Belt__Belt_internalAVLset.balMutate(t);
}

function fromArray(xs) {
  const len = xs.length;
  if (len === 0) {
    return;
  }
  let next = Belt__Belt_SortArrayInt.strictlySortedLength(xs);
  let result;
  if (next >= 0) {
    result = Belt__Belt_internalAVLset.fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = Belt__Belt_internalAVLset.fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for (let i = next; i < len; ++i) {
    result = addMutate(result, xs[i]);
  }
  return result;
}

export {
  has,
  compareAux,
  cmp,
  eq,
  subset,
  get,
  getUndefined,
  getExn,
  addMutate,
  fromArray,
}
/* No side effect */
`,X_=`// Generated by Melange

import * as Belt__Belt_SortArrayString from "./belt_SortArrayString.js";
import * as Belt__Belt_internalAVLset from "./belt_internalAVLset.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Stdlib from "melange/stdlib.js";

function has(_t, x) {
  while (true) {
    const t = _t;
    if (t === undefined) {
      return false;
    }
    const n = Caml_option.valFromOption(t);
    const v = n.v;
    if (x === v) {
      return true;
    }
    _t = x < v ? n.l : n.r;
    continue;
  };
}

function compareAux(_e1, _e2) {
  while (true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      return 0;
    }
    if (!e2) {
      return 0;
    }
    const h2 = e2.hd;
    const h1 = e1.hd;
    const k1 = h1.v;
    const k2 = h2.v;
    if (k1 !== k2) {
      if (k1 < k2) {
        return -1;
      } else {
        return 1;
      }
    }
    _e2 = Belt__Belt_internalAVLset.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt__Belt_internalAVLset.stackAllLeft(h1.r, e1.tl);
    continue;
  };
}

function cmp(s1, s2) {
  const len1 = Belt__Belt_internalAVLset.size(s1);
  const len2 = Belt__Belt_internalAVLset.size(s2);
  if (len1 === len2) {
    return compareAux(Belt__Belt_internalAVLset.stackAllLeft(s1, /* [] */ 0), Belt__Belt_internalAVLset.stackAllLeft(s2, /* [] */ 0));
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function eq(s1, s2) {
  return cmp(s1, s2) === 0;
}

function subset(_s1, _s2) {
  while (true) {
    const s2 = _s2;
    const s1 = _s1;
    if (s1 === undefined) {
      return true;
    }
    if (s2 === undefined) {
      return false;
    }
    const t2 = Caml_option.valFromOption(s2);
    const t1 = Caml_option.valFromOption(s1);
    const v1 = t1.v;
    const l1 = t1.l;
    const r1 = t1.r;
    const v2 = t2.v;
    const l2 = t2.l;
    const r2 = t2.r;
    if (v1 === v2) {
      if (!subset(l1, l2)) {
        return false;
      }
      _s2 = r2;
      _s1 = r1;
      continue;
    }
    if (v1 < v2) {
      if (!subset(Belt__Belt_internalAVLset.create(l1, v1, undefined), l2)) {
        return false;
      }
      _s1 = r1;
      continue;
    }
    if (!subset(Belt__Belt_internalAVLset.create(undefined, v1, r1), r2)) {
      return false;
    }
    _s1 = l1;
    continue;
  };
}

function get(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const t = Caml_option.valFromOption(n);
    const v = t.v;
    if (x === v) {
      return v;
    }
    _n = x < v ? t.l : t.r;
    continue;
  };
}

function getUndefined(_n, x) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const t = Caml_option.valFromOption(n);
    const v = t.v;
    if (x === v) {
      return v;
    }
    _n = x < v ? t.l : t.r;
    continue;
  };
}

function getExn(_n, x) {
  while (true) {
    const n = _n;
    if (n !== undefined) {
      const t = Caml_option.valFromOption(n);
      const v = t.v;
      if (x === v) {
        return v;
      }
      _n = x < v ? t.l : t.r;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function addMutate(t, x) {
  if (t === undefined) {
    return Belt__Belt_internalAVLset.singleton(x);
  }
  const k = t.v;
  if (x === k) {
    return t;
  }
  const l = t.l;
  const r = t.r;
  if (x < k) {
    t.l = addMutate(l, x);
  } else {
    t.r = addMutate(r, x);
  }
  return Belt__Belt_internalAVLset.balMutate(t);
}

function fromArray(xs) {
  const len = xs.length;
  if (len === 0) {
    return;
  }
  let next = Belt__Belt_SortArrayString.strictlySortedLength(xs);
  let result;
  if (next >= 0) {
    result = Belt__Belt_internalAVLset.fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = Belt__Belt_internalAVLset.fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for (let i = next; i < len; ++i) {
    result = addMutate(result, xs[i]);
  }
  return result;
}

export {
  has,
  compareAux,
  cmp,
  eq,
  subset,
  get,
  getUndefined,
  getExn,
  addMutate,
  fromArray,
}
/* No side effect */
`,W_=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,K_=`// Generated by Melange


const Dom__ = {};

export {
  Dom__,
}
/* No side effect */
`,H_=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Y_=`// Generated by Melange


function caml_int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function caml_bool_compare(x, y) {
  if (x) {
    if (y) {
      return 0;
    } else {
      return 1;
    }
  } else if (y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_float_compare(x, y) {
  if (x === y) {
    return 0;
  } else if (x < y) {
    return -1;
  } else if (x > y || x === x) {
    return 1;
  } else if (y === y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function caml_bool_min(x, y) {
  if (x) {
    return y;
  } else {
    return x;
  }
}

function caml_int_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_bool_max(x, y) {
  if (x) {
    return x;
  } else {
    return y;
  }
}

function caml_int_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function i64_eq(x, y) {
  if (x[1] === y[1]) {
    return x[0] === y[0];
  } else {
    return false;
  }
}

function i64_ge(param, param$1) {
  const other_hi = param$1[0];
  const hi = param[0];
  if (hi > other_hi) {
    return true;
  } else if (hi < other_hi) {
    return false;
  } else {
    return param[1] >= param$1[1];
  }
}

function i64_neq(x, y) {
  return !i64_eq(x, y);
}

function i64_lt(x, y) {
  return !i64_ge(x, y);
}

function i64_gt(x, y) {
  if (x[0] > y[0]) {
    return true;
  } else if (x[0] < y[0]) {
    return false;
  } else {
    return x[1] > y[1];
  }
}

function i64_le(x, y) {
  return !i64_gt(x, y);
}

function i64_min(x, y) {
  if (i64_ge(x, y)) {
    return y;
  } else {
    return x;
  }
}

function i64_max(x, y) {
  if (i64_gt(x, y)) {
    return x;
  } else {
    return y;
  }
}

export {
  caml_int_compare,
  caml_bool_compare,
  caml_float_compare,
  caml_string_compare,
  caml_bool_min,
  caml_int_min,
  caml_float_min,
  caml_string_min,
  caml_int32_min,
  caml_bool_max,
  caml_int_max,
  caml_float_max,
  caml_string_max,
  caml_int32_max,
  i64_eq,
  i64_neq,
  i64_lt,
  i64_gt,
  i64_le,
  i64_ge,
  i64_min,
  i64_max,
}
/* No side effect */
`,J_=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function sub(x, offset, len) {
  const result = new Array(len);
  let j = 0;
  let i = offset;
  while (j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  };
  return result;
}

function len(_acc, _l) {
  while (true) {
    const l = _l;
    const acc = _acc;
    if (!l) {
      return acc;
    }
    _l = l.tl;
    _acc = l.hd.length + acc | 0;
    continue;
  };
}

function fill(arr, _i, _l) {
  while (true) {
    const l = _l;
    const i = _i;
    if (!l) {
      return;
    }
    const x = l.hd;
    const l$1 = x.length;
    let k = i;
    let j = 0;
    while (j < l$1) {
      arr[k] = x[j];
      k = k + 1 | 0;
      j = j + 1 | 0;
    };
    _l = l.tl;
    _i = k;
    continue;
  };
}

function concat(l) {
  const v = len(0, l);
  const result = new Array(v);
  fill(result, 0, l);
  return result;
}

function set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  xs[index] = newval;
}

function get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  return xs[index];
}

function make(len, init) {
  const b = new Array(len);
  for (let i = 0; i < len; ++i) {
    b[i] = init;
  }
  return b;
}

function make_float(len) {
  const b = new Array(len);
  for (let i = 0; i < len; ++i) {
    b[i] = 0;
  }
  return b;
}

function blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for (let j = 0; j < len; ++j) {
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return;
  }
  for (let j$1 = len - 1 | 0; j$1 >= 0; --j$1) {
    a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
  }
}

function dup(prim) {
  return prim.slice(0);
}

export {
  dup,
  sub,
  concat,
  make,
  make_float,
  blit,
  get,
  set,
}
/* No side effect */
`,Z_=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Q_=`// Generated by Melange

import * as Caml_int64 from "./caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function set(s, i, ch) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  s[i] = ch;
}

function get(s, i) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  return s[i];
}

function caml_fill_bytes(s, i, l, c) {
  if (l <= 0) {
    return;
  }
  for (let k = i, k_finish = l + i | 0; k < k_finish; ++k) {
    s[k] = c;
  }
}

function caml_create_bytes(len) {
  if (len < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.create"
        });
  }
  const result = new Array(len);
  for (let i = 0; i < len; ++i) {
    result[i] = /* '\\000' */0;
  }
  return result;
}

function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return;
  }
  if (s1 === s2) {
    if (i1 < i2) {
      const range_a = (s1.length - i2 | 0) - 1 | 0;
      const range_b = len - 1 | 0;
      const range = range_a > range_b ? range_b : range_a;
      for (let j = range; j >= 0; --j) {
        s1[i2 + j | 0] = s1[i1 + j | 0];
      }
      return;
    }
    if (i1 <= i2) {
      return;
    }
    const range_a$1 = (s1.length - i1 | 0) - 1 | 0;
    const range_b$1 = len - 1 | 0;
    const range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
    for (let k = 0; k <= range$1; ++k) {
      s1[i2 + k | 0] = s1[i1 + k | 0];
    }
    return;
  }
  const off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for (let i = 0; i < len; ++i) {
      s2[i2 + i | 0] = s1[i1 + i | 0];
    }
    return;
  }
  for (let i$1 = 0; i$1 < off1; ++i$1) {
    s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
  }
  for (let i$2 = off1; i$2 < len; ++i$2) {
    s2[i2 + i$2 | 0] = /* '\\000' */0;
  }
}

function bytes_to_string(a) {
  let i = 0;
  let len = a.length;
  let s = "";
  let s_len = len;
  if (i === 0 && len <= 4096 && len === a.length) {
    return String.fromCharCode.apply(null, a);
  }
  let offset = 0;
  while (s_len > 0) {
    const next = s_len < 1024 ? s_len : 1024;
    const tmp_bytes = new Array(next);
    for (let k = 0; k < next; ++k) {
      tmp_bytes[k] = a[k + offset | 0];
    }
    s = s + String.fromCharCode.apply(null, tmp_bytes);
    s_len = s_len - next | 0;
    offset = offset + next | 0;
  };
  return s;
}

function caml_blit_string(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return;
  }
  const off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for (let i = 0; i < len; ++i) {
      s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
    }
    return;
  }
  for (let i$1 = 0; i$1 < off1; ++i$1) {
    s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
  }
  for (let i$2 = off1; i$2 < len; ++i$2) {
    s2[i2 + i$2 | 0] = /* '\\000' */0;
  }
}

function bytes_of_string(s) {
  const len = s.length;
  const res = new Array(len);
  for (let i = 0; i < len; ++i) {
    res[i] = s.charCodeAt(i);
  }
  return res;
}

function caml_bytes_compare_aux(s1, s2, _off, len, def) {
  while (true) {
    const off = _off;
    if (off >= len) {
      return def;
    }
    const a = s1[off];
    const b = s2[off];
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    _off = off + 1 | 0;
    continue;
  };
}

function caml_bytes_compare(s1, s2) {
  const len1 = s1.length;
  const len2 = s2.length;
  if (len1 === len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, 0);
  } else if (len1 < len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, -1);
  } else {
    return caml_bytes_compare_aux(s1, s2, 0, len2, 1);
  }
}

function caml_bytes_equal(s1, s2) {
  const len1 = s1.length;
  const len2 = s2.length;
  if (len1 === len2) {
    let _off = 0;
    while (true) {
      const off = _off;
      if (off === len1) {
        return true;
      }
      const a = s1[off];
      const b = s2[off];
      if (a !== b) {
        return false;
      }
      _off = off + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function caml_bytes_greaterthan(s1, s2) {
  return caml_bytes_compare(s1, s2) > 0;
}

function caml_bytes_greaterequal(s1, s2) {
  return caml_bytes_compare(s1, s2) >= 0;
}

function caml_bytes_lessthan(s1, s2) {
  return caml_bytes_compare(s1, s2) < 0;
}

function caml_bytes_lessequal(s1, s2) {
  return caml_bytes_compare(s1, s2) <= 0;
}

function bswap16(x) {
  return ((x & 255) << 8) | ((x & 65280) >>> 8);
}

function bswap32(x) {
  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & -16777216) >>> 24);
}

function bswap64(x) {
  return Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    255
  ]), 56), Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    65280
  ]), 40)), Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    16711680
  ]), 24)), Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    4278190080
  ]), 8)), Caml_int64.lsr_(Caml_int64.and_(x, [
    255,
    0
  ]), 8)), Caml_int64.lsr_(Caml_int64.and_(x, [
    65280,
    0
  ]), 24)), Caml_int64.lsr_(Caml_int64.and_(x, [
    16711680,
    0
  ]), 40)), Caml_int64.lsr_(Caml_int64.and_(x, [
    -16777216,
    0
  ]), 56));
}

function get16u(str, idx) {
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  return (b2 << 8) | b1;
}

function get16(str, idx) {
  if (idx < 0 || (idx + 1 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  return get16u(str, idx);
}

function get32(str, idx) {
  if (idx < 0 || (idx + 3 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  const b3 = str[idx + 2 | 0];
  const b4 = str[idx + 3 | 0];
  return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
}

function get64(str, idx) {
  if (idx < 0 || (idx + 7 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  const b3 = str[idx + 2 | 0];
  const b4 = str[idx + 3 | 0];
  const b5 = str[idx + 4 | 0];
  const b6 = str[idx + 5 | 0];
  const b7 = str[idx + 6 | 0];
  const b8 = str[idx + 7 | 0];
  return Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.of_int32(b8), 56), Caml_int64.of_int32(b7)), 48), Caml_int64.of_int32(b6)), 40), Caml_int64.of_int32(b5)), 32), Caml_int64.of_int32(b4)), 24), Caml_int64.of_int32(b3)), 16), Caml_int64.of_int32(b2)), 8), Caml_int64.of_int32(b1));
}

function set16u(b, idx, newval) {
  const b2 = 255 & (newval >>> 8);
  const b1 = 255 & newval;
  b[idx] = b1;
  b[idx + 1 | 0] = b2;
}

function set16(b, idx, newval) {
  if (idx < 0 || (idx + 1 | 0) >= b.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  set16u(b, idx, newval);
}

function set32u(str, idx, newval) {
  const b4 = 255 & (newval >>> 24);
  const b3 = 255 & (newval >>> 16);
  const b2 = 255 & (newval >>> 8);
  const b1 = 255 & newval;
  str[idx] = b1;
  str[idx + 1 | 0] = b2;
  str[idx + 2 | 0] = b3;
  str[idx + 3 | 0] = b4;
}

function set32(str, idx, newval) {
  if (idx < 0 || (idx + 3 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  set32u(str, idx, newval);
}

function set64u(str, idx, newval) {
  const x = Caml_int64.lsr_(newval, 56);
  const b8 = 255 & (x[1] | 0);
  const x$1 = Caml_int64.lsr_(newval, 48);
  const b7 = 255 & (x$1[1] | 0);
  const x$2 = Caml_int64.lsr_(newval, 40);
  const b6 = 255 & (x$2[1] | 0);
  const x$3 = Caml_int64.lsr_(newval, 32);
  const b5 = 255 & (x$3[1] | 0);
  const x$4 = Caml_int64.lsr_(newval, 24);
  const b4 = 255 & (x$4[1] | 0);
  const x$5 = Caml_int64.lsr_(newval, 16);
  const b3 = 255 & (x$5[1] | 0);
  const x$6 = Caml_int64.lsr_(newval, 8);
  const b2 = 255 & (x$6[1] | 0);
  const b1 = 255 & (newval[1] | 0);
  str[idx] = b1;
  str[idx + 1 | 0] = b2;
  str[idx + 2 | 0] = b3;
  str[idx + 3 | 0] = b4;
  str[idx + 4 | 0] = b5;
  str[idx + 5 | 0] = b6;
  str[idx + 6 | 0] = b7;
  str[idx + 7 | 0] = b8;
}

function set64(str, idx, newval) {
  if (idx < 0 || (idx + 7 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  set64u(str, idx, newval);
}

export {
  caml_create_bytes,
  caml_fill_bytes,
  get,
  set,
  bytes_to_string,
  caml_blit_bytes,
  caml_blit_string,
  bytes_of_string,
  caml_bytes_compare,
  caml_bytes_greaterthan,
  caml_bytes_greaterequal,
  caml_bytes_lessthan,
  caml_bytes_lessequal,
  caml_bytes_equal,
  bswap16,
  bswap32,
  bswap64,
  get16u,
  get16,
  get32,
  get64,
  set16u,
  set16,
  set32u,
  set32,
  set64u,
  set64,
}
/* No side effect */
`,nu=`// Generated by Melange


const id = {
  contents: 0
};

function create(str) {
  id.contents = id.contents + 1 | 0;
  return str + ("/" + id.contents);
}

function caml_is_extension(e) {
  if (e == null) {
    return false;
  } else {
    return typeof e.MEL_EXN_ID === "string";
  }
}

function caml_exn_slot_name(x) {
  return x.MEL_EXN_ID;
}

const caml_exn_slot_id = (function(x){
  if (x.MEL_EXN_ID != null) {
    var parts = x.MEL_EXN_ID.split("/");
    if (parts.length > 1) {
      return Number(parts[parts.length - 1])
    } else {
      return -1;
    }
  } else {
    return -1;
  }
}
);

export {
  id,
  create,
  caml_is_extension,
  caml_exn_slot_name,
  caml_exn_slot_id,
}
/* No side effect */
`,tu=`// Generated by Melange


const getGlobalThis = (function(){
  if (typeof globalThis !== 'undefined') return globalThis;
	if (typeof self !== 'undefined') return self;
	if (typeof window !== 'undefined') return window;
	if (typeof global !== 'undefined') return global;
	if (typeof this !== 'undefined') return this;
	throw new Error('Unable to locate global \`this\`');
}
);

const resolve = (function(s){
  var myGlobal = getGlobalThis();
  if (myGlobal[s] === undefined){
    throw new Error(s + " not polyfilled by Melange yet\\n")
  }
  return myGlobal[s]
}
);

const register = (function(s,fn){
  var myGlobal = getGlobalThis();
  myGlobal[s] = fn
  return 0
}
);

export {
  getGlobalThis,
  resolve,
  register,
}
/* No side effect */
`,eu=`// Generated by Melange


const caml_int32_float_of_bits = (function(x){
    return new Float32Array(new Int32Array([x]).buffer)[0]
    }
);

const caml_int32_bits_of_float = (function(x){
  return new Int32Array(new Float32Array([x]).buffer)[0]
}
);

function caml_modf_float(x) {
  if (!isFinite(x)) {
    if (isNaN(x)) {
      return [
        NaN,
        NaN
      ];
    } else {
      return [
        1 / x,
        x
      ];
    }
  }
  const neg = 1 / x < 0;
  const x$1 = Math.abs(x);
  const i = Math.floor(x$1);
  const f = x$1 - i;
  if (neg) {
    return [
      - f,
      - i
    ];
  } else {
    return [
      f,
      i
    ];
  }
}

function caml_ldexp_float(x, exp) {
  let x$p = x;
  let exp$p = exp;
  if (exp$p > 1023) {
    exp$p = exp$p - 1023;
    x$p = x$p * Math.pow(2, 1023);
    if (exp$p > 1023) {
      exp$p = exp$p - 1023;
      x$p = x$p * Math.pow(2, 1023);
    }
    
  } else if (exp$p < -1023) {
    exp$p = exp$p + 1023;
    x$p = x$p * Math.pow(2, -1023);
  }
  return x$p * Math.pow(2, exp$p);
}

function caml_frexp_float(x) {
  if (x === 0 || !isFinite(x)) {
    return [
      x,
      0
    ];
  }
  const neg = x < 0;
  let x$p = Math.abs(x);
  let exp = Math.floor(Math.LOG2E * Math.log(x$p)) + 1;
  x$p = x$p * Math.pow(2, - exp);
  if (x$p < 0.5) {
    x$p = x$p * 2;
    exp = exp - 1;
  }
  if (neg) {
    x$p = - x$p;
  }
  return [
    x$p,
    exp | 0
  ];
}

function caml_copysign_float(x, y) {
  const x$1 = Math.abs(x);
  const y$1 = y === 0 ? 1 / y : y;
  if (y$1 < 0) {
    return - x$1;
  } else {
    return x$1;
  }
}

function caml_expm1_float(x) {
  const y = Math.exp(x);
  const z = y - 1;
  if (Math.abs(x) > 1) {
    return z;
  } else if (z === 0) {
    return x;
  } else {
    return x * z / Math.log(y);
  }
}

function caml_hypot_float(x, y) {
  const x0 = Math.abs(x);
  const y0 = Math.abs(y);
  const a = x0 > y0 ? x0 : y0;
  const b = (
    x0 < y0 ? x0 : y0
  ) / (
    a !== 0 ? a : 1
  );
  return a * Math.sqrt(1 + b * b);
}

function caml_log10_float(x) {
  return Math.LOG10E * Math.log(x);
}

export {
  caml_int32_float_of_bits,
  caml_int32_bits_of_float,
  caml_modf_float,
  caml_ldexp_float,
  caml_frexp_float,
  caml_copysign_float,
  caml_expm1_float,
  caml_hypot_float,
  caml_log10_float,
}
/* No side effect */
`,ru=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,au=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function parse_digit(c) {
  if (c >= 65) {
    if (c >= 97) {
      if (c >= 123) {
        return -1;
      } else {
        return c - 87 | 0;
      }
    } else if (c >= 91) {
      return -1;
    } else {
      return c - 55 | 0;
    }
  } else if (c > 57 || c < 48) {
    return -1;
  } else {
    return c - /* '0' */48 | 0;
  }
}

function int_of_string_base(param) {
  switch (param) {
    case /* Oct */ 0 :
      return 8;
    case /* Hex */ 1 :
      return 16;
    case /* Dec */ 2 :
      return 10;
    case /* Bin */ 3 :
      return 2;
  }
}

function parse_sign_and_base(s) {
  let sign = 1;
  let base = /* Dec */ 2;
  let i = 0;
  const match = s.charCodeAt(i);
  switch (match) {
    case 43 :
      i = i + 1 | 0;
      break;
    case 45 :
      sign = -1;
      i = i + 1 | 0;
      break;
  }
  if (s[i] === "0") {
    const match$1 = s.charCodeAt(i + 1 | 0);
    if (match$1 >= 89) {
      if (match$1 >= 111) {
        if (match$1 < 121) {
          switch (match$1) {
            case 111 :
              base = /* Oct */ 0;
              i = i + 2 | 0;
              break;
            case 117 :
              i = i + 2 | 0;
              break;
            case 112 :
            case 113 :
            case 114 :
            case 115 :
            case 116 :
            case 118 :
            case 119 :
              break;
            case 120 :
              base = /* Hex */ 1;
              i = i + 2 | 0;
              break;
          }
        }
        
      } else if (match$1 === 98) {
        base = /* Bin */ 3;
        i = i + 2 | 0;
      }
      
    } else if (match$1 !== 66) {
      if (match$1 >= 79) {
        switch (match$1) {
          case 79 :
            base = /* Oct */ 0;
            i = i + 2 | 0;
            break;
          case 85 :
            i = i + 2 | 0;
            break;
          case 80 :
          case 81 :
          case 82 :
          case 83 :
          case 84 :
          case 86 :
          case 87 :
            break;
          case 88 :
            base = /* Hex */ 1;
            i = i + 2 | 0;
            break;
        }
      }
      
    } else {
      base = /* Bin */ 3;
      i = i + 2 | 0;
    }
  }
  return [
    i,
    sign,
    base
  ];
}

function caml_int_of_string(s) {
  const match = parse_sign_and_base(s);
  const i = match[0];
  const base = int_of_string_base(match[2]);
  const threshold = 4294967295;
  const len = s.length;
  const c = i < len ? s.charCodeAt(i) : /* '\\000' */0;
  const d = parse_digit(c);
  if (d < 0 || d >= base) {
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "int_of_string"
        });
  }
  const aux = function (_acc, _k) {
    while (true) {
      const k = _k;
      const acc = _acc;
      if (k === len) {
        return acc;
      }
      const a = s.charCodeAt(k);
      if (a === /* '_' */95) {
        _k = k + 1 | 0;
        continue;
      }
      const v = parse_digit(a);
      if (v < 0 || v >= base) {
        throw new Caml_js_exceptions.MelangeError("Failure", {
              MEL_EXN_ID: "Failure",
              _1: "int_of_string"
            });
      }
      const acc$1 = base * acc + v;
      if (acc$1 > threshold) {
        throw new Caml_js_exceptions.MelangeError("Failure", {
              MEL_EXN_ID: "Failure",
              _1: "int_of_string"
            });
      }
      _k = k + 1 | 0;
      _acc = acc$1;
      continue;
    };
  };
  const res = match[1] * aux(d, i + 1 | 0);
  const or_res = res | 0;
  if (base === 10 && res !== or_res) {
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "int_of_string"
        });
  }
  return or_res;
}

function caml_int64_of_string(s) {
  const match = parse_sign_and_base(s);
  const hbase = match[2];
  const i = match[0];
  const base = Caml_int64.of_int32(int_of_string_base(hbase));
  const sign = Caml_int64.of_int32(match[1]);
  let threshold;
  switch (hbase) {
    case /* Oct */ 0 :
      threshold = [
        536870911,
        4294967295
      ];
      break;
    case /* Hex */ 1 :
      threshold = [
        268435455,
        4294967295
      ];
      break;
    case /* Dec */ 2 :
      threshold = [
        429496729,
        2576980377
      ];
      break;
    case /* Bin */ 3 :
      threshold = Caml_int64.max_int;
      break;
  }
  const len = s.length;
  const c = i < len ? s.charCodeAt(i) : /* '\\000' */0;
  const d = Caml_int64.of_int32(parse_digit(c));
  if (Caml.i64_lt(d, Caml_int64.zero) || Caml.i64_ge(d, base)) {
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "int64_of_string"
        });
  }
  const aux = function (_acc, _k) {
    while (true) {
      const k = _k;
      const acc = _acc;
      if (k === len) {
        return acc;
      }
      const a = s.charCodeAt(k);
      if (a === /* '_' */95) {
        _k = k + 1 | 0;
        continue;
      }
      const v = Caml_int64.of_int32(parse_digit(a));
      if (Caml.i64_lt(v, Caml_int64.zero) || Caml.i64_ge(v, base) || Caml.i64_gt(acc, threshold)) {
        throw new Caml_js_exceptions.MelangeError("Failure", {
              MEL_EXN_ID: "Failure",
              _1: "int64_of_string"
            });
      }
      const acc$1 = Caml_int64.add(Caml_int64.mul(base, acc), v);
      _k = k + 1 | 0;
      _acc = acc$1;
      continue;
    };
  };
  const res = Caml_int64.mul(sign, aux(d, i + 1 | 0));
  const or_res = Caml_int64.or_(res, Caml_int64.zero);
  if (Caml.i64_eq(base, [
      0,
      10
    ]) && Caml.i64_neq(res, or_res)) {
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "int64_of_string"
        });
  }
  return or_res;
}

function int_of_base(param) {
  switch (param) {
    case /* Oct */ 0 :
      return 8;
    case /* Hex */ 1 :
      return 16;
    case /* Dec */ 2 :
      return 10;
  }
}

function lowercase(c) {
  if (c >= /* 'A' */65 && c <= /* 'Z' */90 || c >= /* '\\192' */192 && c <= /* '\\214' */214 || c >= /* '\\216' */216 && c <= /* '\\222' */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function parse_format(fmt) {
  const len = fmt.length;
  if (len > 31) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "format_int: format too long"
        });
  }
  let f = {
    justify: "+",
    signstyle: "-",
    filter: " ",
    alternate: false,
    base: /* Dec */ 2,
    signedconv: false,
    width: 0,
    uppercase: false,
    sign: 1,
    prec: -1,
    conv: "f"
  };
  let _i = 0;
  while (true) {
    const i = _i;
    if (i >= len) {
      return f;
    }
    const c = fmt.charCodeAt(i);
    let exit = 0;
    if (c >= 69) {
      if (c >= 88) {
        if (c >= 121) {
          exit = 1;
        } else {
          switch (c) {
            case 88 :
              f.base = /* Hex */ 1;
              f.uppercase = true;
              _i = i + 1 | 0;
              continue;
            case 101 :
            case 102 :
            case 103 :
              exit = 5;
              break;
            case 100 :
            case 105 :
              exit = 4;
              break;
            case 111 :
              f.base = /* Oct */ 0;
              _i = i + 1 | 0;
              continue;
            case 117 :
              f.base = /* Dec */ 2;
              _i = i + 1 | 0;
              continue;
            case 89 :
            case 90 :
            case 91 :
            case 92 :
            case 93 :
            case 94 :
            case 95 :
            case 96 :
            case 97 :
            case 98 :
            case 99 :
            case 104 :
            case 106 :
            case 107 :
            case 108 :
            case 109 :
            case 110 :
            case 112 :
            case 113 :
            case 114 :
            case 115 :
            case 116 :
            case 118 :
            case 119 :
              exit = 1;
              break;
            case 120 :
              f.base = /* Hex */ 1;
              _i = i + 1 | 0;
              continue;
          }
        }
      } else if (c >= 72) {
        exit = 1;
      } else {
        f.signedconv = true;
        f.uppercase = true;
        f.conv = String.fromCharCode(lowercase(c));
        _i = i + 1 | 0;
        continue;
      }
    } else {
      switch (c) {
        case 35 :
          f.alternate = true;
          _i = i + 1 | 0;
          continue;
        case 32 :
        case 43 :
          exit = 2;
          break;
        case 45 :
          f.justify = "-";
          _i = i + 1 | 0;
          continue;
        case 46 :
          f.prec = 0;
          let j = i + 1 | 0;
          while ((function () {
              const w = fmt.charCodeAt(j) - /* '0' */48 | 0;
              return w >= 0 && w <= 9;
            })()) {
            f.prec = (Math.imul(f.prec, 10) + fmt.charCodeAt(j) | 0) - /* '0' */48 | 0;
            j = j + 1 | 0;
          };
          _i = j;
          continue;
        case 48 :
          f.filter = "0";
          _i = i + 1 | 0;
          continue;
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
          exit = 3;
          break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
        _i = i + 1 | 0;
        continue;
      case 2 :
        f.signstyle = String.fromCharCode(c);
        _i = i + 1 | 0;
        continue;
      case 3 :
        f.width = 0;
        let j$1 = i;
        while ((function () {
            const w = fmt.charCodeAt(j$1) - /* '0' */48 | 0;
            return w >= 0 && w <= 9;
          })()) {
          f.width = (Math.imul(f.width, 10) + fmt.charCodeAt(j$1) | 0) - /* '0' */48 | 0;
          j$1 = j$1 + 1 | 0;
        };
        _i = j$1;
        continue;
      case 4 :
        f.signedconv = true;
        f.base = /* Dec */ 2;
        _i = i + 1 | 0;
        continue;
      case 5 :
        f.signedconv = true;
        f.conv = String.fromCharCode(c);
        _i = i + 1 | 0;
        continue;
    }
  };
}

function finish_formatting(config, rawbuffer) {
  const justify = config.justify;
  const signstyle = config.signstyle;
  const filter = config.filter;
  const alternate = config.alternate;
  const base = config.base;
  const signedconv = config.signedconv;
  const width = config.width;
  const uppercase = config.uppercase;
  const sign = config.sign;
  let len = rawbuffer.length;
  if (signedconv && (sign < 0 || signstyle !== "-")) {
    len = len + 1 | 0;
  }
  if (alternate) {
    if (base === /* Oct */ 0) {
      len = len + 1 | 0;
    } else if (base === /* Hex */ 1) {
      len = len + 2 | 0;
    }
    
  }
  let buffer = "";
  if (justify === "+" && filter === " ") {
    for (let _for = len; _for < width; ++_for) {
      buffer = buffer + filter;
    }
  }
  if (signedconv) {
    if (sign < 0) {
      buffer = buffer + "-";
    } else if (signstyle !== "-") {
      buffer = buffer + signstyle;
    }
    
  }
  if (alternate && base === /* Oct */ 0) {
    buffer = buffer + "0";
  }
  if (alternate && base === /* Hex */ 1) {
    buffer = buffer + "0x";
  }
  if (justify === "+" && filter === "0") {
    for (let _for$1 = len; _for$1 < width; ++_for$1) {
      buffer = buffer + filter;
    }
  }
  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
  if (justify === "-") {
    for (let _for$2 = len; _for$2 < width; ++_for$2) {
      buffer = buffer + " ";
    }
  }
  return buffer;
}

function caml_format_int(fmt, i) {
  if (fmt === "%d") {
    return String(i);
  }
  const f = parse_format(fmt);
  const i$1 = i < 0 ? (
      f.signedconv ? (f.sign = -1, (-i >>> 0)) : (i >>> 0)
    ) : i;
  let s = i$1.toString(int_of_base(f.base));
  if (f.prec >= 0) {
    f.filter = " ";
    const n = f.prec - s.length | 0;
    if (n > 0) {
      s = "0".repeat(n) + s;
    }
    
  }
  return finish_formatting(f, s);
}

function dec_of_pos_int64(x) {
  if (!Caml.i64_lt(x, Caml_int64.zero)) {
    return Caml_int64.to_string(x);
  }
  const wbase = [
    0,
    10
  ];
  const y = Caml_int64.discard_sign(x);
  const match = Caml_int64.div_mod(y, wbase);
  const match$1 = Caml_int64.div_mod(Caml_int64.add([
    0,
    8
  ], match[1]), wbase);
  const quotient = Caml_int64.add(Caml_int64.add([
    214748364,
    3435973836
  ], match[0]), match$1[0]);
  return Caml_int64.to_string(quotient) + "0123456789"[Caml_int64.to_int32(match$1[1])];
}

function oct_of_int64(x) {
  let s = "";
  const wbase = [
    0,
    8
  ];
  const cvtbl = "01234567";
  if (Caml.i64_lt(x, Caml_int64.zero)) {
    const y = Caml_int64.discard_sign(x);
    const match = Caml_int64.div_mod(y, wbase);
    let quotient = Caml_int64.add([
      268435456,
      0
    ], match[0]);
    let modulus = match[1];
    s = cvtbl[Caml_int64.to_int32(modulus)] + s;
    while (Caml.i64_neq(quotient, Caml_int64.zero)) {
      const match$1 = Caml_int64.div_mod(quotient, wbase);
      quotient = match$1[0];
      modulus = match$1[1];
      s = cvtbl[Caml_int64.to_int32(modulus)] + s;
    };
  } else {
    const match$2 = Caml_int64.div_mod(x, wbase);
    let quotient$1 = match$2[0];
    let modulus$1 = match$2[1];
    s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;
    while (Caml.i64_neq(quotient$1, Caml_int64.zero)) {
      const match$3 = Caml_int64.div_mod(quotient$1, wbase);
      quotient$1 = match$3[0];
      modulus$1 = match$3[1];
      s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;
    };
  }
  return s;
}

function caml_int64_format(fmt, x) {
  if (fmt === "%d") {
    return Caml_int64.to_string(x);
  }
  const f = parse_format(fmt);
  const x$1 = f.signedconv && Caml.i64_lt(x, Caml_int64.zero) ? (f.sign = -1, Caml_int64.neg(x)) : x;
  const match = f.base;
  let s;
  switch (match) {
    case /* Oct */ 0 :
      s = oct_of_int64(x$1);
      break;
    case /* Hex */ 1 :
      s = Caml_int64.to_hex(x$1);
      break;
    case /* Dec */ 2 :
      s = dec_of_pos_int64(x$1);
      break;
  }
  let fill_s;
  if (f.prec >= 0) {
    f.filter = " ";
    const n = f.prec - s.length | 0;
    fill_s = n > 0 ? "0".repeat(n) + s : s;
  } else {
    fill_s = s;
  }
  return finish_formatting(f, fill_s);
}

function caml_format_float(fmt, x) {
  const f = parse_format(fmt);
  const prec = f.prec < 0 ? 6 : f.prec;
  const x$1 = x < 0 ? (f.sign = -1, - x) : x;
  let s = "";
  if (isNaN(x$1)) {
    s = "nan";
    f.filter = " ";
  } else if (isFinite(x$1)) {
    const match = f.conv;
    switch (match) {
      case "e" :
        s = x$1.toExponential(prec);
        const i = s.length;
        if (s[i - 3 | 0] === "e") {
          s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
        }
        break;
      case "f" :
        s = x$1.toFixed(prec);
        break;
      case "g" :
        const prec$1 = prec !== 0 ? prec : 1;
        s = x$1.toExponential(prec$1 - 1 | 0);
        const j = s.indexOf("e");
        const exp = Number(s.slice(j + 1 | 0)) | 0;
        if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
          let i$1 = j - 1 | 0;
          while (s[i$1] === "0") {
            i$1 = i$1 - 1 | 0;
          };
          if (s[i$1] === ".") {
            i$1 = i$1 - 1 | 0;
          }
          s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
          const i$2 = s.length;
          if (s[i$2 - 3 | 0] === "e") {
            s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
          }
          
        } else {
          let p = prec$1;
          if (exp < 0) {
            p = p - (exp + 1 | 0) | 0;
            s = x$1.toFixed(p);
          } else {
            while ((function () {
                s = x$1.toFixed(p);
                return s.length > (prec$1 + 1 | 0);
              })()) {
              p = p - 1 | 0;
            };
          }
          if (p !== 0) {
            let k = s.length - 1 | 0;
            while (s[k] === "0") {
              k = k - 1 | 0;
            };
            if (s[k] === ".") {
              k = k - 1 | 0;
            }
            s = s.slice(0, k + 1 | 0);
          }
          
        }
        break;
    }
  } else {
    s = "inf";
    f.filter = " ";
  }
  return finish_formatting(f, s);
}

const caml_hexstring_of_float = (function(x,prec,style){
  if (!isFinite(x)) {
    if (isNaN(x)) return "nan";
    return x > 0 ? "infinity":"-infinity";
  }
  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;
  if(sign) x = -x;
  var exp = 0;
  if (x == 0) { }
  else if (x < 1) {
    while (x < 1 && exp > -1022)  { x *= 2; exp-- }
  } else {
    while (x >= 2) { x /= 2; exp++ }
  }
  var exp_sign = exp < 0 ? '' : '+';
  var sign_str = '';
  if (sign) sign_str = '-'
  else {
    switch(style){
    case 43 /* '+' */: sign_str = '+'; break;
    case 32 /* ' ' */: sign_str = ' '; break;
    default: break;
    }
  }
  if (prec >= 0 && prec < 13) {
    /* If a precision is given, and is small, round mantissa accordingly */
      var cst = Math.pow(2,prec * 4);
      x = Math.round(x * cst) / cst;
  }
  var x_str = x.toString(16);
  if(prec >= 0){
      var idx = x_str.indexOf('.');
    if(idx<0) {
      x_str += '.' +  '0'.repeat(prec);
    }
    else {
      var size = idx+1+prec;
      if(x_str.length < size)
        x_str += '0'.repeat(size - x_str.length);
      else
        x_str = x_str.substr(0,size);
    }
  }
  return  (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));
}
);

const float_of_string = (function(s,exn){

    var res = +s;
    if ((s.length > 0) && (res === res))
        return res;
    s = s.replace(/_/g, "");
    res = +s;
    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
        return res;
    };
    var m = /^ *([+-]?)0x([0-9a-f]+)\\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
    //            1        2             3           4
    if(m){
        var m3 = m[3].replace(/0+$/,'');
        var mantissa = parseInt(m[1] + m[2] + m3, 16);
        var exponent = (m[4]|0) - 4*m3.length;
        res = mantissa * Math.pow(2, exponent);
        return res;
    }
    if (/^\\+?inf(inity)?$/i.test(s))
        return Infinity;
    if (/^-inf(inity)?$/i.test(s))
        return -Infinity;
    throw new Error(exn.MEL_EXN_ID, { cause: exn });
}
);

function caml_float_of_string(s) {
  return float_of_string(s, {
    MEL_EXN_ID: "Failure",
    _1: "float_of_string"
  });
}

const caml_nativeint_format = caml_format_int;

const caml_int32_format = caml_format_int;

const caml_int32_of_string = caml_int_of_string;

const caml_nativeint_of_string = caml_int_of_string;

export {
  caml_format_float,
  caml_hexstring_of_float,
  caml_format_int,
  caml_nativeint_format,
  caml_int32_format,
  caml_float_of_string,
  caml_int64_format,
  caml_int_of_string,
  caml_int32_of_string,
  caml_int64_of_string,
  caml_nativeint_of_string,
}
/* No side effect */
`,iu=`// Generated by Melange


function caml_gc_counters(param) {
  return [
    0,
    0,
    0
  ];
}

function caml_gc_set(param) {
  
}

function caml_gc_minor(param) {
  
}

function caml_gc_major_slice(param) {
  return 0;
}

function caml_gc_major(param) {
  
}

function caml_gc_full_major(param) {
  
}

function caml_gc_compaction(param) {
  
}

function caml_final_register(param, param$1) {
  
}

function caml_final_release(param) {
  
}

export {
  caml_gc_counters,
  caml_gc_set,
  caml_gc_minor,
  caml_gc_major_slice,
  caml_gc_major,
  caml_gc_full_major,
  caml_gc_compaction,
  caml_final_register,
  caml_final_release,
}
/* No side effect */
`,su=`// Generated by Melange

import * as Caml_hash_primitive from "./caml_hash_primitive.js";

function push_back(q, v) {
  const cell = {
    content: v,
    next: undefined
  };
  const last = q.last;
  if (last !== undefined) {
    q.length = q.length + 1 | 0;
    last.next = cell;
    q.last = cell;
  } else {
    q.length = 1;
    q.first = cell;
    q.last = cell;
  }
}

function unsafe_pop(q) {
  const cell = q.first;
  const next = cell.next;
  if (next === undefined) {
    q.length = 0;
    q.first = undefined;
    q.last = undefined;
  } else {
    q.length = q.length - 1 | 0;
    q.first = next;
  }
  return cell.content;
}

function caml_hash(count, _limit, seed, obj) {
  let hash = seed;
  if (typeof obj === "number") {
    const u = obj | 0;
    hash = Caml_hash_primitive.caml_hash_mix_int(hash, (u + u | 0) + 1 | 0);
    return Caml_hash_primitive.caml_hash_final_mix(hash);
  }
  if (typeof obj === "string") {
    hash = Caml_hash_primitive.caml_hash_mix_string(hash, obj);
    return Caml_hash_primitive.caml_hash_final_mix(hash);
  }
  const queue = {
    length: 0,
    first: undefined,
    last: undefined
  };
  let num = count;
  push_back(queue, obj);
  num = num - 1 | 0;
  while (queue.length !== 0 && num > 0) {
    const obj$1 = unsafe_pop(queue);
    if (typeof obj$1 === "number") {
      const u$1 = obj$1 | 0;
      hash = Caml_hash_primitive.caml_hash_mix_int(hash, (u$1 + u$1 | 0) + 1 | 0);
      num = num - 1 | 0;
    } else if (typeof obj$1 === "string") {
      hash = Caml_hash_primitive.caml_hash_mix_string(hash, obj$1);
      num = num - 1 | 0;
    } else if (typeof obj$1 === "boolean") {
      const u$2 = obj$1 ? 1 : 0;
      hash = Caml_hash_primitive.caml_hash_mix_int(hash, (u$2 + u$2 | 0) + 1 | 0);
      num = num - 1 | 0;
    } else if (typeof obj$1 !== "undefined" && typeof obj$1 !== "symbol" && typeof obj$1 !== "function") {
      const size = obj$1.length | 0;
      if (size !== 0) {
        const obj_tag = obj$1.TAG;
        const tag = (size << 10) | obj_tag;
        if (obj_tag === 248) {
          hash = Caml_hash_primitive.caml_hash_mix_int(hash, obj$1[1]);
        } else {
          hash = Caml_hash_primitive.caml_hash_mix_int(hash, tag);
          const v = size - 1 | 0;
          const block = v < num ? v : num;
          for (let i = 0; i <= block; ++i) {
            push_back(queue, obj$1[i]);
          }
        }
      } else {
        const size$1 = (function(obj,cb){
            var size = 0
            for(var k in obj){
              cb(obj[k])
              ++ size
            }
            return size
          }
        )(obj$1, (function (v) {
          push_back(queue, v);
        }));
        hash = Caml_hash_primitive.caml_hash_mix_int(hash, (size$1 << 10) | 0);
      }
    }
    
  };
  return Caml_hash_primitive.caml_hash_final_mix(hash);
}

export {
  caml_hash,
}
/* No side effect */
`,ou=`// Generated by Melange


function rotl32(x, n) {
  return (x << n) | (x >>> (32 - n | 0)) | 0;
}

function caml_hash_mix_int(h, d) {
  let d$1 = d;
  d$1 = Math.imul(d$1, -862048943);
  d$1 = rotl32(d$1, 15);
  d$1 = Math.imul(d$1, 461845907);
  let h$1 = h ^ d$1;
  h$1 = rotl32(h$1, 13);
  return (h$1 + (h$1 << 2) | 0) - 430675100 | 0;
}

function caml_hash_final_mix(h) {
  let h$1 = h ^ (h >>> 16);
  h$1 = Math.imul(h$1, -2048144789);
  h$1 = h$1 ^ (h$1 >>> 13);
  h$1 = Math.imul(h$1, -1028477387);
  return h$1 ^ (h$1 >>> 16);
}

function caml_hash_mix_string(h, s) {
  const len = s.length;
  const block = (len / 4 | 0) - 1 | 0;
  let hash = h;
  for (let i = 0; i <= block; ++i) {
    const j = (i << 2);
    const w = s.charCodeAt(j) | (s.charCodeAt(j + 1 | 0) << 8) | (s.charCodeAt(j + 2 | 0) << 16) | (s.charCodeAt(j + 3 | 0) << 24);
    hash = caml_hash_mix_int(hash, w);
  }
  const modulo = len & 3;
  if (modulo !== 0) {
    const w$1 = modulo === 3 ? (s.charCodeAt(len - 1 | 0) << 16) | (s.charCodeAt(len - 2 | 0) << 8) | s.charCodeAt(len - 3 | 0) : (
        modulo === 2 ? (s.charCodeAt(len - 1 | 0) << 8) | s.charCodeAt(len - 2 | 0) : s.charCodeAt(len - 1 | 0)
      );
    hash = caml_hash_mix_int(hash, w$1);
  }
  hash = hash ^ len;
  return hash;
}

export {
  caml_hash_mix_int,
  caml_hash_mix_string,
  caml_hash_final_mix,
}
/* No side effect */
`,lu=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function div(x, y) {
  if (y === 0) {
    throw new Caml_js_exceptions.MelangeError("Division_by_zero", {
          MEL_EXN_ID: "Division_by_zero"
        });
  }
  return x / y | 0;
}

function mod_(x, y) {
  if (y === 0) {
    throw new Caml_js_exceptions.MelangeError("Division_by_zero", {
          MEL_EXN_ID: "Division_by_zero"
        });
  }
  return x % y;
}

export {
  div,
  mod_,
}
/* No side effect */
`,cu=`// Generated by Melange


const Ops = {};

export {
  Ops,
}
/* No side effect */
`,_u=`// Generated by Melange

import * as Caml from "./caml.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function mk(lo, hi) {
  return [
    hi,
    (lo >>> 0)
  ];
}

const min_int = [
  -2147483648,
  0
];

const max_int = [
  2147483647,
  4294967295
];

const one = [
  0,
  1
];

const zero = [
  0,
  0
];

const neg_one = [
  -1,
  4294967295
];

function neg_signed(x) {
  return (x & -2147483648) !== 0;
}

function non_neg_signed(x) {
  return (x & -2147483648) === 0;
}

function succ(param) {
  let x_lo = param[1];
  let x_hi = param[0];
  const lo = x_lo + 1 | 0;
  return [
    x_hi + (
      lo === 0 ? 1 : 0
    ) | 0,
    (lo >>> 0)
  ];
}

function neg(param) {
  const other_lo = (param[1] ^ -1) + 1 | 0;
  return [
    (param[0] ^ -1) + (
      other_lo === 0 ? 1 : 0
    ) | 0,
    (other_lo >>> 0)
  ];
}

function add_aux(param, y_lo, y_hi) {
  const x_lo = param[1];
  const lo = x_lo + y_lo | 0;
  const overflow = neg_signed(x_lo) && (neg_signed(y_lo) || non_neg_signed(lo)) || neg_signed(y_lo) && non_neg_signed(lo) ? 1 : 0;
  return [
    param[0] + y_hi + overflow | 0,
    (lo >>> 0)
  ];
}

function add(self, param) {
  return add_aux(self, param[1], param[0]);
}

function equal_null(x, y) {
  if (y !== null) {
    return Caml.i64_eq(x, y);
  } else {
    return false;
  }
}

function equal_undefined(x, y) {
  if (y !== undefined) {
    return Caml.i64_eq(x, y);
  } else {
    return false;
  }
}

function equal_nullable(x, y) {
  if (y == null) {
    return false;
  } else {
    return Caml.i64_eq(x, y);
  }
}

function sub_aux(x, lo, hi) {
  const y_lo = ((lo ^ -1) + 1 >>> 0);
  const y_hi = (hi ^ -1) + (
    y_lo === 0 ? 1 : 0
  ) | 0;
  return add_aux(x, y_lo, y_hi);
}

function sub(self, param) {
  return sub_aux(self, param[1], param[0]);
}

function lsl_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  const lo = x[1];
  if (numBits >= 32) {
    return [
      (lo << (numBits - 32 | 0)),
      0
    ];
  } else {
    return [
      (lo >>> (32 - numBits | 0)) | (x[0] << numBits),
      ((lo << numBits) >>> 0)
    ];
  }
}

function lsr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  const hi = x[0];
  const offset = numBits - 32 | 0;
  if (offset === 0) {
    return [
      0,
      (hi >>> 0)
    ];
  } else if (offset > 0) {
    return [
      0,
      (hi >>> offset)
    ];
  } else {
    return [
      (hi >>> numBits),
      (((hi << (-offset | 0)) | (x[1] >>> numBits)) >>> 0)
    ];
  }
}

function asr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  const hi = x[0];
  if (numBits < 32) {
    return [
      (hi >> numBits),
      (((hi << (32 - numBits | 0)) | (x[1] >>> numBits)) >>> 0)
    ];
  } else {
    return [
      hi >= 0 ? 0 : -1,
      ((hi >> (numBits - 32 | 0)) >>> 0)
    ];
  }
}

function is_zero(param) {
  if (param[0] !== 0) {
    return false;
  } else {
    return param[1] === 0;
  }
}

function mul(_this, _other) {
  while (true) {
    const other = _other;
    const $$this = _this;
    let lo;
    const this_hi = $$this[0];
    let exit = 0;
    let exit$1 = 0;
    let exit$2 = 0;
    if (this_hi !== 0) {
      exit$2 = 4;
    } else {
      if ($$this[1] === 0) {
        return zero;
      }
      exit$2 = 4;
    }
    if (exit$2 === 4) {
      if (other[0] !== 0) {
        exit$1 = 3;
      } else {
        if (other[1] === 0) {
          return zero;
        }
        exit$1 = 3;
      }
    }
    if (exit$1 === 3) {
      if (this_hi !== -2147483648 || $$this[1] !== 0) {
        exit = 2;
      } else {
        lo = other[1];
      }
    }
    if (exit === 2) {
      const other_hi = other[0];
      const lo$1 = $$this[1];
      let exit$3 = 0;
      if (other_hi !== -2147483648 || other[1] !== 0) {
        exit$3 = 3;
      } else {
        lo = lo$1;
      }
      if (exit$3 === 3) {
        const other_lo = other[1];
        if (this_hi < 0) {
          if (other_hi >= 0) {
            return neg(mul(neg($$this), other));
          }
          _other = neg(other);
          _this = neg($$this);
          continue;
        }
        if (other_hi < 0) {
          return neg(mul($$this, neg(other)));
        }
        const a48 = (this_hi >>> 16);
        const a32 = this_hi & 65535;
        const a16 = (lo$1 >>> 16);
        const a00 = lo$1 & 65535;
        const b48 = (other_hi >>> 16);
        const b32 = other_hi & 65535;
        const b16 = (other_lo >>> 16);
        const b00 = other_lo & 65535;
        let c48 = 0;
        let c32 = 0;
        let c16 = 0;
        const c00 = a00 * b00;
        c16 = (c00 >>> 16) + a16 * b00;
        c32 = (c16 >>> 16);
        c16 = (c16 & 65535) + a00 * b16;
        c32 = c32 + (c16 >>> 16) + a32 * b00;
        c48 = (c32 >>> 16);
        c32 = (c32 & 65535) + a16 * b16;
        c48 = c48 + (c32 >>> 16);
        c32 = (c32 & 65535) + a00 * b32;
        c48 = c48 + (c32 >>> 16);
        c32 = c32 & 65535;
        c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
        return [
          c32 | (c48 << 16),
          ((c00 & 65535 | ((c16 & 65535) << 16)) >>> 0)
        ];
      }
      
    }
    if ((lo & 1) === 0) {
      return zero;
    } else {
      return min_int;
    }
  };
}

function xor(param, param$1) {
  return [
    param[0] ^ param$1[0],
    ((param[1] ^ param$1[1]) >>> 0)
  ];
}

function or_(param, param$1) {
  return [
    param[0] | param$1[0],
    ((param[1] | param$1[1]) >>> 0)
  ];
}

function and_(param, param$1) {
  return [
    param[0] & param$1[0],
    ((param[1] & param$1[1]) >>> 0)
  ];
}

function to_float(param) {
  return param[0] * 0x100000000 + param[1];
}

function of_float(x) {
  if (isNaN(x) || !isFinite(x)) {
    return zero;
  }
  if (x <= -9.22337203685477581e+18) {
    return min_int;
  }
  if (x + 1 >= 9.22337203685477581e+18) {
    return max_int;
  }
  if (x < 0) {
    return neg(of_float(- x));
  }
  const hi = x / 4294967296 | 0;
  const lo = x % 4294967296 | 0;
  return [
    hi,
    (lo >>> 0)
  ];
}

function isSafeInteger(param) {
  const hi = param[0];
  const top11Bits = (hi >> 21);
  if (top11Bits === 0) {
    return true;
  } else if (top11Bits === -1) {
    return !(param[1] === 0 && hi === -2097152);
  } else {
    return false;
  }
}

function to_string(self) {
  if (isSafeInteger(self)) {
    return String(to_float(self));
  }
  if (self[0] < 0) {
    if (Caml.i64_eq(self, min_int)) {
      return "-9223372036854775808";
    } else {
      return "-" + to_string(neg(self));
    }
  }
  const approx_div1 = of_float(Math.floor(to_float(self) / 10));
  const lo = approx_div1[1];
  const hi = approx_div1[0];
  const match = sub_aux(sub_aux(self, (lo << 3), (lo >>> 29) | (hi << 3)), (lo << 1), (lo >>> 31) | (hi << 1));
  const rem_lo = match[1];
  const rem_hi = match[0];
  if (rem_lo === 0 && rem_hi === 0) {
    return to_string(approx_div1) + "0";
  }
  if (rem_hi < 0) {
    const rem_lo$1 = ((rem_lo ^ -1) + 1 >>> 0);
    const delta = Math.ceil(rem_lo$1 / 10);
    const remainder = 10 * delta - rem_lo$1;
    return to_string(sub_aux(approx_div1, delta | 0, 0)) + String(remainder | 0);
  }
  const delta$1 = Math.floor(rem_lo / 10);
  const remainder$1 = rem_lo - 10 * delta$1;
  return to_string(add_aux(approx_div1, delta$1 | 0, 0)) + String(remainder$1 | 0);
}

function div(_self, _other) {
  while (true) {
    const other = _other;
    const self = _self;
    let exit = 0;
    if (other[0] !== 0 || other[1] !== 0) {
      exit = 1;
    } else {
      throw new Caml_js_exceptions.MelangeError("Division_by_zero", {
            MEL_EXN_ID: "Division_by_zero"
          });
    }
    if (exit === 1) {
      const self_hi = self[0];
      let exit$1 = 0;
      if (self_hi !== -2147483648) {
        if (self_hi !== 0) {
          exit$1 = 2;
        } else {
          if (self[1] === 0) {
            return zero;
          }
          exit$1 = 2;
        }
      } else if (self[1] !== 0) {
        exit$1 = 2;
      } else {
        if (Caml.i64_eq(other, one) || Caml.i64_eq(other, neg_one)) {
          return self;
        }
        if (Caml.i64_eq(other, min_int)) {
          return one;
        }
        const half_this = asr_(self, 1);
        const approx = lsl_(div(half_this, other), 1);
        let exit$2 = 0;
        if (approx[0] !== 0) {
          exit$2 = 3;
        } else {
          if (approx[1] === 0) {
            if (other[0] < 0) {
              return one;
            } else {
              return neg(one);
            }
          }
          exit$2 = 3;
        }
        if (exit$2 === 3) {
          const rem = sub(self, mul(other, approx));
          return add(approx, div(rem, other));
        }
        
      }
      if (exit$1 === 2) {
        const other_hi = other[0];
        let exit$3 = 0;
        if (other_hi !== -2147483648) {
          exit$3 = 3;
        } else {
          if (other[1] === 0) {
            return zero;
          }
          exit$3 = 3;
        }
        if (exit$3 === 3) {
          if (self_hi < 0) {
            if (other_hi >= 0) {
              return neg(div(neg(self), other));
            }
            _other = neg(other);
            _self = neg(self);
            continue;
          }
          if (other_hi < 0) {
            return neg(div(self, neg(other)));
          }
          let res = zero;
          let rem$1 = self;
          while (Caml.i64_ge(rem$1, other)) {
            const b = Math.floor(to_float(rem$1) / to_float(other));
            let approx$1 = 1 > b ? 1 : b;
            const log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
            let approxRes = of_float(approx$1);
            let approxRem = mul(approxRes, other);
            while (approxRem[0] < 0 || Caml.i64_gt(approxRem, rem$1)) {
              approx$1 = approx$1 - delta;
              approxRes = of_float(approx$1);
              approxRem = mul(approxRes, other);
            };
            if (is_zero(approxRes)) {
              approxRes = one;
            }
            res = add(res, approxRes);
            rem$1 = sub(rem$1, approxRem);
          };
          return res;
        }
        
      }
      
    }
    
  };
}

function mod_(self, other) {
  return sub(self, mul(div(self, other), other));
}

function div_mod(self, other) {
  const quotient = div(self, other);
  return [
    quotient,
    sub(self, mul(quotient, other))
  ];
}

function compare(self, other) {
  const y = other[0];
  const x = self[0];
  const v = x < y ? -1 : (
      x === y ? 0 : 1
    );
  if (v !== 0) {
    return v;
  }
  const y$1 = other[1];
  const x$1 = self[1];
  if (x$1 < y$1) {
    return -1;
  } else if (x$1 === y$1) {
    return 0;
  } else {
    return 1;
  }
}

function of_int32(lo) {
  return [
    lo < 0 ? -1 : 0,
    (lo >>> 0)
  ];
}

function to_int32(x) {
  return x[1] | 0;
}

function to_hex(x) {
  const x_lo = x[1];
  const x_hi = x[0];
  const aux = function (v) {
    return (v >>> 0).toString(16);
  };
  if (x_hi === 0 && x_lo === 0) {
    return "0";
  }
  if (x_lo === 0) {
    return aux(x_hi) + "00000000";
  }
  if (x_hi === 0) {
    return aux(x_lo);
  }
  const lo = aux(x_lo);
  const pad = 8 - lo.length | 0;
  if (pad <= 0) {
    return aux(x_hi) + lo;
  } else {
    return aux(x_hi) + ("0".repeat(pad) + lo);
  }
}

function discard_sign(x) {
  return [
    2147483647 & x[0],
    x[1]
  ];
}

function float_of_bits(x) {
  return (function(lo,hi){ return (new Float64Array(new Int32Array([lo,hi]).buffer))[0]}
  )(x[1], x[0]);
}

function bits_of_float(x) {
  const match = (function(x){return new Int32Array(new Float64Array([x]).buffer)}
  )(x);
  return [
    match[1],
    (match[0] >>> 0)
  ];
}

export {
  mk,
  succ,
  min_int,
  max_int,
  one,
  zero,
  neg_one,
  of_int32,
  to_int32,
  add,
  neg,
  sub,
  lsl_,
  lsr_,
  asr_,
  is_zero,
  mul,
  xor,
  or_,
  and_,
  equal_null,
  equal_undefined,
  equal_nullable,
  to_float,
  of_float,
  div,
  mod_,
  compare,
  float_of_bits,
  bits_of_float,
  div_mod,
  to_hex,
  discard_sign,
  to_string,
}
/* No side effect */
`,uu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,fu=`// Generated by Melange


const stdout = {
  buffer: "",
  output: (function (param, s) {
    const v = s.length - 1 | 0;
    if (((typeof process !== "undefined") && process.stdout && process.stdout.write
      )) {
      return process.stdout.write(s);
    } else {
      if (s[v] === "\\n") {
        console.log(s.slice(0, v));
      } else {
        console.log(s);
      }
      return;
    }
  })
};

const stderr = {
  buffer: "",
  output: (function (param, s) {
    const v = s.length - 1 | 0;
    if (s[v] === "\\n") {
      console.log(s.slice(0, v));
    } else {
      console.log(s);
    }
  })
};

function caml_ml_flush(oc) {
  if (oc.buffer !== "") {
    oc.output(oc, oc.buffer);
    oc.buffer = "";
    return;
  }
  
}

function caml_ml_output(oc, str, offset, len) {
  const str$1 = offset === 0 && len === str.length ? str : str.slice(offset, len);
  if (((typeof process !== "undefined") && process.stdout && process.stdout.write
    ) && oc === stdout) {
    return process.stdout.write(str$1);
  }
  const id = str$1.lastIndexOf("\\n");
  if (id < 0) {
    oc.buffer = oc.buffer + str$1;
  } else {
    oc.buffer = oc.buffer + str$1.slice(0, id + 1 | 0);
    caml_ml_flush(oc);
    oc.buffer = oc.buffer + str$1.slice(id + 1 | 0);
  }
}

function caml_ml_output_char(oc, $$char) {
  caml_ml_output(oc, String.fromCharCode($$char), 0, 1);
}

function caml_ml_out_channels_list(param) {
  return {
    hd: stdout,
    tl: {
      hd: stderr,
      tl: /* [] */ 0
    }
  };
}

let stdin;

export {
  stdin,
  stdout,
  stderr,
  caml_ml_flush,
  caml_ml_output,
  caml_ml_output_char,
  caml_ml_out_channels_list,
}
/* No side effect */
`,mu=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";

const $$Error = /* @__PURE__ */ Caml_exceptions.create("Caml_js_exceptions.Error");

function internalToOCamlException(e) {
  if (!(e == null) && Caml_exceptions.caml_is_extension(e.cause)) {
    return e.cause;
  } else {
    return {
      MEL_EXN_ID: $$Error,
      _1: e
    };
  }
}

function caml_as_js_exn(exn) {
  if (exn.MEL_EXN_ID === $$Error) {
    return Caml_option.some(exn._1);
  }
  
}

const MelangeError = (function MelangeError(message, cause) {
  var _this = Error.call(this, message, { cause: cause });

  if (_this.cause == null) {
    Object.defineProperty(_this, 'cause', {
      configurable : true,
      enumerable : false,
      writable : true,
      value : cause
    });
  }
  Object.defineProperty(_this, 'name', {
    configurable : true,
    enumerable : false,
    writable : true,
    value : 'MelangeError'
  })

  return _this;
}
);

MelangeError.prototype = Error.prototype;
;

export {
  $$Error,
  internalToOCamlException,
  caml_as_js_exn,
  MelangeError,
}
/*  Not a pure module */
`,du=`// Generated by Melange


/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 1996 Institut National de Recherche en Informatique et   */
/*  en Automatique.  All rights reserved.  This file is distributed    */
/*  under the terms of the GNU Library General Public License, with    */
/*  the special exception on linking described in file ../LICENSE.     */
/*                                                                     */
/***********************************************************************/

/* $Id: lexing.c 6045 2004-01-01 16:42:43Z doligez $ */

/* The table-driven automaton for lexers generated by camllex. */

function caml_lex_array(s) {
    var l = s.length / 2;
    var a = new Array(l);
    // when s.charCodeAt(2 * i + 1 ) > 128 (0x80)
    // a[i] < 0
    // for(var i = 0 ; i <= 0xffff; ++i) { if (i << 16 >> 16 !==i){console.log(i<<16>>16, 'vs',i)}}
    //
    for (var i = 0; i < l; i++)
        a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;
    return a;
}
;

const caml_lex_engine_aux = (function (tbl, start_state, lexbuf, exn){

    if (!Array.isArray(tbl.lex_default)) {
        tbl.lex_base = caml_lex_array(tbl.lex_base);
        tbl.lex_backtrk = caml_lex_array(tbl.lex_backtrk);
        tbl.lex_check = caml_lex_array(tbl.lex_check);
        tbl.lex_trans = caml_lex_array(tbl.lex_trans);
        tbl.lex_default = caml_lex_array(tbl.lex_default);
    }
    var c;
    var state = start_state;
    //var buffer = bytes_of_string(lexbuf.lex_buffer);
    var buffer = lexbuf.lex_buffer;
    if (state >= 0) {
        /* First entry */
        lexbuf.lex_last_pos = lexbuf.lex_start_pos = lexbuf.lex_curr_pos;
        lexbuf.lex_last_action = -1;
    }
    else {
        /* Reentry after refill */
        state = -state - 1;
    }
    for (;;) {
        /* Lookup base address or action number for current state */
        var base = tbl.lex_base[state];
        if (base < 0)
            return -base - 1;
        /* See if it's a backtrack point */
        var backtrk = tbl.lex_backtrk[state];
        if (backtrk >= 0) {
            lexbuf.lex_last_pos = lexbuf.lex_curr_pos;
            lexbuf.lex_last_action = backtrk;
        }
        /* See if we need a refill */
        if (lexbuf.lex_curr_pos >= lexbuf.lex_buffer_len) {
            if (lexbuf.lex_eof_reached === 0)
                return -state - 1;
            else
                c = 256;
        }
        else {
            /* Read next input char */
            c = buffer[lexbuf.lex_curr_pos];
            lexbuf.lex_curr_pos++;
        }
        /* Determine next state */
        if (tbl.lex_check[base + c] === state) {
            state = tbl.lex_trans[base + c];
        }
        else {
            state = tbl.lex_default[state];
        }
        /* If no transition on this char, return to last backtrack point */
        if (state < 0) {
            lexbuf.lex_curr_pos = lexbuf.lex_last_pos;
            if (lexbuf.lex_last_action == -1)
              throw new Error(exn.MEL_EXN_ID, { cause: exn })
            else
                return lexbuf.lex_last_action;
        }
        else {
            /* Erase the EOF condition only if the EOF pseudo-character was
             consumed by the automaton (i.e. there was no backtrack above)
             */
            if (c == 256)
                lexbuf.lex_eof_reached = 0;
        }
    }
}
);

const empty_token_lit = "lexing: empty token";

function caml_lex_engine(tbls, i, buf) {
  return caml_lex_engine_aux(tbls, i, buf, {
    MEL_EXN_ID: "Failure",
    _1: empty_token_lit
  });
}

/***********************************************/
/* New lexer engine, with memory of positions  */
/***********************************************/

/**
 * s -> Lexing.lex_tables.lex_code
 * mem -> Lexing.lexbuf.lex_mem (* int array *)
 */

function caml_lex_run_mem(s, i, mem, curr_pos) {
    for (;;) {
        var dst = s.charCodeAt(i);
        i++;
        if (dst == 0xff)
            return;
        var src = s.charCodeAt(i);
        i++;
        if (src == 0xff)
            mem[dst] = curr_pos;
        else
            mem[dst] = mem[src];
    }
}


/**
 * s -> Lexing.lex_tables.lex_code
 * mem -> Lexing.lexbuf.lex_mem (* int array *)
 */

function caml_lex_run_tag(s, i, mem) {
    for (;;) {
        var dst = s.charCodeAt(i);
        i++;
        if (dst == 0xff)
            return;
        var src = s.charCodeAt(i);
        i++;
        if (src == 0xff)
            mem[dst] = -1;
        else
            mem[dst] = mem[src];
    }
}
;

const caml_new_lex_engine_aux = (function (tbl, start_state, lexbuf, exn) {

    if (!Array.isArray(tbl.lex_default)) {
        tbl.lex_base = caml_lex_array(tbl.lex_base);
        tbl.lex_backtrk = caml_lex_array(tbl.lex_backtrk);
        tbl.lex_check = caml_lex_array(tbl.lex_check);
        tbl.lex_trans = caml_lex_array(tbl.lex_trans);
        tbl.lex_default = caml_lex_array(tbl.lex_default);
    }
    if(!Array.isArray(tbl.lex_default_code)){
        tbl.lex_base_code = caml_lex_array(tbl.lex_base_code);
        tbl.lex_backtrk_code = caml_lex_array(tbl.lex_backtrk_code);
        tbl.lex_check_code = caml_lex_array(tbl.lex_check_code);
        tbl.lex_trans_code = caml_lex_array(tbl.lex_trans_code);
        tbl.lex_default_code = caml_lex_array(tbl.lex_default_code);
    }
    var c, state = start_state;
    //var buffer = caml_bytes_of_string(lexbuf.lex_buffer);
    var buffer = lexbuf.lex_buffer;
    if (state >= 0) {
        /* First entry */
        lexbuf.lex_last_pos = lexbuf.lex_start_pos = lexbuf.lex_curr_pos;
        lexbuf.lex_last_action = -1;
    }
    else {
        /* Reentry after refill */
        state = -state - 1;
    }
    for (;;) {
        /* Lookup base address or action number for current state */
        var base = tbl.lex_base[state];
        if (base < 0) {
            var pc_off = tbl.lex_base_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf.lex_mem);
            return -base - 1;
        }
        /* See if it's a backtrack point */
        var backtrk = tbl.lex_backtrk[state];
        if (backtrk >= 0) {
            var pc_off = tbl.lex_backtrk_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf.lex_mem);
            lexbuf.lex_last_pos = lexbuf.lex_curr_pos;
            lexbuf.lex_last_action = backtrk;
        }
        /* See if we need a refill */
        if (lexbuf.lex_curr_pos >= lexbuf.lex_buffer_len) {
            if (lexbuf.lex_eof_reached == 0)
                return -state - 1;
            else
                c = 256;
        }
        else {
            /* Read next input char */
            c = buffer[lexbuf.lex_curr_pos];
            lexbuf.lex_curr_pos++;
        }
        /* Determine next state */
        var pstate = state;
        if (tbl.lex_check[base + c] == state)
            state = tbl.lex_trans[base + c];
        else
            state = tbl.lex_default[state];
        /* If no transition on this char, return to last backtrack point */
        if (state < 0) {
            lexbuf.lex_curr_pos = lexbuf.lex_last_pos;
            if (lexbuf.lex_last_action == -1)
                throw new Error(exn.MEL_EXN_ID, { cause: exn })
            else
                return lexbuf.lex_last_action;
        }
        else {
            /* If some transition, get and perform memory moves */
            var base_code = tbl.lex_base_code[pstate], pc_off;
            if (tbl.lex_check_code[base_code + c] == pstate)
                pc_off = tbl.lex_trans_code[base_code + c];
            else
                pc_off = tbl.lex_default_code[pstate];
            if (pc_off > 0)
                caml_lex_run_mem(tbl.lex_code, pc_off, lexbuf.lex_mem, lexbuf.lex_curr_pos);
            /* Erase the EOF condition only if the EOF pseudo-character was
             consumed by the automaton (i.e. there was no backtrack above)
             */
            if (c == 256)
                lexbuf.lex_eof_reached = 0;
        }
    }
    }
);

function caml_new_lex_engine(tbl, i, buf) {
  return caml_new_lex_engine_aux(tbl, i, buf, {
    MEL_EXN_ID: "Failure",
    _1: empty_token_lit
  });
}

export {
  caml_lex_engine,
  caml_new_lex_engine,
}
/*  Not a pure module */
`,pu=`// Generated by Melange

import * as Caml_bytes from "./caml_bytes.js";

function cmn(q, a, b, x, s, t) {
  const a$1 = ((a + q | 0) + x | 0) + t | 0;
  return ((a$1 << s) | (a$1 >>> (32 - s | 0)) | 0) + b | 0;
}

function f(a, b, c, d, x, s, t) {
  return cmn(b & c | (b ^ -1) & d, a, b, x, s, t);
}

function g(a, b, c, d, x, s, t) {
  return cmn(b & d | c & (d ^ -1), a, b, x, s, t);
}

function h(a, b, c, d, x, s, t) {
  return cmn(b ^ c ^ d, a, b, x, s, t);
}

function i(a, b, c, d, x, s, t) {
  return cmn(c ^ (b | d ^ -1), a, b, x, s, t);
}

function cycle(x, k) {
  let a = x[0];
  let b = x[1];
  let c = x[2];
  let d = x[3];
  a = f(a, b, c, d, k[0], 7, -680876936);
  d = f(d, a, b, c, k[1], 12, -389564586);
  c = f(c, d, a, b, k[2], 17, 606105819);
  b = f(b, c, d, a, k[3], 22, -1044525330);
  a = f(a, b, c, d, k[4], 7, -176418897);
  d = f(d, a, b, c, k[5], 12, 1200080426);
  c = f(c, d, a, b, k[6], 17, -1473231341);
  b = f(b, c, d, a, k[7], 22, -45705983);
  a = f(a, b, c, d, k[8], 7, 1770035416);
  d = f(d, a, b, c, k[9], 12, -1958414417);
  c = f(c, d, a, b, k[10], 17, -42063);
  b = f(b, c, d, a, k[11], 22, -1990404162);
  a = f(a, b, c, d, k[12], 7, 1804603682);
  d = f(d, a, b, c, k[13], 12, -40341101);
  c = f(c, d, a, b, k[14], 17, -1502002290);
  b = f(b, c, d, a, k[15], 22, 1236535329);
  a = g(a, b, c, d, k[1], 5, -165796510);
  d = g(d, a, b, c, k[6], 9, -1069501632);
  c = g(c, d, a, b, k[11], 14, 643717713);
  b = g(b, c, d, a, k[0], 20, -373897302);
  a = g(a, b, c, d, k[5], 5, -701558691);
  d = g(d, a, b, c, k[10], 9, 38016083);
  c = g(c, d, a, b, k[15], 14, -660478335);
  b = g(b, c, d, a, k[4], 20, -405537848);
  a = g(a, b, c, d, k[9], 5, 568446438);
  d = g(d, a, b, c, k[14], 9, -1019803690);
  c = g(c, d, a, b, k[3], 14, -187363961);
  b = g(b, c, d, a, k[8], 20, 1163531501);
  a = g(a, b, c, d, k[13], 5, -1444681467);
  d = g(d, a, b, c, k[2], 9, -51403784);
  c = g(c, d, a, b, k[7], 14, 1735328473);
  b = g(b, c, d, a, k[12], 20, -1926607734);
  a = h(a, b, c, d, k[5], 4, -378558);
  d = h(d, a, b, c, k[8], 11, -2022574463);
  c = h(c, d, a, b, k[11], 16, 1839030562);
  b = h(b, c, d, a, k[14], 23, -35309556);
  a = h(a, b, c, d, k[1], 4, -1530992060);
  d = h(d, a, b, c, k[4], 11, 1272893353);
  c = h(c, d, a, b, k[7], 16, -155497632);
  b = h(b, c, d, a, k[10], 23, -1094730640);
  a = h(a, b, c, d, k[13], 4, 681279174);
  d = h(d, a, b, c, k[0], 11, -358537222);
  c = h(c, d, a, b, k[3], 16, -722521979);
  b = h(b, c, d, a, k[6], 23, 76029189);
  a = h(a, b, c, d, k[9], 4, -640364487);
  d = h(d, a, b, c, k[12], 11, -421815835);
  c = h(c, d, a, b, k[15], 16, 530742520);
  b = h(b, c, d, a, k[2], 23, -995338651);
  a = i(a, b, c, d, k[0], 6, -198630844);
  d = i(d, a, b, c, k[7], 10, 1126891415);
  c = i(c, d, a, b, k[14], 15, -1416354905);
  b = i(b, c, d, a, k[5], 21, -57434055);
  a = i(a, b, c, d, k[12], 6, 1700485571);
  d = i(d, a, b, c, k[3], 10, -1894986606);
  c = i(c, d, a, b, k[10], 15, -1051523);
  b = i(b, c, d, a, k[1], 21, -2054922799);
  a = i(a, b, c, d, k[8], 6, 1873313359);
  d = i(d, a, b, c, k[15], 10, -30611744);
  c = i(c, d, a, b, k[6], 15, -1560198380);
  b = i(b, c, d, a, k[13], 21, 1309151649);
  a = i(a, b, c, d, k[4], 6, -145523070);
  d = i(d, a, b, c, k[11], 10, -1120210379);
  c = i(c, d, a, b, k[2], 15, 718787259);
  b = i(b, c, d, a, k[9], 21, -343485551);
  x[0] = a + x[0] | 0;
  x[1] = b + x[1] | 0;
  x[2] = c + x[2] | 0;
  x[3] = d + x[3] | 0;
}

const state = [
  1732584193,
  -271733879,
  -1732584194,
  271733878
];

const md5blk = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];

function caml_md5_string(s, start, len) {
  const s$1 = s.slice(start, len);
  const n = s$1.length;
  state[0] = 1732584193;
  state[1] = -271733879;
  state[2] = -1732584194;
  state[3] = 271733878;
  for (let i = 0; i <= 15; ++i) {
    md5blk[i] = 0;
  }
  const i_end = n / 64 | 0;
  for (let i$1 = 1; i$1 <= i_end; ++i$1) {
    for (let j = 0; j <= 15; ++j) {
      const k = ((i$1 << 6) - 64 | 0) + (j << 2) | 0;
      md5blk[j] = ((s$1.charCodeAt(k) + (s$1.charCodeAt(k + 1 | 0) << 8) | 0) + (s$1.charCodeAt(k + 2 | 0) << 16) | 0) + (s$1.charCodeAt(k + 3 | 0) << 24) | 0;
    }
    cycle(state, md5blk);
  }
  const s_tail = s$1.slice((i_end << 6));
  for (let kk = 0; kk <= 15; ++kk) {
    md5blk[kk] = 0;
  }
  const i_end$1 = s_tail.length - 1 | 0;
  for (let i$2 = 0; i$2 <= i_end$1; ++i$2) {
    md5blk[i$2 / 4 | 0] = md5blk[i$2 / 4 | 0] | (s_tail.charCodeAt(i$2) << (i$2 % 4 << 3));
  }
  const i$3 = i_end$1 + 1 | 0;
  md5blk[i$3 / 4 | 0] = md5blk[i$3 / 4 | 0] | (128 << (i$3 % 4 << 3));
  if (i$3 > 55) {
    cycle(state, md5blk);
    for (let i$4 = 0; i$4 <= 15; ++i$4) {
      md5blk[i$4] = 0;
    }
  }
  md5blk[14] = (n << 3);
  cycle(state, md5blk);
  return String.fromCharCode(state[0] & 255, (state[0] >> 8) & 255, (state[0] >> 16) & 255, (state[0] >> 24) & 255, state[1] & 255, (state[1] >> 8) & 255, (state[1] >> 16) & 255, (state[1] >> 24) & 255, state[2] & 255, (state[2] >> 8) & 255, (state[2] >> 16) & 255, (state[2] >> 24) & 255, state[3] & 255, (state[3] >> 8) & 255, (state[3] >> 16) & 255, (state[3] >> 24) & 255);
}

function caml_md5_bytes(s, start, len) {
  return caml_md5_string(Caml_bytes.bytes_to_string(s), start, len);
}

export {
  caml_md5_string,
  caml_md5_bytes,
}
/* No side effect */
`,hu=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "./caml_obj.js";

function init_mod(loc, shape) {
  const undef_module = function (param) {
    throw new Caml_js_exceptions.MelangeError("Undefined_recursive_module", {
          MEL_EXN_ID: "Undefined_recursive_module",
          _1: loc
        });
  };
  const loop = function (shape, struct_, idx) {
    if (/* tag */ typeof shape === "number" || typeof shape === "string") {
      switch (shape) {
        case /* Function */ 0 :
          struct_[idx] = undef_module;
          return;
        case /* Lazy */ 1 :
          struct_[idx] = {
            LAZY_DONE: true,
            VAL: undef_module
          };
          return;
        case /* Class */ 2 :
          struct_[idx] = [
            undef_module,
            undef_module,
            undef_module,
            0
          ];
          return;
      }
    } else {
      if (shape.TAG === /* Module */ 0) {
        const comps = shape._0;
        const v = {};
        struct_[idx] = v;
        const len = comps.length;
        for (let i = 0; i < len; ++i) {
          const match = comps[i];
          loop(match[0], v, match[1]);
        }
        return;
      }
      struct_[idx] = shape._0;
      return;
    }
  };
  const res = {};
  const dummy_name = "dummy";
  loop(shape, res, dummy_name);
  return res[dummy_name];
}

function update_mod(shape, o, n) {
  const aux = function (shape, o, n, parent, i) {
    if (/* tag */ typeof shape === "number" || typeof shape === "string") {
      switch (shape) {
        case /* Function */ 0 :
          parent[i] = n;
          return;
        case /* Lazy */ 1 :
        case /* Class */ 2 :
          return Caml_obj.update_dummy(o, n);
      }
    } else {
      if (shape.TAG !== /* Module */ 0) {
        return;
      }
      const comps = shape._0;
      for (let i$1 = 0, i_finish = comps.length; i$1 < i_finish; ++i$1) {
        const match = comps[i$1];
        const name = match[1];
        aux(match[0], o[name], n[name], o, name);
      }
      return;
    }
  };
  if (/* tag */ typeof shape === "number" || typeof shape === "string") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/runtime/caml_module.ml",
            95,
            9
          ]
        });
  }
  if (shape.TAG === /* Module */ 0) {
    const comps = shape._0;
    for (let i = 0, i_finish = comps.length; i < i_finish; ++i) {
      const match = comps[i];
      const name = match[1];
      aux(match[0], o[name], n[name], o, name);
    }
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/runtime/caml_module.ml",
          95,
          9
        ]
      });
}

export {
  init_mod,
  update_mod,
}
/* No side effect */
`,gu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,yu=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

const for_in = (function(o,foo){
        for (var x in o) { foo(x) }}
);

const caml_obj_dup = (function(x){
  if(Array.isArray(x)){
    var len = x.length
    var v = new Array(len)
    for(var i = 0 ; i < len ; ++i){
      v[i] = x[i]
    }
    if(x.TAG !== undefined){
      v.TAG = x.TAG // TODO this can be removed eventually
    }
    return v
  }
  return Object.assign({},x)
}
);

const update_dummy = (function(x,y){
  var k
  if(Array.isArray(y)){
    for(k = 0; k < y.length ; ++k){
      x[k] = y[k]
    }
    if(y.TAG !== undefined){
      x.TAG = y.TAG
    }
  } else {
    for (var k in y){
      x[k] = y[k]
    }
  }
}
);

function caml_compare(a, b) {
  if (a === b) {
    return 0;
  }
  const a_type = typeof a;
  const b_type = typeof b;
  switch (a_type) {
    case "bigint" :
      if (b_type === "bigint") {
        return Caml.caml_float_compare(a, b);
      }
      break;
    case "boolean" :
      if (b_type === "boolean") {
        return Caml.caml_int_compare(a, b);
      }
      break;
    case "function" :
      if (b_type === "function") {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "compare: functional value"
            });
      }
      break;
    case "number" :
      if (b_type === "number") {
        return Caml.caml_float_compare(a, b);
      }
      break;
    case "string" :
      if (b_type === "string") {
        return Caml.caml_string_compare(a, b);
      } else {
        return 1;
      }
    case "undefined" :
      return -1;
  }
  switch (b_type) {
    case "string" :
      return -1;
    case "undefined" :
      return 1;
    default:
      if (a_type === "boolean") {
        return 1;
      }
      if (b_type === "boolean") {
        return -1;
      }
      if (a_type === "function") {
        return 1;
      }
      if (b_type === "function") {
        return -1;
      }
      if (a_type === "number") {
        if (b === null || b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b_type === "number") {
        if (a === null || a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a === null) {
        if (b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b === null) {
        if (a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
        if (b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return aux_obj_compare(a, b);
        } else {
          return -1;
        }
      }
      const tag_a = a.TAG;
      const tag_b = b.TAG;
      if (tag_a === 248) {
        return Caml.caml_int_compare(a[1], b[1]);
      }
      if (tag_a === 251) {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "equal: abstract value"
            });
      }
      if (tag_a !== tag_b) {
        if (tag_a < tag_b) {
          return -1;
        } else {
          return 1;
        }
      }
      const len_a = a.length | 0;
      const len_b = b.length | 0;
      if (len_a === len_b) {
        if (Array.isArray(a)) {
          let _i = 0;
          while (true) {
            const i = _i;
            if (i === len_a) {
              return 0;
            }
            const res = caml_compare(a[i], b[i]);
            if (res !== 0) {
              return res;
            }
            _i = i + 1 | 0;
            continue;
          };
        } else if ((a instanceof Date && b instanceof Date
          )) {
          return (a - b
          );
        } else {
          return aux_obj_compare(a, b);
        }
      } else if (len_a < len_b) {
        let _i$1 = 0;
        while (true) {
          const i$1 = _i$1;
          if (i$1 === len_a) {
            return -1;
          }
          const res$1 = caml_compare(a[i$1], b[i$1]);
          if (res$1 !== 0) {
            return res$1;
          }
          _i$1 = i$1 + 1 | 0;
          continue;
        };
      } else {
        let _i$2 = 0;
        while (true) {
          const i$2 = _i$2;
          if (i$2 === len_b) {
            return 1;
          }
          const res$2 = caml_compare(a[i$2], b[i$2]);
          if (res$2 !== 0) {
            return res$2;
          }
          _i$2 = i$2 + 1 | 0;
          continue;
        };
      }
  }
}

function aux_obj_compare(a, b) {
  const min_key_lhs = {
    contents: undefined
  };
  const min_key_rhs = {
    contents: undefined
  };
  const do_key = function (param, key) {
    const min_key = param[2];
    const b = param[1];
    if (!(!Object.prototype.hasOwnProperty.call(b, key) || caml_compare(param[0][key], b[key]) > 0)) {
      return;
    }
    const mk = min_key.contents;
    if (mk !== undefined && key >= mk) {
      return;
    } else {
      min_key.contents = key;
      return;
    }
  };
  const partial_arg = [
    a,
    b,
    min_key_rhs
  ];
  const do_key_a = function (param) {
    return do_key(partial_arg, param);
  };
  const partial_arg$1 = [
    b,
    a,
    min_key_lhs
  ];
  const do_key_b = function (param) {
    return do_key(partial_arg$1, param);
  };
  for_in(a, do_key_a);
  for_in(b, do_key_b);
  const match = min_key_lhs.contents;
  const match$1 = min_key_rhs.contents;
  if (match !== undefined) {
    if (match$1 !== undefined) {
      return Caml.caml_string_compare(match, match$1);
    } else {
      return -1;
    }
  } else if (match$1 !== undefined) {
    return 1;
  } else {
    return 0;
  }
}

function caml_equal(a, b) {
  if (a === b) {
    return true;
  }
  const a_type = typeof a;
  if (a_type === "string" || a_type === "number" || a_type === "bigint" || a_type === "boolean" || a_type === "undefined" || a === null) {
    return false;
  }
  const b_type = typeof b;
  if (a_type === "function" || b_type === "function") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "equal: functional value"
        });
  }
  if (b_type === "number" || b_type === "bigint" || b_type === "undefined" || b === null) {
    return false;
  }
  const tag_a = a.TAG;
  const tag_b = b.TAG;
  if (tag_a === 248) {
    return a[1] === b[1];
  }
  if (tag_a === 251) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "equal: abstract value"
        });
  }
  if (tag_a !== tag_b) {
    return false;
  }
  const len_a = a.length | 0;
  const len_b = b.length | 0;
  if (len_a === len_b) {
    if (Array.isArray(a)) {
      let _i = 0;
      while (true) {
        const i = _i;
        if (i === len_a) {
          return true;
        }
        if (!caml_equal(a[i], b[i])) {
          return false;
        }
        _i = i + 1 | 0;
        continue;
      };
    } else if ((a instanceof Date && b instanceof Date
      )) {
      return !(a > b || a < b);
    } else {
      const result = {
        contents: true
      };
      const do_key_a = function (key) {
        if (!Object.prototype.hasOwnProperty.call(b, key)) {
          result.contents = false;
          return;
        }
        
      };
      const do_key_b = function (key) {
        if (!Object.prototype.hasOwnProperty.call(a, key) || !caml_equal(b[key], a[key])) {
          result.contents = false;
          return;
        }
        
      };
      for_in(a, do_key_a);
      if (result.contents) {
        for_in(b, do_key_b);
      }
      return result.contents;
    }
  } else {
    return false;
  }
}

function caml_equal_null(x, y) {
  if (y !== null) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_undefined(x, y) {
  if (y !== undefined) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_nullable(x, y) {
  if (y == null) {
    return x === y;
  } else {
    return caml_equal(x, y);
  }
}

function caml_notequal(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a !== b;
  } else {
    return !caml_equal(a, b);
  }
}

function caml_greaterequal(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a >= b;
  } else {
    return caml_compare(a, b) >= 0;
  }
}

function caml_greaterthan(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a > b;
  } else {
    return caml_compare(a, b) > 0;
  }
}

function caml_lessequal(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a <= b;
  } else {
    return caml_compare(a, b) <= 0;
  }
}

function caml_lessthan(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a < b;
  } else {
    return caml_compare(a, b) < 0;
  }
}

function caml_min(x, y) {
  if (caml_compare(x, y) <= 0) {
    return x;
  } else {
    return y;
  }
}

function caml_max(x, y) {
  if (caml_compare(x, y) >= 0) {
    return x;
  } else {
    return y;
  }
}

export {
  caml_obj_dup,
  update_dummy,
  caml_compare,
  caml_equal,
  caml_equal_null,
  caml_equal_undefined,
  caml_equal_nullable,
  caml_notequal,
  caml_greaterequal,
  caml_greaterthan,
  caml_lessthan,
  caml_lessequal,
  caml_min,
  caml_max,
}
/* No side effect */
`,bu=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "./caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

const caml_methods_cache = Caml_array.make(1000, 0);

function caml_set_oo_id(b) {
  b[1] = Caml_exceptions.id.contents;
  Caml_exceptions.id.contents = Caml_exceptions.id.contents + 1 | 0;
  return b;
}

function caml_get_public_method(obj, tag, cacheid) {
  const meths = obj[0];
  const offs = caml_methods_cache[cacheid];
  if (meths[offs] === tag) {
    return meths[offs - 1 | 0];
  }
  const aux = function (_i) {
    while (true) {
      const i = _i;
      if (i < 3) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/runtime/caml_oo.ml",
                64,
                20
              ]
            });
      }
      if (meths[i] === tag) {
        caml_methods_cache[cacheid] = i;
        return i;
      }
      _i = i - 2 | 0;
      continue;
    };
  };
  return meths[aux((meths[0] << 1) + 1 | 0) - 1 | 0];
}

export {
  caml_get_public_method,
  caml_set_oo_id,
}
/* No side effect */
`,xu=`// Generated by Melange

import * as Caml_oo from "./caml_oo.js";
import * as Curry from "./curry.js";

function js(label, cacheid, obj, args) {
  const meth = Caml_oo.caml_get_public_method(obj, label, cacheid);
  return Curry.app(meth, args);
}

function js1(label, cacheid, a0) {
  return Curry._1(Caml_oo.caml_get_public_method(a0, label, cacheid), a0);
}

function js2(label, cacheid, a0, a1) {
  return Curry._2(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1);
}

function js3(label, cacheid, a0, a1, a2) {
  return Curry._3(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2);
}

function js4(label, cacheid, a0, a1, a2, a3) {
  return Curry._4(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3);
}

function js5(label, cacheid, a0, a1, a2, a3, a4) {
  return Curry._5(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4);
}

function js6(label, cacheid, a0, a1, a2, a3, a4, a5) {
  return Curry._6(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5);
}

function js7(label, cacheid, a0, a1, a2, a3, a4, a5, a6) {
  return Curry._7(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5, a6);
}

function js8(label, cacheid, a0, a1, a2, a3, a4, a5, a6, a7) {
  return Curry._8(Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5, a6, a7);
}

export {
  js,
  js1,
  js2,
  js3,
  js4,
  js5,
  js6,
  js7,
  js8,
}
/* No side effect */
`,vu=`// Generated by Melange


function isNested(x) {
  return x.MEL_PRIVATE_NESTED_SOME_NONE !== undefined;
}

function some(x) {
  if (x === undefined) {
    return {
      MEL_PRIVATE_NESTED_SOME_NONE: 0
    };
  } else if (x !== null && x.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
    return {
      MEL_PRIVATE_NESTED_SOME_NONE: x.MEL_PRIVATE_NESTED_SOME_NONE + 1 | 0
    };
  } else {
    return x;
  }
}

function nullable_to_opt(x) {
  if (x == null) {
    return;
  } else {
    return some(x);
  }
}

function undefined_to_opt(x) {
  if (x === undefined) {
    return;
  } else {
    return some(x);
  }
}

function null_to_opt(x) {
  if (x === null) {
    return;
  } else {
    return some(x);
  }
}

function valFromOption(x) {
  if (!(x !== null && x.MEL_PRIVATE_NESTED_SOME_NONE !== undefined)) {
    return x;
  }
  const depth = x.MEL_PRIVATE_NESTED_SOME_NONE;
  if (depth === 0) {
    return;
  } else {
    return {
      MEL_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0
    };
  }
}

function option_get(x) {
  if (x === undefined) {
    return;
  } else {
    return valFromOption(x);
  }
}

function option_unwrap(x) {
  if (x !== undefined) {
    return x.VAL;
  } else {
    return x;
  }
}

export {
  nullable_to_opt,
  undefined_to_opt,
  null_to_opt,
  valFromOption,
  some,
  isNested,
  option_get,
  option_unwrap,
}
/* No side effect */
`,$u=`// Generated by Melange


/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 1996 Institut National de Recherche en Informatique et   */
/*  en Automatique.  All rights reserved.  This file is distributed    */
/*  under the terms of the GNU Library General Public License, with    */
/*  the special exception on linking described in file ../LICENSE.     */
/*                                                                     */
/***********************************************************************/

/* $Id: parsing.c 8983 2008-08-06 09:38:25Z xleroy $ */

/* The PDA automaton for parsers generated by camlyacc */

/* The pushdown automata */

/**
 * caml_lex_array("abcd")
 * [25185, 25699]
 * @param s
 * @returns {any[]}
 * TODO: duplicated with module {!Caml_lex}
 */
function caml_lex_array(s) {
    var l = s.length / 2;
    var a = new Array(l);
    for (var i = 0; i < l; i++)
        a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;
    return a;
}
/**
 * Note that TS enum is not friendly to Closure compiler
 * @enum{number}
 */
var Automata = {
    START: 0,
    LOOP: 6,
    TOKEN_READ: 1,
    TEST_SHIFT: 7,
    ERROR_DETECTED: 5,
    SHIFT: 8,
    SHIFT_RECOVER: 9,
    STACK_GROWN_1: 2,
    REDUCE: 10,
    STACK_GROWN_2: 3,
    SEMANTIC_ACTION_COMPUTED: 4
};
/**
 * @enum{number}
 */
var Result = {
    READ_TOKEN: 0,
    RAISE_PARSE_ERROR: 1,
    GROW_STACKS_1: 2,
    GROW_STACKS_2: 3,
    COMPUTE_SEMANTIC_ACTION: 4,
    CALL_ERROR_FUNCTION: 5
};
var PARSER_TRACE = false;
;

const caml_parse_engine = (function (tables /* parser_table */, env /* parser_env */, cmd /* parser_input*/, arg /* Obj.t*/) {
    var ERRCODE = 256;
    //var START = 0;
    //var TOKEN_READ = 1;
    //var STACKS_GROWN_1 = 2;
    //var STACKS_GROWN_2 = 3;
    //var SEMANTIC_ACTION_COMPUTED = 4;
    //var ERROR_DETECTED = 5;
    //var loop = 6;
    //var testshift = 7;
    //var shift = 8;
    //var shift_recover = 9;
    //var reduce = 10;
    // Parsing.parser_env
    var env_s_stack = 's_stack'; // array
    var env_v_stack = 'v_stack'; // array
    var env_symb_start_stack = 'symb_start_stack'; // array
    var env_symb_end_stack = 'symb_end_stack'; // array
    var env_stacksize = 'stacksize';
    var env_stackbase = 'stackbase';
    var env_curr_char = 'curr_char';
    var env_lval = 'lval'; // Obj.t
    var env_symb_start = 'symb_start'; // position
    var env_symb_end = 'symb_end'; // position
    var env_asp = 'asp';
    var env_rule_len = 'rule_len';
    var env_rule_number = 'rule_number';
    var env_sp = 'sp';
    var env_state = 'state';
    var env_errflag = 'errflag';
    // Parsing.parse_tables
    // var _tbl_actions = 1;
    var tbl_transl_const = 'transl_const'; // array
    var tbl_transl_block = 'transl_block'; // array
    var tbl_lhs = 'lhs';
    var tbl_len = 'len';
    var tbl_defred = 'defred';
    var tbl_dgoto = 'dgoto';
    var tbl_sindex = 'sindex';
    var tbl_rindex = 'rindex';
    var tbl_gindex = 'gindex';
    var tbl_tablesize = 'tablesize';
    var tbl_table = 'table';
    var tbl_check = 'check';
    // var _tbl_error_function = 14;
    // var _tbl_names_const = 15;
    // var _tbl_names_block = 16;
    if (!tables.preprocessed) {
        tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
        tables.preprocessed = true;
    }
    var res;
    var n, n1, n2, state1;
    // RESTORE
    var sp = env[env_sp];
    var state = env[env_state];
    var errflag = env[env_errflag];
    exit: for (;;) {
        //console.error("State", Automata[cmd]);
        switch (cmd) {
            case Automata.START:
                state = 0;
                errflag = 0;
            // Fall through
            case Automata.LOOP:
                n = tables.defred[state];
                if (n != 0) {
                    cmd = Automata.REDUCE;
                    break;
                }
                if (env[env_curr_char] >= 0) {
                    cmd = Automata.TEST_SHIFT;
                    break;
                }
                res = Result.READ_TOKEN;
                break exit;
            /* The ML code calls the lexer and updates */
            /* symb_start and symb_end */
            case Automata.TOKEN_READ:
                if (typeof arg !== 'number') {
                    env[env_curr_char] = tables[tbl_transl_block][arg.TAG | 0 /* + 1 */];
                    env[env_lval] = arg._0; // token carries payload
                }
                else {
                    env[env_curr_char] = tables[tbl_transl_const][arg /* + 1 */];
                    env[env_lval] = 0; // const token
                }
                if (PARSER_TRACE) {
                    console.error("State %d, read token", state, arg);
                }
            // Fall through
            case Automata.TEST_SHIFT:
                n1 = tables.sindex[state];
                n2 = n1 + env[env_curr_char];
                if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                    tables.check[n2] == env[env_curr_char]) {
                    cmd = Automata.SHIFT;
                    break;
                }
                n1 = tables.rindex[state];
                n2 = n1 + env[env_curr_char];
                if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                    tables.check[n2] == env[env_curr_char]) {
                    n = tables.table[n2];
                    cmd = Automata.REDUCE;
                    break;
                }
                if (errflag <= 0) {
                    res = Result.CALL_ERROR_FUNCTION;
                    break exit;
                }
            // Fall through
            /* The ML code calls the error function */
            case Automata.ERROR_DETECTED:
                if (errflag < 3) {
                    errflag = 3;
                    for (;;) {
                        state1 = env[env_s_stack][sp /* + 1*/];
                        n1 = tables.sindex[state1];
                        n2 = n1 + ERRCODE;
                        if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                            tables.check[n2] == ERRCODE) {
                            cmd = Automata.SHIFT_RECOVER;
                            break;
                        }
                        else {
                            if (sp <= env[env_stackbase])
                                return Result.RAISE_PARSE_ERROR;
                            /* The ML code raises Parse_error */
                            sp--;
                        }
                    }
                }
                else {
                    if (env[env_curr_char] == 0)
                        return Result.RAISE_PARSE_ERROR;
                    /* The ML code raises Parse_error */
                    env[env_curr_char] = -1;
                    cmd = Automata.LOOP;
                    break;
                }
            // Fall through
            case Automata.SHIFT:
                env[env_curr_char] = -1;
                if (errflag > 0)
                    errflag--;
            // Fall through
            case Automata.SHIFT_RECOVER:
                if (PARSER_TRACE) {
                    console.error("State %d: shift to state %d", state, tables.table[n2]);
                }
                state = tables.table[n2];
                sp++;
                if (sp >= env[env_stacksize]) {
                    res = Result.GROW_STACKS_1;
                    break exit;
                }
            // Fall through
            /* The ML code resizes the stacks */
            case Automata.STACK_GROWN_1:
                env[env_s_stack][sp /* + 1 */] = state;
                env[env_v_stack][sp /* + 1 */] = env[env_lval];
                env[env_symb_start_stack][sp /* + 1 */] = env[env_symb_start];
                env[env_symb_end_stack][sp /* + 1 */] = env[env_symb_end];
                cmd = Automata.LOOP;
                break;
            case Automata.REDUCE:
                if (PARSER_TRACE) {
                    console.error("State %d : reduce by rule %d", state, n);
                }
                var m = tables.len[n];
                env[env_asp] = sp;
                env[env_rule_number] = n;
                env[env_rule_len] = m;
                sp = sp - m + 1;
                m = tables.lhs[n];
                state1 = env[env_s_stack][sp - 1]; //
                n1 = tables.gindex[m];
                n2 = n1 + state1;
                if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                    tables.check[n2] == state1)
                    state = tables.table[n2];
                else
                    state = tables.dgoto[m];
                if (sp >= env[env_stacksize]) {
                    res = Result.GROW_STACKS_2;
                    break exit;
                }
            // Fall through
            /* The ML code resizes the stacks */
            case Automata.STACK_GROWN_2:
                res = Result.COMPUTE_SEMANTIC_ACTION;
                break exit;
            /* The ML code calls the semantic action */
            case Automata.SEMANTIC_ACTION_COMPUTED:
                env[env_s_stack][sp /* + 1 */] = state;
                env[env_v_stack][sp /* + 1*/] = arg;
                var asp = env[env_asp];
                env[env_symb_end_stack][sp /* + 1*/] = env[env_symb_end_stack][asp /* + 1*/];
                if (sp > asp) {
                    /* This is an epsilon production. Take symb_start equal to symb_end. */
                    env[env_symb_start_stack][sp /* + 1*/] = env[env_symb_end_stack][asp /*+ 1*/];
                }
                cmd = Automata.LOOP;
                break;
            /* Should not happen */
            default:
                return Result.RAISE_PARSE_ERROR;
        }
    }
    // SAVE
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
}
);

const caml_set_parser_trace = (function (v) {
    var old = PARSER_TRACE;
    PARSER_TRACE = v;
    return old;
}
);

export {
  caml_parse_engine,
  caml_set_parser_trace,
}
/*  Not a pure module */
`,ku=`// Generated by Melange


const spliceApply = (function(fn,args){
  var i, argLen;
  argLen = args.length
  var applied = []
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  return fn.apply(null,applied)
}
);

const spliceNewApply = (function (ctor,args){
  var i, argLen;
  argLen = args.length
  var applied = [null] // Function.prototype.bind.apply(fn, args) requires the first element in \`args\` to be \`null\`
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  var C = Function.prototype.bind.apply(ctor, applied)
  return new C()
}
);

const spliceObjApply = (function(obj,name,args){
  var i, argLen;
  argLen = args.length
  var applied = []
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  return (obj[name]).apply(obj,applied)
}
);

export {
  spliceApply,
  spliceNewApply,
  spliceObjApply,
}
/* No side effect */
`,Cu=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function get(s, i) {
  if (i >= s.length || i < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  return s.charCodeAt(i);
}

function make(n, ch) {
  return String.fromCharCode(ch).repeat(n);
}

export {
  get,
  make,
}
/* No side effect */
`,Eu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Au=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function caml_sys_getenv(s) {
  if (typeof process === "undefined" || process.env === undefined) {
    throw new Caml_js_exceptions.MelangeError("Not_found", {
          MEL_EXN_ID: "Not_found"
        });
  }
  const x = process.env[s];
  if (x !== undefined) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Not_found", {
        MEL_EXN_ID: "Not_found"
      });
}

const os_type = (function(_){
  if(typeof process !== 'undefined' && process.platform === 'win32'){
        return "Win32"
  }
  else {
    return "Unix"
  }
}
);

function caml_sys_time(param) {
  if (typeof process === "undefined" || process.uptime === undefined) {
    return -1;
  } else {
    return process.uptime();
  }
}

function caml_sys_system_command(_cmd) {
  return 127;
}

const caml_sys_getcwd = (function(param){
    if (typeof process === "undefined" || process.cwd === undefined){
      return "/"
    }
    return process.cwd()
  }
);

function caml_sys_executable_name(param) {
  if (typeof process === "undefined") {
    return "";
  }
  const argv = process.argv;
  if (argv == null) {
    return "";
  } else {
    return argv[0];
  }
}

function caml_sys_argv(param) {
  if (typeof process === "undefined") {
    return [""];
  }
  const argv = process.argv;
  if (argv == null) {
    return [""];
  } else {
    return argv;
  }
}

function caml_sys_exit(exit_code) {
  if (typeof process !== "undefined") {
    return process.exit(exit_code);
  }
  
}

function caml_sys_is_directory(_s) {
  throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "caml_sys_is_directory not implemented"
      });
}

function caml_sys_file_exists(_s) {
  throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "caml_sys_file_exists not implemented"
      });
}

export {
  caml_sys_getenv,
  caml_sys_time,
  os_type,
  caml_sys_system_command,
  caml_sys_getcwd,
  caml_sys_executable_name,
  caml_sys_argv,
  caml_sys_exit,
  caml_sys_is_directory,
  caml_sys_file_exists,
}
/* No side effect */
`,wu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Su=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";

function app(_f, _args) {
  while (true) {
    const args = _args;
    const f = _f;
    const init_arity = f.length;
    const arity = init_arity === 0 ? 1 : init_arity;
    const len = args.length;
    const d = arity - len | 0;
    if (d === 0) {
      return f.apply(null, args);
    }
    if (d >= 0) {
      return function (x) {
        return app(f, args.concat([x]));
      };
    }
    _args = Caml_array.sub(args, arity, -d | 0);
    _f = f.apply(null, Caml_array.sub(args, 0, arity));
    continue;
  };
}

function _1(o, a0) {
  const arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    switch (arity) {
      case 1 :
        return o(a0);
      case 2 :
        return function (param) {
          return o(a0, param);
        };
      case 3 :
        return function (param, param$1) {
          return o(a0, param, param$1);
        };
      case 4 :
        return function (param, param$1, param$2) {
          return o(a0, param, param$1, param$2);
        };
      case 5 :
        return function (param, param$1, param$2, param$3) {
          return o(a0, param, param$1, param$2, param$3);
        };
      case 6 :
        return function (param, param$1, param$2, param$3, param$4) {
          return o(a0, param, param$1, param$2, param$3, param$4);
        };
      case 7 :
        return function (param, param$1, param$2, param$3, param$4, param$5) {
          return o(a0, param, param$1, param$2, param$3, param$4, param$5);
        };
      default:
        return app(o, [a0]);
    }
  }
}

function __1(o) {
  const arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return function (a0) {
      return _1(o, a0);
    };
  }
}

function _2(o, a0, a1) {
  const arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    switch (arity) {
      case 1 :
        return app(o(a0), [a1]);
      case 2 :
        return o(a0, a1);
      case 3 :
        return function (param) {
          return o(a0, a1, param);
        };
      case 4 :
        return function (param, param$1) {
          return o(a0, a1, param, param$1);
        };
      case 5 :
        return function (param, param$1, param$2) {
          return o(a0, a1, param, param$1, param$2);
        };
      case 6 :
        return function (param, param$1, param$2, param$3) {
          return o(a0, a1, param, param$1, param$2, param$3);
        };
      case 7 :
        return function (param, param$1, param$2, param$3, param$4) {
          return o(a0, a1, param, param$1, param$2, param$3, param$4);
        };
      default:
        return app(o, [
          a0,
          a1
        ]);
    }
  }
}

function __2(o) {
  const arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return function (a0, a1) {
      return _2(o, a0, a1);
    };
  }
}

function _3(o, a0, a1, a2) {
  const arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    switch (arity) {
      case 1 :
        return app(o(a0), [
          a1,
          a2
        ]);
      case 2 :
        return app(o(a0, a1), [a2]);
      case 3 :
        return o(a0, a1, a2);
      case 4 :
        return function (param) {
          return o(a0, a1, a2, param);
        };
      case 5 :
        return function (param, param$1) {
          return o(a0, a1, a2, param, param$1);
        };
      case 6 :
        return function (param, param$1, param$2) {
          return o(a0, a1, a2, param, param$1, param$2);
        };
      case 7 :
        return function (param, param$1, param$2, param$3) {
          return o(a0, a1, a2, param, param$1, param$2, param$3);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2
        ]);
    }
  }
}

function __3(o) {
  const arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return function (a0, a1, a2) {
      return _3(o, a0, a1, a2);
    };
  }
}

function _4(o, a0, a1, a2, a3) {
  const arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    switch (arity) {
      case 1 :
        return app(o(a0), [
          a1,
          a2,
          a3
        ]);
      case 2 :
        return app(o(a0, a1), [
          a2,
          a3
        ]);
      case 3 :
        return app(o(a0, a1, a2), [a3]);
      case 4 :
        return o(a0, a1, a2, a3);
      case 5 :
        return function (param) {
          return o(a0, a1, a2, a3, param);
        };
      case 6 :
        return function (param, param$1) {
          return o(a0, a1, a2, a3, param, param$1);
        };
      case 7 :
        return function (param, param$1, param$2) {
          return o(a0, a1, a2, a3, param, param$1, param$2);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3
        ]);
    }
  }
}

function __4(o) {
  const arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return function (a0, a1, a2, a3) {
      return _4(o, a0, a1, a2, a3);
    };
  }
}

function _5(o, a0, a1, a2, a3, a4) {
  const arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    switch (arity) {
      case 1 :
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4
        ]);
      case 2 :
        return app(o(a0, a1), [
          a2,
          a3,
          a4
        ]);
      case 3 :
        return app(o(a0, a1, a2), [
          a3,
          a4
        ]);
      case 4 :
        return app(o(a0, a1, a2, a3), [a4]);
      case 5 :
        return o(a0, a1, a2, a3, a4);
      case 6 :
        return function (param) {
          return o(a0, a1, a2, a3, a4, param);
        };
      case 7 :
        return function (param, param$1) {
          return o(a0, a1, a2, a3, a4, param, param$1);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4
        ]);
    }
  }
}

function __5(o) {
  const arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4) {
      return _5(o, a0, a1, a2, a3, a4);
    };
  }
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  const arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    switch (arity) {
      case 1 :
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4,
          a5
        ]);
      case 2 :
        return app(o(a0, a1), [
          a2,
          a3,
          a4,
          a5
        ]);
      case 3 :
        return app(o(a0, a1, a2), [
          a3,
          a4,
          a5
        ]);
      case 4 :
        return app(o(a0, a1, a2, a3), [
          a4,
          a5
        ]);
      case 5 :
        return app(o(a0, a1, a2, a3, a4), [a5]);
      case 6 :
        return o(a0, a1, a2, a3, a4, a5);
      case 7 :
        return function (param) {
          return o(a0, a1, a2, a3, a4, a5, param);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4,
          a5
        ]);
    }
  }
}

function __6(o) {
  const arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5) {
      return _6(o, a0, a1, a2, a3, a4, a5);
    };
  }
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  const arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    switch (arity) {
      case 1 :
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4,
          a5,
          a6
        ]);
      case 2 :
        return app(o(a0, a1), [
          a2,
          a3,
          a4,
          a5,
          a6
        ]);
      case 3 :
        return app(o(a0, a1, a2), [
          a3,
          a4,
          a5,
          a6
        ]);
      case 4 :
        return app(o(a0, a1, a2, a3), [
          a4,
          a5,
          a6
        ]);
      case 5 :
        return app(o(a0, a1, a2, a3, a4), [
          a5,
          a6
        ]);
      case 6 :
        return app(o(a0, a1, a2, a3, a4, a5), [a6]);
      case 7 :
        return o(a0, a1, a2, a3, a4, a5, a6);
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6
        ]);
    }
  }
}

function __7(o) {
  const arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6) {
      return _7(o, a0, a1, a2, a3, a4, a5, a6);
    };
  }
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  const arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    switch (arity) {
      case 1 :
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
      case 2 :
        return app(o(a0, a1), [
          a2,
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
      case 3 :
        return app(o(a0, a1, a2), [
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
      case 4 :
        return app(o(a0, a1, a2, a3), [
          a4,
          a5,
          a6,
          a7
        ]);
      case 5 :
        return app(o(a0, a1, a2, a3, a4), [
          a5,
          a6,
          a7
        ]);
      case 6 :
        return app(o(a0, a1, a2, a3, a4, a5), [
          a6,
          a7
        ]);
      case 7 :
        return app(o(a0, a1, a2, a3, a4, a5, a6), [a7]);
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
    }
  }
}

function __8(o) {
  const arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6, a7) {
      return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
    };
  }
}

export {
  app,
  _1,
  __1,
  _2,
  __2,
  _3,
  __3,
  _4,
  __4,
  _5,
  __5,
  _6,
  __6,
  _7,
  __7,
  _8,
  __8,
}
/* No side effect */
`,Bu=`// Generated by Melange


const Fn = {};

const Internal = {};

export {
  Fn,
  Internal,
}
/* No side effect */
`,Iu=`// Generated by Melange


const Callback = {};

const Meth = {};

const Internal = {};

export {
  Callback,
  Meth,
  Internal,
}
/* No side effect */
`,ju=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Mu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Lu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Tu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Nu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Du=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function get(dict, k) {
  if ((k in dict
    )) {
    return Caml_option.some(dict[k]);
  }
  
}

const unsafeDeleteKey = (function (dict,key){
      delete dict[key];
     }
);

function entries(dict) {
  const keys = Object.keys(dict);
  const l = keys.length;
  const values = new Array(l);
  for (let i = 0; i < l; ++i) {
    const key = keys[i];
    values[i] = [
      key,
      dict[key]
    ];
  }
  return values;
}

function values(dict) {
  const keys = Object.keys(dict);
  const l = keys.length;
  const values$1 = new Array(l);
  for (let i = 0; i < l; ++i) {
    values$1[i] = dict[keys[i]];
  }
  return values$1;
}

function fromList(entries) {
  const dict = {};
  let _param = entries;
  while (true) {
    const param = _param;
    if (!param) {
      return dict;
    }
    const match = param.hd;
    dict[match[0]] = match[1];
    _param = param.tl;
    continue;
  };
}

function fromArray(entries) {
  const dict = {};
  const l = entries.length;
  for (let i = 0; i < l; ++i) {
    const match = entries[i];
    dict[match[0]] = match[1];
  }
  return dict;
}

function map(f, source) {
  const target = {};
  const keys = Object.keys(source);
  const l = keys.length;
  for (let i = 0; i < l; ++i) {
    const key = keys[i];
    target[key] = f(source[key]);
  }
  return target;
}

export {
  get,
  unsafeDeleteKey,
  entries,
  values,
  fromList,
  fromArray,
  map,
}
/* No side effect */
`,Ou=`// Generated by Melange

import * as Caml_js_exceptions from "./caml_js_exceptions.js";

const anyToExnInternal = Caml_js_exceptions.internalToOCamlException;

function raiseError(str) {
  throw new Caml_js_exceptions.MelangeError(new Error(str).MEL_EXN_ID, new Error(str));
}

function raiseEvalError(str) {
  throw new Caml_js_exceptions.MelangeError(new EvalError(str).MEL_EXN_ID, new EvalError(str));
}

function raiseRangeError(str) {
  throw new Caml_js_exceptions.MelangeError(new RangeError(str).MEL_EXN_ID, new RangeError(str));
}

function raiseReferenceError(str) {
  throw new Caml_js_exceptions.MelangeError(new ReferenceError(str).MEL_EXN_ID, new ReferenceError(str));
}

function raiseSyntaxError(str) {
  throw new Caml_js_exceptions.MelangeError(new SyntaxError(str).MEL_EXN_ID, new SyntaxError(str));
}

function raiseTypeError(str) {
  throw new Caml_js_exceptions.MelangeError(new TypeError(str).MEL_EXN_ID, new TypeError(str));
}

function raiseUriError(str) {
  throw new Caml_js_exceptions.MelangeError(new URIError(str).MEL_EXN_ID, new URIError(str));
}

const $$Error$1 = Caml_js_exceptions.$$Error;

export {
  $$Error$1 as $$Error,
  anyToExnInternal,
  raiseError,
  raiseEvalError,
  raiseRangeError,
  raiseReferenceError,
  raiseSyntaxError,
  raiseTypeError,
  raiseUriError,
}
/* Caml_js_exceptions Not a pure module */
`,zu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Gu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Fu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Pu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Uu=`// Generated by Melange


function equal(x, y) {
  return x === y;
}

const max = 2147483647;

const min = -2147483648;

export {
  equal,
  max,
  min,
}
/* No side effect */
`,Ru=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Vu=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function classify(x) {
  const ty = typeof x;
  if (ty === "string") {
    return {
      TAG: /* JSONString */ 0,
      _0: x
    };
  } else if (ty === "number") {
    return {
      TAG: /* JSONNumber */ 1,
      _0: x
    };
  } else if (ty === "boolean") {
    if (x === true) {
      return /* JSONTrue */ 1;
    } else {
      return /* JSONFalse */ 0;
    }
  } else if (x === null) {
    return /* JSONNull */ 2;
  } else if (Array.isArray(x)) {
    return {
      TAG: /* JSONArray */ 3,
      _0: x
    };
  } else {
    return {
      TAG: /* JSONObject */ 2,
      _0: x
    };
  }
}

function test(x, v) {
  switch (v) {
    case /* String */ 0 :
      return typeof x === "string";
    case /* Number */ 1 :
      return typeof x === "number";
    case /* Object */ 2 :
      if (x !== null && typeof x === "object") {
        return !Array.isArray(x);
      } else {
        return false;
      }
    case /* Array */ 3 :
      return Array.isArray(x);
    case /* Boolean */ 4 :
      return typeof x === "boolean";
    case /* Null */ 5 :
      return x === null;
  }
}

function decodeString(json) {
  if (typeof json === "string") {
    return json;
  }
  
}

function decodeNumber(json) {
  if (typeof json === "number") {
    return json;
  }
  
}

function decodeObject(json) {
  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
    return Caml_option.some(json);
  }
  
}

function decodeArray(json) {
  if (Array.isArray(json)) {
    return json;
  }
  
}

function decodeBoolean(json) {
  if (typeof json === "boolean") {
    return json;
  }
  
}

function decodeNull(json) {
  if (json === null) {
    return null;
  }
  
}

const patch = (function (json) {
  var x = [json];
  var q = [{ kind: 0, i: 0, parent: x }];
  while (q.length !== 0) {
    // begin pop the stack
    var cur = q[q.length - 1];
    if (cur.kind === 0) {
      cur.val = cur.parent[cur.i]; // patch the undefined value for array
      if (++cur.i === cur.parent.length) {
        q.pop();
      }
    } else {
      q.pop();
    }
    // finish
    var task = cur.val;
    if (typeof task === "object") {
      if (Array.isArray(task) && task.length !== 0) {
        q.push({ kind: 0, i: 0, parent: task, val: undefined });
      } else {
        for (var k in task) {
          if (k === "RE_PRIVATE_NONE") {
            if (cur.kind === 0) {
              cur.parent[cur.i - 1] = undefined;
            } else {
              cur.parent[cur.i] = undefined;
            }
            continue;
          }
          q.push({ kind: 1, i: k, parent: task, val: task[k] });
        }
      }
    }
  }
  return x[0];
}
);

function serializeExn(x) {
  return (function(obj){
      var output= JSON.stringify(obj,function(_,value){
        if(value===undefined){
          return {RE_PRIVATE_NONE : true}
          }
        return value
        });

 if(output === undefined){
   // JSON.stringify will raise TypeError when it detects cylic objects
   throw new TypeError("output is undefined")
      }
 return output
 }
  )(x);
}

function deserializeUnsafe(s) {
  return patch(JSON.parse(s));
}

export {
  classify,
  test,
  decodeString,
  decodeNumber,
  decodeObject,
  decodeArray,
  decodeBoolean,
  decodeNull,
  deserializeUnsafe,
  serializeExn,
}
/* No side effect */
`,qu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Xu=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function raiseWhenNotFound(x) {
  if (x == null) {
    throw new Caml_js_exceptions.MelangeError("Not_found", {
          MEL_EXN_ID: "Not_found"
        });
  }
  return x;
}

function fromInt(len, xs, $$enum) {
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === len) {
      return;
    }
    const k = xs[i];
    if (k === $$enum) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function fromIntAssert(len, xs, $$enum) {
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === len) {
      throw new Caml_js_exceptions.MelangeError("Not_found", {
            MEL_EXN_ID: "Not_found"
          });
    }
    const k = xs[i];
    if (k === $$enum) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

export {
  raiseWhenNotFound,
  fromInt,
  fromIntAssert,
}
/* No side effect */
`,Wu=`// Generated by Melange


function ceil_int(f) {
  if (f > 2147483647) {
    return 2147483647;
  } else if (f < -2147483648) {
    return -2147483648;
  } else {
    return Math.ceil(f);
  }
}

function floor_int(f) {
  if (f > 2147483647) {
    return 2147483647;
  } else if (f < -2147483648) {
    return -2147483648;
  } else {
    return Math.floor(f);
  }
}

function random_int(min, max) {
  return floor_int(Math.random() * (max - min | 0)) + min | 0;
}

export {
  ceil_int,
  floor_int,
  random_int,
}
/* No side effect */
`,Ku=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";

function getExn(f) {
  if (f !== null) {
    return f;
  }
  throw new Caml_js_exceptions.MelangeError(new Error("Js.Null.getExn").MEL_EXN_ID, new Error("Js.Null.getExn"));
}

function map(f, x) {
  if (x !== null) {
    return f(x);
  } else {
    return null;
  }
}

function bind(f, x) {
  if (x !== null) {
    return f(x);
  } else {
    return null;
  }
}

function iter(f, x) {
  if (x !== null) {
    return f(x);
  }
  
}

function fromOption(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return null;
  }
}

export {
  getExn,
  bind,
  map,
  iter,
  fromOption,
}
/* No side effect */
`,Hu=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function map(f, x) {
  if (x == null) {
    return x;
  } else {
    return f(x);
  }
}

function bind(f, x) {
  if (x == null) {
    return x;
  } else {
    return f(x);
  }
}

function iter(f, x) {
  if (!(x == null)) {
    return f(x);
  }
  
}

function fromOption(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  
}

export {
  map,
  bind,
  iter,
  fromOption,
}
/* No side effect */
`,Yu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Ju=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Zu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Qu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,nf=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,tf=`// Generated by Melange


const $$ArrayBuffer = {};

const $$Int8Array = {};

const $$Uint8Array = {};

const $$Uint8ClampedArray = {};

const $$Int16Array = {};

const $$Uint16Array = {};

const $$Int32Array = {};

const $$Uint32Array = {};

const $$Float32Array = {};

const $$Float64Array = {};

const $$DataView = {};

export {
  $$ArrayBuffer,
  $$Int8Array,
  $$Uint8Array,
  $$Uint8ClampedArray,
  $$Int16Array,
  $$Uint16Array,
  $$Int32Array,
  $$Uint32Array,
  $$Float32Array,
  $$Float64Array,
  $$DataView,
}
/* No side effect */
`,ef=`// Generated by Melange


function classify(x) {
  const ty = typeof x;
  if (ty === "undefined") {
    return /* JSUndefined */ 3;
  } else if (x === null) {
    return /* JSNull */ 2;
  } else if (ty === "number") {
    return {
      TAG: /* JSNumber */ 0,
      _0: x
    };
  } else if (ty === "bigint") {
    return {
      TAG: /* JSBigInt */ 5,
      _0: x
    };
  } else if (ty === "string") {
    return {
      TAG: /* JSString */ 1,
      _0: x
    };
  } else if (ty === "boolean") {
    if (x === true) {
      return /* JSTrue */ 1;
    } else {
      return /* JSFalse */ 0;
    }
  } else if (ty === "symbol") {
    return {
      TAG: /* JSSymbol */ 4,
      _0: x
    };
  } else if (ty === "function") {
    return {
      TAG: /* JSFunction */ 2,
      _0: x
    };
  } else {
    return {
      TAG: /* JSObject */ 3,
      _0: x
    };
  }
}

function test(x, v) {
  switch (v) {
    case /* Undefined */ 0 :
      return typeof x === "undefined";
    case /* Null */ 1 :
      return x === null;
    case /* Boolean */ 2 :
      return typeof x === "boolean";
    case /* Number */ 3 :
      return typeof x === "number";
    case /* String */ 4 :
      return typeof x === "string";
    case /* Function */ 5 :
      return typeof x === "function";
    case /* Object */ 6 :
      return typeof x === "object";
    case /* Symbol */ 7 :
      return typeof x === "symbol";
    case /* BigInt */ 8 :
      return typeof x === "bigint";
  }
}

export {
  test,
  classify,
}
/* No side effect */
`,rf=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";

function testAny(x) {
  return x === undefined;
}

function getExn(f) {
  if (f !== undefined) {
    return f;
  }
  throw new Caml_js_exceptions.MelangeError(new Error("Js.Undefined.getExn").MEL_EXN_ID, new Error("Js.Undefined.getExn"));
}

function map(f, x) {
  if (x !== undefined) {
    return f(x);
  }
  
}

function bind(f, x) {
  if (x !== undefined) {
    return f(x);
  }
  
}

function iter(f, x) {
  if (x !== undefined) {
    return f(x);
  }
  
}

function fromOption(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  
}

export {
  testAny,
  getExn,
  map,
  bind,
  iter,
  fromOption,
}
/* No side effect */
`,af=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,sf=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,of=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Caml_sys from "melange.js/caml_sys.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__String from "./string.js";

const Bad = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Arg.Bad");

const Help = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Arg.Help");

const Stop = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Arg.Stop");

function assoc3(x, _l) {
  while (true) {
    const l = _l;
    if (l) {
      const match = l.hd;
      if (Caml_obj.caml_equal(match[0], x)) {
        return match[1];
      }
      _l = l.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function split(s) {
  const i = Stdlib__String.index(s, /* '=' */61);
  const len = s.length;
  return [
    Stdlib__String.sub(s, 0, i),
    Stdlib__String.sub(s, i + 1 | 0, len - (i + 1 | 0) | 0)
  ];
}

function make_symlist(prefix, sep, suffix, l) {
  if (l) {
    return Stdlib__List.fold_left((function (x, y) {
      return x + (sep + y);
    }), prefix + l.hd, l.tl) + suffix;
  } else {
    return "<none>";
  }
}

function help_action(param) {
  throw new Caml_js_exceptions.MelangeError(Stop, {
        MEL_EXN_ID: Stop,
        _1: {
          TAG: /* Unknown */ 0,
          _0: "-help"
        }
      });
}

function add_help(speclist) {
  let add1;
  try {
    assoc3("-help", speclist);
    add1 = /* [] */ 0;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      add1 = {
        hd: [
          "-help",
          {
            TAG: /* Unit */ 0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */ 0
      };
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  let add2;
  try {
    assoc3("--help", speclist);
    add2 = /* [] */ 0;
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
      add2 = {
        hd: [
          "--help",
          {
            TAG: /* Unit */ 0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */ 0
      };
    } else {
      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
    }
  }
  return Stdlib.$at(speclist, Stdlib.$at(add1, add2));
}

function usage_b(buf, speclist, errmsg) {
  Curry._1(Stdlib__Printf.bprintf(buf, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* Char_literal */ 12,
        _0: /* '\\n' */10,
        _1: /* End_of_format */ 0
      }
    },
    _1: "%s\\n"
  }), errmsg);
  Stdlib__List.iter((function (param) {
    const doc = param[2];
    if (doc.length === 0) {
      return;
    }
    const spec = param[1];
    const key = param[0];
    if (spec.TAG === /* Symbol */ 11) {
      return Curry._3(Stdlib__Printf.bprintf(buf, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "  ",
          _1: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* Char_literal */ 12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* Char_literal */ 12,
                    _0: /* '\\n' */10,
                    _1: /* End_of_format */ 0
                  }
                }
              }
            }
          }
        },
        _1: "  %s %s%s\\n"
      }), key, make_symlist("{", "|", "}", spec._0), doc);
    } else {
      return Curry._2(Stdlib__Printf.bprintf(buf, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "  ",
          _1: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* Char_literal */ 12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* Char_literal */ 12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */ 0
                }
              }
            }
          }
        },
        _1: "  %s %s\\n"
      }), key, doc);
    }
  }), add_help(speclist));
}

function usage_string(speclist, errmsg) {
  const b = Stdlib__Buffer.create(200);
  usage_b(b, speclist, errmsg);
  return Stdlib__Buffer.contents(b);
}

function usage(speclist, errmsg) {
  Curry._1(Stdlib__Printf.eprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: /* End_of_format */ 0
    },
    _1: "%s"
  }), usage_string(speclist, errmsg));
}

const current = {
  contents: 0
};

function bool_of_string_opt(x) {
  try {
    return Stdlib.bool_of_string(x);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Invalid_argument) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function int_of_string_opt(x) {
  try {
    return Caml_format.caml_int_of_string(x);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function float_of_string_opt(x) {
  try {
    return Caml_format.caml_float_of_string(x);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function parse_and_expand_argv_dynamic_aux(allow_expand, current, argv, speclist, anonfun, errmsg) {
  const initpos = current.contents;
  const convert_error = function (error) {
    const b = Stdlib__Buffer.create(200);
    const progname = initpos < argv.contents.length ? Caml_array.get(argv.contents, initpos) : "(?)";
    switch (error.TAG) {
      case /* Unknown */ 0 :
        const s = error._0;
        switch (s) {
          case "--help" :
          case "-help" :
            break;
          default:
            Curry._2(Stdlib__Printf.bprintf(b, {
              TAG: /* Format */ 0,
              _0: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: ": unknown option '",
                  _1: {
                    TAG: /* String */ 2,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* String_literal */ 11,
                      _0: "'.\\n",
                      _1: /* End_of_format */ 0
                    }
                  }
                }
              },
              _1: "%s: unknown option '%s'.\\n"
            }), progname, s);
        }
        break;
      case /* Wrong */ 1 :
        Curry._4(Stdlib__Printf.bprintf(b, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": wrong argument '",
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: "'; option '",
                  _1: {
                    TAG: /* String */ 2,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* String_literal */ 11,
                      _0: "' expects ",
                      _1: {
                        TAG: /* String */ 2,
                        _0: /* No_padding */ 0,
                        _1: {
                          TAG: /* String_literal */ 11,
                          _0: ".\\n",
                          _1: /* End_of_format */ 0
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          _1: "%s: wrong argument '%s'; option '%s' expects %s.\\n"
        }), progname, error._1, error._0, error._2);
        break;
      case /* Missing */ 2 :
        Curry._2(Stdlib__Printf.bprintf(b, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": option '",
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: "' needs an argument.\\n",
                  _1: /* End_of_format */ 0
                }
              }
            }
          },
          _1: "%s: option '%s' needs an argument.\\n"
        }), progname, error._0);
        break;
      case /* Message */ 3 :
        Curry._2(Stdlib__Printf.bprintf(b, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": ",
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: ".\\n",
                  _1: /* End_of_format */ 0
                }
              }
            }
          },
          _1: "%s: %s.\\n"
        }), progname, error._0);
        break;
    }
    usage_b(b, speclist.contents, errmsg);
    if (Caml_obj.caml_equal(error, {
        TAG: /* Unknown */ 0,
        _0: "-help"
      }) || Caml_obj.caml_equal(error, {
        TAG: /* Unknown */ 0,
        _0: "--help"
      })) {
      return {
        MEL_EXN_ID: Help,
        _1: Stdlib__Buffer.contents(b)
      };
    } else {
      return {
        MEL_EXN_ID: Bad,
        _1: Stdlib__Buffer.contents(b)
      };
    }
  };
  current.contents = current.contents + 1 | 0;
  while (current.contents < argv.contents.length) {
    try {
      const s = Caml_array.get(argv.contents, current.contents);
      if (Stdlib__String.starts_with("-", s)) {
        let match;
        try {
          match = [
            assoc3(s, speclist.contents),
            undefined
          ];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            try {
              const match$1 = split(s);
              match = [
                assoc3(match$1[0], speclist.contents),
                match$1[1]
              ];
            }
            catch (raw_exn$1){
              const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Unknown */ 0,
                        _0: s
                      }
                    });
              }
              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
            }
          } else {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
        const follow = match[1];
        const no_arg = function (param) {
          if (follow === undefined) {
            return;
          }
          throw new Caml_js_exceptions.MelangeError(Stop, {
                MEL_EXN_ID: Stop,
                _1: {
                  TAG: /* Wrong */ 1,
                  _0: s,
                  _1: follow,
                  _2: "no argument"
                }
              });
        };
        const get_arg = function (param) {
          if (follow !== undefined) {
            return follow;
          }
          if ((current.contents + 1 | 0) < argv.contents.length) {
            return Caml_array.get(argv.contents, current.contents + 1 | 0);
          }
          throw new Caml_js_exceptions.MelangeError(Stop, {
                MEL_EXN_ID: Stop,
                _1: {
                  TAG: /* Missing */ 2,
                  _0: s
                }
              });
        };
        const consume_arg = function (param) {
          if (follow !== undefined) {
            return;
          } else {
            current.contents = current.contents + 1 | 0;
            return;
          }
        };
        const treat_action = function (f) {
          switch (f.TAG) {
            case /* Unit */ 0 :
              no_arg(undefined);
              return Curry._1(f._0, undefined);
            case /* Bool */ 1 :
              const arg = get_arg(undefined);
              const s$1 = bool_of_string_opt(arg);
              if (s$1 !== undefined) {
                Curry._1(f._0, s$1);
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Wrong */ 1,
                        _0: s,
                        _1: arg,
                        _2: "a boolean"
                      }
                    });
              }
              return consume_arg(undefined);
            case /* Set */ 2 :
              no_arg(undefined);
              f._0.contents = true;
              return;
            case /* Clear */ 3 :
              no_arg(undefined);
              f._0.contents = false;
              return;
            case /* String */ 4 :
              const arg$1 = get_arg(undefined);
              Curry._1(f._0, arg$1);
              return consume_arg(undefined);
            case /* Set_string */ 5 :
              f._0.contents = get_arg(undefined);
              return consume_arg(undefined);
            case /* Int */ 6 :
              const arg$2 = get_arg(undefined);
              const x = int_of_string_opt(arg$2);
              if (x !== undefined) {
                Curry._1(f._0, x);
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Wrong */ 1,
                        _0: s,
                        _1: arg$2,
                        _2: "an integer"
                      }
                    });
              }
              return consume_arg(undefined);
            case /* Set_int */ 7 :
              const arg$3 = get_arg(undefined);
              const x$1 = int_of_string_opt(arg$3);
              if (x$1 !== undefined) {
                f._0.contents = x$1;
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Wrong */ 1,
                        _0: s,
                        _1: arg$3,
                        _2: "an integer"
                      }
                    });
              }
              return consume_arg(undefined);
            case /* Float */ 8 :
              const arg$4 = get_arg(undefined);
              const x$2 = float_of_string_opt(arg$4);
              if (x$2 !== undefined) {
                Curry._1(f._0, x$2);
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Wrong */ 1,
                        _0: s,
                        _1: arg$4,
                        _2: "a float"
                      }
                    });
              }
              return consume_arg(undefined);
            case /* Set_float */ 9 :
              const arg$5 = get_arg(undefined);
              const x$3 = float_of_string_opt(arg$5);
              if (x$3 !== undefined) {
                f._0.contents = x$3;
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Wrong */ 1,
                        _0: s,
                        _1: arg$5,
                        _2: "a float"
                      }
                    });
              }
              return consume_arg(undefined);
            case /* Tuple */ 10 :
              no_arg(undefined);
              return Stdlib__List.iter(treat_action, f._0);
            case /* Symbol */ 11 :
              const symb = f._0;
              const arg$6 = get_arg(undefined);
              if (Stdlib__List.mem(arg$6, symb)) {
                Curry._1(f._1, arg$6);
                return consume_arg(undefined);
              }
              throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Wrong */ 1,
                      _0: s,
                      _1: arg$6,
                      _2: "one of: " + make_symlist("", " ", "", symb)
                    }
                  });
            case /* Rest */ 12 :
              const f$1 = f._0;
              no_arg(undefined);
              while (current.contents < (argv.contents.length - 1 | 0)) {
                Curry._1(f$1, Caml_array.get(argv.contents, current.contents + 1 | 0));
                consume_arg(undefined);
              };
              return;
            case /* Rest_all */ 13 :
              no_arg(undefined);
              let acc = /* [] */ 0;
              while (current.contents < (argv.contents.length - 1 | 0)) {
                acc = {
                  hd: Caml_array.get(argv.contents, current.contents + 1 | 0),
                  tl: acc
                };
                consume_arg(undefined);
              };
              return Curry._1(f._0, Stdlib__List.rev(acc));
            case /* Expand */ 14 :
              if (!allow_expand) {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
                      MEL_EXN_ID: Stdlib.Invalid_argument,
                      _1: "Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"
                    });
              }
              const arg$7 = get_arg(undefined);
              const newarg = Curry._1(f._0, arg$7);
              consume_arg(undefined);
              const before = Stdlib__Array.sub(argv.contents, 0, current.contents + 1 | 0);
              const after = Stdlib__Array.sub(argv.contents, current.contents + 1 | 0, (argv.contents.length - current.contents | 0) - 1 | 0);
              argv.contents = Caml_array.concat({
                hd: before,
                tl: {
                  hd: newarg,
                  tl: {
                    hd: after,
                    tl: /* [] */ 0
                  }
                }
              });
              return;
          }
        };
        treat_action(match[0]);
      } else {
        Curry._1(anonfun, s);
      }
    }
    catch (raw_m){
      const m = Caml_js_exceptions.internalToOCamlException(raw_m);
      if (m.MEL_EXN_ID === Bad) {
        throw new Caml_js_exceptions.MelangeError(convert_error({
              TAG: /* Message */ 3,
              _0: m._1
            }).MEL_EXN_ID, convert_error({
              TAG: /* Message */ 3,
              _0: m._1
            }));
      }
      if (m.MEL_EXN_ID === Stop) {
        throw new Caml_js_exceptions.MelangeError(convert_error(m._1).MEL_EXN_ID, convert_error(m._1));
      }
      throw new Caml_js_exceptions.MelangeError(m.MEL_EXN_ID, m);
    }
    current.contents = current.contents + 1 | 0;
  };
}

function parse_and_expand_argv_dynamic(current, argv, speclist, anonfun, errmsg) {
  parse_and_expand_argv_dynamic_aux(true, current, argv, speclist, anonfun, errmsg);
}

function parse_argv_dynamic(currentOpt, argv, speclist, anonfun, errmsg) {
  const current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_and_expand_argv_dynamic_aux(false, current$1, {
    contents: argv
  }, speclist, anonfun, errmsg);
}

function parse_argv(currentOpt, argv, speclist, anonfun, errmsg) {
  const current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_argv_dynamic(current$1, argv, {
    contents: speclist
  }, anonfun, errmsg);
}

function parse(l, f, msg) {
  try {
    return parse_argv(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw new Caml_js_exceptions.MelangeError(msg$1.MEL_EXN_ID, msg$1);
  }
}

function parse_dynamic(l, f, msg) {
  try {
    return parse_argv_dynamic(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw new Caml_js_exceptions.MelangeError(msg$1.MEL_EXN_ID, msg$1);
  }
}

function parse_expand(l, f, msg) {
  try {
    const argv = {
      contents: Caml_sys.caml_sys_argv(0)
    };
    const spec = {
      contents: l
    };
    const current$1 = {
      contents: current.contents
    };
    return parse_and_expand_argv_dynamic(current$1, argv, spec, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw new Caml_js_exceptions.MelangeError(msg$1.MEL_EXN_ID, msg$1);
  }
}

function second_word(s) {
  const len = s.length;
  const loop = function (_n) {
    while (true) {
      const n = _n;
      if (n >= len) {
        return len;
      }
      if (Caml_string.get(s, n) !== /* ' ' */32) {
        return n;
      }
      _n = n + 1 | 0;
      continue;
    };
  };
  let n;
  try {
    n = Stdlib__String.index(s, /* '\\t' */9);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      let exit = 0;
      let n$1;
      try {
        n$1 = Stdlib__String.index(s, /* ' ' */32);
        exit = 2;
      }
      catch (raw_exn$1){
        const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
          return len;
        }
        throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
      }
      if (exit === 2) {
        return loop(n$1 + 1 | 0);
      }
      
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  return loop(n + 1 | 0);
}

function max_arg_len(cur, param) {
  const kwd = param[0];
  if (param[1].TAG === /* Symbol */ 11) {
    return Stdlib__Int.max(cur, kwd.length);
  } else {
    return Stdlib__Int.max(cur, kwd.length + second_word(param[2]) | 0);
  }
}

function replace_leading_tab(s) {
  const seen = {
    contents: false
  };
  return Stdlib__String.map((function (c) {
    if (c !== 9 || seen.contents) {
      return c;
    } else {
      seen.contents = true;
      return /* ' ' */32;
    }
  }), s);
}

function align(limitOpt, speclist) {
  const limit = limitOpt !== undefined ? limitOpt : Stdlib.max_int;
  const completed = add_help(speclist);
  const len = Stdlib__List.fold_left(max_arg_len, 0, completed);
  const len$1 = Stdlib__Int.min(len, limit);
  return Stdlib__List.map((function (param) {
    const kwd = param[0];
    const spec = param[1];
    if (param[2] === "") {
      return param;
    }
    if (spec.TAG === /* Symbol */ 11) {
      const msg = param[2];
      const cutcol = second_word(msg);
      const n = Stdlib__Int.max(0, len$1 - cutcol | 0) + 3 | 0;
      const spaces = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, /* ' ' */32));
      return [
        kwd,
        spec,
        "\\n" + (spaces + replace_leading_tab(msg))
      ];
    }
    const msg$1 = param[2];
    const spec$1 = param[1];
    const cutcol$1 = second_word(msg$1);
    const kwd_len = kwd.length;
    const diff = (len$1 - kwd_len | 0) - cutcol$1 | 0;
    if (diff <= 0) {
      return [
        kwd,
        spec$1,
        replace_leading_tab(msg$1)
      ];
    }
    const spaces$1 = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(diff, /* ' ' */32));
    const prefix = Stdlib__String.sub(replace_leading_tab(msg$1), 0, cutcol$1);
    const suffix = Stdlib__String.sub(msg$1, cutcol$1, msg$1.length - cutcol$1 | 0);
    return [
      kwd,
      spec$1,
      prefix + (spaces$1 + suffix)
    ];
  }), completed);
}

function trim_cr(s) {
  const len = s.length;
  if (len > 0 && Caml_string.get(s, len - 1 | 0) === /* '\\r' */13) {
    return Stdlib__String.sub(s, 0, len - 1 | 0);
  } else {
    return s;
  }
}

function read_aux(trim, sep, file) {
  const ic = Stdlib.open_in_bin(file);
  const buf = Stdlib__Buffer.create(200);
  const words = {
    contents: /* [] */ 0
  };
  const stash = function (param) {
    const word = Stdlib__Buffer.contents(buf);
    const word$1 = trim ? trim_cr(word) : word;
    words.contents = {
      hd: word$1,
      tl: words.contents
    };
    buf.position = 0;
  };
  try {
    while (true) {
      const c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
      if (c === sep) {
        stash(undefined);
      } else {
        Stdlib__Buffer.add_char(buf, c);
      }
    };
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID !== Stdlib.End_of_file) {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    
  }
  if (buf.position > 0) {
    stash(undefined);
  }
  Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  return Stdlib__Array.of_list(Stdlib__List.rev(words.contents));
}

function read_arg(param) {
  return read_aux(true, /* '\\n' */10, param);
}

function read_arg0(param) {
  return read_aux(false, /* '\\000' */0, param);
}

function write_aux(sep, file, args) {
  const oc = Stdlib.open_out_bin(file);
  Stdlib__Array.iter((function (s) {
    Curry._2(Stdlib__Printf.fprintf(oc, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* Char */ 0,
          _0: /* End_of_format */ 0
        }
      },
      _1: "%s%c"
    }), s, sep);
  }), args);
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function write_arg(param, param$1) {
  return write_aux(/* '\\n' */10, param, param$1);
}

function write_arg0(param, param$1) {
  return write_aux(/* '\\000' */0, param, param$1);
}

export {
  parse,
  parse_dynamic,
  parse_argv,
  parse_argv_dynamic,
  parse_and_expand_argv_dynamic,
  parse_expand,
  Help,
  Bad,
  usage,
  usage_string,
  align,
  current,
  read_arg,
  read_arg0,
  write_arg,
  write_arg0,
}
/* No side effect */
`,lf=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__String from "./string.js";

const Floatarray = {};

function init(l, f) {
  if (l === 0) {
    return [];
  }
  if (l < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.init"
        });
  }
  const res = Caml_array.make(l, Curry._1(f, 0));
  for (let i = 1; i < l; ++i) {
    res[i] = Curry._1(f, i);
  }
  return res;
}

function make_matrix(sx, sy, init) {
  if (sy < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.make_matrix"
        });
  }
  const res = Caml_array.make(sx, []);
  if (sy > 0) {
    for (let x = 0; x < sx; ++x) {
      res[x] = Caml_array.make(sy, init);
    }
  }
  return res;
}

function init_matrix(sx, sy, f) {
  if (sy < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.init_matrix"
        });
  }
  const res = Caml_array.make(sx, []);
  if (sy > 0) {
    for (let x = 0; x < sx; ++x) {
      const row = Caml_array.make(sy, Curry._2(f, x, 0));
      for (let y = 1; y < sy; ++y) {
        row[y] = Curry._2(f, x, y);
      }
      res[x] = row;
    }
  }
  return res;
}

function copy(a) {
  const l = a.length;
  if (l === 0) {
    return [];
  } else {
    return Caml_array.sub(a, 0, l);
  }
}

function append(a1, a2) {
  const l1 = a1.length;
  if (l1 === 0) {
    return copy(a2);
  } else if (a2.length === 0) {
    return Caml_array.sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}

function sub(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.sub"
        });
  }
  return Caml_array.sub(a, ofs, len);
}

function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.fill"
        });
  }
  for (let i = ofs, i_finish = ofs + len | 0; i < i_finish; ++i) {
    a[i] = v;
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.blit"
        });
  }
  Caml_array.blit(a1, ofs1, a2, ofs2, len);
}

function iter(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._1(f, a[i]);
  }
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.iter2: arrays must have the same length"
        });
  }
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._2(f, a[i], b[i]);
  }
}

function map(f, a) {
  const l = a.length;
  if (l === 0) {
    return [];
  }
  const r = Caml_array.make(l, Curry._1(f, a[0]));
  for (let i = 1; i < l; ++i) {
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_inplace(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    a[i] = Curry._1(f, a[i]);
  }
}

function mapi_inplace(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    a[i] = Curry._2(f, i, a[i]);
  }
}

function map2(f, a, b) {
  const la = a.length;
  const lb = b.length;
  if (la !== lb) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.map2: arrays must have the same length"
        });
  }
  if (la === 0) {
    return [];
  }
  const r = Caml_array.make(la, Curry._2(f, a[0], b[0]));
  for (let i = 1; i < la; ++i) {
    r[i] = Curry._2(f, a[i], b[i]);
  }
  return r;
}

function iteri(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._2(f, i, a[i]);
  }
}

function mapi(f, a) {
  const l = a.length;
  if (l === 0) {
    return [];
  }
  const r = Caml_array.make(l, Curry._2(f, 0, a[0]));
  for (let i = 1; i < l; ++i) {
    r[i] = Curry._2(f, i, a[i]);
  }
  return r;
}

function to_list(a) {
  let _i = a.length - 1 | 0;
  let _res = /* [] */ 0;
  while (true) {
    const res = _res;
    const i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue;
  };
}

function list_length(_accu, _param) {
  while (true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = accu + 1 | 0;
    continue;
  };
}

function of_list(l) {
  if (!l) {
    return [];
  }
  const a = Caml_array.make(list_length(0, l), l.hd);
  let _i = 1;
  let _param = l.tl;
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return a;
    }
    a[i] = param.hd;
    _param = param.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function fold_left(f, x, a) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_left_map(f, acc, input_array) {
  const len = input_array.length;
  if (len === 0) {
    return [
      acc,
      []
    ];
  }
  const match = Curry._2(f, acc, input_array[0]);
  const output_array = Caml_array.make(len, match[1]);
  let acc$1 = match[0];
  for (let i = 1; i < len; ++i) {
    const match$1 = Curry._2(f, acc$1, input_array[i]);
    acc$1 = match$1[0];
    output_array[i] = match$1[1];
  }
  return [
    acc$1,
    output_array
  ];
}

function fold_right(f, a, x) {
  let r = x;
  for (let i = a.length - 1 | 0; i >= 0; --i) {
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function for_all(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function for_all2(p, l1, l2) {
  const n1 = l1.length;
  const n2 = l2.length;
  if (n1 !== n2) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.for_all2"
        });
  }
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n1) {
      return true;
    }
    if (!Curry._2(p, l1[i], l2[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function exists2(p, l1, l2) {
  const n1 = l1.length;
  const n2 = l2.length;
  if (n1 !== n2) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.exists2"
        });
  }
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n1) {
      return false;
    }
    if (Curry._2(p, l1[i], l2[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function mem(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Caml_obj.caml_equal(a[i], x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function memq(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_opt(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const x = a[i];
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_index(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    if (Curry._1(p, a[i])) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_map(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = Curry._1(f, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_mapi(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = Curry._2(f, i, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function split(x) {
  if (Caml_obj.caml_equal(x, [])) {
    return [
      [],
      []
    ];
  }
  const match = x[0];
  const n = x.length;
  const a = Caml_array.make(n, match[0]);
  const b = Caml_array.make(n, match[1]);
  for (let i = 1; i < n; ++i) {
    const match$1 = x[i];
    a[i] = match$1[0];
    b[i] = match$1[1];
  }
  return [
    a,
    b
  ];
}

function combine(a, b) {
  const na = a.length;
  const nb = b.length;
  if (na !== nb) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.combine"
        });
  }
  if (na === 0) {
    return [];
  }
  const x = Caml_array.make(na, [
    a[0],
    b[0]
  ]);
  for (let i = 1; i < na; ++i) {
    x[i] = [
      a[i],
      b[i]
    ];
  }
  return x;
}

const Bottom = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Array.Bottom");

function sort(cmp, a) {
  const maxson = function (l, i) {
    const i31 = ((i + i | 0) + i | 0) + 1 | 0;
    let x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.get(a, x), Caml_array.get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw new Caml_js_exceptions.MelangeError(Bottom, {
          MEL_EXN_ID: Bottom,
          _1: i
        });
  };
  const trickle = function (l, i, e) {
    try {
      let _i = i;
      while (true) {
        const i$1 = _i;
        const j = maxson(l, i$1);
        if (Curry._2(cmp, Caml_array.get(a, j), e) <= 0) {
          return Caml_array.set(a, i$1, e);
        }
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue;
      };
    }
    catch (raw_i){
      const i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.MEL_EXN_ID === Bottom) {
        return Caml_array.set(a, i$2._1, e);
      }
      throw new Caml_js_exceptions.MelangeError(i$2.MEL_EXN_ID, i$2);
    }
  };
  const bubble = function (l, i) {
    try {
      let _i = i;
      while (true) {
        const i$1 = _i;
        const j = maxson(l, i$1);
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue;
      };
    }
    catch (raw_i){
      const i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.MEL_EXN_ID === Bottom) {
        return i$2._1;
      }
      throw new Caml_js_exceptions.MelangeError(i$2.MEL_EXN_ID, i$2);
    }
  };
  const trickleup = function (_i, e) {
    while (true) {
      const i = _i;
      const father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "array.cppo.ml",
                378,
                4
              ]
            });
      }
      if (Curry._2(cmp, Caml_array.get(a, father), e) >= 0) {
        return Caml_array.set(a, i, e);
      }
      Caml_array.set(a, i, Caml_array.get(a, father));
      if (father <= 0) {
        return Caml_array.set(a, 0, e);
      }
      _i = father;
      continue;
    };
  };
  const l = a.length;
  for (let i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i) {
    trickle(l, i, Caml_array.get(a, i));
  }
  for (let i$1 = l - 1 | 0; i$1 >= 2; --i$1) {
    const e = Caml_array.get(a, i$1);
    Caml_array.set(a, i$1, Caml_array.get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return;
  }
  const e$1 = Caml_array.get(a, 1);
  Caml_array.set(a, 1, Caml_array.get(a, 0));
  Caml_array.set(a, 0, e$1);
}

function stable_sort(cmp, a) {
  const merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    const src1r = src1ofs + src1len | 0;
    const src2r = src2ofs + src2len | 0;
    let _i1 = src1ofs;
    let _s1 = Caml_array.get(a, src1ofs);
    let _i2 = src2ofs;
    let _s2 = Caml_array.get(src2, src2ofs);
    let _d = dstofs;
    while (true) {
      const d = _d;
      const s2 = _s2;
      const i2 = _i2;
      const s1 = _s1;
      const i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.set(dst, d, s1);
        const i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Caml_array.get(a, i1$1);
        _i1 = i1$1;
        continue;
      }
      Caml_array.set(dst, d, s2);
      const i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Caml_array.get(src2, i2$1);
      _i2 = i2$1;
      continue;
    };
  };
  const isortto = function (srcofs, dst, dstofs, len) {
    for (let i = 0; i < len; ++i) {
      const e = Caml_array.get(a, srcofs + i | 0);
      let j = (dstofs + i | 0) - 1 | 0;
      while (j >= dstofs && Curry._2(cmp, Caml_array.get(dst, j), e) > 0) {
        Caml_array.set(dst, j + 1 | 0, Caml_array.get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.set(dst, j + 1 | 0, e);
    }
  };
  const sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    const l1 = len / 2 | 0;
    const l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  const l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  const l1 = l / 2 | 0;
  const l2 = l - l1 | 0;
  const t = Caml_array.make(l2, Caml_array.get(a, 0));
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  merge(l2, l1, t, 0, l2, a, 0);
}

function shuffle_contract_violation(i, j) {
  const s = Stdlib__String.concat("", {
    hd: "Array.shuffle: 'rand ",
    tl: {
      hd: String(i + 1 | 0),
      tl: {
        hd: "' returned ",
        tl: {
          hd: String(j),
          tl: {
            hd: ", out of expected range [0; ",
            tl: {
              hd: String(i),
              tl: {
                hd: "]",
                tl: /* [] */ 0
              }
            }
          }
        }
      }
    }
  });
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: s
      });
}

function shuffle(rand, a) {
  for (let i = a.length - 1 | 0; i >= 1; --i) {
    const j = Curry._1(rand, i + 1 | 0);
    if (!(0 <= j && j <= i)) {
      shuffle_contract_violation(i, j);
    }
    const v = a[i];
    a[i] = a[j];
    a[j] = v;
  }
}

function to_seq(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: [
        i,
        x
      ],
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq(i) {
  let l = Stdlib__Seq.fold_left((function (acc, x) {
    return {
      hd: x,
      tl: acc
    };
  }), /* [] */ 0, i);
  if (!l) {
    return [];
  }
  const len = list_length(0, l);
  const a = Caml_array.make(len, l.hd);
  let _i = len - 2 | 0;
  let _param = l.tl;
  while (true) {
    const param = _param;
    const i$1 = _i;
    if (!param) {
      return a;
    }
    a[i$1] = param.hd;
    _param = param.tl;
    _i = i$1 - 1 | 0;
    continue;
  };
}

const concat = Caml_array.concat;

const fast_sort = stable_sort;

export {
  init,
  make_matrix,
  init_matrix,
  append,
  concat,
  sub,
  copy,
  fill,
  blit,
  to_list,
  of_list,
  iter,
  iteri,
  map,
  map_inplace,
  mapi,
  mapi_inplace,
  fold_left,
  fold_left_map,
  fold_right,
  iter2,
  map2,
  for_all,
  exists,
  for_all2,
  exists2,
  mem,
  memq,
  find_opt,
  find_index,
  find_map,
  find_mapi,
  split,
  combine,
  sort,
  stable_sort,
  fast_sort,
  shuffle,
  to_seq,
  to_seqi,
  of_seq,
  Floatarray,
}
/* No side effect */
`,cf=`// Generated by Melange

import * as Stdlib__Array from "./array.js";

const init = Stdlib__Array.init;

const make_matrix = Stdlib__Array.make_matrix;

const init_matrix = Stdlib__Array.init_matrix;

const append = Stdlib__Array.append;

const concat = Stdlib__Array.concat;

const sub = Stdlib__Array.sub;

const copy = Stdlib__Array.copy;

const fill = Stdlib__Array.fill;

const blit = Stdlib__Array.blit;

const to_list = Stdlib__Array.to_list;

const of_list = Stdlib__Array.of_list;

const iter = Stdlib__Array.iter;

const iteri = Stdlib__Array.iteri;

const map = Stdlib__Array.map;

const map_inplace = Stdlib__Array.map_inplace;

const mapi = Stdlib__Array.mapi;

const mapi_inplace = Stdlib__Array.mapi_inplace;

const fold_left = Stdlib__Array.fold_left;

const fold_left_map = Stdlib__Array.fold_left_map;

const fold_right = Stdlib__Array.fold_right;

const iter2 = Stdlib__Array.iter2;

const map2 = Stdlib__Array.map2;

const for_all = Stdlib__Array.for_all;

const exists = Stdlib__Array.exists;

const for_all2 = Stdlib__Array.for_all2;

const exists2 = Stdlib__Array.exists2;

const mem = Stdlib__Array.mem;

const memq = Stdlib__Array.memq;

const find_opt = Stdlib__Array.find_opt;

const find_index = Stdlib__Array.find_index;

const find_map = Stdlib__Array.find_map;

const find_mapi = Stdlib__Array.find_mapi;

const split = Stdlib__Array.split;

const combine = Stdlib__Array.combine;

const sort = Stdlib__Array.sort;

const stable_sort = Stdlib__Array.stable_sort;

const fast_sort = Stdlib__Array.fast_sort;

const shuffle = Stdlib__Array.shuffle;

const to_seq = Stdlib__Array.to_seq;

const to_seqi = Stdlib__Array.to_seqi;

const of_seq = Stdlib__Array.of_seq;

const Floatarray = Stdlib__Array.Floatarray;

export {
  init,
  make_matrix,
  init_matrix,
  append,
  concat,
  sub,
  copy,
  fill,
  blit,
  to_list,
  of_list,
  iter,
  iteri,
  map,
  map_inplace,
  mapi,
  mapi_inplace,
  fold_left,
  fold_left_map,
  fold_right,
  iter2,
  map2,
  for_all,
  exists,
  for_all2,
  exists2,
  mem,
  memq,
  find_opt,
  find_index,
  find_map,
  find_mapi,
  split,
  combine,
  sort,
  stable_sort,
  fast_sort,
  shuffle,
  to_seq,
  to_seqi,
  of_seq,
  Floatarray,
}
/* No side effect */
`,_f=`// Generated by Melange

import * as CamlinternalAtomic from "./camlinternalAtomic.js";

const make = CamlinternalAtomic.make;

const get = CamlinternalAtomic.get;

const set = CamlinternalAtomic.set;

const exchange = CamlinternalAtomic.exchange;

const compare_and_set = CamlinternalAtomic.compare_and_set;

const fetch_and_add = CamlinternalAtomic.fetch_and_add;

const incr = CamlinternalAtomic.incr;

const decr = CamlinternalAtomic.decr;

export {
  make,
  get,
  set,
  exchange,
  compare_and_set,
  fetch_and_add,
  incr,
  decr,
}
/* No side effect */
`,uf=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_hash from "melange.js/caml_hash.js";

function equal(prim0, prim1) {
  return prim0 === prim1;
}

const compare = Caml.caml_int_compare;

function to_int(param) {
  if (param) {
    return 1;
  } else {
    return 0;
  }
}

function to_float(param) {
  if (param) {
    return 1;
  } else {
    return 0;
  }
}

function to_string(param) {
  if (param) {
    return "true";
  } else {
    return "false";
  }
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function not(prim) {
  return !prim;
}

export {
  not,
  equal,
  compare,
  to_int,
  to_float,
  to_string,
  seeded_hash,
  hash,
}
/* No side effect */
`,ff=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__String from "./string.js";
import * as Stdlib__Sys from "./sys.js";

function create(n) {
  const n$1 = n < 1 ? 1 : n;
  const n$2 = n$1 > Stdlib__Sys.max_string_length ? Stdlib__Sys.max_string_length : n$1;
  const s = Caml_bytes.caml_create_bytes(n$2);
  return {
    inner: {
      buffer: s,
      length: n$2
    },
    position: 0,
    initial_buffer: s
  };
}

function contents(b) {
  return Stdlib__Bytes.sub_string(b.inner.buffer, 0, b.position);
}

function to_bytes(b) {
  return Stdlib__Bytes.sub(b.inner.buffer, 0, b.position);
}

function sub(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.position - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.sub"
        });
  }
  return Stdlib__Bytes.sub_string(b.inner.buffer, ofs, len);
}

function blit(src, srcoff, dst, dstoff, len) {
  if (len < 0 || srcoff < 0 || srcoff > (src.position - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.blit"
        });
  }
  Stdlib__Bytes.blit(src.inner.buffer, srcoff, dst, dstoff, len);
}

function nth(b, ofs) {
  const position = b.position;
  const match = b.inner;
  if (ofs < 0 || ofs >= position || position > match.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.nth"
        });
  }
  return match.buffer[ofs];
}

function length(b) {
  return b.position;
}

function clear(b) {
  b.position = 0;
}

function reset(b) {
  b.position = 0;
  const inner_buffer = b.initial_buffer;
  const inner_length = b.initial_buffer.length;
  const inner = {
    buffer: inner_buffer,
    length: inner_length
  };
  b.inner = inner;
}

function resize(b, more) {
  const old_pos = b.position;
  const old_len = b.inner.length;
  let new_len = old_len;
  while ((old_pos + more | 0) > new_len) {
    new_len = (new_len << 1);
  };
  if (new_len > Stdlib__Sys.max_string_length) {
    if ((old_pos + more | 0) <= Stdlib__Sys.max_string_length) {
      new_len = Stdlib__Sys.max_string_length;
    } else {
      throw new Caml_js_exceptions.MelangeError("Failure", {
            MEL_EXN_ID: "Failure",
            _1: "Buffer.add: cannot grow buffer"
          });
    }
  }
  const new_buffer = Caml_bytes.caml_create_bytes(new_len);
  Stdlib__Bytes.blit(b.inner.buffer, 0, new_buffer, 0, b.position);
  b.inner = {
    buffer: new_buffer,
    length: new_len
  };
}

function add_char(b, c) {
  const pos = b.position;
  const match = b.inner;
  if (pos >= match.length) {
    resize(b, 1);
    Caml_bytes.set(b.inner.buffer, b.position, c);
  } else {
    match.buffer[pos] = c;
  }
  b.position = pos + 1 | 0;
}

function add_utf_8_uchar(b, u) {
  while (true) {
    const pos = b.position;
    if (pos >= b.inner.length) {
      resize(b, 4);
    }
    const n = Stdlib__Bytes.set_utf_8_uchar(b.inner.buffer, pos, u);
    if (n !== 0) {
      b.position = pos + n | 0;
      return;
    }
    resize(b, 4);
    continue;
  };
}

function add_utf_16be_uchar(b, u) {
  while (true) {
    const pos = b.position;
    if (pos >= b.inner.length) {
      resize(b, 4);
    }
    const n = Stdlib__Bytes.set_utf_16be_uchar(b.inner.buffer, pos, u);
    if (n !== 0) {
      b.position = pos + n | 0;
      return;
    }
    resize(b, 4);
    continue;
  };
}

function add_utf_16le_uchar(b, u) {
  while (true) {
    const pos = b.position;
    if (pos >= b.inner.length) {
      resize(b, 4);
    }
    const n = Stdlib__Bytes.set_utf_16le_uchar(b.inner.buffer, pos, u);
    if (n !== 0) {
      b.position = pos + n | 0;
      return;
    }
    resize(b, 4);
    continue;
  };
}

function add_substring(b, s, offset, len) {
  if (offset < 0 || len < 0 || offset > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.add_substring"
        });
  }
  const position = b.position;
  const match = b.inner;
  const new_position = position + len | 0;
  if (new_position > match.length) {
    resize(b, len);
    Stdlib__Bytes.blit_string(s, offset, b.inner.buffer, b.position, len);
  } else {
    Caml_bytes.caml_blit_string(s, offset, match.buffer, position, len);
  }
  b.position = new_position;
}

function add_subbytes(b, bytes, offset, len) {
  if (offset < 0 || len < 0 || offset > (bytes.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.add_subbytes"
        });
  }
  const position = b.position;
  const match = b.inner;
  const new_position = position + len | 0;
  if (new_position > match.length) {
    resize(b, len);
    Stdlib__Bytes.blit(bytes, offset, b.inner.buffer, b.position, len);
  } else {
    Caml_bytes.caml_blit_bytes(bytes, offset, match.buffer, position, len);
  }
  b.position = new_position;
}

function add_string(b, s) {
  add_substring(b, s, 0, s.length);
}

function add_bytes(b, bytes) {
  add_subbytes(b, bytes, 0, bytes.length);
}

function add_buffer(b, bs) {
  add_subbytes(b, bs.inner.buffer, 0, bs.position);
}

function really_input_up_to(ic, buf, ofs, len) {
  let _already_read = 0;
  let _ofs = ofs;
  let _to_read = len;
  while (true) {
    const to_read = _to_read;
    const ofs$1 = _ofs;
    const already_read = _already_read;
    if (to_read === 0) {
      return already_read;
    }
    const r = Stdlib.input(ic, buf, ofs$1, to_read);
    if (r === 0) {
      return already_read;
    }
    const already_read$1 = already_read + r | 0;
    const ofs$2 = ofs$1 + r | 0;
    const to_read$1 = to_read - r | 0;
    _to_read = to_read$1;
    _ofs = ofs$2;
    _already_read = already_read$1;
    continue;
  };
}

function unsafe_add_channel_up_to(b, ic, len) {
  if ((b.position + len | 0) > b.inner.length) {
    resize(b, len);
  }
  const n = really_input_up_to(ic, b.inner.buffer, b.position, len);
  b.position = b.position + n | 0;
  return n;
}

function add_channel(b, ic, len) {
  if (len < 0 || len > Stdlib__Sys.max_string_length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.add_channel"
        });
  }
  const n = unsafe_add_channel_up_to(b, ic, len);
  if (n < len) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
          MEL_EXN_ID: Stdlib.End_of_file
        });
  }
  
}

function output_buffer(oc, b) {
  Stdlib.output(oc, b.inner.buffer, 0, b.position);
}

function closing(param) {
  if (param === 40) {
    return /* ')' */41;
  }
  if (param === 123) {
    return /* '}' */125;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/buffer.ml",
          222,
          9
        ]
      });
}

function advance_to_closing(opening, closing, k, s, start) {
  let _k = k;
  let _i = start;
  let lim = s.length;
  while (true) {
    const i = _i;
    const k$1 = _k;
    if (i >= lim) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    if (Caml_string.get(s, i) === opening) {
      _i = i + 1 | 0;
      _k = k$1 + 1 | 0;
      continue;
    }
    if (Caml_string.get(s, i) === closing) {
      if (k$1 === 0) {
        return i;
      }
      _i = i + 1 | 0;
      _k = k$1 - 1 | 0;
      continue;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function advance_to_non_alpha(s, start) {
  let _i = start;
  let lim = s.length;
  while (true) {
    const i = _i;
    if (i >= lim) {
      return lim;
    }
    const match = Caml_string.get(s, i);
    if (match >= 91) {
      if (match >= 97) {
        if (match >= 123) {
          return i;
        }
        
      } else if (match !== 95) {
        return i;
      }
      
    } else if (match >= 58) {
      if (match < 65) {
        return i;
      }
      
    } else if (match < 48) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_ident(s, start, lim) {
  if (start >= lim) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  const c = Caml_string.get(s, start);
  if (c !== 40 && c !== 123) {
    const stop = advance_to_non_alpha(s, start);
    if (stop === start) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    return [
      Stdlib__String.sub(s, start, stop - start | 0),
      stop
    ];
  }
  const new_start = start + 1 | 0;
  const stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);
  return [
    Stdlib__String.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),
    stop$1 + 1 | 0
  ];
}

function add_substitute(b, f, s) {
  const lim = s.length;
  let _previous = /* ' ' */32;
  let _i = 0;
  while (true) {
    const i = _i;
    const previous = _previous;
    if (i >= lim) {
      if (previous === /* '\\\\' */92) {
        return add_char(b, previous);
      } else {
        return;
      }
    }
    const current = Caml_string.get(s, i);
    if (current !== 36) {
      if (previous === /* '\\\\' */92) {
        add_char(b, previous);
      }
      if (current !== /* '\\\\' */92) {
        add_char(b, current);
      }
      _i = i + 1 | 0;
      _previous = current;
      continue;
    }
    if (previous === /* '\\\\' */92) {
      add_char(b, current);
      _i = i + 1 | 0;
      _previous = /* ' ' */32;
      continue;
    }
    const j = i + 1 | 0;
    let val;
    try {
      val = find_ident(s, j, lim);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        add_char(b, /* '$' */36);
        _i = j;
        _previous = /* ' ' */32;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    add_string(b, Curry._1(f, val[0]));
    _i = val[1];
    _previous = /* ' ' */32;
    continue;
  };
}

function truncate(b, len) {
  if (len < 0 || len > b.position) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.truncate"
        });
  }
  b.position = len;
}

function to_seq(b) {
  const aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */ 0;
    }
    const x = Caml_bytes.get(b.inner.buffer, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(b) {
  const aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */ 0;
    }
    const x = Caml_bytes.get(b.inner.buffer, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: [
        i,
        x
      ],
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function add_seq(b, seq) {
  Stdlib__Seq.iter((function (param) {
    return add_char(b, param);
  }), seq);
}

function of_seq(i) {
  const b = create(32);
  Stdlib__Seq.iter((function (param) {
    return add_char(b, param);
  }), i);
  return b;
}

function add_int8(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 1 | 0;
  if (new_position > match.length) {
    resize(b, 1);
    Caml_bytes.set(b.inner.buffer, b.position, x);
  } else {
    match.buffer[position] = x;
  }
  b.position = new_position;
}

function add_int16_ne(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 2 | 0;
  if (new_position > match.length) {
    resize(b, 2);
    Caml_bytes.set16(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set16u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int32_ne(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 4 | 0;
  if (new_position > match.length) {
    resize(b, 4);
    Caml_bytes.set32(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set32u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int64_ne(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 8 | 0;
  if (new_position > match.length) {
    resize(b, 8);
    Caml_bytes.set64(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set64u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int16_le(b, x) {
  add_int16_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap16(x) : x);
}

function add_int16_be(b, x) {
  add_int16_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap16(x));
}

function add_int32_le(b, x) {
  add_int32_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap32(x) : x);
}

function add_int32_be(b, x) {
  add_int32_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap32(x));
}

function add_int64_le(b, x) {
  add_int64_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap64(x) : x);
}

function add_int64_be(b, x) {
  add_int64_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap64(x));
}

const add_uint8 = add_int8;

const add_uint16_ne = add_int16_ne;

const add_uint16_be = add_int16_be;

const add_uint16_le = add_int16_le;

export {
  create,
  contents,
  to_bytes,
  sub,
  blit,
  nth,
  length,
  clear,
  reset,
  output_buffer,
  truncate,
  add_char,
  add_utf_8_uchar,
  add_utf_16le_uchar,
  add_utf_16be_uchar,
  add_string,
  add_bytes,
  add_substring,
  add_subbytes,
  add_substitute,
  add_buffer,
  add_channel,
  to_seq,
  to_seqi,
  add_seq,
  of_seq,
  add_uint8,
  add_int8,
  add_uint16_ne,
  add_uint16_be,
  add_uint16_le,
  add_int16_ne,
  add_int16_be,
  add_int16_le,
  add_int32_ne,
  add_int32_be,
  add_int32_le,
  add_int64_ne,
  add_int64_be,
  add_int64_le,
}
/* No side effect */
`,mf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Char from "./char.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Sys from "./sys.js";

function make(n, c) {
  const s = Caml_bytes.caml_create_bytes(n);
  Caml_bytes.caml_fill_bytes(s, 0, n, c);
  return s;
}

function init(n, f) {
  const s = Caml_bytes.caml_create_bytes(n);
  for (let i = 0; i < n; ++i) {
    s[i] = Curry._1(f, i);
  }
  return s;
}

const empty = [];

function copy(s) {
  const len = s.length;
  const r = Caml_bytes.caml_create_bytes(len);
  Caml_bytes.caml_blit_bytes(s, 0, r, 0, len);
  return r;
}

function to_string(b) {
  return Caml_bytes.bytes_to_string(copy(b));
}

function of_string(s) {
  return copy(Caml_bytes.bytes_of_string(s));
}

function sub(s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.sub / Bytes.sub"
        });
  }
  const r = Caml_bytes.caml_create_bytes(len);
  Caml_bytes.caml_blit_bytes(s, ofs, r, 0, len);
  return r;
}

function sub_string(b, ofs, len) {
  return Caml_bytes.bytes_to_string(sub(b, ofs, len));
}

function $plus$plus(a, b) {
  const c = a + b | 0;
  const match = a < 0;
  const match$1 = b < 0;
  const match$2 = c < 0;
  if (match) {
    if (!match$1) {
      return c;
    }
    if (match$2) {
      return c;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Bytes.extend"
        });
  }
  if (match$1) {
    return c;
  }
  if (match$2) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Bytes.extend"
        });
  }
  return c;
}

function extend(s, left, right) {
  const len = $plus$plus($plus$plus(s.length, left), right);
  const r = Caml_bytes.caml_create_bytes(len);
  const match = left < 0 ? [
      -left | 0,
      0
    ] : [
      0,
      left
    ];
  const dstoff = match[1];
  const srcoff = match[0];
  const cpylen = Stdlib__Int.min(s.length - srcoff | 0, len - dstoff | 0);
  if (cpylen > 0) {
    Caml_bytes.caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
  }
  return r;
}

function fill(s, ofs, len, c) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.fill / Bytes.fill"
        });
  }
  Caml_bytes.caml_fill_bytes(s, ofs, len, c);
}

function blit(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Bytes.blit"
        });
  }
  Caml_bytes.caml_blit_bytes(s1, ofs1, s2, ofs2, len);
}

function blit_string(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.blit / Bytes.blit_string"
        });
  }
  Caml_bytes.caml_blit_string(s1, ofs1, s2, ofs2, len);
}

function iter(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._1(f, a[i]);
  }
}

function iteri(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._2(f, i, a[i]);
  }
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Bytes.concat"
      });
}

function sum_lengths(_acc, seplen, _param) {
  while (true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return acc;
    }
    const hd = param.hd;
    if (!param.tl) {
      return hd.length + acc | 0;
    }
    _param = param.tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue;
  };
}

function concat(sep, l) {
  if (!l) {
    return empty;
  }
  const seplen = sep.length;
  let dst = Caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l));
  let _pos = 0;
  let _param = l;
  while (true) {
    const param = _param;
    const pos = _pos;
    if (!param) {
      return dst;
    }
    const hd = param.hd;
    if (param.tl) {
      Caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
      Caml_bytes.caml_blit_bytes(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = param.tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue;
    }
    Caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
    return dst;
  };
}

function cat(s1, s2) {
  const l1 = s1.length;
  const l2 = s2.length;
  const r = Caml_bytes.caml_create_bytes(l1 + l2 | 0);
  Caml_bytes.caml_blit_bytes(s1, 0, r, 0, l1);
  Caml_bytes.caml_blit_bytes(s2, 0, r, l1, l2);
  return r;
}

function is_space(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}

function trim(s) {
  const len = s.length;
  let i = 0;
  while (i < len && is_space(s[i])) {
    i = i + 1 | 0;
  };
  let j = len - 1 | 0;
  while (j >= i && is_space(s[j])) {
    j = j - 1 | 0;
  };
  if (j >= i) {
    return sub(s, i, (j - i | 0) + 1 | 0);
  } else {
    return empty;
  }
}

function unsafe_escape(s) {
  let n = 0;
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    const match = s[i];
    n = n + (
      match >= 32 ? (
          match > 92 || match < 34 ? (
              match >= 127 ? 4 : 1
            ) : (
              match > 91 || match < 35 ? 2 : 1
            )
        ) : (
          match >= 11 ? (
              match !== 13 ? 4 : 2
            ) : (
              match >= 8 ? 2 : 4
            )
        )
    ) | 0;
  }
  if (n === s.length) {
    return s;
  }
  const s$p = Caml_bytes.caml_create_bytes(n);
  n = 0;
  for (let i$1 = 0, i_finish$1 = s.length; i$1 < i_finish$1; ++i$1) {
    const c = s[i$1];
    let exit = 0;
    if (c >= 35) {
      if (c !== 92) {
        if (c >= 127) {
          exit = 1;
        } else {
          s$p[n] = c;
        }
      } else {
        exit = 2;
      }
    } else if (c >= 32) {
      if (c >= 34) {
        exit = 2;
      } else {
        s$p[n] = c;
      }
    } else if (c >= 14) {
      exit = 1;
    } else {
      switch (c) {
        case 8 :
          s$p[n] = /* '\\\\' */92;
          n = n + 1 | 0;
          s$p[n] = /* 'b' */98;
          break;
        case 9 :
          s$p[n] = /* '\\\\' */92;
          n = n + 1 | 0;
          s$p[n] = /* 't' */116;
          break;
        case 10 :
          s$p[n] = /* '\\\\' */92;
          n = n + 1 | 0;
          s$p[n] = /* 'n' */110;
          break;
        case 0 :
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 11 :
        case 12 :
          exit = 1;
          break;
        case 13 :
          s$p[n] = /* '\\\\' */92;
          n = n + 1 | 0;
          s$p[n] = /* 'r' */114;
          break;
      }
    }
    switch (exit) {
      case 1 :
        s$p[n] = /* '\\\\' */92;
        n = n + 1 | 0;
        s$p[n] = 48 + (c / 100 | 0) | 0;
        n = n + 1 | 0;
        s$p[n] = 48 + (c / 10 | 0) % 10 | 0;
        n = n + 1 | 0;
        s$p[n] = 48 + c % 10 | 0;
        break;
      case 2 :
        s$p[n] = /* '\\\\' */92;
        n = n + 1 | 0;
        s$p[n] = c;
        break;
    }
    n = n + 1 | 0;
  }
  return s$p;
}

function escaped(b) {
  return unsafe_escape(copy(b));
}

function map(f, s) {
  const l = s.length;
  if (l === 0) {
    return s;
  }
  const r = Caml_bytes.caml_create_bytes(l);
  for (let i = 0; i < l; ++i) {
    r[i] = Curry._1(f, s[i]);
  }
  return r;
}

function mapi(f, s) {
  const l = s.length;
  if (l === 0) {
    return s;
  }
  const r = Caml_bytes.caml_create_bytes(l);
  for (let i = 0; i < l; ++i) {
    r[i] = Curry._2(f, i, s[i]);
  }
  return r;
}

function fold_left(f, x, a) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  let r = x;
  for (let i = a.length - 1 | 0; i >= 0; --i) {
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, s) {
  const n = s.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, s[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function for_all(p, s) {
  const n = s.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, s[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function uppercase_ascii(s) {
  return map(Stdlib__Char.uppercase_ascii, s);
}

function lowercase_ascii(s) {
  return map(Stdlib__Char.lowercase_ascii, s);
}

function apply1(f, s) {
  if (s.length === 0) {
    return s;
  }
  const r = copy(s);
  r[0] = Curry._1(f, s[0]);
  return r;
}

function capitalize_ascii(s) {
  return apply1(Stdlib__Char.uppercase_ascii, s);
}

function uncapitalize_ascii(s) {
  return apply1(Stdlib__Char.lowercase_ascii, s);
}

function starts_with(prefix, s) {
  const len_s = s.length;
  const len_pre = prefix.length;
  if (len_s >= len_pre) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_pre) {
        return true;
      }
      if (s[i] !== prefix[i]) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function ends_with(suffix, s) {
  const len_s = s.length;
  const len_suf = suffix.length;
  const diff = len_s - len_suf | 0;
  if (diff >= 0) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_suf) {
        return true;
      }
      if (s[diff + i | 0] !== suffix[i]) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function index_rec(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    if (s[i] === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      return;
    }
    if (s[i] === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from / Bytes.index_from"
        });
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from_opt / Bytes.index_from_opt"
        });
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    if (s[i] === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  };
}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from / Bytes.rindex_from"
        });
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      return;
    }
    if (s[i] === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  };
}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from_opt / Bytes.rindex_from_opt"
        });
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.contains_from / Bytes.contains_from"
        });
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rcontains_from / Bytes.rcontains_from"
        });
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const compare = Caml_bytes.caml_bytes_compare;

function split_on_char(sep, s) {
  let r = /* [] */ 0;
  let j = s.length;
  for (let i = s.length - 1 | 0; i >= 0; --i) {
    if (s[i] === sep) {
      r = {
        hd: sub(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
    
  }
  return {
    hd: sub(s, 0, j),
    tl: r
  };
}

function to_seq(s) {
  const aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */ 0;
    }
    const x = Caml_bytes.get(s, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(s) {
  const aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */ 0;
    }
    const x = Caml_bytes.get(s, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: [
        i,
        x
      ],
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq(i) {
  const n = {
    contents: 0
  };
  const buf = {
    contents: make(256, /* '\\000' */0)
  };
  const resize = function (param) {
    const new_len = Stdlib__Int.min((buf.contents.length << 1), Stdlib__Sys.max_string_length);
    if (buf.contents.length === new_len) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
            MEL_EXN_ID: "Failure",
            _1: "Bytes.of_seq: cannot grow bytes"
          });
    }
    const new_buf = make(new_len, /* '\\000' */0);
    blit(buf.contents, 0, new_buf, 0, n.contents);
    buf.contents = new_buf;
  };
  Stdlib__Seq.iter((function (c) {
    if (n.contents === buf.contents.length) {
      resize(undefined);
    }
    Caml_bytes.set(buf.contents, n.contents, c);
    n.contents = n.contents + 1 | 0;
  }), i);
  return sub(buf.contents, 0, n.contents);
}

function unsafe_get_uint16_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap16(Caml_bytes.get16u(b, i));
  } else {
    return Caml_bytes.get16u(b, i);
  }
}

function unsafe_get_uint16_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get16u(b, i);
  } else {
    return Caml_bytes.bswap16(Caml_bytes.get16u(b, i));
  }
}

function get_int8(b, i) {
  return ((Caml_bytes.get(b, i) << (Stdlib__Sys.int_size - 8 | 0)) >> (Stdlib__Sys.int_size - 8 | 0));
}

function get_uint16_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap16(Caml_bytes.get16(b, i));
  } else {
    return Caml_bytes.get16(b, i);
  }
}

function get_uint16_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get16(b, i);
  } else {
    return Caml_bytes.bswap16(Caml_bytes.get16(b, i));
  }
}

function get_int16_ne(b, i) {
  return ((Caml_bytes.get16(b, i) << (Stdlib__Sys.int_size - 16 | 0)) >> (Stdlib__Sys.int_size - 16 | 0));
}

function get_int16_le(b, i) {
  return ((get_uint16_le(b, i) << (Stdlib__Sys.int_size - 16 | 0)) >> (Stdlib__Sys.int_size - 16 | 0));
}

function get_int16_be(b, i) {
  return ((get_uint16_be(b, i) << (Stdlib__Sys.int_size - 16 | 0)) >> (Stdlib__Sys.int_size - 16 | 0));
}

function get_int32_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap32(Caml_bytes.get32(b, i));
  } else {
    return Caml_bytes.get32(b, i);
  }
}

function get_int32_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get32(b, i);
  } else {
    return Caml_bytes.bswap32(Caml_bytes.get32(b, i));
  }
}

function get_int64_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap64(Caml_bytes.get64(b, i));
  } else {
    return Caml_bytes.get64(b, i);
  }
}

function get_int64_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get64(b, i);
  } else {
    return Caml_bytes.bswap64(Caml_bytes.get64(b, i));
  }
}

function unsafe_set_uint16_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16u(b, i, Caml_bytes.bswap16(x));
  } else {
    return Caml_bytes.set16u(b, i, x);
  }
}

function unsafe_set_uint16_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16u(b, i, x);
  } else {
    return Caml_bytes.set16u(b, i, Caml_bytes.bswap16(x));
  }
}

function set_int16_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16(b, i, Caml_bytes.bswap16(x));
  } else {
    return Caml_bytes.set16(b, i, x);
  }
}

function set_int16_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16(b, i, x);
  } else {
    return Caml_bytes.set16(b, i, Caml_bytes.bswap16(x));
  }
}

function set_int32_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set32(b, i, Caml_bytes.bswap32(x));
  } else {
    return Caml_bytes.set32(b, i, x);
  }
}

function set_int32_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set32(b, i, x);
  } else {
    return Caml_bytes.set32(b, i, Caml_bytes.bswap32(x));
  }
}

function set_int64_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set64(b, i, Caml_bytes.bswap64(x));
  } else {
    return Caml_bytes.set64(b, i, x);
  }
}

function set_int64_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set64(b, i, x);
  } else {
    return Caml_bytes.set64(b, i, Caml_bytes.bswap64(x));
  }
}

const set_uint8 = Caml_bytes.set;

const set_uint16_ne = Caml_bytes.set16;

function get_utf_8_uchar(b, i) {
  const b0 = Caml_bytes.get(b, i);
  const max = b.length - 1 | 0;
  let exit = 0;
  if (b0 >= 224) {
    if (b0 >= 237) {
      if (b0 >= 245) {
        return 16842749;
      }
      switch (b0) {
        case 237 :
          const i$1 = i + 1 | 0;
          if (i$1 > max) {
            return 16842749;
          }
          const b1 = b[i$1];
          if ((b1 >>> 5) !== 4) {
            return 16842749;
          }
          const i$2 = i$1 + 1 | 0;
          if (i$2 > max) {
            return 33619965;
          }
          const b2 = b[i$2];
          if ((b2 >>> 6) !== 2) {
            return 33619965;
          }
          const u = ((b0 & 15) << 12) | ((b1 & 63) << 6) | b2 & 63;
          return 184549376 | u;
        case 238 :
        case 239 :
          exit = 1;
          break;
        case 240 :
          const i$3 = i + 1 | 0;
          if (i$3 > max) {
            return 16842749;
          }
          const b1$1 = b[i$3];
          if (b1$1 < 144 || 191 < b1$1) {
            return 16842749;
          }
          const i$4 = i$3 + 1 | 0;
          if (i$4 > max) {
            return 33619965;
          }
          const b2$1 = b[i$4];
          if ((b2$1 >>> 6) !== 2) {
            return 33619965;
          }
          const i$5 = i$4 + 1 | 0;
          if (i$5 > max) {
            return 50397181;
          }
          const b3 = b[i$5];
          if ((b3 >>> 6) !== 2) {
            return 50397181;
          }
          const u$1 = ((b0 & 7) << 18) | ((b1$1 & 63) << 12) | ((b2$1 & 63) << 6) | b3 & 63;
          return 201326592 | u$1;
        case 241 :
        case 242 :
        case 243 :
          exit = 2;
          break;
        case 244 :
          const i$6 = i + 1 | 0;
          if (i$6 > max) {
            return 16842749;
          }
          const b1$2 = b[i$6];
          if ((b1$2 >>> 4) !== 8) {
            return 16842749;
          }
          const i$7 = i$6 + 1 | 0;
          if (i$7 > max) {
            return 33619965;
          }
          const b2$2 = b[i$7];
          if ((b2$2 >>> 6) !== 2) {
            return 33619965;
          }
          const i$8 = i$7 + 1 | 0;
          if (i$8 > max) {
            return 50397181;
          }
          const b3$1 = b[i$8];
          if ((b3$1 >>> 6) !== 2) {
            return 50397181;
          }
          const u$2 = ((b0 & 7) << 18) | ((b1$2 & 63) << 12) | ((b2$2 & 63) << 6) | b3$1 & 63;
          return 201326592 | u$2;
      }
    } else if (b0 >= 225) {
      exit = 1;
    } else {
      const i$9 = i + 1 | 0;
      if (i$9 > max) {
        return 16842749;
      }
      const b1$3 = b[i$9];
      if ((b1$3 >>> 5) !== 5) {
        return 16842749;
      }
      const i$10 = i$9 + 1 | 0;
      if (i$10 > max) {
        return 33619965;
      }
      const b2$3 = b[i$10];
      if ((b2$3 >>> 6) !== 2) {
        return 33619965;
      }
      const u$3 = ((b0 & 15) << 12) | ((b1$3 & 63) << 6) | b2$3 & 63;
      return 184549376 | u$3;
    }
  } else {
    if (b0 < 128) {
      return 150994944 | b0;
    }
    if (b0 < 194) {
      return 16842749;
    }
    const i$11 = i + 1 | 0;
    if (i$11 > max) {
      return 16842749;
    }
    const b1$4 = b[i$11];
    if ((b1$4 >>> 6) !== 2) {
      return 16842749;
    }
    const u$4 = ((b0 & 31) << 6) | b1$4 & 63;
    return 167772160 | u$4;
  }
  switch (exit) {
    case 1 :
      const i$12 = i + 1 | 0;
      if (i$12 > max) {
        return 16842749;
      }
      const b1$5 = b[i$12];
      if ((b1$5 >>> 6) !== 2) {
        return 16842749;
      }
      const i$13 = i$12 + 1 | 0;
      if (i$13 > max) {
        return 33619965;
      }
      const b2$4 = b[i$13];
      if ((b2$4 >>> 6) !== 2) {
        return 33619965;
      }
      const u$5 = ((b0 & 15) << 12) | ((b1$5 & 63) << 6) | b2$4 & 63;
      return 184549376 | u$5;
    case 2 :
      const i$14 = i + 1 | 0;
      if (i$14 > max) {
        return 16842749;
      }
      const b1$6 = b[i$14];
      if ((b1$6 >>> 6) !== 2) {
        return 16842749;
      }
      const i$15 = i$14 + 1 | 0;
      if (i$15 > max) {
        return 33619965;
      }
      const b2$5 = b[i$15];
      if ((b2$5 >>> 6) !== 2) {
        return 33619965;
      }
      const i$16 = i$15 + 1 | 0;
      if (i$16 > max) {
        return 50397181;
      }
      const b3$2 = b[i$16];
      if ((b3$2 >>> 6) !== 2) {
        return 50397181;
      }
      const u$6 = ((b0 & 7) << 18) | ((b1$6 & 63) << 12) | ((b2$5 & 63) << 6) | b3$2 & 63;
      return 201326592 | u$6;
  }
}

function set_utf_8_uchar(b, i, u) {
  const max = b.length - 1 | 0;
  const u$1 = u;
  if (u$1 < 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/bytes.ml",
            654,
            20
          ]
        });
  }
  if (u$1 <= 127) {
    Caml_bytes.set(b, i, u$1);
    return 1;
  }
  if (u$1 <= 2047) {
    const last = i + 1 | 0;
    if (last > max) {
      return 0;
    } else {
      Caml_bytes.set(b, i, 192 | (u$1 >>> 6));
      b[last] = 128 | u$1 & 63;
      return 2;
    }
  }
  if (u$1 <= 65535) {
    const last$1 = i + 2 | 0;
    if (last$1 > max) {
      return 0;
    } else {
      Caml_bytes.set(b, i, 224 | (u$1 >>> 12));
      b[i + 1 | 0] = 128 | (u$1 >>> 6) & 63;
      b[last$1] = 128 | u$1 & 63;
      return 3;
    }
  }
  if (u$1 <= 1114111) {
    const last$2 = i + 3 | 0;
    if (last$2 > max) {
      return 0;
    } else {
      Caml_bytes.set(b, i, 240 | (u$1 >>> 18));
      b[i + 1 | 0] = 128 | (u$1 >>> 12) & 63;
      b[i + 2 | 0] = 128 | (u$1 >>> 6) & 63;
      b[last$2] = 128 | u$1 & 63;
      return 4;
    }
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/bytes.ml",
          679,
          9
        ]
      });
}

function is_valid_utf_8(b) {
  let max = b.length - 1 | 0;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i > max) {
      return true;
    }
    const match = b[i];
    let exit = 0;
    if (match >= 224) {
      if (match >= 237) {
        if (match >= 245) {
          return false;
        }
        switch (match) {
          case 237 :
            const last = i + 2 | 0;
            if (last > max || (b[i + 1 | 0] >>> 5) !== 4 || (b[last] >>> 6) !== 2) {
              return false;
            }
            _i = last + 1 | 0;
            continue;
          case 238 :
          case 239 :
            exit = 1;
            break;
          case 240 :
            const last$1 = i + 3 | 0;
            let tmp = true;
            if (last$1 <= max) {
              const b$1 = b[i + 1 | 0];
              tmp = b$1 < 144 || 191 < b$1 || (b[i + 2 | 0] >>> 6) !== 2 || (b[last$1] >>> 6) !== 2;
            }
            if (tmp) {
              return false;
            }
            _i = last$1 + 1 | 0;
            continue;
          case 241 :
          case 242 :
          case 243 :
            exit = 2;
            break;
          case 244 :
            const last$2 = i + 3 | 0;
            if (last$2 > max || (b[i + 1 | 0] >>> 4) !== 8 || (b[i + 2 | 0] >>> 6) !== 2 || (b[last$2] >>> 6) !== 2) {
              return false;
            }
            _i = last$2 + 1 | 0;
            continue;
        }
      } else if (match >= 225) {
        exit = 1;
      } else {
        const last$3 = i + 2 | 0;
        if (last$3 > max || (b[i + 1 | 0] >>> 5) !== 5 || (b[last$3] >>> 6) !== 2) {
          return false;
        }
        _i = last$3 + 1 | 0;
        continue;
      }
    } else {
      if (match >= 128) {
        if (match < 194) {
          return false;
        }
        const last$4 = i + 1 | 0;
        if (last$4 > max || (b[last$4] >>> 6) !== 2) {
          return false;
        }
        _i = last$4 + 1 | 0;
        continue;
      }
      _i = i + 1 | 0;
      continue;
    }
    switch (exit) {
      case 1 :
        const last$5 = i + 2 | 0;
        if (last$5 > max || (b[i + 1 | 0] >>> 6) !== 2 || (b[last$5] >>> 6) !== 2) {
          return false;
        }
        _i = last$5 + 1 | 0;
        continue;
      case 2 :
        const last$6 = i + 3 | 0;
        if (last$6 > max || (b[i + 1 | 0] >>> 6) !== 2 || (b[i + 2 | 0] >>> 6) !== 2 || (b[last$6] >>> 6) !== 2) {
          return false;
        }
        _i = last$6 + 1 | 0;
        continue;
    }
  };
}

function get_utf_16be_uchar(b, i) {
  const max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  if (i === max) {
    return 16842749;
  }
  const u = unsafe_get_uint16_be(b, i);
  if (u < 55296 || u > 57343) {
    return 167772160 | u;
  }
  if (u > 56319) {
    return 33619965;
  }
  const last = i + 3 | 0;
  if (last > max) {
    return (((max - i | 0) + 1 | 0) << 24) | 65533;
  }
  const u$1 = unsafe_get_uint16_be(b, i + 2 | 0);
  if (u$1 < 56320 || u$1 > 57343) {
    return 33619965;
  }
  const u$2 = (((u & 1023) << 10) | u$1 & 1023) + 65536 | 0;
  return 201326592 | u$2;
}

function set_utf_16be_uchar(b, i, u) {
  const max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  const u$1 = u;
  if (u$1 < 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/bytes.ml",
            766,
            20
          ]
        });
  }
  if (u$1 <= 65535) {
    const last = i + 1 | 0;
    if (last > max) {
      return 0;
    } else {
      unsafe_set_uint16_be(b, i, u$1);
      return 2;
    }
  }
  if (u$1 <= 1114111) {
    const last$1 = i + 3 | 0;
    if (last$1 > max) {
      return 0;
    }
    const u$p = u$1 - 65536 | 0;
    const hi = 55296 | (u$p >>> 10);
    const lo = 56320 | u$p & 1023;
    unsafe_set_uint16_be(b, i, hi);
    unsafe_set_uint16_be(b, i + 2 | 0, lo);
    return 4;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/bytes.ml",
          777,
          9
        ]
      });
}

function is_valid_utf_16be(b) {
  let max = b.length - 1 | 0;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i > max) {
      return true;
    }
    if (i === max) {
      return false;
    }
    const u = unsafe_get_uint16_be(b, i);
    if (u < 55296 || u > 57343) {
      _i = i + 2 | 0;
      continue;
    }
    if (u > 56319) {
      return false;
    }
    const last = i + 3 | 0;
    if (last > max) {
      return false;
    }
    const u$1 = unsafe_get_uint16_be(b, i + 2 | 0);
    if (u$1 < 56320 || u$1 > 57343) {
      return false;
    }
    _i = i + 4 | 0;
    continue;
  };
}

function get_utf_16le_uchar(b, i) {
  const max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  if (i === max) {
    return 16842749;
  }
  const u = unsafe_get_uint16_le(b, i);
  if (u < 55296 || u > 57343) {
    return 167772160 | u;
  }
  if (u > 56319) {
    return 33619965;
  }
  const last = i + 3 | 0;
  if (last > max) {
    return (((max - i | 0) + 1 | 0) << 24) | 65533;
  }
  const u$1 = unsafe_get_uint16_le(b, i + 2 | 0);
  if (u$1 < 56320 || u$1 > 57343) {
    return 33619965;
  }
  const u$2 = (((u & 1023) << 10) | u$1 & 1023) + 65536 | 0;
  return 201326592 | u$2;
}

function set_utf_16le_uchar(b, i, u) {
  const max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds"
        });
  }
  const u$1 = u;
  if (u$1 < 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/bytes.ml",
            820,
            20
          ]
        });
  }
  if (u$1 <= 65535) {
    const last = i + 1 | 0;
    if (last > max) {
      return 0;
    } else {
      unsafe_set_uint16_le(b, i, u$1);
      return 2;
    }
  }
  if (u$1 <= 1114111) {
    const last$1 = i + 3 | 0;
    if (last$1 > max) {
      return 0;
    }
    const u$p = u$1 - 65536 | 0;
    const hi = 55296 | (u$p >>> 10);
    const lo = 56320 | u$p & 1023;
    unsafe_set_uint16_le(b, i, hi);
    unsafe_set_uint16_le(b, i + 2 | 0, lo);
    return 4;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/bytes.ml",
          831,
          9
        ]
      });
}

function is_valid_utf_16le(b) {
  let max = b.length - 1 | 0;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i > max) {
      return true;
    }
    if (i === max) {
      return false;
    }
    const u = unsafe_get_uint16_le(b, i);
    if (u < 55296 || u > 57343) {
      _i = i + 2 | 0;
      continue;
    }
    if (u > 56319) {
      return false;
    }
    const last = i + 3 | 0;
    if (last > max) {
      return false;
    }
    const u$1 = unsafe_get_uint16_le(b, i + 2 | 0);
    if (u$1 < 56320 || u$1 > 57343) {
      return false;
    }
    _i = i + 4 | 0;
    continue;
  };
}

const equal = Caml_bytes.caml_bytes_equal;

const unsafe_to_string = Caml_bytes.bytes_to_string;

const unsafe_of_string = Caml_bytes.bytes_of_string;

const get_uint8 = Caml_bytes.get;

const get_uint16_ne = Caml_bytes.get16;

const get_int32_ne = Caml_bytes.get32;

const get_int64_ne = Caml_bytes.get64;

const set_int8 = Caml_bytes.set;

const set_uint16_be = set_int16_be;

const set_uint16_le = set_int16_le;

const set_int16_ne = Caml_bytes.set16;

const set_int32_ne = Caml_bytes.set32;

const set_int64_ne = Caml_bytes.set64;

export {
  make,
  init,
  empty,
  copy,
  of_string,
  to_string,
  sub,
  sub_string,
  extend,
  fill,
  blit,
  blit_string,
  concat,
  cat,
  iter,
  iteri,
  map,
  mapi,
  fold_left,
  fold_right,
  for_all,
  exists,
  trim,
  escaped,
  index,
  index_opt,
  rindex,
  rindex_opt,
  index_from,
  index_from_opt,
  rindex_from,
  rindex_from_opt,
  contains,
  contains_from,
  rcontains_from,
  uppercase_ascii,
  lowercase_ascii,
  capitalize_ascii,
  uncapitalize_ascii,
  compare,
  equal,
  starts_with,
  ends_with,
  unsafe_to_string,
  unsafe_of_string,
  split_on_char,
  to_seq,
  to_seqi,
  of_seq,
  get_utf_8_uchar,
  set_utf_8_uchar,
  is_valid_utf_8,
  get_utf_16be_uchar,
  set_utf_16be_uchar,
  is_valid_utf_16be,
  get_utf_16le_uchar,
  set_utf_16le_uchar,
  is_valid_utf_16le,
  get_uint8,
  get_int8,
  get_uint16_ne,
  get_uint16_be,
  get_uint16_le,
  get_int16_ne,
  get_int16_be,
  get_int16_le,
  get_int32_ne,
  get_int32_be,
  get_int32_le,
  get_int64_ne,
  get_int64_be,
  get_int64_le,
  set_uint8,
  set_int8,
  set_uint16_ne,
  set_uint16_be,
  set_uint16_le,
  set_int16_ne,
  set_int16_be,
  set_int16_le,
  set_int32_ne,
  set_int32_be,
  set_int32_le,
  set_int64_ne,
  set_int64_be,
  set_int64_le,
  unsafe_escape,
}
/* No side effect */
`,df=`// Generated by Melange

import * as Stdlib__Bytes from "./bytes.js";

const make = Stdlib__Bytes.make;

const init = Stdlib__Bytes.init;

const empty = Stdlib__Bytes.empty;

const copy = Stdlib__Bytes.copy;

const of_string = Stdlib__Bytes.of_string;

const to_string = Stdlib__Bytes.to_string;

const sub = Stdlib__Bytes.sub;

const sub_string = Stdlib__Bytes.sub_string;

const extend = Stdlib__Bytes.extend;

const fill = Stdlib__Bytes.fill;

const blit = Stdlib__Bytes.blit;

const blit_string = Stdlib__Bytes.blit_string;

const concat = Stdlib__Bytes.concat;

const cat = Stdlib__Bytes.cat;

const iter = Stdlib__Bytes.iter;

const iteri = Stdlib__Bytes.iteri;

const map = Stdlib__Bytes.map;

const mapi = Stdlib__Bytes.mapi;

const fold_left = Stdlib__Bytes.fold_left;

const fold_right = Stdlib__Bytes.fold_right;

const for_all = Stdlib__Bytes.for_all;

const exists = Stdlib__Bytes.exists;

const trim = Stdlib__Bytes.trim;

const escaped = Stdlib__Bytes.escaped;

const index = Stdlib__Bytes.index;

const index_opt = Stdlib__Bytes.index_opt;

const rindex = Stdlib__Bytes.rindex;

const rindex_opt = Stdlib__Bytes.rindex_opt;

const index_from = Stdlib__Bytes.index_from;

const index_from_opt = Stdlib__Bytes.index_from_opt;

const rindex_from = Stdlib__Bytes.rindex_from;

const rindex_from_opt = Stdlib__Bytes.rindex_from_opt;

const contains = Stdlib__Bytes.contains;

const contains_from = Stdlib__Bytes.contains_from;

const rcontains_from = Stdlib__Bytes.rcontains_from;

const uppercase_ascii = Stdlib__Bytes.uppercase_ascii;

const lowercase_ascii = Stdlib__Bytes.lowercase_ascii;

const capitalize_ascii = Stdlib__Bytes.capitalize_ascii;

const uncapitalize_ascii = Stdlib__Bytes.uncapitalize_ascii;

const compare = Stdlib__Bytes.compare;

const equal = Stdlib__Bytes.equal;

const starts_with = Stdlib__Bytes.starts_with;

const ends_with = Stdlib__Bytes.ends_with;

const unsafe_to_string = Stdlib__Bytes.unsafe_to_string;

const unsafe_of_string = Stdlib__Bytes.unsafe_of_string;

const split_on_char = Stdlib__Bytes.split_on_char;

const to_seq = Stdlib__Bytes.to_seq;

const to_seqi = Stdlib__Bytes.to_seqi;

const of_seq = Stdlib__Bytes.of_seq;

const get_utf_8_uchar = Stdlib__Bytes.get_utf_8_uchar;

const set_utf_8_uchar = Stdlib__Bytes.set_utf_8_uchar;

const is_valid_utf_8 = Stdlib__Bytes.is_valid_utf_8;

const get_utf_16be_uchar = Stdlib__Bytes.get_utf_16be_uchar;

const set_utf_16be_uchar = Stdlib__Bytes.set_utf_16be_uchar;

const is_valid_utf_16be = Stdlib__Bytes.is_valid_utf_16be;

const get_utf_16le_uchar = Stdlib__Bytes.get_utf_16le_uchar;

const set_utf_16le_uchar = Stdlib__Bytes.set_utf_16le_uchar;

const is_valid_utf_16le = Stdlib__Bytes.is_valid_utf_16le;

const get_uint8 = Stdlib__Bytes.get_uint8;

const get_int8 = Stdlib__Bytes.get_int8;

const get_uint16_ne = Stdlib__Bytes.get_uint16_ne;

const get_uint16_be = Stdlib__Bytes.get_uint16_be;

const get_uint16_le = Stdlib__Bytes.get_uint16_le;

const get_int16_ne = Stdlib__Bytes.get_int16_ne;

const get_int16_be = Stdlib__Bytes.get_int16_be;

const get_int16_le = Stdlib__Bytes.get_int16_le;

const get_int32_ne = Stdlib__Bytes.get_int32_ne;

const get_int32_be = Stdlib__Bytes.get_int32_be;

const get_int32_le = Stdlib__Bytes.get_int32_le;

const get_int64_ne = Stdlib__Bytes.get_int64_ne;

const get_int64_be = Stdlib__Bytes.get_int64_be;

const get_int64_le = Stdlib__Bytes.get_int64_le;

const set_uint8 = Stdlib__Bytes.set_uint8;

const set_int8 = Stdlib__Bytes.set_int8;

const set_uint16_ne = Stdlib__Bytes.set_uint16_ne;

const set_uint16_be = Stdlib__Bytes.set_uint16_be;

const set_uint16_le = Stdlib__Bytes.set_uint16_le;

const set_int16_ne = Stdlib__Bytes.set_int16_ne;

const set_int16_be = Stdlib__Bytes.set_int16_be;

const set_int16_le = Stdlib__Bytes.set_int16_le;

const set_int32_ne = Stdlib__Bytes.set_int32_ne;

const set_int32_be = Stdlib__Bytes.set_int32_be;

const set_int32_le = Stdlib__Bytes.set_int32_le;

const set_int64_ne = Stdlib__Bytes.set_int64_ne;

const set_int64_be = Stdlib__Bytes.set_int64_be;

const set_int64_le = Stdlib__Bytes.set_int64_le;

const unsafe_escape = Stdlib__Bytes.unsafe_escape;

export {
  make,
  init,
  empty,
  copy,
  of_string,
  to_string,
  sub,
  sub_string,
  extend,
  fill,
  blit,
  blit_string,
  concat,
  cat,
  iter,
  iteri,
  map,
  mapi,
  fold_left,
  fold_right,
  for_all,
  exists,
  trim,
  escaped,
  index,
  index_opt,
  rindex,
  rindex_opt,
  index_from,
  index_from_opt,
  rindex_from,
  rindex_from_opt,
  contains,
  contains_from,
  rcontains_from,
  uppercase_ascii,
  lowercase_ascii,
  capitalize_ascii,
  uncapitalize_ascii,
  compare,
  equal,
  starts_with,
  ends_with,
  unsafe_to_string,
  unsafe_of_string,
  split_on_char,
  to_seq,
  to_seqi,
  of_seq,
  get_utf_8_uchar,
  set_utf_8_uchar,
  is_valid_utf_8,
  get_utf_16be_uchar,
  set_utf_16be_uchar,
  is_valid_utf_16be,
  get_utf_16le_uchar,
  set_utf_16le_uchar,
  is_valid_utf_16le,
  get_uint8,
  get_int8,
  get_uint16_ne,
  get_uint16_be,
  get_uint16_le,
  get_int16_ne,
  get_int16_be,
  get_int16_le,
  get_int32_ne,
  get_int32_be,
  get_int32_le,
  get_int64_ne,
  get_int64_be,
  get_int64_le,
  set_uint8,
  set_int8,
  set_uint16_ne,
  set_uint16_be,
  set_uint16_le,
  set_int16_ne,
  set_int16_be,
  set_int16_le,
  set_int32_ne,
  set_int32_be,
  set_int32_le,
  set_int64_ne,
  set_int64_be,
  set_int64_le,
  unsafe_escape,
}
/* No side effect */
`,pf=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Stdlib__Obj from "./obj.js";

function register(name, v) {
  Caml_external_polyfill.resolve("caml_register_named_value")(name, v);
}

function register_exception(name, exn) {
  const slot = exn.TAG === Stdlib__Obj.object_tag ? exn : exn[0];
  Caml_external_polyfill.resolve("caml_register_named_value")(name, slot);
}

export {
  register,
  register_exception,
}
/* No side effect */
`,hf=`// Generated by Melange


function make(v) {
  return {
    v: v
  };
}

function get(r) {
  return r.v;
}

function set(r, v) {
  r.v = v;
}

function exchange(r, v) {
  const cur = r.v;
  r.v = v;
  return cur;
}

function compare_and_set(r, seen, v) {
  const cur = r.v;
  if (cur === seen) {
    r.v = v;
    return true;
  } else {
    return false;
  }
}

function fetch_and_add(r, n) {
  const cur = r.v;
  r.v = cur + n | 0;
  return cur;
}

function incr(r) {
  fetch_and_add(r, 1);
}

function decr(r) {
  fetch_and_add(r, -1);
}

export {
  make,
  get,
  set,
  exchange,
  compare_and_set,
  fetch_and_add,
  incr,
  decr,
}
/* No side effect */
`,gf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Char from "./char.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__String from "./string.js";

function create_char_set(param) {
  return Stdlib__Bytes.make(32, /* '\\000' */0);
}

function add_in_char_set(char_set, c) {
  const str_ind = (c >>> 3);
  const mask = (1 << (c & 7));
  Caml_bytes.set(char_set, str_ind, Stdlib.char_of_int(Caml_bytes.get(char_set, str_ind) | mask));
}

const freeze_char_set = Stdlib__Bytes.to_string;

function rev_char_set(char_set) {
  const char_set$p = Stdlib__Bytes.make(32, /* '\\000' */0);
  for (let i = 0; i <= 31; ++i) {
    Caml_bytes.set(char_set$p, i, Stdlib.char_of_int(Caml_string.get(char_set, i) ^ 255));
  }
  return Caml_bytes.bytes_to_string(char_set$p);
}

function is_in_char_set(char_set, c) {
  const str_ind = (c >>> 3);
  const mask = (1 << (c & 7));
  return (Caml_string.get(char_set, str_ind) & mask) !== 0;
}

function pad_of_pad_opt(pad_opt) {
  if (pad_opt !== undefined) {
    return {
      TAG: /* Lit_padding */ 0,
      _0: /* Right */ 1,
      _1: pad_opt
    };
  } else {
    return /* No_padding */ 0;
  }
}

function prec_of_prec_opt(prec_opt) {
  if (prec_opt !== undefined) {
    return {
      TAG: /* Lit_precision */ 0,
      _0: prec_opt
    };
  } else {
    return /* No_precision */ 0;
  }
}

function param_format_of_ignored_format(ign, fmt) {
  if (/* tag */ typeof ign === "number" || typeof ign === "string") {
    switch (ign) {
      case /* Ignored_char */ 0 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Char */ 0,
            _0: fmt
          }
        };
      case /* Ignored_caml_char */ 1 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Caml_char */ 1,
            _0: fmt
          }
        };
      case /* Ignored_reader */ 2 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Reader */ 19,
            _0: fmt
          }
        };
      case /* Ignored_scan_next_char */ 3 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Scan_next_char */ 22,
            _0: fmt
          }
        };
    }
  } else {
    switch (ign.TAG) {
      case /* Ignored_string */ 0 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: pad_of_pad_opt(ign._0),
            _1: fmt
          }
        };
      case /* Ignored_caml_string */ 1 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Caml_string */ 3,
            _0: pad_of_pad_opt(ign._0),
            _1: fmt
          }
        };
      case /* Ignored_int */ 2 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Int */ 4,
            _0: ign._0,
            _1: pad_of_pad_opt(ign._1),
            _2: /* No_precision */ 0,
            _3: fmt
          }
        };
      case /* Ignored_int32 */ 3 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Int32 */ 5,
            _0: ign._0,
            _1: pad_of_pad_opt(ign._1),
            _2: /* No_precision */ 0,
            _3: fmt
          }
        };
      case /* Ignored_nativeint */ 4 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Nativeint */ 6,
            _0: ign._0,
            _1: pad_of_pad_opt(ign._1),
            _2: /* No_precision */ 0,
            _3: fmt
          }
        };
      case /* Ignored_int64 */ 5 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Int64 */ 7,
            _0: ign._0,
            _1: pad_of_pad_opt(ign._1),
            _2: /* No_precision */ 0,
            _3: fmt
          }
        };
      case /* Ignored_float */ 6 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Float */ 8,
            _0: [
              /* Float_flag_ */ 0,
              /* Float_f */ 0
            ],
            _1: pad_of_pad_opt(ign._0),
            _2: prec_of_prec_opt(ign._1),
            _3: fmt
          }
        };
      case /* Ignored_bool */ 7 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Bool */ 9,
            _0: pad_of_pad_opt(ign._0),
            _1: fmt
          }
        };
      case /* Ignored_format_arg */ 8 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Format_arg */ 13,
            _0: ign._0,
            _1: ign._1,
            _2: fmt
          }
        };
      case /* Ignored_format_subst */ 9 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Format_subst */ 14,
            _0: ign._0,
            _1: ign._1,
            _2: fmt
          }
        };
      case /* Ignored_scan_char_set */ 10 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Scan_char_set */ 20,
            _0: ign._0,
            _1: ign._1,
            _2: fmt
          }
        };
      case /* Ignored_scan_get_counter */ 11 :
        return {
          TAG: /* Param_format_EBB */ 0,
          _0: {
            TAG: /* Scan_get_counter */ 21,
            _0: ign._0,
            _1: fmt
          }
        };
    }
  }
}

function default_float_precision(fconv) {
  const match = fconv[1];
  if (match === /* Float_F */ 5) {
    return 12;
  } else {
    return -6;
  }
}

function buffer_check_size(buf, overhead) {
  const len = buf.bytes.length;
  const min_len = buf.ind + overhead | 0;
  if (min_len <= len) {
    return;
  }
  const new_len = Stdlib__Int.max((len << 1), min_len);
  const new_str = Caml_bytes.caml_create_bytes(new_len);
  Stdlib__Bytes.blit(buf.bytes, 0, new_str, 0, len);
  buf.bytes = new_str;
}

function buffer_add_char(buf, c) {
  buffer_check_size(buf, 1);
  Caml_bytes.set(buf.bytes, buf.ind, c);
  buf.ind = buf.ind + 1 | 0;
}

function buffer_add_string(buf, s) {
  const str_len = s.length;
  buffer_check_size(buf, str_len);
  Stdlib__String.blit(s, 0, buf.bytes, buf.ind, str_len);
  buf.ind = buf.ind + str_len | 0;
}

function buffer_contents(buf) {
  return Stdlib__Bytes.sub_string(buf.bytes, 0, buf.ind);
}

function char_of_iconv(iconv) {
  switch (iconv) {
    case /* Int_x */ 6 :
    case /* Int_Cx */ 7 :
      return /* 'x' */120;
    case /* Int_X */ 8 :
    case /* Int_CX */ 9 :
      return /* 'X' */88;
    case /* Int_o */ 10 :
    case /* Int_Co */ 11 :
      return /* 'o' */111;
    case /* Int_i */ 3 :
    case /* Int_pi */ 4 :
    case /* Int_si */ 5 :
    case /* Int_Ci */ 14 :
      return /* 'i' */105;
    case /* Int_u */ 12 :
    case /* Int_Cu */ 15 :
      return /* 'u' */117;
    default:
      return /* 'd' */100;
  }
}

function char_of_fconv(cFOpt, fconv) {
  const cF = cFOpt !== undefined ? cFOpt : /* 'F' */70;
  const match = fconv[1];
  switch (match) {
    case /* Float_f */ 0 :
      return /* 'f' */102;
    case /* Float_e */ 1 :
      return /* 'e' */101;
    case /* Float_E */ 2 :
      return /* 'E' */69;
    case /* Float_g */ 3 :
      return /* 'g' */103;
    case /* Float_G */ 4 :
      return /* 'G' */71;
    case /* Float_F */ 5 :
      return cF;
    case /* Float_h */ 6 :
      return /* 'h' */104;
    case /* Float_H */ 7 :
      return /* 'H' */72;
    case /* Float_CF */ 8 :
      return /* 'F' */70;
  }
}

function char_of_counter(counter) {
  switch (counter) {
    case /* Line_counter */ 0 :
      return /* 'l' */108;
    case /* Char_counter */ 1 :
      return /* 'n' */110;
    case /* Token_counter */ 2 :
      return /* 'N' */78;
  }
}

function bprint_char_set(buf, char_set) {
  const print_char = function (buf, i) {
    const c = Stdlib.char_of_int(i);
    if (c !== 37) {
      if (c !== 64) {
        return buffer_add_char(buf, c);
      } else {
        buffer_add_char(buf, /* '%' */37);
        return buffer_add_char(buf, /* '@' */64);
      }
    } else {
      buffer_add_char(buf, /* '%' */37);
      return buffer_add_char(buf, /* '%' */37);
    }
  };
  const print_out = function (set, _i) {
    while (true) {
      const i = _i;
      if (i >= 256) {
        return;
      }
      if (is_in_char_set(set, Stdlib.char_of_int(i))) {
        const match = Stdlib.char_of_int(i);
        if (match > 93 || match < 45) {
          if (match >= 255) {
            return print_char(buf, 255);
          } else {
            return print_second(set, i + 1 | 0);
          }
        } else if (match > 92 || match < 46) {
          return print_out(set, i + 1 | 0);
        } else {
          return print_second(set, i + 1 | 0);
        }
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const print_second = function (set, i) {
    if (is_in_char_set(set, Stdlib.char_of_int(i))) {
      const match = Stdlib.char_of_int(i);
      if (match > 93 || match < 45) {
        if (match >= 255) {
          print_char(buf, 254);
          return print_char(buf, 255);
        }
        
      } else if ((match > 92 || match < 46) && !is_in_char_set(set, Stdlib.char_of_int(i + 1 | 0))) {
        print_char(buf, i - 1 | 0);
        return print_out(set, i + 1 | 0);
      }
      if (is_in_char_set(set, Stdlib.char_of_int(i + 1 | 0))) {
        let i$1 = i - 1 | 0;
        let _j = i + 2 | 0;
        while (true) {
          const j = _j;
          if (j === 256 || !is_in_char_set(set, Stdlib.char_of_int(j))) {
            print_char(buf, i$1);
            print_char(buf, /* '-' */45);
            print_char(buf, j - 1 | 0);
            if (j < 256) {
              return print_out(set, j + 1 | 0);
            } else {
              return;
            }
          }
          _j = j + 1 | 0;
          continue;
        };
      } else {
        print_char(buf, i - 1 | 0);
        print_char(buf, i);
        return print_out(set, i + 2 | 0);
      }
    }
    print_char(buf, i - 1 | 0);
    print_out(set, i + 1 | 0);
  };
  const print_start = function (set) {
    const is_alone = function (c) {
      const before = Stdlib__Char.chr(c - 1 | 0);
      const after = Stdlib__Char.chr(c + 1 | 0);
      if (is_in_char_set(set, c)) {
        return !(is_in_char_set(set, before) && is_in_char_set(set, after));
      } else {
        return false;
      }
    };
    if (is_alone(/* ']' */93)) {
      buffer_add_char(buf, /* ']' */93);
    }
    print_out(set, 1);
    if (is_alone(/* '-' */45)) {
      return buffer_add_char(buf, /* '-' */45);
    }
    
  };
  buffer_add_char(buf, /* '[' */91);
  print_start(is_in_char_set(char_set, /* '\\000' */0) ? (buffer_add_char(buf, /* '^' */94), rev_char_set(char_set)) : char_set);
  buffer_add_char(buf, /* ']' */93);
}

function bprint_padty(buf, padty) {
  switch (padty) {
    case /* Left */ 0 :
      return buffer_add_char(buf, /* '-' */45);
    case /* Right */ 1 :
      return;
    case /* Zeros */ 2 :
      return buffer_add_char(buf, /* '0' */48);
  }
}

function bprint_ignored_flag(buf, ign_flag) {
  if (ign_flag) {
    return buffer_add_char(buf, /* '_' */95);
  }
  
}

function bprint_pad_opt(buf, pad_opt) {
  if (pad_opt !== undefined) {
    return buffer_add_string(buf, Caml_format.caml_format_int("%d", pad_opt));
  }
  
}

function bprint_padding(buf, pad) {
  if (/* tag */ typeof pad === "number" || typeof pad === "string") {
    return;
  }
  if (pad.TAG === /* Lit_padding */ 0) {
    bprint_padty(buf, pad._0);
    return buffer_add_string(buf, Caml_format.caml_format_int("%d", pad._1));
  }
  bprint_padty(buf, pad._0);
  buffer_add_char(buf, /* '*' */42);
}

function bprint_precision(buf, prec) {
  if (/* tag */ typeof prec === "number" || typeof prec === "string") {
    if (prec === /* No_precision */ 0) {
      return;
    } else {
      return buffer_add_string(buf, ".*");
    }
  }
  buffer_add_char(buf, /* '.' */46);
  buffer_add_string(buf, Caml_format.caml_format_int("%d", prec._0));
}

function bprint_iconv_flag(buf, iconv) {
  switch (iconv) {
    case /* Int_pd */ 1 :
    case /* Int_pi */ 4 :
      return buffer_add_char(buf, /* '+' */43);
    case /* Int_sd */ 2 :
    case /* Int_si */ 5 :
      return buffer_add_char(buf, /* ' ' */32);
    case /* Int_d */ 0 :
    case /* Int_i */ 3 :
    case /* Int_x */ 6 :
    case /* Int_X */ 8 :
    case /* Int_o */ 10 :
    case /* Int_u */ 12 :
      return;
    default:
      return buffer_add_char(buf, /* '#' */35);
  }
}

function bprint_int_fmt(buf, ign_flag, iconv, pad, prec) {
  buffer_add_char(buf, /* '%' */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c) {
  buffer_add_char(buf, /* '%' */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, c);
  buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_fconv_flag(buf, fconv) {
  const match = fconv[0];
  switch (match) {
    case /* Float_flag_ */ 0 :
      break;
    case /* Float_flag_p */ 1 :
      buffer_add_char(buf, /* '+' */43);
      break;
    case /* Float_flag_s */ 2 :
      buffer_add_char(buf, /* ' ' */32);
      break;
  }
  const match$1 = fconv[1];
  if (match$1 === /* Float_CF */ 8) {
    return buffer_add_char(buf, /* '#' */35);
  }
  
}

function bprint_float_fmt(buf, ign_flag, fconv, pad, prec) {
  buffer_add_char(buf, /* '%' */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_fconv_flag(buf, fconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, char_of_fconv(undefined, fconv));
}

function string_of_formatting_lit(formatting_lit) {
  if (/* tag */ typeof formatting_lit === "number" || typeof formatting_lit === "string") {
    switch (formatting_lit) {
      case /* Close_box */ 0 :
        return "@]";
      case /* Close_tag */ 1 :
        return "@}";
      case /* FFlush */ 2 :
        return "@?";
      case /* Force_newline */ 3 :
        return "@\\n";
      case /* Flush_newline */ 4 :
        return "@.";
      case /* Escaped_at */ 5 :
        return "@@";
      case /* Escaped_percent */ 6 :
        return "@%";
    }
  } else {
    switch (formatting_lit.TAG) {
      case /* Break */ 0 :
      case /* Magic_size */ 1 :
        return formatting_lit._0;
      case /* Scan_indic */ 2 :
        return "@" + Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, formatting_lit._0));
    }
  }
}

function bprint_char_literal(buf, chr) {
  if (chr !== 37) {
    return buffer_add_char(buf, chr);
  } else {
    return buffer_add_string(buf, "%%");
  }
}

function bprint_string_literal(buf, str) {
  for (let i = 0, i_finish = str.length; i < i_finish; ++i) {
    bprint_char_literal(buf, Caml_string.get(str, i));
  }
}

function bprint_fmtty(buf, _fmtty) {
  while (true) {
    const fmtty = _fmtty;
    if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
      return;
    }
    switch (fmtty.TAG) {
      case /* Char_ty */ 0 :
        buffer_add_string(buf, "%c");
        _fmtty = fmtty._0;
        continue;
      case /* String_ty */ 1 :
        buffer_add_string(buf, "%s");
        _fmtty = fmtty._0;
        continue;
      case /* Int_ty */ 2 :
        buffer_add_string(buf, "%i");
        _fmtty = fmtty._0;
        continue;
      case /* Int32_ty */ 3 :
        buffer_add_string(buf, "%li");
        _fmtty = fmtty._0;
        continue;
      case /* Nativeint_ty */ 4 :
        buffer_add_string(buf, "%ni");
        _fmtty = fmtty._0;
        continue;
      case /* Int64_ty */ 5 :
        buffer_add_string(buf, "%Li");
        _fmtty = fmtty._0;
        continue;
      case /* Float_ty */ 6 :
        buffer_add_string(buf, "%f");
        _fmtty = fmtty._0;
        continue;
      case /* Bool_ty */ 7 :
        buffer_add_string(buf, "%B");
        _fmtty = fmtty._0;
        continue;
      case /* Format_arg_ty */ 8 :
        buffer_add_string(buf, "%{");
        bprint_fmtty(buf, fmtty._0);
        buffer_add_string(buf, "%}");
        _fmtty = fmtty._1;
        continue;
      case /* Format_subst_ty */ 9 :
        buffer_add_string(buf, "%(");
        bprint_fmtty(buf, fmtty._0);
        buffer_add_string(buf, "%)");
        _fmtty = fmtty._2;
        continue;
      case /* Alpha_ty */ 10 :
        buffer_add_string(buf, "%a");
        _fmtty = fmtty._0;
        continue;
      case /* Theta_ty */ 11 :
        buffer_add_string(buf, "%t");
        _fmtty = fmtty._0;
        continue;
      case /* Any_ty */ 12 :
        buffer_add_string(buf, "%?");
        _fmtty = fmtty._0;
        continue;
      case /* Reader_ty */ 13 :
        buffer_add_string(buf, "%r");
        _fmtty = fmtty._0;
        continue;
      case /* Ignored_reader_ty */ 14 :
        buffer_add_string(buf, "%_r");
        _fmtty = fmtty._0;
        continue;
    }
  };
}

function bprint_fmt(buf, fmt) {
  let _fmt = fmt;
  let _ign_flag = false;
  while (true) {
    const ign_flag = _ign_flag;
    const fmt$1 = _fmt;
    if (/* tag */ typeof fmt$1 === "number" || typeof fmt$1 === "string") {
      return;
    }
    switch (fmt$1.TAG) {
      case /* Char */ 0 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        buffer_add_char(buf, /* 'c' */99);
        _ign_flag = false;
        _fmt = fmt$1._0;
        continue;
      case /* Caml_char */ 1 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        buffer_add_char(buf, /* 'C' */67);
        _ign_flag = false;
        _fmt = fmt$1._0;
        continue;
      case /* String */ 2 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_padding(buf, fmt$1._0);
        buffer_add_char(buf, /* 's' */115);
        _ign_flag = false;
        _fmt = fmt$1._1;
        continue;
      case /* Caml_string */ 3 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_padding(buf, fmt$1._0);
        buffer_add_char(buf, /* 'S' */83);
        _ign_flag = false;
        _fmt = fmt$1._1;
        continue;
      case /* Int */ 4 :
        bprint_int_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2);
        _ign_flag = false;
        _fmt = fmt$1._3;
        continue;
      case /* Int32 */ 5 :
        bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* 'l' */108);
        _ign_flag = false;
        _fmt = fmt$1._3;
        continue;
      case /* Nativeint */ 6 :
        bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* 'n' */110);
        _ign_flag = false;
        _fmt = fmt$1._3;
        continue;
      case /* Int64 */ 7 :
        bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* 'L' */76);
        _ign_flag = false;
        _fmt = fmt$1._3;
        continue;
      case /* Float */ 8 :
        bprint_float_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2);
        _ign_flag = false;
        _fmt = fmt$1._3;
        continue;
      case /* Bool */ 9 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_padding(buf, fmt$1._0);
        buffer_add_char(buf, /* 'B' */66);
        _ign_flag = false;
        _fmt = fmt$1._1;
        continue;
      case /* Flush */ 10 :
        buffer_add_string(buf, "%!");
        _fmt = fmt$1._0;
        continue;
      case /* String_literal */ 11 :
        bprint_string_literal(buf, fmt$1._0);
        _fmt = fmt$1._1;
        continue;
      case /* Char_literal */ 12 :
        bprint_char_literal(buf, fmt$1._0);
        _fmt = fmt$1._1;
        continue;
      case /* Format_arg */ 13 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_pad_opt(buf, fmt$1._0);
        buffer_add_char(buf, /* '{' */123);
        bprint_fmtty(buf, fmt$1._1);
        buffer_add_char(buf, /* '%' */37);
        buffer_add_char(buf, /* '}' */125);
        _ign_flag = false;
        _fmt = fmt$1._2;
        continue;
      case /* Format_subst */ 14 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_pad_opt(buf, fmt$1._0);
        buffer_add_char(buf, /* '(' */40);
        bprint_fmtty(buf, fmt$1._1);
        buffer_add_char(buf, /* '%' */37);
        buffer_add_char(buf, /* ')' */41);
        _ign_flag = false;
        _fmt = fmt$1._2;
        continue;
      case /* Alpha */ 15 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        buffer_add_char(buf, /* 'a' */97);
        _ign_flag = false;
        _fmt = fmt$1._0;
        continue;
      case /* Theta */ 16 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        buffer_add_char(buf, /* 't' */116);
        _ign_flag = false;
        _fmt = fmt$1._0;
        continue;
      case /* Formatting_lit */ 17 :
        bprint_string_literal(buf, string_of_formatting_lit(fmt$1._0));
        _fmt = fmt$1._1;
        continue;
      case /* Formatting_gen */ 18 :
        const fmting_gen = fmt$1._0;
        if (fmting_gen.TAG === /* Open_tag */ 0) {
          buffer_add_string(buf, "@{");
          buffer_add_string(buf, fmting_gen._0._1);
        } else {
          buffer_add_string(buf, "@[");
          buffer_add_string(buf, fmting_gen._0._1);
        }
        _fmt = fmt$1._1;
        continue;
      case /* Reader */ 19 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        buffer_add_char(buf, /* 'r' */114);
        _ign_flag = false;
        _fmt = fmt$1._0;
        continue;
      case /* Scan_char_set */ 20 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_pad_opt(buf, fmt$1._0);
        bprint_char_set(buf, fmt$1._1);
        _ign_flag = false;
        _fmt = fmt$1._2;
        continue;
      case /* Scan_get_counter */ 21 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        buffer_add_char(buf, char_of_counter(fmt$1._0));
        _ign_flag = false;
        _fmt = fmt$1._1;
        continue;
      case /* Scan_next_char */ 22 :
        buffer_add_char(buf, /* '%' */37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_string_literal(buf, "0c");
        _ign_flag = false;
        _fmt = fmt$1._0;
        continue;
      case /* Ignored_param */ 23 :
        const fmt$p = param_format_of_ignored_format(fmt$1._0, fmt$1._1);
        _ign_flag = true;
        _fmt = fmt$p._0;
        continue;
      case /* Custom */ 24 :
        for (let _i = 1, _i_finish = int_of_custom_arity(fmt$1._0); _i <= _i_finish; ++_i) {
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* '?' */63);
        }
        _ign_flag = false;
        _fmt = fmt$1._2;
        continue;
    }
  };
}

function string_of_fmt(fmt) {
  const buf = {
    ind: 0,
    bytes: Caml_bytes.caml_create_bytes(16)
  };
  bprint_fmt(buf, fmt);
  return buffer_contents(buf);
}

function symm(rest) {
  if (/* tag */ typeof rest === "number" || typeof rest === "string") {
    return /* End_of_fmtty */ 0;
  }
  switch (rest.TAG) {
    case /* Char_ty */ 0 :
      return {
        TAG: /* Char_ty */ 0,
        _0: symm(rest._0)
      };
    case /* String_ty */ 1 :
      return {
        TAG: /* String_ty */ 1,
        _0: symm(rest._0)
      };
    case /* Int_ty */ 2 :
      return {
        TAG: /* Int_ty */ 2,
        _0: symm(rest._0)
      };
    case /* Int32_ty */ 3 :
      return {
        TAG: /* Int32_ty */ 3,
        _0: symm(rest._0)
      };
    case /* Nativeint_ty */ 4 :
      return {
        TAG: /* Nativeint_ty */ 4,
        _0: symm(rest._0)
      };
    case /* Int64_ty */ 5 :
      return {
        TAG: /* Int64_ty */ 5,
        _0: symm(rest._0)
      };
    case /* Float_ty */ 6 :
      return {
        TAG: /* Float_ty */ 6,
        _0: symm(rest._0)
      };
    case /* Bool_ty */ 7 :
      return {
        TAG: /* Bool_ty */ 7,
        _0: symm(rest._0)
      };
    case /* Format_arg_ty */ 8 :
      return {
        TAG: /* Format_arg_ty */ 8,
        _0: rest._0,
        _1: symm(rest._1)
      };
    case /* Format_subst_ty */ 9 :
      return {
        TAG: /* Format_subst_ty */ 9,
        _0: rest._1,
        _1: rest._0,
        _2: symm(rest._2)
      };
    case /* Alpha_ty */ 10 :
      return {
        TAG: /* Alpha_ty */ 10,
        _0: symm(rest._0)
      };
    case /* Theta_ty */ 11 :
      return {
        TAG: /* Theta_ty */ 11,
        _0: symm(rest._0)
      };
    case /* Any_ty */ 12 :
      return {
        TAG: /* Any_ty */ 12,
        _0: symm(rest._0)
      };
    case /* Reader_ty */ 13 :
      return {
        TAG: /* Reader_ty */ 13,
        _0: symm(rest._0)
      };
    case /* Ignored_reader_ty */ 14 :
      return {
        TAG: /* Ignored_reader_ty */ 14,
        _0: symm(rest._0)
      };
  }
}

function fmtty_rel_det(rest) {
  if (/* tag */ typeof rest === "number" || typeof rest === "string") {
    return [
      (function (param) {
        return /* Refl */ 0;
      }),
      (function (param) {
        return /* Refl */ 0;
      }),
      (function (param) {
        return /* Refl */ 0;
      }),
      (function (param) {
        return /* Refl */ 0;
      })
    ];
  }
  switch (rest.TAG) {
    case /* Char_ty */ 0 :
      const match = fmtty_rel_det(rest._0);
      const af = match[1];
      const fa = match[0];
      return [
        (function (param) {
          Curry._1(fa, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match[2],
        match[3]
      ];
    case /* String_ty */ 1 :
      const match$1 = fmtty_rel_det(rest._0);
      const af$1 = match$1[1];
      const fa$1 = match$1[0];
      return [
        (function (param) {
          Curry._1(fa$1, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$1, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$1[2],
        match$1[3]
      ];
    case /* Int_ty */ 2 :
      const match$2 = fmtty_rel_det(rest._0);
      const af$2 = match$2[1];
      const fa$2 = match$2[0];
      return [
        (function (param) {
          Curry._1(fa$2, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$2, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$2[2],
        match$2[3]
      ];
    case /* Int32_ty */ 3 :
      const match$3 = fmtty_rel_det(rest._0);
      const af$3 = match$3[1];
      const fa$3 = match$3[0];
      return [
        (function (param) {
          Curry._1(fa$3, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$3, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$3[2],
        match$3[3]
      ];
    case /* Nativeint_ty */ 4 :
      const match$4 = fmtty_rel_det(rest._0);
      const af$4 = match$4[1];
      const fa$4 = match$4[0];
      return [
        (function (param) {
          Curry._1(fa$4, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$4, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$4[2],
        match$4[3]
      ];
    case /* Int64_ty */ 5 :
      const match$5 = fmtty_rel_det(rest._0);
      const af$5 = match$5[1];
      const fa$5 = match$5[0];
      return [
        (function (param) {
          Curry._1(fa$5, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$5, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$5[2],
        match$5[3]
      ];
    case /* Float_ty */ 6 :
      const match$6 = fmtty_rel_det(rest._0);
      const af$6 = match$6[1];
      const fa$6 = match$6[0];
      return [
        (function (param) {
          Curry._1(fa$6, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$6, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$6[2],
        match$6[3]
      ];
    case /* Bool_ty */ 7 :
      const match$7 = fmtty_rel_det(rest._0);
      const af$7 = match$7[1];
      const fa$7 = match$7[0];
      return [
        (function (param) {
          Curry._1(fa$7, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$7, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$7[2],
        match$7[3]
      ];
    case /* Format_arg_ty */ 8 :
      const match$8 = fmtty_rel_det(rest._1);
      const af$8 = match$8[1];
      const fa$8 = match$8[0];
      return [
        (function (param) {
          Curry._1(fa$8, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$8, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$8[2],
        match$8[3]
      ];
    case /* Format_subst_ty */ 9 :
      const match$9 = fmtty_rel_det(rest._2);
      const de = match$9[3];
      const ed = match$9[2];
      const af$9 = match$9[1];
      const fa$9 = match$9[0];
      const ty = trans(symm(rest._0), rest._1);
      const match$10 = fmtty_rel_det(ty);
      const jd = match$10[3];
      const dj = match$10[2];
      const ga = match$10[1];
      const ag = match$10[0];
      return [
        (function (param) {
          Curry._1(fa$9, /* Refl */ 0);
          Curry._1(ag, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(ga, /* Refl */ 0);
          Curry._1(af$9, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(ed, /* Refl */ 0);
          Curry._1(dj, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(jd, /* Refl */ 0);
          Curry._1(de, /* Refl */ 0);
          return /* Refl */ 0;
        })
      ];
    case /* Alpha_ty */ 10 :
      const match$11 = fmtty_rel_det(rest._0);
      const af$10 = match$11[1];
      const fa$10 = match$11[0];
      return [
        (function (param) {
          Curry._1(fa$10, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$10, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$11[2],
        match$11[3]
      ];
    case /* Theta_ty */ 11 :
      const match$12 = fmtty_rel_det(rest._0);
      const af$11 = match$12[1];
      const fa$11 = match$12[0];
      return [
        (function (param) {
          Curry._1(fa$11, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$11, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$12[2],
        match$12[3]
      ];
    case /* Any_ty */ 12 :
      const match$13 = fmtty_rel_det(rest._0);
      const af$12 = match$13[1];
      const fa$12 = match$13[0];
      return [
        (function (param) {
          Curry._1(fa$12, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$12, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        match$13[2],
        match$13[3]
      ];
    case /* Reader_ty */ 13 :
      const match$14 = fmtty_rel_det(rest._0);
      const de$1 = match$14[3];
      const ed$1 = match$14[2];
      const af$13 = match$14[1];
      const fa$13 = match$14[0];
      return [
        (function (param) {
          Curry._1(fa$13, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$13, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(ed$1, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(de$1, /* Refl */ 0);
          return /* Refl */ 0;
        })
      ];
    case /* Ignored_reader_ty */ 14 :
      const match$15 = fmtty_rel_det(rest._0);
      const de$2 = match$15[3];
      const ed$2 = match$15[2];
      const af$14 = match$15[1];
      const fa$14 = match$15[0];
      return [
        (function (param) {
          Curry._1(fa$14, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(af$14, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(ed$2, /* Refl */ 0);
          return /* Refl */ 0;
        }),
        (function (param) {
          Curry._1(de$2, /* Refl */ 0);
          return /* Refl */ 0;
        })
      ];
  }
}

function trans(ty1, ty2) {
  let exit = 0;
  if (/* tag */ typeof ty1 === "number" || typeof ty1 === "string") {
    if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
      return /* End_of_fmtty */ 0;
    }
    switch (ty2.TAG) {
      case /* Format_arg_ty */ 8 :
        exit = 6;
        break;
      case /* Format_subst_ty */ 9 :
        exit = 7;
        break;
      case /* Alpha_ty */ 10 :
        exit = 1;
        break;
      case /* Theta_ty */ 11 :
        exit = 2;
        break;
      case /* Any_ty */ 12 :
        exit = 3;
        break;
      case /* Reader_ty */ 13 :
        exit = 4;
        break;
      case /* Ignored_reader_ty */ 14 :
        exit = 5;
        break;
      default:
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                850,
                23
              ]
            });
    }
  } else {
    switch (ty1.TAG) {
      case /* Char_ty */ 0 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* Char_ty */ 0 :
              return {
                TAG: /* Char_ty */ 0,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* String_ty */ 1 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* String_ty */ 1 :
              return {
                TAG: /* String_ty */ 1,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* Int_ty */ 2 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* Int_ty */ 2 :
              return {
                TAG: /* Int_ty */ 2,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* Int32_ty */ 3 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* Int32_ty */ 3 :
              return {
                TAG: /* Int32_ty */ 3,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* Nativeint_ty */ 4 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* Nativeint_ty */ 4 :
              return {
                TAG: /* Nativeint_ty */ 4,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* Int64_ty */ 5 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* Int64_ty */ 5 :
              return {
                TAG: /* Int64_ty */ 5,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* Float_ty */ 6 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* Float_ty */ 6 :
              return {
                TAG: /* Float_ty */ 6,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* Bool_ty */ 7 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          exit = 8;
        } else {
          switch (ty2.TAG) {
            case /* Bool_ty */ 7 :
              return {
                TAG: /* Bool_ty */ 7,
                _0: trans(ty1._0, ty2._0)
              };
            case /* Format_arg_ty */ 8 :
              exit = 6;
              break;
            case /* Format_subst_ty */ 9 :
              exit = 7;
              break;
            case /* Alpha_ty */ 10 :
              exit = 1;
              break;
            case /* Theta_ty */ 11 :
              exit = 2;
              break;
            case /* Any_ty */ 12 :
              exit = 3;
              break;
            case /* Reader_ty */ 13 :
              exit = 4;
              break;
            case /* Ignored_reader_ty */ 14 :
              exit = 5;
              break;
          }
        }
        break;
      case /* Format_arg_ty */ 8 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  836,
                  26
                ]
              });
        }
        switch (ty2.TAG) {
          case /* Format_arg_ty */ 8 :
            return {
              TAG: /* Format_arg_ty */ 8,
              _0: trans(ty1._0, ty2._0),
              _1: trans(ty1._1, ty2._1)
            };
          case /* Alpha_ty */ 10 :
            exit = 1;
            break;
          case /* Theta_ty */ 11 :
            exit = 2;
            break;
          case /* Any_ty */ 12 :
            exit = 3;
            break;
          case /* Reader_ty */ 13 :
            exit = 4;
            break;
          case /* Ignored_reader_ty */ 14 :
            exit = 5;
            break;
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    836,
                    26
                  ]
                });
        }
        break;
      case /* Format_subst_ty */ 9 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  846,
                  28
                ]
              });
        }
        switch (ty2.TAG) {
          case /* Format_arg_ty */ 8 :
            exit = 6;
            break;
          case /* Format_subst_ty */ 9 :
            const ty = trans(symm(ty1._1), ty2._0);
            const match = fmtty_rel_det(ty);
            Curry._1(match[1], /* Refl */ 0);
            Curry._1(match[3], /* Refl */ 0);
            return {
              TAG: /* Format_subst_ty */ 9,
              _0: ty1._0,
              _1: ty2._1,
              _2: trans(ty1._2, ty2._2)
            };
          case /* Alpha_ty */ 10 :
            exit = 1;
            break;
          case /* Theta_ty */ 11 :
            exit = 2;
            break;
          case /* Any_ty */ 12 :
            exit = 3;
            break;
          case /* Reader_ty */ 13 :
            exit = 4;
            break;
          case /* Ignored_reader_ty */ 14 :
            exit = 5;
            break;
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    846,
                    28
                  ]
                });
        }
        break;
      case /* Alpha_ty */ 10 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  814,
                  21
                ]
              });
        }
        if (ty2.TAG === /* Alpha_ty */ 10) {
          return {
            TAG: /* Alpha_ty */ 10,
            _0: trans(ty1._0, ty2._0)
          };
        }
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                814,
                21
              ]
            });
      case /* Theta_ty */ 11 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  818,
                  21
                ]
              });
        }
        switch (ty2.TAG) {
          case /* Alpha_ty */ 10 :
            exit = 1;
            break;
          case /* Theta_ty */ 11 :
            return {
              TAG: /* Theta_ty */ 11,
              _0: trans(ty1._0, ty2._0)
            };
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    818,
                    21
                  ]
                });
        }
        break;
      case /* Any_ty */ 12 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  822,
                  19
                ]
              });
        }
        switch (ty2.TAG) {
          case /* Alpha_ty */ 10 :
            exit = 1;
            break;
          case /* Theta_ty */ 11 :
            exit = 2;
            break;
          case /* Any_ty */ 12 :
            return {
              TAG: /* Any_ty */ 12,
              _0: trans(ty1._0, ty2._0)
            };
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    822,
                    19
                  ]
                });
        }
        break;
      case /* Reader_ty */ 13 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  826,
                  22
                ]
              });
        }
        switch (ty2.TAG) {
          case /* Alpha_ty */ 10 :
            exit = 1;
            break;
          case /* Theta_ty */ 11 :
            exit = 2;
            break;
          case /* Any_ty */ 12 :
            exit = 3;
            break;
          case /* Reader_ty */ 13 :
            return {
              TAG: /* Reader_ty */ 13,
              _0: trans(ty1._0, ty2._0)
            };
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    826,
                    22
                  ]
                });
        }
        break;
      case /* Ignored_reader_ty */ 14 :
        if (/* tag */ typeof ty2 === "number" || typeof ty2 === "string") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  831,
                  30
                ]
              });
        }
        switch (ty2.TAG) {
          case /* Alpha_ty */ 10 :
            exit = 1;
            break;
          case /* Theta_ty */ 11 :
            exit = 2;
            break;
          case /* Any_ty */ 12 :
            exit = 3;
            break;
          case /* Reader_ty */ 13 :
            exit = 4;
            break;
          case /* Ignored_reader_ty */ 14 :
            return {
              TAG: /* Ignored_reader_ty */ 14,
              _0: trans(ty1._0, ty2._0)
            };
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    831,
                    30
                  ]
                });
        }
        break;
    }
  }
  switch (exit) {
    case 1 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              815,
              21
            ]
          });
    case 2 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              819,
              21
            ]
          });
    case 3 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              823,
              19
            ]
          });
    case 4 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              827,
              22
            ]
          });
    case 5 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              832,
              30
            ]
          });
    case 6 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              837,
              26
            ]
          });
    case 7 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              847,
              28
            ]
          });
    case 8 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              851,
              23
            ]
          });
  }
}

function fmtty_of_formatting_gen(formatting_gen) {
  return fmtty_of_fmt(formatting_gen._0._0);
}

function fmtty_of_fmt(_fmtty) {
  while (true) {
    const fmtty = _fmtty;
    if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
      return /* End_of_fmtty */ 0;
    }
    switch (fmtty.TAG) {
      case /* String */ 2 :
      case /* Caml_string */ 3 :
        break;
      case /* Int */ 4 :
        const ty_rest = fmtty_of_fmt(fmtty._3);
        const prec_ty = fmtty_of_precision_fmtty(fmtty._2, {
          TAG: /* Int_ty */ 2,
          _0: ty_rest
        });
        return fmtty_of_padding_fmtty(fmtty._1, prec_ty);
      case /* Int32 */ 5 :
        const ty_rest$1 = fmtty_of_fmt(fmtty._3);
        const prec_ty$1 = fmtty_of_precision_fmtty(fmtty._2, {
          TAG: /* Int32_ty */ 3,
          _0: ty_rest$1
        });
        return fmtty_of_padding_fmtty(fmtty._1, prec_ty$1);
      case /* Nativeint */ 6 :
        const ty_rest$2 = fmtty_of_fmt(fmtty._3);
        const prec_ty$2 = fmtty_of_precision_fmtty(fmtty._2, {
          TAG: /* Nativeint_ty */ 4,
          _0: ty_rest$2
        });
        return fmtty_of_padding_fmtty(fmtty._1, prec_ty$2);
      case /* Int64 */ 7 :
        const ty_rest$3 = fmtty_of_fmt(fmtty._3);
        const prec_ty$3 = fmtty_of_precision_fmtty(fmtty._2, {
          TAG: /* Int64_ty */ 5,
          _0: ty_rest$3
        });
        return fmtty_of_padding_fmtty(fmtty._1, prec_ty$3);
      case /* Float */ 8 :
        const ty_rest$4 = fmtty_of_fmt(fmtty._3);
        const prec_ty$4 = fmtty_of_precision_fmtty(fmtty._2, {
          TAG: /* Float_ty */ 6,
          _0: ty_rest$4
        });
        return fmtty_of_padding_fmtty(fmtty._1, prec_ty$4);
      case /* Bool */ 9 :
        return fmtty_of_padding_fmtty(fmtty._0, {
          TAG: /* Bool_ty */ 7,
          _0: fmtty_of_fmt(fmtty._1)
        });
      case /* Flush */ 10 :
        _fmtty = fmtty._0;
        continue;
      case /* Format_arg */ 13 :
        return {
          TAG: /* Format_arg_ty */ 8,
          _0: fmtty._1,
          _1: fmtty_of_fmt(fmtty._2)
        };
      case /* Format_subst */ 14 :
        const ty = fmtty._1;
        return {
          TAG: /* Format_subst_ty */ 9,
          _0: ty,
          _1: ty,
          _2: fmtty_of_fmt(fmtty._2)
        };
      case /* Alpha */ 15 :
        return {
          TAG: /* Alpha_ty */ 10,
          _0: fmtty_of_fmt(fmtty._0)
        };
      case /* Theta */ 16 :
        return {
          TAG: /* Theta_ty */ 11,
          _0: fmtty_of_fmt(fmtty._0)
        };
      case /* String_literal */ 11 :
      case /* Char_literal */ 12 :
      case /* Formatting_lit */ 17 :
        _fmtty = fmtty._1;
        continue;
      case /* Formatting_gen */ 18 :
        return CamlinternalFormatBasics.concat_fmtty(fmtty_of_formatting_gen(fmtty._0), fmtty_of_fmt(fmtty._1));
      case /* Reader */ 19 :
        return {
          TAG: /* Reader_ty */ 13,
          _0: fmtty_of_fmt(fmtty._0)
        };
      case /* Scan_char_set */ 20 :
        return {
          TAG: /* String_ty */ 1,
          _0: fmtty_of_fmt(fmtty._2)
        };
      case /* Scan_get_counter */ 21 :
        return {
          TAG: /* Int_ty */ 2,
          _0: fmtty_of_fmt(fmtty._1)
        };
      case /* Ignored_param */ 23 :
        let ign = fmtty._0;
        let fmt = fmtty._1;
        if (/* tag */ typeof ign === "number" || typeof ign === "string") {
          if (ign === /* Ignored_reader */ 2) {
            return {
              TAG: /* Ignored_reader_ty */ 14,
              _0: fmtty_of_fmt(fmt)
            };
          } else {
            return fmtty_of_fmt(fmt);
          }
        } else if (ign.TAG === /* Ignored_format_subst */ 9) {
          return CamlinternalFormatBasics.concat_fmtty(ign._1, fmtty_of_fmt(fmt));
        } else {
          return fmtty_of_fmt(fmt);
        }
      case /* Custom */ 24 :
        return fmtty_of_custom(fmtty._0, fmtty_of_fmt(fmtty._2));
      default:
        return {
          TAG: /* Char_ty */ 0,
          _0: fmtty_of_fmt(fmtty._0)
        };
    }
    return fmtty_of_padding_fmtty(fmtty._0, {
      TAG: /* String_ty */ 1,
      _0: fmtty_of_fmt(fmtty._1)
    });
  };
}

function fmtty_of_custom(arity, fmtty) {
  if (/* tag */ typeof arity === "number" || typeof arity === "string") {
    return fmtty;
  } else {
    return {
      TAG: /* Any_ty */ 12,
      _0: fmtty_of_custom(arity._0, fmtty)
    };
  }
}

function fmtty_of_padding_fmtty(pad, fmtty) {
  if (/* tag */ typeof pad === "number" || typeof pad === "string" || pad.TAG === /* Lit_padding */ 0) {
    return fmtty;
  } else {
    return {
      TAG: /* Int_ty */ 2,
      _0: fmtty
    };
  }
}

function fmtty_of_precision_fmtty(prec, fmtty) {
  if (/* tag */ (typeof prec === "number" || typeof prec === "string") && prec !== /* No_precision */ 0) {
    return {
      TAG: /* Int_ty */ 2,
      _0: fmtty
    };
  } else {
    return fmtty;
  }
}

const Type_mismatch = /* @__PURE__ */ Caml_exceptions.create("CamlinternalFormat.Type_mismatch");

function type_padding(pad, fmtty) {
  if (/* tag */ typeof pad === "number" || typeof pad === "string") {
    return {
      TAG: /* Padding_fmtty_EBB */ 0,
      _0: /* No_padding */ 0,
      _1: fmtty
    };
  }
  if (pad.TAG === /* Lit_padding */ 0) {
    return {
      TAG: /* Padding_fmtty_EBB */ 0,
      _0: {
        TAG: /* Lit_padding */ 0,
        _0: pad._0,
        _1: pad._1
      },
      _1: fmtty
    };
  }
  if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
    throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
          MEL_EXN_ID: Type_mismatch
        });
  }
  if (fmtty.TAG === /* Int_ty */ 2) {
    return {
      TAG: /* Padding_fmtty_EBB */ 0,
      _0: {
        TAG: /* Arg_padding */ 1,
        _0: pad._0
      },
      _1: fmtty._0
    };
  }
  throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
        MEL_EXN_ID: Type_mismatch
      });
}

function type_padprec(pad, prec, fmtty) {
  const match = type_padding(pad, fmtty);
  if (!/* tag */ (typeof prec === "number" || typeof prec === "string")) {
    return {
      TAG: /* Padprec_fmtty_EBB */ 0,
      _0: match._0,
      _1: {
        TAG: /* Lit_precision */ 0,
        _0: prec._0
      },
      _2: match._1
    };
  }
  if (prec === /* No_precision */ 0) {
    return {
      TAG: /* Padprec_fmtty_EBB */ 0,
      _0: match._0,
      _1: /* No_precision */ 0,
      _2: match._1
    };
  }
  const rest = match._1;
  if (/* tag */ typeof rest === "number" || typeof rest === "string") {
    throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
          MEL_EXN_ID: Type_mismatch
        });
  }
  if (rest.TAG === /* Int_ty */ 2) {
    return {
      TAG: /* Padprec_fmtty_EBB */ 0,
      _0: match._0,
      _1: /* Arg_precision */ 1,
      _2: rest._0
    };
  }
  throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
        MEL_EXN_ID: Type_mismatch
      });
}

function type_ignored_format_substitution(sub_fmtty, fmt, fmtty) {
  if (/* tag */ typeof sub_fmtty === "number" || typeof sub_fmtty === "string") {
    return {
      TAG: /* Fmtty_fmt_EBB */ 0,
      _0: /* End_of_fmtty */ 0,
      _1: type_format_gen(fmt, fmtty)
    };
  }
  switch (sub_fmtty.TAG) {
    case /* Char_ty */ 0 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Char_ty */ 0) {
        const match = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Char_ty */ 0,
            _0: match._0
          },
          _1: match._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* String_ty */ 1 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* String_ty */ 1) {
        const match$1 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* String_ty */ 1,
            _0: match$1._0
          },
          _1: match$1._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Int_ty */ 2 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Int_ty */ 2) {
        const match$2 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Int_ty */ 2,
            _0: match$2._0
          },
          _1: match$2._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Int32_ty */ 3 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Int32_ty */ 3) {
        const match$3 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Int32_ty */ 3,
            _0: match$3._0
          },
          _1: match$3._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Nativeint_ty */ 4 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Nativeint_ty */ 4) {
        const match$4 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Nativeint_ty */ 4,
            _0: match$4._0
          },
          _1: match$4._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Int64_ty */ 5 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Int64_ty */ 5) {
        const match$5 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Int64_ty */ 5,
            _0: match$5._0
          },
          _1: match$5._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Float_ty */ 6 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Float_ty */ 6) {
        const match$6 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Float_ty */ 6,
            _0: match$6._0
          },
          _1: match$6._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Bool_ty */ 7 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Bool_ty */ 7) {
        const match$7 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Bool_ty */ 7,
            _0: match$7._0
          },
          _1: match$7._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Format_arg_ty */ 8 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Format_arg_ty */ 8) {
        const sub2_fmtty$p = fmtty._0;
        if (Caml_obj.caml_notequal({
            TAG: /* Fmtty_EBB */ 0,
            _0: sub_fmtty._0
          }, {
            TAG: /* Fmtty_EBB */ 0,
            _0: sub2_fmtty$p
          })) {
          throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
                MEL_EXN_ID: Type_mismatch
              });
        }
        const match$8 = type_ignored_format_substitution(sub_fmtty._1, fmt, fmtty._1);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Format_arg_ty */ 8,
            _0: sub2_fmtty$p,
            _1: match$8._0
          },
          _1: match$8._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Format_subst_ty */ 9 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Format_subst_ty */ 9) {
        const sub2_fmtty$p$1 = fmtty._1;
        const sub1_fmtty$p = fmtty._0;
        if (Caml_obj.caml_notequal({
            TAG: /* Fmtty_EBB */ 0,
            _0: CamlinternalFormatBasics.erase_rel(sub_fmtty._0)
          }, {
            TAG: /* Fmtty_EBB */ 0,
            _0: CamlinternalFormatBasics.erase_rel(sub1_fmtty$p)
          })) {
          throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
                MEL_EXN_ID: Type_mismatch
              });
        }
        if (Caml_obj.caml_notequal({
            TAG: /* Fmtty_EBB */ 0,
            _0: CamlinternalFormatBasics.erase_rel(sub_fmtty._1)
          }, {
            TAG: /* Fmtty_EBB */ 0,
            _0: CamlinternalFormatBasics.erase_rel(sub2_fmtty$p$1)
          })) {
          throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
                MEL_EXN_ID: Type_mismatch
              });
        }
        const sub_fmtty$p = trans(symm(sub1_fmtty$p), sub2_fmtty$p$1);
        const match$9 = fmtty_rel_det(sub_fmtty$p);
        Curry._1(match$9[1], /* Refl */ 0);
        Curry._1(match$9[3], /* Refl */ 0);
        const match$10 = type_ignored_format_substitution(CamlinternalFormatBasics.erase_rel(sub_fmtty._2), fmt, fmtty._2);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Format_subst_ty */ 9,
            _0: sub1_fmtty$p,
            _1: sub2_fmtty$p$1,
            _2: symm(match$10._0)
          },
          _1: match$10._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Alpha_ty */ 10 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Alpha_ty */ 10) {
        const match$11 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Alpha_ty */ 10,
            _0: match$11._0
          },
          _1: match$11._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Theta_ty */ 11 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Theta_ty */ 11) {
        const match$12 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Theta_ty */ 11,
            _0: match$12._0
          },
          _1: match$12._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Any_ty */ 12 :
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Reader_ty */ 13 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Reader_ty */ 13) {
        const match$13 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Reader_ty */ 13,
            _0: match$13._0
          },
          _1: match$13._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Ignored_reader_ty */ 14 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Ignored_reader_ty */ 14) {
        const match$14 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
        return {
          TAG: /* Fmtty_fmt_EBB */ 0,
          _0: {
            TAG: /* Ignored_reader_ty */ 14,
            _0: match$14._0
          },
          _1: match$14._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
  }
}

function type_format_gen(fmt, fmtty) {
  if (/* tag */ typeof fmt === "number" || typeof fmt === "string") {
    return {
      TAG: /* Fmt_fmtty_EBB */ 0,
      _0: /* End_of_format */ 0,
      _1: fmtty
    };
  }
  switch (fmt.TAG) {
    case /* Char */ 0 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Char_ty */ 0) {
        const match = type_format_gen(fmt._0, fmtty._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Char */ 0,
            _0: match._0
          },
          _1: match._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Caml_char */ 1 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Char_ty */ 0) {
        const match$1 = type_format_gen(fmt._0, fmtty._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Caml_char */ 1,
            _0: match$1._0
          },
          _1: match$1._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* String */ 2 :
      const match$2 = type_padding(fmt._0, fmtty);
      const fmtty_rest = match$2._1;
      if (/* tag */ typeof fmtty_rest === "number" || typeof fmtty_rest === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest.TAG === /* String_ty */ 1) {
        const match$3 = type_format_gen(fmt._1, fmtty_rest._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: match$2._0,
            _1: match$3._0
          },
          _1: match$3._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Caml_string */ 3 :
      const match$4 = type_padding(fmt._0, fmtty);
      const fmtty_rest$1 = match$4._1;
      if (/* tag */ typeof fmtty_rest$1 === "number" || typeof fmtty_rest$1 === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest$1.TAG === /* String_ty */ 1) {
        const match$5 = type_format_gen(fmt._1, fmtty_rest$1._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Caml_string */ 3,
            _0: match$4._0,
            _1: match$5._0
          },
          _1: match$5._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Int */ 4 :
      const match$6 = type_padprec(fmt._1, fmt._2, fmtty);
      const fmtty_rest$2 = match$6._2;
      if (/* tag */ typeof fmtty_rest$2 === "number" || typeof fmtty_rest$2 === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest$2.TAG === /* Int_ty */ 2) {
        const match$7 = type_format_gen(fmt._3, fmtty_rest$2._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Int */ 4,
            _0: fmt._0,
            _1: match$6._0,
            _2: match$6._1,
            _3: match$7._0
          },
          _1: match$7._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Int32 */ 5 :
      const match$8 = type_padprec(fmt._1, fmt._2, fmtty);
      const fmtty_rest$3 = match$8._2;
      if (/* tag */ typeof fmtty_rest$3 === "number" || typeof fmtty_rest$3 === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest$3.TAG === /* Int32_ty */ 3) {
        const match$9 = type_format_gen(fmt._3, fmtty_rest$3._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Int32 */ 5,
            _0: fmt._0,
            _1: match$8._0,
            _2: match$8._1,
            _3: match$9._0
          },
          _1: match$9._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Nativeint */ 6 :
      const match$10 = type_padprec(fmt._1, fmt._2, fmtty);
      const fmtty_rest$4 = match$10._2;
      if (/* tag */ typeof fmtty_rest$4 === "number" || typeof fmtty_rest$4 === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest$4.TAG === /* Nativeint_ty */ 4) {
        const match$11 = type_format_gen(fmt._3, fmtty_rest$4._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Nativeint */ 6,
            _0: fmt._0,
            _1: match$10._0,
            _2: match$10._1,
            _3: match$11._0
          },
          _1: match$11._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Int64 */ 7 :
      const match$12 = type_padprec(fmt._1, fmt._2, fmtty);
      const fmtty_rest$5 = match$12._2;
      if (/* tag */ typeof fmtty_rest$5 === "number" || typeof fmtty_rest$5 === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest$5.TAG === /* Int64_ty */ 5) {
        const match$13 = type_format_gen(fmt._3, fmtty_rest$5._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Int64 */ 7,
            _0: fmt._0,
            _1: match$12._0,
            _2: match$12._1,
            _3: match$13._0
          },
          _1: match$13._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Float */ 8 :
      const match$14 = type_padprec(fmt._1, fmt._2, fmtty);
      const fmtty_rest$6 = match$14._2;
      if (/* tag */ typeof fmtty_rest$6 === "number" || typeof fmtty_rest$6 === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest$6.TAG === /* Float_ty */ 6) {
        const match$15 = type_format_gen(fmt._3, fmtty_rest$6._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Float */ 8,
            _0: fmt._0,
            _1: match$14._0,
            _2: match$14._1,
            _3: match$15._0
          },
          _1: match$15._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Bool */ 9 :
      const match$16 = type_padding(fmt._0, fmtty);
      const fmtty_rest$7 = match$16._1;
      if (/* tag */ typeof fmtty_rest$7 === "number" || typeof fmtty_rest$7 === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty_rest$7.TAG === /* Bool_ty */ 7) {
        const match$17 = type_format_gen(fmt._1, fmtty_rest$7._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Bool */ 9,
            _0: match$16._0,
            _1: match$17._0
          },
          _1: match$17._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Flush */ 10 :
      const match$18 = type_format_gen(fmt._0, fmtty);
      return {
        TAG: /* Fmt_fmtty_EBB */ 0,
        _0: {
          TAG: /* Flush */ 10,
          _0: match$18._0
        },
        _1: match$18._1
      };
    case /* String_literal */ 11 :
      const match$19 = type_format_gen(fmt._1, fmtty);
      return {
        TAG: /* Fmt_fmtty_EBB */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: fmt._0,
          _1: match$19._0
        },
        _1: match$19._1
      };
    case /* Char_literal */ 12 :
      const match$20 = type_format_gen(fmt._1, fmtty);
      return {
        TAG: /* Fmt_fmtty_EBB */ 0,
        _0: {
          TAG: /* Char_literal */ 12,
          _0: fmt._0,
          _1: match$20._0
        },
        _1: match$20._1
      };
    case /* Format_arg */ 13 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Format_arg_ty */ 8) {
        const sub_fmtty$p = fmtty._0;
        if (Caml_obj.caml_notequal({
            TAG: /* Fmtty_EBB */ 0,
            _0: fmt._1
          }, {
            TAG: /* Fmtty_EBB */ 0,
            _0: sub_fmtty$p
          })) {
          throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
                MEL_EXN_ID: Type_mismatch
              });
        }
        const match$21 = type_format_gen(fmt._2, fmtty._1);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Format_arg */ 13,
            _0: fmt._0,
            _1: sub_fmtty$p,
            _2: match$21._0
          },
          _1: match$21._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Format_subst */ 14 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Format_subst_ty */ 9) {
        const sub_fmtty1 = fmtty._0;
        if (Caml_obj.caml_notequal({
            TAG: /* Fmtty_EBB */ 0,
            _0: CamlinternalFormatBasics.erase_rel(fmt._1)
          }, {
            TAG: /* Fmtty_EBB */ 0,
            _0: CamlinternalFormatBasics.erase_rel(sub_fmtty1)
          })) {
          throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
                MEL_EXN_ID: Type_mismatch
              });
        }
        const match$22 = type_format_gen(fmt._2, CamlinternalFormatBasics.erase_rel(fmtty._2));
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Format_subst */ 14,
            _0: fmt._0,
            _1: sub_fmtty1,
            _2: match$22._0
          },
          _1: match$22._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Alpha */ 15 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Alpha_ty */ 10) {
        const match$23 = type_format_gen(fmt._0, fmtty._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Alpha */ 15,
            _0: match$23._0
          },
          _1: match$23._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Theta */ 16 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Theta_ty */ 11) {
        const match$24 = type_format_gen(fmt._0, fmtty._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Theta */ 16,
            _0: match$24._0
          },
          _1: match$24._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Formatting_lit */ 17 :
      const match$25 = type_format_gen(fmt._1, fmtty);
      return {
        TAG: /* Fmt_fmtty_EBB */ 0,
        _0: {
          TAG: /* Formatting_lit */ 17,
          _0: fmt._0,
          _1: match$25._0
        },
        _1: match$25._1
      };
    case /* Formatting_gen */ 18 :
      let formatting_gen = fmt._0;
      let fmt0 = fmt._1;
      if (formatting_gen.TAG === /* Open_tag */ 0) {
        const match$26 = formatting_gen._0;
        const match$27 = type_format_gen(match$26._0, fmtty);
        const match$28 = type_format_gen(fmt0, match$27._1);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Formatting_gen */ 18,
            _0: {
              TAG: /* Open_tag */ 0,
              _0: {
                TAG: /* Format */ 0,
                _0: match$27._0,
                _1: match$26._1
              }
            },
            _1: match$28._0
          },
          _1: match$28._1
        };
      }
      const match$29 = formatting_gen._0;
      const match$30 = type_format_gen(match$29._0, fmtty);
      const match$31 = type_format_gen(fmt0, match$30._1);
      return {
        TAG: /* Fmt_fmtty_EBB */ 0,
        _0: {
          TAG: /* Formatting_gen */ 18,
          _0: {
            TAG: /* Open_box */ 1,
            _0: {
              TAG: /* Format */ 0,
              _0: match$30._0,
              _1: match$29._1
            }
          },
          _1: match$31._0
        },
        _1: match$31._1
      };
    case /* Reader */ 19 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Reader_ty */ 13) {
        const match$32 = type_format_gen(fmt._0, fmtty._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Reader */ 19,
            _0: match$32._0
          },
          _1: match$32._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Scan_char_set */ 20 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* String_ty */ 1) {
        const match$33 = type_format_gen(fmt._2, fmtty._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Scan_char_set */ 20,
            _0: fmt._0,
            _1: fmt._1,
            _2: match$33._0
          },
          _1: match$33._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Scan_get_counter */ 21 :
      if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      }
      if (fmtty.TAG === /* Int_ty */ 2) {
        const match$34 = type_format_gen(fmt._1, fmtty._0);
        return {
          TAG: /* Fmt_fmtty_EBB */ 0,
          _0: {
            TAG: /* Scan_get_counter */ 21,
            _0: fmt._0,
            _1: match$34._0
          },
          _1: match$34._1
        };
      }
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
    case /* Ignored_param */ 23 :
      let ign = fmt._0;
      let fmt$1 = fmt._1;
      if (/* tag */ typeof ign === "number" || typeof ign === "string") {
        if (ign !== /* Ignored_reader */ 2) {
          return type_ignored_param_one(ign, fmt$1, fmtty);
        }
        if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
          throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
                MEL_EXN_ID: Type_mismatch
              });
        }
        if (fmtty.TAG === /* Ignored_reader_ty */ 14) {
          const match$35 = type_format_gen(fmt$1, fmtty._0);
          return {
            TAG: /* Fmt_fmtty_EBB */ 0,
            _0: {
              TAG: /* Ignored_param */ 23,
              _0: /* Ignored_reader */ 2,
              _1: match$35._0
            },
            _1: match$35._1
          };
        }
        throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
              MEL_EXN_ID: Type_mismatch
            });
      } else {
        switch (ign.TAG) {
          case /* Ignored_format_arg */ 8 :
            return type_ignored_param_one({
              TAG: /* Ignored_format_arg */ 8,
              _0: ign._0,
              _1: ign._1
            }, fmt$1, fmtty);
          case /* Ignored_format_subst */ 9 :
            const match$36 = type_ignored_format_substitution(ign._1, fmt$1, fmtty);
            const match$37 = match$36._1;
            return {
              TAG: /* Fmt_fmtty_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: {
                  TAG: /* Ignored_format_subst */ 9,
                  _0: ign._0,
                  _1: match$36._0
                },
                _1: match$37._0
              },
              _1: match$37._1
            };
          default:
            return type_ignored_param_one(ign, fmt$1, fmtty);
        }
      }
    case /* Scan_next_char */ 22 :
    case /* Custom */ 24 :
      throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
            MEL_EXN_ID: Type_mismatch
          });
  }
}

function type_ignored_param_one(ign, fmt, fmtty) {
  const match = type_format_gen(fmt, fmtty);
  return {
    TAG: /* Fmt_fmtty_EBB */ 0,
    _0: {
      TAG: /* Ignored_param */ 23,
      _0: ign,
      _1: match._0
    },
    _1: match._1
  };
}

function type_format(fmt, fmtty) {
  const match = type_format_gen(fmt, fmtty);
  let tmp = match._1;
  if (/* tag */ typeof tmp === "number" || typeof tmp === "string") {
    return match._0;
  }
  throw new Caml_js_exceptions.MelangeError(Type_mismatch, {
        MEL_EXN_ID: Type_mismatch
      });
}

function recast(fmt, fmtty) {
  return type_format(fmt, CamlinternalFormatBasics.erase_rel(symm(fmtty)));
}

function fix_padding(padty, width, str) {
  const len = str.length;
  const width$1 = Stdlib.abs(width);
  const padty$1 = width < 0 ? /* Left */ 0 : padty;
  if (width$1 <= len) {
    return str;
  }
  const res = Stdlib__Bytes.make(width$1, padty$1 === /* Zeros */ 2 ? /* '0' */48 : /* ' ' */32);
  switch (padty$1) {
    case /* Left */ 0 :
      Stdlib__String.blit(str, 0, res, 0, len);
      break;
    case /* Right */ 1 :
      Stdlib__String.blit(str, 0, res, width$1 - len | 0, len);
      break;
    case /* Zeros */ 2 :
      if (len > 0 && (Caml_string.get(str, 0) === /* '+' */43 || Caml_string.get(str, 0) === /* '-' */45 || Caml_string.get(str, 0) === /* ' ' */32)) {
        Caml_bytes.set(res, 0, Caml_string.get(str, 0));
        Stdlib__String.blit(str, 1, res, (width$1 - len | 0) + 1 | 0, len - 1 | 0);
      } else if (len > 1 && Caml_string.get(str, 0) === /* '0' */48 && (Caml_string.get(str, 1) === /* 'x' */120 || Caml_string.get(str, 1) === /* 'X' */88)) {
        Caml_bytes.set(res, 1, Caml_string.get(str, 1));
        Stdlib__String.blit(str, 2, res, (width$1 - len | 0) + 2 | 0, len - 2 | 0);
      } else {
        Stdlib__String.blit(str, 0, res, width$1 - len | 0, len);
      }
      break;
  }
  return Caml_bytes.bytes_to_string(res);
}

function fix_int_precision(prec, str) {
  const prec$1 = Stdlib.abs(prec);
  const len = str.length;
  const c = Caml_string.get(str, 0);
  let exit = 0;
  if (c >= 58) {
    if (c >= 71) {
      if (c > 102 || c < 97) {
        return str;
      }
      exit = 2;
    } else {
      if (c < 65) {
        return str;
      }
      exit = 2;
    }
  } else if (c !== 32) {
    if (c < 43) {
      return str;
    }
    switch (c) {
      case 43 :
      case 45 :
        exit = 1;
        break;
      case 44 :
      case 46 :
      case 47 :
        return str;
      case 48 :
        if ((prec$1 + 2 | 0) > len && len > 1 && (Caml_string.get(str, 1) === /* 'x' */120 || Caml_string.get(str, 1) === /* 'X' */88)) {
          const res = Stdlib__Bytes.make(prec$1 + 2 | 0, /* '0' */48);
          Caml_bytes.set(res, 1, Caml_string.get(str, 1));
          Stdlib__String.blit(str, 2, res, (prec$1 - len | 0) + 4 | 0, len - 2 | 0);
          return Caml_bytes.bytes_to_string(res);
        }
        exit = 2;
        break;
      case 49 :
      case 50 :
      case 51 :
      case 52 :
      case 53 :
      case 54 :
      case 55 :
      case 56 :
      case 57 :
        exit = 2;
        break;
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 :
      if ((prec$1 + 1 | 0) <= len) {
        return str;
      }
      const res$1 = Stdlib__Bytes.make(prec$1 + 1 | 0, /* '0' */48);
      Caml_bytes.set(res$1, 0, c);
      Stdlib__String.blit(str, 1, res$1, (prec$1 - len | 0) + 2 | 0, len - 1 | 0);
      return Caml_bytes.bytes_to_string(res$1);
    case 2 :
      if (prec$1 <= len) {
        return str;
      }
      const res$2 = Stdlib__Bytes.make(prec$1, /* '0' */48);
      Stdlib__String.blit(str, 0, res$2, prec$1 - len | 0, len);
      return Caml_bytes.bytes_to_string(res$2);
  }
}

function string_to_caml_string(str) {
  const str$1 = Stdlib__String.escaped(str);
  const l = str$1.length;
  const res = Stdlib__Bytes.make(l + 2 | 0, /* '"' */34);
  Caml_bytes.caml_blit_string(str$1, 0, res, 1, l);
  return Caml_bytes.bytes_to_string(res);
}

function format_of_iconv(param) {
  switch (param) {
    case /* Int_pd */ 1 :
      return "%+d";
    case /* Int_sd */ 2 :
      return "% d";
    case /* Int_pi */ 4 :
      return "%+i";
    case /* Int_si */ 5 :
      return "% i";
    case /* Int_x */ 6 :
      return "%x";
    case /* Int_Cx */ 7 :
      return "%#x";
    case /* Int_X */ 8 :
      return "%X";
    case /* Int_CX */ 9 :
      return "%#X";
    case /* Int_o */ 10 :
      return "%o";
    case /* Int_Co */ 11 :
      return "%#o";
    case /* Int_d */ 0 :
    case /* Int_Cd */ 13 :
      return "%d";
    case /* Int_i */ 3 :
    case /* Int_Ci */ 14 :
      return "%i";
    case /* Int_u */ 12 :
    case /* Int_Cu */ 15 :
      return "%u";
  }
}

function format_of_iconvL(param) {
  switch (param) {
    case /* Int_pd */ 1 :
      return "%+Ld";
    case /* Int_sd */ 2 :
      return "% Ld";
    case /* Int_pi */ 4 :
      return "%+Li";
    case /* Int_si */ 5 :
      return "% Li";
    case /* Int_x */ 6 :
      return "%Lx";
    case /* Int_Cx */ 7 :
      return "%#Lx";
    case /* Int_X */ 8 :
      return "%LX";
    case /* Int_CX */ 9 :
      return "%#LX";
    case /* Int_o */ 10 :
      return "%Lo";
    case /* Int_Co */ 11 :
      return "%#Lo";
    case /* Int_d */ 0 :
    case /* Int_Cd */ 13 :
      return "%Ld";
    case /* Int_i */ 3 :
    case /* Int_Ci */ 14 :
      return "%Li";
    case /* Int_u */ 12 :
    case /* Int_Cu */ 15 :
      return "%Lu";
  }
}

function format_of_iconvl(param) {
  switch (param) {
    case /* Int_pd */ 1 :
      return "%+ld";
    case /* Int_sd */ 2 :
      return "% ld";
    case /* Int_pi */ 4 :
      return "%+li";
    case /* Int_si */ 5 :
      return "% li";
    case /* Int_x */ 6 :
      return "%lx";
    case /* Int_Cx */ 7 :
      return "%#lx";
    case /* Int_X */ 8 :
      return "%lX";
    case /* Int_CX */ 9 :
      return "%#lX";
    case /* Int_o */ 10 :
      return "%lo";
    case /* Int_Co */ 11 :
      return "%#lo";
    case /* Int_d */ 0 :
    case /* Int_Cd */ 13 :
      return "%ld";
    case /* Int_i */ 3 :
    case /* Int_Ci */ 14 :
      return "%li";
    case /* Int_u */ 12 :
    case /* Int_Cu */ 15 :
      return "%lu";
  }
}

function format_of_iconvn(param) {
  switch (param) {
    case /* Int_pd */ 1 :
      return "%+nd";
    case /* Int_sd */ 2 :
      return "% nd";
    case /* Int_pi */ 4 :
      return "%+ni";
    case /* Int_si */ 5 :
      return "% ni";
    case /* Int_x */ 6 :
      return "%nx";
    case /* Int_Cx */ 7 :
      return "%#nx";
    case /* Int_X */ 8 :
      return "%nX";
    case /* Int_CX */ 9 :
      return "%#nX";
    case /* Int_o */ 10 :
      return "%no";
    case /* Int_Co */ 11 :
      return "%#no";
    case /* Int_d */ 0 :
    case /* Int_Cd */ 13 :
      return "%nd";
    case /* Int_i */ 3 :
    case /* Int_Ci */ 14 :
      return "%ni";
    case /* Int_u */ 12 :
    case /* Int_Cu */ 15 :
      return "%nu";
  }
}

function format_of_fconv(fconv, prec) {
  const prec$1 = Stdlib.abs(prec);
  const symb = char_of_fconv(/* 'g' */103, fconv);
  const buf = {
    ind: 0,
    bytes: Caml_bytes.caml_create_bytes(16)
  };
  buffer_add_char(buf, /* '%' */37);
  bprint_fconv_flag(buf, fconv);
  buffer_add_char(buf, /* '.' */46);
  buffer_add_string(buf, Caml_format.caml_format_int("%d", prec$1));
  buffer_add_char(buf, symb);
  return buffer_contents(buf);
}

function transform_int_alt(iconv, s) {
  switch (iconv) {
    case /* Int_Cd */ 13 :
    case /* Int_Ci */ 14 :
    case /* Int_Cu */ 15 :
      break;
    default:
      return s;
  }
  let n = 0;
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    const match = s.charCodeAt(i);
    if (!(match > 57 || match < 48)) {
      n = n + 1 | 0;
    }
    
  }
  const digits = n;
  const buf = Caml_bytes.caml_create_bytes(s.length + ((digits - 1 | 0) / 3 | 0) | 0);
  const pos = {
    contents: 0
  };
  const put = function (c) {
    Caml_bytes.set(buf, pos.contents, c);
    pos.contents = pos.contents + 1 | 0;
  };
  let left = (digits - 1 | 0) % 3 + 1 | 0;
  for (let i$1 = 0, i_finish$1 = s.length; i$1 < i_finish$1; ++i$1) {
    const c = s.charCodeAt(i$1);
    if (c > 57 || c < 48) {
      put(c);
    } else {
      if (left === 0) {
        put(/* '_' */95);
        left = 3;
      }
      left = left - 1 | 0;
      put(c);
    }
  }
  return Caml_bytes.bytes_to_string(buf);
}

function convert_int(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_format_int(format_of_iconv(iconv), n));
}

function convert_int32(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_int32_format(format_of_iconvl(iconv), n));
}

function convert_nativeint(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_nativeint_format(format_of_iconvn(iconv), n));
}

function convert_int64(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_int64_format(format_of_iconvL(iconv), n));
}

function convert_float(fconv, prec, x) {
  const hex = function (param) {
    const match = fconv[0];
    let sign;
    switch (match) {
      case /* Float_flag_ */ 0 :
        sign = /* '-' */45;
        break;
      case /* Float_flag_p */ 1 :
        sign = /* '+' */43;
        break;
      case /* Float_flag_s */ 2 :
        sign = /* ' ' */32;
        break;
    }
    return Caml_format.caml_hexstring_of_float(x, prec, sign);
  };
  const add_dot_if_needed = function (str) {
    const len = str.length;
    const is_valid = function (_i) {
      while (true) {
        const i = _i;
        if (i === len) {
          return false;
        }
        const match = Caml_string.get(str, i);
        if (match > 69 || match < 46) {
          if (match === 101) {
            return true;
          }
          _i = i + 1 | 0;
          continue;
        }
        if (match > 68 || match < 47) {
          return true;
        }
        _i = i + 1 | 0;
        continue;
      };
    };
    if (is_valid(0)) {
      return str;
    } else {
      return str + ".";
    }
  };
  const caml_special_val = function (str) {
    const match = Stdlib.classify_float(x);
    switch (match) {
      case /* FP_infinite */ 3 :
        if (x < 0.0) {
          return "neg_infinity";
        } else {
          return "infinity";
        }
      case /* FP_nan */ 4 :
        return "nan";
      default:
        return str;
    }
  };
  const match = fconv[1];
  switch (match) {
    case /* Float_F */ 5 :
      const str = Caml_format.caml_format_float(format_of_fconv(fconv, prec), x);
      return caml_special_val(add_dot_if_needed(str));
    case /* Float_h */ 6 :
      return hex(undefined);
    case /* Float_H */ 7 :
      const s = hex(undefined);
      return Caml_bytes.bytes_to_string(Stdlib__Bytes.uppercase_ascii(Caml_bytes.bytes_of_string(s)));
    case /* Float_CF */ 8 :
      return caml_special_val(hex(undefined));
    default:
      return Caml_format.caml_format_float(format_of_fconv(fconv, prec), x);
  }
}

function format_caml_char(c) {
  const str = Stdlib__Char.escaped(c);
  const l = str.length;
  const res = Stdlib__Bytes.make(l + 2 | 0, /* '\\'' */39);
  Caml_bytes.caml_blit_string(str, 0, res, 1, l);
  return Caml_bytes.bytes_to_string(res);
}

function string_of_fmtty(fmtty) {
  const buf = {
    ind: 0,
    bytes: Caml_bytes.caml_create_bytes(16)
  };
  bprint_fmtty(buf, fmtty);
  return buffer_contents(buf);
}

function make_printf(_k, _acc, _fmt) {
  while (true) {
    const fmt = _fmt;
    const acc = _acc;
    const k = _k;
    if (/* tag */ typeof fmt === "number" || typeof fmt === "string") {
      return Curry._1(k, acc);
    }
    switch (fmt.TAG) {
      case /* Char */ 0 :
        const rest = fmt._0;
        return function (c) {
          const new_acc = {
            TAG: /* Acc_data_char */ 5,
            _0: acc,
            _1: c
          };
          return make_printf(k, new_acc, rest);
        };
      case /* Caml_char */ 1 :
        const rest$1 = fmt._0;
        return function (c) {
          const new_acc_1 = format_caml_char(c);
          const new_acc = {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: new_acc_1
          };
          return make_printf(k, new_acc, rest$1);
        };
      case /* String */ 2 :
        return make_padding(k, acc, fmt._1, fmt._0, (function (str) {
          return str;
        }));
      case /* Caml_string */ 3 :
        return make_padding(k, acc, fmt._1, fmt._0, string_to_caml_string);
      case /* Int */ 4 :
        return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_int, fmt._0);
      case /* Int32 */ 5 :
        return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_int32, fmt._0);
      case /* Nativeint */ 6 :
        return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_nativeint, fmt._0);
      case /* Int64 */ 7 :
        return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_int64, fmt._0);
      case /* Float */ 8 :
        let fmt$1 = fmt._3;
        let pad = fmt._1;
        let prec = fmt._2;
        let fconv = fmt._0;
        if (/* tag */ typeof pad === "number" || typeof pad === "string") {
          if (/* tag */ typeof prec === "number" || typeof prec === "string") {
            if (prec === /* No_precision */ 0) {
              return function (x) {
                const str = convert_float(fconv, default_float_precision(fconv), x);
                return make_printf(k, {
                  TAG: /* Acc_data_string */ 4,
                  _0: acc,
                  _1: str
                }, fmt$1);
              };
            } else {
              return function (p, x) {
                const str = convert_float(fconv, p, x);
                return make_printf(k, {
                  TAG: /* Acc_data_string */ 4,
                  _0: acc,
                  _1: str
                }, fmt$1);
              };
            }
          }
          const p = prec._0;
          return function (x) {
            const str = convert_float(fconv, p, x);
            return make_printf(k, {
              TAG: /* Acc_data_string */ 4,
              _0: acc,
              _1: str
            }, fmt$1);
          };
        }
        if (pad.TAG === /* Lit_padding */ 0) {
          const w = pad._1;
          const padty = pad._0;
          if (/* tag */ typeof prec === "number" || typeof prec === "string") {
            if (prec === /* No_precision */ 0) {
              return function (x) {
                const str = convert_float(fconv, default_float_precision(fconv), x);
                const str$p = fix_padding(padty, w, str);
                return make_printf(k, {
                  TAG: /* Acc_data_string */ 4,
                  _0: acc,
                  _1: str$p
                }, fmt$1);
              };
            } else {
              return function (p, x) {
                const str = fix_padding(padty, w, convert_float(fconv, p, x));
                return make_printf(k, {
                  TAG: /* Acc_data_string */ 4,
                  _0: acc,
                  _1: str
                }, fmt$1);
              };
            }
          }
          const p$1 = prec._0;
          return function (x) {
            const str = fix_padding(padty, w, convert_float(fconv, p$1, x));
            return make_printf(k, {
              TAG: /* Acc_data_string */ 4,
              _0: acc,
              _1: str
            }, fmt$1);
          };
        }
        const padty$1 = pad._0;
        if (/* tag */ typeof prec === "number" || typeof prec === "string") {
          if (prec === /* No_precision */ 0) {
            return function (w, x) {
              const str = convert_float(fconv, default_float_precision(fconv), x);
              const str$p = fix_padding(padty$1, w, str);
              return make_printf(k, {
                TAG: /* Acc_data_string */ 4,
                _0: acc,
                _1: str$p
              }, fmt$1);
            };
          } else {
            return function (w, p, x) {
              const str = fix_padding(padty$1, w, convert_float(fconv, p, x));
              return make_printf(k, {
                TAG: /* Acc_data_string */ 4,
                _0: acc,
                _1: str
              }, fmt$1);
            };
          }
        }
        const p$2 = prec._0;
        return function (w, x) {
          const str = fix_padding(padty$1, w, convert_float(fconv, p$2, x));
          return make_printf(k, {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: str
          }, fmt$1);
        };
      case /* Bool */ 9 :
        return make_padding(k, acc, fmt._1, fmt._0, Stdlib.string_of_bool);
      case /* Flush */ 10 :
        _fmt = fmt._0;
        _acc = {
          TAG: /* Acc_flush */ 7,
          _0: acc
        };
        continue;
      case /* String_literal */ 11 :
        _fmt = fmt._1;
        _acc = {
          TAG: /* Acc_string_literal */ 2,
          _0: acc,
          _1: fmt._0
        };
        continue;
      case /* Char_literal */ 12 :
        _fmt = fmt._1;
        _acc = {
          TAG: /* Acc_char_literal */ 3,
          _0: acc,
          _1: fmt._0
        };
        continue;
      case /* Format_arg */ 13 :
        const rest$2 = fmt._2;
        const ty = string_of_fmtty(fmt._1);
        return function (str) {
          return make_printf(k, {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: ty
          }, rest$2);
        };
      case /* Format_subst */ 14 :
        const rest$3 = fmt._2;
        const fmtty = fmt._1;
        return function (param) {
          return make_printf(k, acc, CamlinternalFormatBasics.concat_fmt(recast(param._0, fmtty), rest$3));
        };
      case /* Alpha */ 15 :
        const rest$4 = fmt._0;
        return function (f, x) {
          return make_printf(k, {
            TAG: /* Acc_delay */ 6,
            _0: acc,
            _1: (function (o) {
              return Curry._2(f, o, x);
            })
          }, rest$4);
        };
      case /* Theta */ 16 :
        const rest$5 = fmt._0;
        return function (f) {
          return make_printf(k, {
            TAG: /* Acc_delay */ 6,
            _0: acc,
            _1: f
          }, rest$5);
        };
      case /* Formatting_lit */ 17 :
        _fmt = fmt._1;
        _acc = {
          TAG: /* Acc_formatting_lit */ 0,
          _0: acc,
          _1: fmt._0
        };
        continue;
      case /* Formatting_gen */ 18 :
        const match = fmt._0;
        if (match.TAG === /* Open_tag */ 0) {
          const rest$6 = fmt._1;
          const k$p = function (kacc) {
            return make_printf(k, {
              TAG: /* Acc_formatting_gen */ 1,
              _0: acc,
              _1: {
                TAG: /* Acc_open_tag */ 0,
                _0: kacc
              }
            }, rest$6);
          };
          _fmt = match._0._0;
          _acc = /* End_of_acc */ 0;
          _k = k$p;
          continue;
        }
        const rest$7 = fmt._1;
        const k$p$1 = function (kacc) {
          return make_printf(k, {
            TAG: /* Acc_formatting_gen */ 1,
            _0: acc,
            _1: {
              TAG: /* Acc_open_box */ 1,
              _0: kacc
            }
          }, rest$7);
        };
        _fmt = match._0._0;
        _acc = /* End_of_acc */ 0;
        _k = k$p$1;
        continue;
      case /* Reader */ 19 :
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                1558,
                4
              ]
            });
      case /* Scan_char_set */ 20 :
        const rest$8 = fmt._2;
        const new_acc = {
          TAG: /* Acc_invalid_arg */ 8,
          _0: acc,
          _1: "Printf: bad conversion %["
        };
        return function (param) {
          return make_printf(k, new_acc, rest$8);
        };
      case /* Scan_get_counter */ 21 :
        const rest$9 = fmt._1;
        return function (n) {
          const new_acc_1 = Caml_format.caml_format_int("%u", n);
          const new_acc = {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: new_acc_1
          };
          return make_printf(k, new_acc, rest$9);
        };
      case /* Scan_next_char */ 22 :
        const rest$10 = fmt._0;
        return function (c) {
          const new_acc = {
            TAG: /* Acc_data_char */ 5,
            _0: acc,
            _1: c
          };
          return make_printf(k, new_acc, rest$10);
        };
      case /* Ignored_param */ 23 :
        return make_ignored_param(k, acc, fmt._0, fmt._1);
      case /* Custom */ 24 :
        return make_custom(k, acc, fmt._2, fmt._0, Curry._1(fmt._1, undefined));
    }
  };
}

function make_ignored_param(k, acc, ign, fmt) {
  if (!/* tag */ (typeof ign === "number" || typeof ign === "string")) {
    if (ign.TAG === /* Ignored_format_subst */ 9) {
      return make_from_fmtty(k, acc, ign._1, fmt);
    } else {
      return make_invalid_arg(k, acc, fmt);
    }
  }
  if (ign !== /* Ignored_reader */ 2) {
    return make_invalid_arg(k, acc, fmt);
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalFormat.cppo.ml",
          1626,
          39
        ]
      });
}

function make_from_fmtty(k, acc, fmtty, fmt) {
  if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
    return make_invalid_arg(k, acc, fmt);
  }
  switch (fmtty.TAG) {
    case /* Char_ty */ 0 :
      const rest = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest, fmt);
      };
    case /* String_ty */ 1 :
      const rest$1 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$1, fmt);
      };
    case /* Int_ty */ 2 :
      const rest$2 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$2, fmt);
      };
    case /* Int32_ty */ 3 :
      const rest$3 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$3, fmt);
      };
    case /* Nativeint_ty */ 4 :
      const rest$4 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$4, fmt);
      };
    case /* Int64_ty */ 5 :
      const rest$5 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$5, fmt);
      };
    case /* Float_ty */ 6 :
      const rest$6 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$6, fmt);
      };
    case /* Bool_ty */ 7 :
      const rest$7 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$7, fmt);
      };
    case /* Format_arg_ty */ 8 :
      const rest$8 = fmtty._1;
      return function (param) {
        return make_from_fmtty(k, acc, rest$8, fmt);
      };
    case /* Format_subst_ty */ 9 :
      const rest$9 = fmtty._2;
      const ty = trans(symm(fmtty._0), fmtty._1);
      return function (param) {
        return make_from_fmtty(k, acc, CamlinternalFormatBasics.concat_fmtty(ty, rest$9), fmt);
      };
    case /* Alpha_ty */ 10 :
      const rest$10 = fmtty._0;
      return function (param, param$1) {
        return make_from_fmtty(k, acc, rest$10, fmt);
      };
    case /* Theta_ty */ 11 :
      const rest$11 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$11, fmt);
      };
    case /* Any_ty */ 12 :
      const rest$12 = fmtty._0;
      return function (param) {
        return make_from_fmtty(k, acc, rest$12, fmt);
      };
    case /* Reader_ty */ 13 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              1649,
              31
            ]
          });
    case /* Ignored_reader_ty */ 14 :
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              1650,
              31
            ]
          });
  }
}

function make_invalid_arg(k, acc, fmt) {
  return make_printf(k, {
    TAG: /* Acc_invalid_arg */ 8,
    _0: acc,
    _1: "Printf: bad conversion %_"
  }, fmt);
}

function make_padding(k, acc, fmt, pad, trans) {
  if (/* tag */ typeof pad === "number" || typeof pad === "string") {
    return function (x) {
      const new_acc_1 = Curry._1(trans, x);
      const new_acc = {
        TAG: /* Acc_data_string */ 4,
        _0: acc,
        _1: new_acc_1
      };
      return make_printf(k, new_acc, fmt);
    };
  }
  if (pad.TAG === /* Lit_padding */ 0) {
    const width = pad._1;
    const padty = pad._0;
    return function (x) {
      const new_acc_1 = fix_padding(padty, width, Curry._1(trans, x));
      const new_acc = {
        TAG: /* Acc_data_string */ 4,
        _0: acc,
        _1: new_acc_1
      };
      return make_printf(k, new_acc, fmt);
    };
  }
  const padty$1 = pad._0;
  return function (w, x) {
    const new_acc_1 = fix_padding(padty$1, w, Curry._1(trans, x));
    const new_acc = {
      TAG: /* Acc_data_string */ 4,
      _0: acc,
      _1: new_acc_1
    };
    return make_printf(k, new_acc, fmt);
  };
}

function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv) {
  if (/* tag */ typeof pad === "number" || typeof pad === "string") {
    if (/* tag */ typeof prec === "number" || typeof prec === "string") {
      if (prec === /* No_precision */ 0) {
        return function (x) {
          const str = Curry._2(trans, iconv, x);
          return make_printf(k, {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: str
          }, fmt);
        };
      } else {
        return function (p, x) {
          const str = fix_int_precision(p, Curry._2(trans, iconv, x));
          return make_printf(k, {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: str
          }, fmt);
        };
      }
    }
    const p = prec._0;
    return function (x) {
      const str = fix_int_precision(p, Curry._2(trans, iconv, x));
      return make_printf(k, {
        TAG: /* Acc_data_string */ 4,
        _0: acc,
        _1: str
      }, fmt);
    };
  }
  if (pad.TAG === /* Lit_padding */ 0) {
    const w = pad._1;
    const padty = pad._0;
    if (/* tag */ typeof prec === "number" || typeof prec === "string") {
      if (prec === /* No_precision */ 0) {
        return function (x) {
          const str = fix_padding(padty, w, Curry._2(trans, iconv, x));
          return make_printf(k, {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: str
          }, fmt);
        };
      } else {
        return function (p, x) {
          const str = fix_padding(padty, w, fix_int_precision(p, Curry._2(trans, iconv, x)));
          return make_printf(k, {
            TAG: /* Acc_data_string */ 4,
            _0: acc,
            _1: str
          }, fmt);
        };
      }
    }
    const p$1 = prec._0;
    return function (x) {
      const str = fix_padding(padty, w, fix_int_precision(p$1, Curry._2(trans, iconv, x)));
      return make_printf(k, {
        TAG: /* Acc_data_string */ 4,
        _0: acc,
        _1: str
      }, fmt);
    };
  }
  const padty$1 = pad._0;
  if (/* tag */ typeof prec === "number" || typeof prec === "string") {
    if (prec === /* No_precision */ 0) {
      return function (w, x) {
        const str = fix_padding(padty$1, w, Curry._2(trans, iconv, x));
        return make_printf(k, {
          TAG: /* Acc_data_string */ 4,
          _0: acc,
          _1: str
        }, fmt);
      };
    } else {
      return function (w, p, x) {
        const str = fix_padding(padty$1, w, fix_int_precision(p, Curry._2(trans, iconv, x)));
        return make_printf(k, {
          TAG: /* Acc_data_string */ 4,
          _0: acc,
          _1: str
        }, fmt);
      };
    }
  }
  const p$2 = prec._0;
  return function (w, x) {
    const str = fix_padding(padty$1, w, fix_int_precision(p$2, Curry._2(trans, iconv, x)));
    return make_printf(k, {
      TAG: /* Acc_data_string */ 4,
      _0: acc,
      _1: str
    }, fmt);
  };
}

function make_custom(k, acc, rest, arity, f) {
  if (/* tag */ typeof arity === "number" || typeof arity === "string") {
    return make_printf(k, {
      TAG: /* Acc_data_string */ 4,
      _0: acc,
      _1: f
    }, rest);
  }
  const arity$1 = arity._0;
  return function (x) {
    return make_custom(k, acc, rest, arity$1, Curry._1(f, x));
  };
}

function make_iprintf(_k, o, _fmt) {
  while (true) {
    const fmt = _fmt;
    const k = _k;
    let exit = 0;
    if (/* tag */ typeof fmt === "number" || typeof fmt === "string") {
      return Curry._1(k, o);
    }
    switch (fmt.TAG) {
      case /* String */ 2 :
        let exit$1 = 0;
        let tmp = fmt._0;
        if (/* tag */ typeof tmp === "number" || typeof tmp === "string" || tmp.TAG === /* Lit_padding */ 0) {
          exit$1 = 4;
        } else {
          const partial_arg = make_iprintf(k, o, fmt._1);
          const partial_arg$1 = function (param) {
            return partial_arg;
          };
          return function (param) {
            return partial_arg$1;
          };
        }
        if (exit$1 === 4) {
          const partial_arg$2 = make_iprintf(k, o, fmt._1);
          return function (param) {
            return partial_arg$2;
          };
        }
        break;
      case /* Caml_string */ 3 :
        let exit$2 = 0;
        let tmp$1 = fmt._0;
        if (/* tag */ typeof tmp$1 === "number" || typeof tmp$1 === "string" || tmp$1.TAG === /* Lit_padding */ 0) {
          exit$2 = 4;
        } else {
          const partial_arg$3 = make_iprintf(k, o, fmt._1);
          const partial_arg$4 = function (param) {
            return partial_arg$3;
          };
          return function (param) {
            return partial_arg$4;
          };
        }
        if (exit$2 === 4) {
          const partial_arg$5 = make_iprintf(k, o, fmt._1);
          return function (param) {
            return partial_arg$5;
          };
        }
        break;
      case /* Bool */ 9 :
        let exit$3 = 0;
        let tmp$2 = fmt._0;
        if (/* tag */ typeof tmp$2 === "number" || typeof tmp$2 === "string" || tmp$2.TAG === /* Lit_padding */ 0) {
          exit$3 = 4;
        } else {
          const partial_arg$6 = make_iprintf(k, o, fmt._1);
          const partial_arg$7 = function (param) {
            return partial_arg$6;
          };
          return function (param) {
            return partial_arg$7;
          };
        }
        if (exit$3 === 4) {
          const partial_arg$8 = make_iprintf(k, o, fmt._1);
          return function (param) {
            return partial_arg$8;
          };
        }
        break;
      case /* Flush */ 10 :
        _fmt = fmt._0;
        continue;
      case /* Format_subst */ 14 :
        const rest = fmt._2;
        const fmtty = fmt._1;
        return function (param) {
          return make_iprintf(k, o, CamlinternalFormatBasics.concat_fmt(recast(param._0, fmtty), rest));
        };
      case /* Alpha */ 15 :
        const partial_arg$9 = make_iprintf(k, o, fmt._0);
        const partial_arg$10 = function (param) {
          return partial_arg$9;
        };
        return function (param) {
          return partial_arg$10;
        };
      case /* String_literal */ 11 :
      case /* Char_literal */ 12 :
      case /* Formatting_lit */ 17 :
        exit = 2;
        break;
      case /* Formatting_gen */ 18 :
        const match = fmt._0;
        if (match.TAG === /* Open_tag */ 0) {
          const rest$1 = fmt._1;
          _fmt = match._0._0;
          _k = (function (koc) {
            return make_iprintf(k, koc, rest$1);
          });
          continue;
        }
        const rest$2 = fmt._1;
        _fmt = match._0._0;
        _k = (function (koc) {
          return make_iprintf(k, koc, rest$2);
        });
        continue;
      case /* Reader */ 19 :
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                1830,
                8
              ]
            });
      case /* Format_arg */ 13 :
      case /* Scan_char_set */ 20 :
        exit = 3;
        break;
      case /* Scan_get_counter */ 21 :
        const partial_arg$11 = make_iprintf(k, o, fmt._1);
        return function (param) {
          return partial_arg$11;
        };
      case /* Char */ 0 :
      case /* Caml_char */ 1 :
      case /* Theta */ 16 :
      case /* Scan_next_char */ 22 :
        exit = 1;
        break;
      case /* Ignored_param */ 23 :
        return make_ignored_param((function (param) {
          return Curry._1(k, o);
        }), /* End_of_acc */ 0, fmt._0, fmt._1);
      case /* Custom */ 24 :
        return fn_of_custom_arity(k, o, fmt._2, fmt._0);
      default:
        let fmt$1 = fmt._3;
        let pad = fmt._1;
        let prec = fmt._2;
        if (/* tag */ typeof pad === "number" || typeof pad === "string") {
          if (/* tag */ typeof prec === "number" || typeof prec === "string") {
            if (prec === /* No_precision */ 0) {
              const partial_arg$12 = make_iprintf(k, o, fmt$1);
              return function (param) {
                return partial_arg$12;
              };
            }
            const partial_arg$13 = make_iprintf(k, o, fmt$1);
            const partial_arg$14 = function (param) {
              return partial_arg$13;
            };
            return function (param) {
              return partial_arg$14;
            };
          } else {
            const partial_arg$15 = make_iprintf(k, o, fmt$1);
            return function (param) {
              return partial_arg$15;
            };
          }
        } else if (pad.TAG === /* Lit_padding */ 0) {
          if (/* tag */ typeof prec === "number" || typeof prec === "string") {
            if (prec === /* No_precision */ 0) {
              const partial_arg$16 = make_iprintf(k, o, fmt$1);
              return function (param) {
                return partial_arg$16;
              };
            }
            const partial_arg$17 = make_iprintf(k, o, fmt$1);
            const partial_arg$18 = function (param) {
              return partial_arg$17;
            };
            return function (param) {
              return partial_arg$18;
            };
          } else {
            const partial_arg$19 = make_iprintf(k, o, fmt$1);
            return function (param) {
              return partial_arg$19;
            };
          }
        } else if (/* tag */ typeof prec === "number" || typeof prec === "string") {
          if (prec === /* No_precision */ 0) {
            const partial_arg$20 = make_iprintf(k, o, fmt$1);
            const partial_arg$21 = function (param) {
              return partial_arg$20;
            };
            return function (param) {
              return partial_arg$21;
            };
          }
          const partial_arg$22 = make_iprintf(k, o, fmt$1);
          const partial_arg$23 = function (param) {
            return partial_arg$22;
          };
          const partial_arg$24 = function (param) {
            return partial_arg$23;
          };
          return function (param) {
            return partial_arg$24;
          };
        } else {
          const partial_arg$25 = make_iprintf(k, o, fmt$1);
          const partial_arg$26 = function (param) {
            return partial_arg$25;
          };
          return function (param) {
            return partial_arg$26;
          };
        }
    }
    switch (exit) {
      case 1 :
        const partial_arg$27 = make_iprintf(k, o, fmt._0);
        return function (param) {
          return partial_arg$27;
        };
      case 2 :
        _fmt = fmt._1;
        continue;
      case 3 :
        const partial_arg$28 = make_iprintf(k, o, fmt._2);
        return function (param) {
          return partial_arg$28;
        };
    }
  };
}

function fn_of_custom_arity(k, o, fmt, arity) {
  if (/* tag */ typeof arity === "number" || typeof arity === "string") {
    return make_iprintf(k, o, fmt);
  }
  const partial_arg = fn_of_custom_arity(k, o, fmt, arity._0);
  return function (param) {
    return partial_arg;
  };
}

function output_acc(o, _acc) {
  while (true) {
    const acc = _acc;
    let exit = 0;
    if (/* tag */ typeof acc === "number" || typeof acc === "string") {
      return;
    }
    switch (acc.TAG) {
      case /* Acc_formatting_lit */ 0 :
        const s = string_of_formatting_lit(acc._1);
        output_acc(o, acc._0);
        return Stdlib.output_string(o, s);
      case /* Acc_formatting_gen */ 1 :
        const acc$p = acc._1;
        const p = acc._0;
        if (acc$p.TAG === /* Acc_open_tag */ 0) {
          output_acc(o, p);
          Stdlib.output_string(o, "@{");
          _acc = acc$p._0;
          continue;
        }
        output_acc(o, p);
        Stdlib.output_string(o, "@[");
        _acc = acc$p._0;
        continue;
      case /* Acc_string_literal */ 2 :
      case /* Acc_data_string */ 4 :
        exit = 1;
        break;
      case /* Acc_char_literal */ 3 :
      case /* Acc_data_char */ 5 :
        exit = 2;
        break;
      case /* Acc_delay */ 6 :
        output_acc(o, acc._0);
        return Curry._1(acc._1, o);
      case /* Acc_flush */ 7 :
        output_acc(o, acc._0);
        return Caml_io.caml_ml_flush(o);
      case /* Acc_invalid_arg */ 8 :
        output_acc(o, acc._0);
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: acc._1
            });
    }
    switch (exit) {
      case 1 :
        output_acc(o, acc._0);
        return Stdlib.output_string(o, acc._1);
      case 2 :
        output_acc(o, acc._0);
        return Caml_io.caml_ml_output_char(o, acc._1);
    }
  };
}

function bufput_acc(b, _acc) {
  while (true) {
    const acc = _acc;
    let exit = 0;
    if (/* tag */ typeof acc === "number" || typeof acc === "string") {
      return;
    }
    switch (acc.TAG) {
      case /* Acc_formatting_lit */ 0 :
        const s = string_of_formatting_lit(acc._1);
        bufput_acc(b, acc._0);
        return Stdlib__Buffer.add_string(b, s);
      case /* Acc_formatting_gen */ 1 :
        const acc$p = acc._1;
        const p = acc._0;
        if (acc$p.TAG === /* Acc_open_tag */ 0) {
          bufput_acc(b, p);
          Stdlib__Buffer.add_string(b, "@{");
          _acc = acc$p._0;
          continue;
        }
        bufput_acc(b, p);
        Stdlib__Buffer.add_string(b, "@[");
        _acc = acc$p._0;
        continue;
      case /* Acc_string_literal */ 2 :
      case /* Acc_data_string */ 4 :
        exit = 1;
        break;
      case /* Acc_char_literal */ 3 :
      case /* Acc_data_char */ 5 :
        exit = 2;
        break;
      case /* Acc_delay */ 6 :
        bufput_acc(b, acc._0);
        return Curry._1(acc._1, b);
      case /* Acc_flush */ 7 :
        _acc = acc._0;
        continue;
      case /* Acc_invalid_arg */ 8 :
        bufput_acc(b, acc._0);
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: acc._1
            });
    }
    switch (exit) {
      case 1 :
        bufput_acc(b, acc._0);
        return Stdlib__Buffer.add_string(b, acc._1);
      case 2 :
        bufput_acc(b, acc._0);
        return Stdlib__Buffer.add_char(b, acc._1);
    }
  };
}

function strput_acc(b, _acc) {
  while (true) {
    const acc = _acc;
    let exit = 0;
    if (/* tag */ typeof acc === "number" || typeof acc === "string") {
      return;
    }
    switch (acc.TAG) {
      case /* Acc_formatting_lit */ 0 :
        const s = string_of_formatting_lit(acc._1);
        strput_acc(b, acc._0);
        return Stdlib__Buffer.add_string(b, s);
      case /* Acc_formatting_gen */ 1 :
        const acc$p = acc._1;
        const p = acc._0;
        if (acc$p.TAG === /* Acc_open_tag */ 0) {
          strput_acc(b, p);
          Stdlib__Buffer.add_string(b, "@{");
          _acc = acc$p._0;
          continue;
        }
        strput_acc(b, p);
        Stdlib__Buffer.add_string(b, "@[");
        _acc = acc$p._0;
        continue;
      case /* Acc_string_literal */ 2 :
      case /* Acc_data_string */ 4 :
        exit = 1;
        break;
      case /* Acc_char_literal */ 3 :
      case /* Acc_data_char */ 5 :
        exit = 2;
        break;
      case /* Acc_delay */ 6 :
        strput_acc(b, acc._0);
        return Stdlib__Buffer.add_string(b, Curry._1(acc._1, undefined));
      case /* Acc_flush */ 7 :
        _acc = acc._0;
        continue;
      case /* Acc_invalid_arg */ 8 :
        strput_acc(b, acc._0);
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: acc._1
            });
    }
    switch (exit) {
      case 1 :
        strput_acc(b, acc._0);
        return Stdlib__Buffer.add_string(b, acc._1);
      case 2 :
        strput_acc(b, acc._0);
        return Stdlib__Buffer.add_char(b, acc._1);
    }
  };
}

function failwith_message(param) {
  const buf = Stdlib__Buffer.create(256);
  const k = function (acc) {
    strput_acc(buf, acc);
    const s = Stdlib__Buffer.contents(buf);
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: s
        });
  };
  return make_printf(k, /* End_of_acc */ 0, param._0);
}

function open_box_of_string(str) {
  if (str === "") {
    return [
      0,
      /* Pp_box */ 4
    ];
  }
  const len = str.length;
  const invalid_box = function (param) {
    return Curry._1(failwith_message({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "invalid box description ",
        _1: {
          TAG: /* Caml_string */ 3,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        }
      },
      _1: "invalid box description %S"
    }), str);
  };
  const parse_spaces = function (_i) {
    while (true) {
      const i = _i;
      if (i === len) {
        return i;
      }
      const match = Caml_string.get(str, i);
      if (match !== 9) {
        if (match !== 32) {
          return i;
        }
        _i = i + 1 | 0;
        continue;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const parse_lword = function (i, _j) {
    while (true) {
      const j = _j;
      if (j === len) {
        return j;
      }
      const match = Caml_string.get(str, j);
      if (match > 122 || match < 97) {
        return j;
      }
      _j = j + 1 | 0;
      continue;
    };
  };
  const parse_int = function (i, _j) {
    while (true) {
      const j = _j;
      if (j === len) {
        return j;
      }
      const match = Caml_string.get(str, j);
      if (match >= 48) {
        if (match >= 58) {
          return j;
        }
        _j = j + 1 | 0;
        continue;
      }
      if (match !== 45) {
        return j;
      }
      _j = j + 1 | 0;
      continue;
    };
  };
  const wstart = parse_spaces(0);
  const wend = parse_lword(wstart, wstart);
  const box_name = Stdlib__String.sub(str, wstart, wend - wstart | 0);
  const nstart = parse_spaces(wend);
  const nend = parse_int(nstart, nstart);
  let indent;
  if (nstart === nend) {
    indent = 0;
  } else {
    try {
      indent = Caml_format.caml_int_of_string(Stdlib__String.sub(str, nstart, nend - nstart | 0));
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Failure) {
        indent = invalid_box(undefined);
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
  }
  const exp_end = parse_spaces(nend);
  if (exp_end !== len) {
    invalid_box(undefined);
  }
  let box_type;
  switch (box_name) {
    case "" :
    case "b" :
      box_type = /* Pp_box */ 4;
      break;
    case "h" :
      box_type = /* Pp_hbox */ 0;
      break;
    case "hov" :
      box_type = /* Pp_hovbox */ 3;
      break;
    case "hv" :
      box_type = /* Pp_hvbox */ 2;
      break;
    case "v" :
      box_type = /* Pp_vbox */ 1;
      break;
    default:
      box_type = invalid_box(undefined);
  }
  return [
    indent,
    box_type
  ];
}

function make_padding_fmt_ebb(pad, fmt) {
  if (/* tag */ typeof pad === "number" || typeof pad === "string") {
    return {
      TAG: /* Padding_fmt_EBB */ 0,
      _0: /* No_padding */ 0,
      _1: fmt
    };
  } else if (pad.TAG === /* Lit_padding */ 0) {
    return {
      TAG: /* Padding_fmt_EBB */ 0,
      _0: {
        TAG: /* Lit_padding */ 0,
        _0: pad._0,
        _1: pad._1
      },
      _1: fmt
    };
  } else {
    return {
      TAG: /* Padding_fmt_EBB */ 0,
      _0: {
        TAG: /* Arg_padding */ 1,
        _0: pad._0
      },
      _1: fmt
    };
  }
}

function make_precision_fmt_ebb(prec, fmt) {
  if (/* tag */ typeof prec === "number" || typeof prec === "string") {
    if (prec === /* No_precision */ 0) {
      return {
        TAG: /* Precision_fmt_EBB */ 0,
        _0: /* No_precision */ 0,
        _1: fmt
      };
    } else {
      return {
        TAG: /* Precision_fmt_EBB */ 0,
        _0: /* Arg_precision */ 1,
        _1: fmt
      };
    }
  } else {
    return {
      TAG: /* Precision_fmt_EBB */ 0,
      _0: {
        TAG: /* Lit_precision */ 0,
        _0: prec._0
      },
      _1: fmt
    };
  }
}

function make_padprec_fmt_ebb(pad, prec, fmt) {
  const match = make_precision_fmt_ebb(prec, fmt);
  const fmt$p = match._1;
  const prec$1 = match._0;
  if (/* tag */ typeof pad === "number" || typeof pad === "string") {
    return {
      TAG: /* Padprec_fmt_EBB */ 0,
      _0: /* No_padding */ 0,
      _1: prec$1,
      _2: fmt$p
    };
  } else if (pad.TAG === /* Lit_padding */ 0) {
    return {
      TAG: /* Padprec_fmt_EBB */ 0,
      _0: {
        TAG: /* Lit_padding */ 0,
        _0: pad._0,
        _1: pad._1
      },
      _1: prec$1,
      _2: fmt$p
    };
  } else {
    return {
      TAG: /* Padprec_fmt_EBB */ 0,
      _0: {
        TAG: /* Arg_padding */ 1,
        _0: pad._0
      },
      _1: prec$1,
      _2: fmt$p
    };
  }
}

function fmt_ebb_of_string(legacy_behavior, str) {
  const legacy_behavior$1 = legacy_behavior !== undefined ? legacy_behavior : true;
  const invalid_format_message = function (str_ind, msg) {
    return Curry._3(failwith_message({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "invalid format ",
        _1: {
          TAG: /* Caml_string */ 3,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": at character number ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ", ",
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: /* End_of_format */ 0
                }
              }
            }
          }
        }
      },
      _1: "invalid format %S: at character number %d, %s"
    }), str, str_ind, msg);
  };
  const invalid_format_without = function (str_ind, c, s) {
    return Curry._4(failwith_message({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "invalid format ",
        _1: {
          TAG: /* Caml_string */ 3,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": at character number ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ", '",
                _1: {
                  TAG: /* Char */ 0,
                  _0: {
                    TAG: /* String_literal */ 11,
                    _0: "' without ",
                    _1: {
                      TAG: /* String */ 2,
                      _0: /* No_padding */ 0,
                      _1: /* End_of_format */ 0
                    }
                  }
                }
              }
            }
          }
        }
      },
      _1: "invalid format %S: at character number %d, '%c' without %s"
    }), str, str_ind, c, s);
  };
  const expected_character = function (str_ind, expected, read) {
    return Curry._4(failwith_message({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "invalid format ",
        _1: {
          TAG: /* Caml_string */ 3,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": at character number ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ", ",
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* String_literal */ 11,
                    _0: " expected, read ",
                    _1: {
                      TAG: /* Caml_char */ 1,
                      _0: /* End_of_format */ 0
                    }
                  }
                }
              }
            }
          }
        }
      },
      _1: "invalid format %S: at character number %d, %s expected, read %C"
    }), str, str_ind, expected, read);
  };
  const parse_literal = function (lit_start, _str_ind, end_ind) {
    while (true) {
      const str_ind = _str_ind;
      if (str_ind === end_ind) {
        return add_literal(lit_start, str_ind, /* End_of_format */ 0);
      }
      const match = Caml_string.get(str, str_ind);
      if (match !== 37) {
        if (match !== 64) {
          _str_ind = str_ind + 1 | 0;
          continue;
        }
        const fmt_rest = parse_after_at(str_ind + 1 | 0, end_ind);
        return add_literal(lit_start, str_ind, fmt_rest._0);
      }
      const fmt_rest$1 = parse_format(str_ind, end_ind);
      return add_literal(lit_start, str_ind, fmt_rest$1._0);
    };
  };
  const parse_after_at = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      return {
        TAG: /* Fmt_EBB */ 0,
        _0: {
          TAG: /* Char_literal */ 12,
          _0: /* '@' */64,
          _1: /* End_of_format */ 0
        }
      };
    }
    const c = Caml_string.get(str, str_ind);
    if (c >= 65) {
      if (c >= 94) {
        switch (c) {
          case 123 :
            return parse_tag(true, str_ind + 1 | 0, end_ind);
          case 125 :
            const beg_ind = str_ind + 1 | 0;
            const fmt_rest = parse_literal(beg_ind, beg_ind, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: /* Close_tag */ 1,
                _1: fmt_rest._0
              }
            };
        }
      } else if (c >= 91) {
        switch (c) {
          case 91 :
            return parse_tag(false, str_ind + 1 | 0, end_ind);
          case 92 :
            break;
          case 93 :
            const beg_ind$1 = str_ind + 1 | 0;
            const fmt_rest$1 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: /* Close_box */ 0,
                _1: fmt_rest$1._0
              }
            };
        }
      }
      
    } else if (c !== 10) {
      if (c >= 32) {
        switch (c) {
          case 32 :
            const beg_ind$2 = str_ind + 1 | 0;
            const fmt_rest$2 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: {
                  TAG: /* Break */ 0,
                  _0: "@ ",
                  _1: 1,
                  _2: 0
                },
                _1: fmt_rest$2._0
              }
            };
          case 37 :
            if ((str_ind + 1 | 0) < end_ind && Caml_string.get(str, str_ind + 1 | 0) === /* '%' */37) {
              const beg_ind$3 = str_ind + 2 | 0;
              const fmt_rest$3 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
              return {
                TAG: /* Fmt_EBB */ 0,
                _0: {
                  TAG: /* Formatting_lit */ 17,
                  _0: /* Escaped_percent */ 6,
                  _1: fmt_rest$3._0
                }
              };
            }
            const fmt_rest$4 = parse_literal(str_ind, str_ind, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Char_literal */ 12,
                _0: /* '@' */64,
                _1: fmt_rest$4._0
              }
            };
          case 44 :
            const beg_ind$4 = str_ind + 1 | 0;
            const fmt_rest$5 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: {
                  TAG: /* Break */ 0,
                  _0: "@,",
                  _1: 0,
                  _2: 0
                },
                _1: fmt_rest$5._0
              }
            };
          case 46 :
            const beg_ind$5 = str_ind + 1 | 0;
            const fmt_rest$6 = parse_literal(beg_ind$5, beg_ind$5, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: /* Flush_newline */ 4,
                _1: fmt_rest$6._0
              }
            };
          case 59 :
            let str_ind$1 = str_ind + 1 | 0;
            let match;
            try {
              if (str_ind$1 === end_ind || Caml_string.get(str, str_ind$1) !== /* '<' */60) {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                      MEL_EXN_ID: Stdlib.Not_found
                    });
              }
              const str_ind_1 = parse_spaces(str_ind$1 + 1 | 0, end_ind);
              const match$1 = Caml_string.get(str, str_ind_1);
              let exit = 0;
              if (match$1 >= 48) {
                if (match$1 >= 58) {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
                }
                exit = 1;
              } else {
                if (match$1 !== 45) {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
                }
                exit = 1;
              }
              if (exit === 1) {
                const match$2 = parse_integer(str_ind_1, end_ind);
                const width = match$2[1];
                const str_ind_3 = parse_spaces(match$2[0], end_ind);
                const match$3 = Caml_string.get(str, str_ind_3);
                if (match$3 > 57 || match$3 < 45) {
                  if (match$3 !== 62) {
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                          MEL_EXN_ID: Stdlib.Not_found
                        });
                  }
                  const s = Stdlib__String.sub(str, str_ind$1 - 2 | 0, (str_ind_3 - str_ind$1 | 0) + 3 | 0);
                  match = [
                    str_ind_3 + 1 | 0,
                    {
                      TAG: /* Break */ 0,
                      _0: s,
                      _1: width,
                      _2: 0
                    }
                  ];
                } else {
                  if (match$3 === 47 || match$3 === 46) {
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                          MEL_EXN_ID: Stdlib.Not_found
                        });
                  }
                  const match$4 = parse_integer(str_ind_3, end_ind);
                  const str_ind_5 = parse_spaces(match$4[0], end_ind);
                  if (Caml_string.get(str, str_ind_5) !== /* '>' */62) {
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                          MEL_EXN_ID: Stdlib.Not_found
                        });
                  }
                  const s$1 = Stdlib__String.sub(str, str_ind$1 - 2 | 0, (str_ind_5 - str_ind$1 | 0) + 3 | 0);
                  match = [
                    str_ind_5 + 1 | 0,
                    {
                      TAG: /* Break */ 0,
                      _0: s$1,
                      _1: width,
                      _2: match$4[1]
                    }
                  ];
                }
              }
              
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found || exn.MEL_EXN_ID === Stdlib.Failure) {
                match = [
                  str_ind$1,
                  {
                    TAG: /* Break */ 0,
                    _0: "@;",
                    _1: 1,
                    _2: 0
                  }
                ];
              } else {
                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
              }
            }
            const next_ind = match[0];
            const fmt_rest$7 = parse_literal(next_ind, next_ind, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: match[1],
                _1: fmt_rest$7._0
              }
            };
          case 60 :
            let str_ind$2 = str_ind + 1 | 0;
            let match$5;
            try {
              const str_ind_1$1 = parse_spaces(str_ind$2, end_ind);
              const match$6 = Caml_string.get(str, str_ind_1$1);
              let exit$1 = 0;
              if (match$6 >= 48) {
                if (match$6 >= 58) {
                  match$5 = undefined;
                } else {
                  exit$1 = 1;
                }
              } else if (match$6 !== 45) {
                match$5 = undefined;
              } else {
                exit$1 = 1;
              }
              if (exit$1 === 1) {
                const match$7 = parse_integer(str_ind_1$1, end_ind);
                const str_ind_3$1 = parse_spaces(match$7[0], end_ind);
                if (Caml_string.get(str, str_ind_3$1) !== /* '>' */62) {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
                }
                const s$2 = Stdlib__String.sub(str, str_ind$2 - 2 | 0, (str_ind_3$1 - str_ind$2 | 0) + 3 | 0);
                match$5 = [
                  str_ind_3$1 + 1 | 0,
                  {
                    TAG: /* Magic_size */ 1,
                    _0: s$2,
                    _1: match$7[1]
                  }
                ];
              }
              
            }
            catch (raw_exn$1){
              const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found || exn$1.MEL_EXN_ID === Stdlib.Failure) {
                match$5 = undefined;
              } else {
                throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
              }
            }
            if (match$5 !== undefined) {
              const next_ind$1 = match$5[0];
              const fmt_rest$8 = parse_literal(next_ind$1, next_ind$1, end_ind);
              return {
                TAG: /* Fmt_EBB */ 0,
                _0: {
                  TAG: /* Formatting_lit */ 17,
                  _0: match$5[1],
                  _1: fmt_rest$8._0
                }
              };
            }
            const fmt_rest$9 = parse_literal(str_ind$2, str_ind$2, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: {
                  TAG: /* Scan_indic */ 2,
                  _0: /* '<' */60
                },
                _1: fmt_rest$9._0
              }
            };
          case 33 :
          case 34 :
          case 35 :
          case 36 :
          case 38 :
          case 39 :
          case 40 :
          case 41 :
          case 42 :
          case 43 :
          case 45 :
          case 47 :
          case 48 :
          case 49 :
          case 50 :
          case 51 :
          case 52 :
          case 53 :
          case 54 :
          case 55 :
          case 56 :
          case 57 :
          case 58 :
          case 61 :
          case 62 :
            break;
          case 63 :
            const beg_ind$6 = str_ind + 1 | 0;
            const fmt_rest$10 = parse_literal(beg_ind$6, beg_ind$6, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: /* FFlush */ 2,
                _1: fmt_rest$10._0
              }
            };
          case 64 :
            const beg_ind$7 = str_ind + 1 | 0;
            const fmt_rest$11 = parse_literal(beg_ind$7, beg_ind$7, end_ind);
            return {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: /* Escaped_at */ 5,
                _1: fmt_rest$11._0
              }
            };
        }
      }
      
    } else {
      const beg_ind$8 = str_ind + 1 | 0;
      const fmt_rest$12 = parse_literal(beg_ind$8, beg_ind$8, end_ind);
      return {
        TAG: /* Fmt_EBB */ 0,
        _0: {
          TAG: /* Formatting_lit */ 17,
          _0: /* Force_newline */ 3,
          _1: fmt_rest$12._0
        }
      };
    }
    const beg_ind$9 = str_ind + 1 | 0;
    const fmt_rest$13 = parse_literal(beg_ind$9, beg_ind$9, end_ind);
    return {
      TAG: /* Fmt_EBB */ 0,
      _0: {
        TAG: /* Formatting_lit */ 17,
        _0: {
          TAG: /* Scan_indic */ 2,
          _0: c
        },
        _1: fmt_rest$13._0
      }
    };
  };
  const parse_format = function (pct_ind, end_ind) {
    let str_ind = pct_ind + 1 | 0;
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    const match = Caml_string.get(str, str_ind);
    if (match !== 95) {
      return parse_flags(pct_ind, str_ind, end_ind, false);
    } else {
      return parse_flags(pct_ind, str_ind + 1 | 0, end_ind, true);
    }
  };
  const add_literal = function (lit_start, str_ind, fmt) {
    const size = str_ind - lit_start | 0;
    if (size !== 0) {
      if (size !== 1) {
        return {
          TAG: /* Fmt_EBB */ 0,
          _0: {
            TAG: /* String_literal */ 11,
            _0: Stdlib__String.sub(str, lit_start, size),
            _1: fmt
          }
        };
      } else {
        return {
          TAG: /* Fmt_EBB */ 0,
          _0: {
            TAG: /* Char_literal */ 12,
            _0: Caml_string.get(str, lit_start),
            _1: fmt
          }
        };
      }
    } else {
      return {
        TAG: /* Fmt_EBB */ 0,
        _0: fmt
      };
    }
  };
  const parse_integer = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    const match = Caml_string.get(str, str_ind);
    if (match >= 48) {
      if (match >= 58) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                2840,
                11
              ]
            });
      }
      return parse_positive(str_ind, end_ind, 0);
    }
    if (match !== 45) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              2840,
              11
            ]
          });
    }
    if ((str_ind + 1 | 0) === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    const c = Caml_string.get(str, str_ind + 1 | 0);
    if (c > 57 || c < 48) {
      return expected_character(str_ind + 1 | 0, "digit", c);
    }
    const match$1 = parse_positive(str_ind + 1 | 0, end_ind, 0);
    return [
      match$1[0],
      -match$1[1] | 0
    ];
  };
  const parse_spaces = function (_str_ind, end_ind) {
    while (true) {
      const str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      if (Caml_string.get(str, str_ind) !== /* ' ' */32) {
        return str_ind;
      }
      _str_ind = str_ind + 1 | 0;
      continue;
    };
  };
  const incompatible_flag = function (pct_ind, str_ind, symb, option) {
    const subfmt = Stdlib__String.sub(str, pct_ind, str_ind - pct_ind | 0);
    return Curry._5(failwith_message({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "invalid format ",
        _1: {
          TAG: /* Caml_string */ 3,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": at character number ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ", ",
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* String_literal */ 11,
                    _0: " is incompatible with '",
                    _1: {
                      TAG: /* Char */ 0,
                      _0: {
                        TAG: /* String_literal */ 11,
                        _0: "' in sub-format ",
                        _1: {
                          TAG: /* Caml_string */ 3,
                          _0: /* No_padding */ 0,
                          _1: /* End_of_format */ 0
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      _1: "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"
    }), str, pct_ind, option, symb, subfmt);
  };
  const compute_int_conv = function (pct_ind, str_ind, _plus, _hash, _space, symb) {
    while (true) {
      const space = _space;
      const hash = _hash;
      const plus = _plus;
      let exit = 0;
      if (plus) {
        if (hash) {
          exit = 2;
        } else if (!space) {
          if (symb === 100) {
            return /* Int_pd */ 1;
          }
          if (symb === 105) {
            return /* Int_pi */ 4;
          }
          
        }
        
      } else if (hash) {
        if (space) {
          exit = 2;
        } else {
          switch (symb) {
            case 88 :
              return /* Int_CX */ 9;
            case 100 :
              return /* Int_Cd */ 13;
            case 105 :
              return /* Int_Ci */ 14;
            case 111 :
              return /* Int_Co */ 11;
            case 117 :
              return /* Int_Cu */ 15;
            case 120 :
              return /* Int_Cx */ 7;
            default:
              exit = 2;
          }
        }
      } else if (space) {
        if (symb === 100) {
          return /* Int_sd */ 2;
        }
        if (symb === 105) {
          return /* Int_si */ 5;
        }
        
      } else {
        switch (symb) {
          case 88 :
            return /* Int_X */ 8;
          case 100 :
            return /* Int_d */ 0;
          case 105 :
            return /* Int_i */ 3;
          case 111 :
            return /* Int_o */ 10;
          case 117 :
            return /* Int_u */ 12;
          case 120 :
            return /* Int_x */ 6;
        }
      }
      if (exit === 2) {
        let exit$1 = 0;
        switch (symb) {
          case 88 :
            if (legacy_behavior$1) {
              return /* Int_CX */ 9;
            }
            break;
          case 111 :
            if (legacy_behavior$1) {
              return /* Int_Co */ 11;
            }
            break;
          case 100 :
          case 105 :
          case 117 :
            exit$1 = 3;
            break;
          case 120 :
            if (legacy_behavior$1) {
              return /* Int_Cx */ 7;
            }
            break;
        }
        if (exit$1 === 3) {
          if (!legacy_behavior$1) {
            return incompatible_flag(pct_ind, str_ind, symb, "'#'");
          }
          _hash = false;
          continue;
        }
        
      }
      if (plus) {
        if (space) {
          if (!legacy_behavior$1) {
            return incompatible_flag(pct_ind, str_ind, /* ' ' */32, "'+'");
          }
          _space = false;
          continue;
        }
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "'+'");
        }
        _plus = false;
        continue;
      }
      if (space) {
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "' '");
        }
        _space = false;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              2938,
              28
            ]
          });
    };
  };
  const parse_after_padding = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    const symb = Caml_string.get(str, str_ind);
    if (symb !== 46) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, /* No_precision */ 0, pad, symb);
    } else {
      let str_ind$1 = str_ind + 1 | 0;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      const parse_literal = function (minus, str_ind) {
        const match = parse_positive(str_ind, end_ind, 0);
        return parse_after_precision(pct_ind, match[0], end_ind, minus, plus, hash, space, ign, pad, {
          TAG: /* Lit_precision */ 0,
          _0: match[1]
        });
      };
      const symb$1 = Caml_string.get(str, str_ind$1);
      let exit = 0;
      if (symb$1 >= 48) {
        if (symb$1 < 58) {
          return parse_literal(minus, str_ind$1);
        }
        
      } else if (symb$1 >= 42) {
        switch (symb$1) {
          case 42 :
            return parse_after_precision(pct_ind, str_ind$1 + 1 | 0, end_ind, minus, plus, hash, space, ign, pad, /* Arg_precision */ 1);
          case 43 :
          case 45 :
            exit = 2;
            break;
          case 44 :
          case 46 :
          case 47 :
            break;
        }
      }
      if (exit === 2 && legacy_behavior$1) {
        return parse_literal(minus || symb$1 === /* '-' */45, str_ind$1 + 1 | 0);
      }
      if (legacy_behavior$1) {
        return parse_after_precision(pct_ind, str_ind$1, end_ind, minus, plus, hash, space, ign, pad, {
          TAG: /* Lit_precision */ 0,
          _0: 0
        });
      } else {
        return invalid_format_without(str_ind$1 - 1 | 0, /* '.' */46, "precision");
      }
    }
  };
  const parse_positive = function (_str_ind, end_ind, _acc) {
    while (true) {
      const acc = _acc;
      const str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      const c = Caml_string.get(str, str_ind);
      if (c > 57 || c < 48) {
        return [
          str_ind,
          acc
        ];
      }
      const new_acc = Math.imul(acc, 10) + (c - /* '0' */48 | 0) | 0;
      _acc = new_acc;
      _str_ind = str_ind + 1 | 0;
      continue;
    };
  };
  const search_subformat_end = function (_str_ind, end_ind, c) {
    while (true) {
      const str_ind = _str_ind;
      if (str_ind === end_ind) {
        Curry._3(failwith_message({
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String_literal */ 11,
            _0: "invalid format ",
            _1: {
              TAG: /* Caml_string */ 3,
              _0: /* No_padding */ 0,
              _1: {
                TAG: /* String_literal */ 11,
                _0: ": unclosed sub-format, expected \\"",
                _1: {
                  TAG: /* Char_literal */ 12,
                  _0: /* '%' */37,
                  _1: {
                    TAG: /* Char */ 0,
                    _0: {
                      TAG: /* String_literal */ 11,
                      _0: "\\" at character number ",
                      _1: {
                        TAG: /* Int */ 4,
                        _0: /* Int_d */ 0,
                        _1: /* No_padding */ 0,
                        _2: /* No_precision */ 0,
                        _3: /* End_of_format */ 0
                      }
                    }
                  }
                }
              }
            }
          },
          _1: "invalid format %S: unclosed sub-format, expected \\"%%%c\\" at character number %d"
        }), str, c, end_ind);
      }
      const match = Caml_string.get(str, str_ind);
      if (match !== 37) {
        _str_ind = str_ind + 1 | 0;
        continue;
      }
      if ((str_ind + 1 | 0) === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      if (Caml_string.get(str, str_ind + 1 | 0) === c) {
        return str_ind;
      }
      const match$1 = Caml_string.get(str, str_ind + 1 | 0);
      if (match$1 >= 95) {
        if (match$1 >= 123) {
          if (match$1 < 126) {
            switch (match$1) {
              case 123 :
                const sub_end = search_subformat_end(str_ind + 2 | 0, end_ind, /* '}' */125);
                _str_ind = sub_end + 2 | 0;
                continue;
              case 124 :
                break;
              case 125 :
                return expected_character(str_ind + 1 | 0, "character ')'", /* '}' */125);
            }
          }
          
        } else if (match$1 < 96) {
          if ((str_ind + 2 | 0) === end_ind) {
            invalid_format_message(end_ind, "unexpected end of format");
          }
          const match$2 = Caml_string.get(str, str_ind + 2 | 0);
          if (match$2 !== 40) {
            if (match$2 !== 123) {
              _str_ind = str_ind + 3 | 0;
              continue;
            }
            const sub_end$1 = search_subformat_end(str_ind + 3 | 0, end_ind, /* '}' */125);
            _str_ind = sub_end$1 + 2 | 0;
            continue;
          }
          const sub_end$2 = search_subformat_end(str_ind + 3 | 0, end_ind, /* ')' */41);
          _str_ind = sub_end$2 + 2 | 0;
          continue;
        }
        
      } else if (match$1 !== 40) {
        if (match$1 === 41) {
          return expected_character(str_ind + 1 | 0, "character '}'", /* ')' */41);
        }
        
      } else {
        const sub_end$3 = search_subformat_end(str_ind + 2 | 0, end_ind, /* ')' */41);
        _str_ind = sub_end$3 + 2 | 0;
        continue;
      }
      _str_ind = str_ind + 2 | 0;
      continue;
    };
  };
  const parse_conversion = function (pct_ind, str_ind, end_ind, plus, hash, space, ign, pad, prec, padprec, symb) {
    let plus_used = false;
    let hash_used = false;
    let space_used = false;
    const ign_used = {
      contents: false
    };
    const pad_used = {
      contents: false
    };
    const prec_used = {
      contents: false
    };
    const get_int_pad = function (param) {
      pad_used.contents = true;
      prec_used.contents = true;
      if (/* tag */ (typeof prec === "number" || typeof prec === "string") && prec === /* No_precision */ 0) {
        return pad;
      }
      if (/* tag */ typeof pad === "number" || typeof pad === "string") {
        return /* No_padding */ 0;
      }
      if (pad.TAG === /* Lit_padding */ 0) {
        switch (pad._0) {
          case /* Left */ 0 :
          case /* Right */ 1 :
            return pad;
          case /* Zeros */ 2 :
            if (legacy_behavior$1) {
              return {
                TAG: /* Lit_padding */ 0,
                _0: /* Right */ 1,
                _1: pad._1
              };
            } else {
              return incompatible_flag(pct_ind, str_ind, /* '0' */48, "precision");
            }
        }
      } else {
        switch (pad._0) {
          case /* Left */ 0 :
          case /* Right */ 1 :
            return pad;
          case /* Zeros */ 2 :
            if (legacy_behavior$1) {
              return {
                TAG: /* Arg_padding */ 1,
                _0: /* Right */ 1
              };
            } else {
              return incompatible_flag(pct_ind, str_ind, /* '0' */48, "precision");
            }
        }
      }
    };
    const check_no_0 = function (symb, pad) {
      if (/* tag */ typeof pad === "number" || typeof pad === "string") {
        return pad;
      }
      if (pad.TAG === /* Lit_padding */ 0) {
        switch (pad._0) {
          case /* Left */ 0 :
          case /* Right */ 1 :
            return pad;
          case /* Zeros */ 2 :
            if (legacy_behavior$1) {
              return {
                TAG: /* Lit_padding */ 0,
                _0: /* Right */ 1,
                _1: pad._1
              };
            } else {
              return incompatible_flag(pct_ind, str_ind, symb, "0");
            }
        }
      } else {
        switch (pad._0) {
          case /* Left */ 0 :
          case /* Right */ 1 :
            return pad;
          case /* Zeros */ 2 :
            if (legacy_behavior$1) {
              return {
                TAG: /* Arg_padding */ 1,
                _0: /* Right */ 1
              };
            } else {
              return incompatible_flag(pct_ind, str_ind, symb, "0");
            }
        }
      }
    };
    const opt_of_pad = function (c, pad) {
      if (/* tag */ typeof pad === "number" || typeof pad === "string") {
        return;
      }
      if (pad.TAG !== /* Lit_padding */ 0) {
        return incompatible_flag(pct_ind, str_ind, c, "'*'");
      }
      switch (pad._0) {
        case /* Left */ 0 :
          if (legacy_behavior$1) {
            return pad._1;
          } else {
            return incompatible_flag(pct_ind, str_ind, c, "'-'");
          }
        case /* Right */ 1 :
          return pad._1;
        case /* Zeros */ 2 :
          if (legacy_behavior$1) {
            return pad._1;
          } else {
            return incompatible_flag(pct_ind, str_ind, c, "'0'");
          }
      }
    };
    const get_prec_opt = function (param) {
      prec_used.contents = true;
      if (/* tag */ typeof prec === "number" || typeof prec === "string") {
        if (prec === /* No_precision */ 0) {
          return;
        } else {
          return incompatible_flag(pct_ind, str_ind, /* '_' */95, "'*'");
        }
      } else {
        return prec._0;
      }
    };
    let fmt_result;
    let exit = 0;
    let exit$1 = 0;
    let exit$2 = 0;
    if (symb >= 124) {
      exit$1 = 6;
    } else {
      switch (symb) {
        case 33 :
          const fmt_rest = parse_literal(str_ind, str_ind, end_ind);
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Flush */ 10,
              _0: fmt_rest._0
            }
          };
          break;
        case 40 :
          const sub_end = search_subformat_end(str_ind, end_ind, /* ')' */41);
          const beg_ind = sub_end + 2 | 0;
          const fmt_rest$1 = parse_literal(beg_ind, beg_ind, end_ind);
          const fmt_rest$2 = fmt_rest$1._0;
          const sub_fmt = parse_literal(str_ind, str_ind, sub_end);
          const sub_fmtty = fmtty_of_fmt(sub_fmt._0);
          if (ign_used.contents = true, ign) {
            const ignored_0 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
            const ignored = {
              TAG: /* Ignored_format_subst */ 9,
              _0: ignored_0,
              _1: sub_fmtty
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored,
                _1: fmt_rest$2
              }
            };
          } else {
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Format_subst */ 14,
                _0: opt_of_pad(/* '(' */40, (pad_used.contents = true, pad)),
                _1: sub_fmtty,
                _2: fmt_rest$2
              }
            };
          }
          break;
        case 44 :
          fmt_result = parse_literal(str_ind, str_ind, end_ind);
          break;
        case 37 :
        case 64 :
          exit$1 = 4;
          break;
        case 67 :
          const fmt_rest$3 = parse_literal(str_ind, str_ind, end_ind);
          const fmt_rest$4 = fmt_rest$3._0;
          fmt_result = (ign_used.contents = true, ign) ? ({
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: /* Ignored_caml_char */ 1,
                _1: fmt_rest$4
              }
            }) : ({
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Caml_char */ 1,
                _0: fmt_rest$4
              }
            });
          break;
        case 78 :
          const fmt_rest$5 = parse_literal(str_ind, str_ind, end_ind);
          const fmt_rest$6 = fmt_rest$5._0;
          if (ign_used.contents = true, ign) {
            const ignored$1 = {
              TAG: /* Ignored_scan_get_counter */ 11,
              _0: /* Token_counter */ 2
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored$1,
                _1: fmt_rest$6
              }
            };
          } else {
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Scan_get_counter */ 21,
                _0: /* Token_counter */ 2,
                _1: fmt_rest$6
              }
            };
          }
          break;
        case 83 :
          const pad$1 = check_no_0(symb, (pad_used.contents = true, padprec));
          const fmt_rest$7 = parse_literal(str_ind, str_ind, end_ind);
          const fmt_rest$8 = fmt_rest$7._0;
          if (ign_used.contents = true, ign) {
            const ignored$2 = {
              TAG: /* Ignored_caml_string */ 1,
              _0: opt_of_pad(/* '_' */95, (pad_used.contents = true, padprec))
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored$2,
                _1: fmt_rest$8
              }
            };
          } else {
            const match = make_padding_fmt_ebb(pad$1, fmt_rest$8);
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Caml_string */ 3,
                _0: match._0,
                _1: match._1
              }
            };
          }
          break;
        case 91 :
          const match$1 = parse_char_set(str_ind, end_ind);
          const char_set = match$1[1];
          const next_ind = match$1[0];
          const fmt_rest$9 = parse_literal(next_ind, next_ind, end_ind);
          const fmt_rest$10 = fmt_rest$9._0;
          if (ign_used.contents = true, ign) {
            const ignored_0$1 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
            const ignored$3 = {
              TAG: /* Ignored_scan_char_set */ 10,
              _0: ignored_0$1,
              _1: char_set
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored$3,
                _1: fmt_rest$10
              }
            };
          } else {
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Scan_char_set */ 20,
                _0: opt_of_pad(/* '[' */91, (pad_used.contents = true, pad)),
                _1: char_set,
                _2: fmt_rest$10
              }
            };
          }
          break;
        case 32 :
        case 35 :
        case 43 :
        case 45 :
        case 95 :
          exit$1 = 5;
          break;
        case 97 :
          const fmt_rest$11 = parse_literal(str_ind, str_ind, end_ind);
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Alpha */ 15,
              _0: fmt_rest$11._0
            }
          };
          break;
        case 66 :
        case 98 :
          exit$1 = 3;
          break;
        case 99 :
          const char_format = function (fmt_rest) {
            if (ign_used.contents = true, ign) {
              return {
                TAG: /* Fmt_EBB */ 0,
                _0: {
                  TAG: /* Ignored_param */ 23,
                  _0: /* Ignored_char */ 0,
                  _1: fmt_rest
                }
              };
            } else {
              return {
                TAG: /* Fmt_EBB */ 0,
                _0: {
                  TAG: /* Char */ 0,
                  _0: fmt_rest
                }
              };
            }
          };
          const scan_format = function (fmt_rest) {
            if (ign_used.contents = true, ign) {
              return {
                TAG: /* Fmt_EBB */ 0,
                _0: {
                  TAG: /* Ignored_param */ 23,
                  _0: /* Ignored_scan_next_char */ 3,
                  _1: fmt_rest
                }
              };
            } else {
              return {
                TAG: /* Fmt_EBB */ 0,
                _0: {
                  TAG: /* Scan_next_char */ 22,
                  _0: fmt_rest
                }
              };
            }
          };
          const fmt_rest$12 = parse_literal(str_ind, str_ind, end_ind);
          const fmt_rest$13 = fmt_rest$12._0;
          const _n = opt_of_pad(/* 'c' */99, (pad_used.contents = true, pad));
          fmt_result = _n !== undefined ? (
              _n !== 0 ? (
                  legacy_behavior$1 ? char_format(fmt_rest$13) : invalid_format_message(str_ind, "non-zero widths are unsupported for %c conversions")
                ) : scan_format(fmt_rest$13)
            ) : char_format(fmt_rest$13);
          break;
        case 69 :
        case 70 :
        case 71 :
        case 72 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
          exit$1 = 2;
          break;
        case 76 :
        case 108 :
        case 110 :
          exit$2 = 8;
          break;
        case 114 :
          const fmt_rest$14 = parse_literal(str_ind, str_ind, end_ind);
          const fmt_rest$15 = fmt_rest$14._0;
          fmt_result = (ign_used.contents = true, ign) ? ({
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: /* Ignored_reader */ 2,
                _1: fmt_rest$15
              }
            }) : ({
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Reader */ 19,
                _0: fmt_rest$15
              }
            });
          break;
        case 115 :
          const pad$2 = check_no_0(symb, (pad_used.contents = true, padprec));
          const fmt_rest$16 = parse_literal(str_ind, str_ind, end_ind);
          const fmt_rest$17 = fmt_rest$16._0;
          if (ign_used.contents = true, ign) {
            const ignored$4 = {
              TAG: /* Ignored_string */ 0,
              _0: opt_of_pad(/* '_' */95, (pad_used.contents = true, padprec))
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored$4,
                _1: fmt_rest$17
              }
            };
          } else {
            const match$2 = make_padding_fmt_ebb(pad$2, fmt_rest$17);
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* String */ 2,
                _0: match$2._0,
                _1: match$2._1
              }
            };
          }
          break;
        case 116 :
          const fmt_rest$18 = parse_literal(str_ind, str_ind, end_ind);
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Theta */ 16,
              _0: fmt_rest$18._0
            }
          };
          break;
        case 88 :
        case 100 :
        case 105 :
        case 111 :
        case 117 :
        case 120 :
          exit$2 = 7;
          break;
        case 0 :
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        case 10 :
        case 11 :
        case 12 :
        case 13 :
        case 14 :
        case 15 :
        case 16 :
        case 17 :
        case 18 :
        case 19 :
        case 20 :
        case 21 :
        case 22 :
        case 23 :
        case 24 :
        case 25 :
        case 26 :
        case 27 :
        case 28 :
        case 29 :
        case 30 :
        case 31 :
        case 34 :
        case 36 :
        case 38 :
        case 39 :
        case 41 :
        case 42 :
        case 46 :
        case 47 :
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
        case 58 :
        case 59 :
        case 60 :
        case 61 :
        case 62 :
        case 63 :
        case 65 :
        case 68 :
        case 73 :
        case 74 :
        case 75 :
        case 77 :
        case 79 :
        case 80 :
        case 81 :
        case 82 :
        case 84 :
        case 85 :
        case 86 :
        case 87 :
        case 89 :
        case 90 :
        case 92 :
        case 93 :
        case 94 :
        case 96 :
        case 106 :
        case 107 :
        case 109 :
        case 112 :
        case 113 :
        case 118 :
        case 119 :
        case 121 :
        case 122 :
          exit$1 = 6;
          break;
        case 123 :
          const sub_end$1 = search_subformat_end(str_ind, end_ind, /* '}' */125);
          const sub_fmt$1 = parse_literal(str_ind, str_ind, sub_end$1);
          const beg_ind$1 = sub_end$1 + 2 | 0;
          const fmt_rest$19 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
          const fmt_rest$20 = fmt_rest$19._0;
          const sub_fmtty$1 = fmtty_of_fmt(sub_fmt$1._0);
          if (ign_used.contents = true, ign) {
            const ignored_0$2 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
            const ignored$5 = {
              TAG: /* Ignored_format_arg */ 8,
              _0: ignored_0$2,
              _1: sub_fmtty$1
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored$5,
                _1: fmt_rest$20
              }
            };
          } else {
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Format_arg */ 13,
                _0: opt_of_pad(/* '{' */123, (pad_used.contents = true, pad)),
                _1: sub_fmtty$1,
                _2: fmt_rest$20
              }
            };
          }
          break;
      }
    }
    switch (exit$2) {
      case 7 :
        plus_used = true;
        hash_used = true;
        space_used = true;
        const iconv = compute_int_conv(pct_ind, str_ind, plus, hash, space, symb);
        const fmt_rest$21 = parse_literal(str_ind, str_ind, end_ind);
        const fmt_rest$22 = fmt_rest$21._0;
        if (ign_used.contents = true, ign) {
          const ignored_1 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
          const ignored$6 = {
            TAG: /* Ignored_int */ 2,
            _0: iconv,
            _1: ignored_1
          };
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Ignored_param */ 23,
              _0: ignored$6,
              _1: fmt_rest$22
            }
          };
        } else {
          const match$3 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$22);
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Int */ 4,
              _0: iconv,
              _1: match$3._0,
              _2: match$3._1,
              _3: match$3._2
            }
          };
        }
        break;
      case 8 :
        if (str_ind === end_ind || !is_int_base(Caml_string.get(str, str_ind))) {
          const fmt_rest$23 = parse_literal(str_ind, str_ind, end_ind);
          const fmt_rest$24 = fmt_rest$23._0;
          const counter = counter_of_char(symb);
          if (ign_used.contents = true, ign) {
            const ignored$7 = {
              TAG: /* Ignored_scan_get_counter */ 11,
              _0: counter
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored$7,
                _1: fmt_rest$24
              }
            };
          } else {
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Scan_get_counter */ 21,
                _0: counter,
                _1: fmt_rest$24
              }
            };
          }
        } else {
          exit$1 = 6;
        }
        break;
    }
    switch (exit$1) {
      case 2 :
        plus_used = true;
        hash_used = true;
        space_used = true;
        const fconv = compute_float_conv(pct_ind, str_ind, plus, hash, space, symb);
        const fmt_rest$25 = parse_literal(str_ind, str_ind, end_ind);
        const fmt_rest$26 = fmt_rest$25._0;
        if (ign_used.contents = true, ign) {
          const ignored_0$3 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
          const ignored_1$1 = get_prec_opt(undefined);
          const ignored$8 = {
            TAG: /* Ignored_float */ 6,
            _0: ignored_0$3,
            _1: ignored_1$1
          };
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Ignored_param */ 23,
              _0: ignored$8,
              _1: fmt_rest$26
            }
          };
        } else {
          const match$4 = make_padprec_fmt_ebb((pad_used.contents = true, pad), (prec_used.contents = true, prec), fmt_rest$26);
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Float */ 8,
              _0: fconv,
              _1: match$4._0,
              _2: match$4._1,
              _3: match$4._2
            }
          };
        }
        break;
      case 3 :
        const pad$3 = check_no_0(symb, (pad_used.contents = true, padprec));
        const fmt_rest$27 = parse_literal(str_ind, str_ind, end_ind);
        const fmt_rest$28 = fmt_rest$27._0;
        if (ign_used.contents = true, ign) {
          const ignored$9 = {
            TAG: /* Ignored_bool */ 7,
            _0: opt_of_pad(/* '_' */95, (pad_used.contents = true, padprec))
          };
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Ignored_param */ 23,
              _0: ignored$9,
              _1: fmt_rest$28
            }
          };
        } else {
          const match$5 = make_padding_fmt_ebb(pad$3, fmt_rest$28);
          fmt_result = {
            TAG: /* Fmt_EBB */ 0,
            _0: {
              TAG: /* Bool */ 9,
              _0: match$5._0,
              _1: match$5._1
            }
          };
        }
        break;
      case 4 :
        const fmt_rest$29 = parse_literal(str_ind, str_ind, end_ind);
        fmt_result = {
          TAG: /* Fmt_EBB */ 0,
          _0: {
            TAG: /* Char_literal */ 12,
            _0: symb,
            _1: fmt_rest$29._0
          }
        };
        break;
      case 5 :
        fmt_result = Curry._3(failwith_message({
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String_literal */ 11,
            _0: "invalid format ",
            _1: {
              TAG: /* Caml_string */ 3,
              _0: /* No_padding */ 0,
              _1: {
                TAG: /* String_literal */ 11,
                _0: ": at character number ",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: {
                    TAG: /* String_literal */ 11,
                    _0: ", flag ",
                    _1: {
                      TAG: /* Caml_char */ 1,
                      _0: {
                        TAG: /* String_literal */ 11,
                        _0: " is only allowed after the '",
                        _1: {
                          TAG: /* Char_literal */ 12,
                          _0: /* '%' */37,
                          _1: {
                            TAG: /* String_literal */ 11,
                            _0: "', before padding and precision",
                            _1: /* End_of_format */ 0
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          _1: "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"
        }), str, pct_ind, symb);
        break;
      case 6 :
        if (symb >= 108) {
          if (symb >= 111) {
            exit = 1;
          } else {
            switch (symb) {
              case 108 :
                plus_used = true;
                hash_used = true;
                space_used = true;
                const iconv$1 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, Caml_string.get(str, str_ind));
                const beg_ind$2 = str_ind + 1 | 0;
                const fmt_rest$30 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
                const fmt_rest$31 = fmt_rest$30._0;
                if (ign_used.contents = true, ign) {
                  const ignored_1$2 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
                  const ignored$10 = {
                    TAG: /* Ignored_int32 */ 3,
                    _0: iconv$1,
                    _1: ignored_1$2
                  };
                  fmt_result = {
                    TAG: /* Fmt_EBB */ 0,
                    _0: {
                      TAG: /* Ignored_param */ 23,
                      _0: ignored$10,
                      _1: fmt_rest$31
                    }
                  };
                } else {
                  const match$6 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$31);
                  fmt_result = {
                    TAG: /* Fmt_EBB */ 0,
                    _0: {
                      TAG: /* Int32 */ 5,
                      _0: iconv$1,
                      _1: match$6._0,
                      _2: match$6._1,
                      _3: match$6._2
                    }
                  };
                }
                break;
              case 109 :
                exit = 1;
                break;
              case 110 :
                plus_used = true;
                hash_used = true;
                space_used = true;
                const iconv$2 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, Caml_string.get(str, str_ind));
                const beg_ind$3 = str_ind + 1 | 0;
                const fmt_rest$32 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
                const fmt_rest$33 = fmt_rest$32._0;
                if (ign_used.contents = true, ign) {
                  const ignored_1$3 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
                  const ignored$11 = {
                    TAG: /* Ignored_nativeint */ 4,
                    _0: iconv$2,
                    _1: ignored_1$3
                  };
                  fmt_result = {
                    TAG: /* Fmt_EBB */ 0,
                    _0: {
                      TAG: /* Ignored_param */ 23,
                      _0: ignored$11,
                      _1: fmt_rest$33
                    }
                  };
                } else {
                  const match$7 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$33);
                  fmt_result = {
                    TAG: /* Fmt_EBB */ 0,
                    _0: {
                      TAG: /* Nativeint */ 6,
                      _0: iconv$2,
                      _1: match$7._0,
                      _2: match$7._1,
                      _3: match$7._2
                    }
                  };
                }
                break;
            }
          }
        } else if (symb !== 76) {
          exit = 1;
        } else {
          plus_used = true;
          hash_used = true;
          space_used = true;
          const iconv$3 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, Caml_string.get(str, str_ind));
          const beg_ind$4 = str_ind + 1 | 0;
          const fmt_rest$34 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
          const fmt_rest$35 = fmt_rest$34._0;
          if (ign_used.contents = true, ign) {
            const ignored_1$4 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
            const ignored$12 = {
              TAG: /* Ignored_int64 */ 5,
              _0: iconv$3,
              _1: ignored_1$4
            };
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Ignored_param */ 23,
                _0: ignored$12,
                _1: fmt_rest$35
              }
            };
          } else {
            const match$8 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$35);
            fmt_result = {
              TAG: /* Fmt_EBB */ 0,
              _0: {
                TAG: /* Int64 */ 7,
                _0: iconv$3,
                _1: match$8._0,
                _2: match$8._1,
                _3: match$8._2
              }
            };
          }
        }
        break;
    }
    if (exit === 1) {
      fmt_result = Curry._3(failwith_message({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "invalid format ",
          _1: {
            TAG: /* Caml_string */ 3,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": at character number ",
              _1: {
                TAG: /* Int */ 4,
                _0: /* Int_d */ 0,
                _1: /* No_padding */ 0,
                _2: /* No_precision */ 0,
                _3: {
                  TAG: /* String_literal */ 11,
                  _0: ", invalid conversion \\"",
                  _1: {
                    TAG: /* Char_literal */ 12,
                    _0: /* '%' */37,
                    _1: {
                      TAG: /* Char */ 0,
                      _0: {
                        TAG: /* Char_literal */ 12,
                        _0: /* '"' */34,
                        _1: /* End_of_format */ 0
                      }
                    }
                  }
                }
              }
            }
          }
        },
        _1: "invalid format %S: at character number %d, invalid conversion \\"%%%c\\""
      }), str, str_ind - 1 | 0, symb);
    }
    if (!legacy_behavior$1) {
      if (!plus_used && plus) {
        incompatible_flag(pct_ind, str_ind, symb, "'+'");
      }
      if (!hash_used && hash) {
        incompatible_flag(pct_ind, str_ind, symb, "'#'");
      }
      if (!space_used && space) {
        incompatible_flag(pct_ind, str_ind, symb, "' '");
      }
      if (!pad_used.contents && Caml_obj.caml_notequal({
          TAG: /* Padding_EBB */ 0,
          _0: pad
        }, {
          TAG: /* Padding_EBB */ 0,
          _0: /* No_padding */ 0
        })) {
        incompatible_flag(pct_ind, str_ind, symb, "\`padding'");
      }
      if (!prec_used.contents && Caml_obj.caml_notequal({
          TAG: /* Precision_EBB */ 0,
          _0: prec
        }, {
          TAG: /* Precision_EBB */ 0,
          _0: /* No_precision */ 0
        })) {
        incompatible_flag(pct_ind, str_ind, ign ? /* '_' */95 : symb, "\`precision'");
      }
      if (ign && plus) {
        incompatible_flag(pct_ind, str_ind, /* '_' */95, "'+'");
      }
      
    }
    if (!ign_used.contents && ign) {
      let exit$3 = 0;
      if (symb >= 38) {
        if (symb !== 44) {
          if (symb !== 64 || !legacy_behavior$1) {
            exit$3 = 1;
          }
          
        } else if (!legacy_behavior$1) {
          exit$3 = 1;
        }
        
      } else if (symb !== 33) {
        if (!(symb >= 37 && legacy_behavior$1)) {
          exit$3 = 1;
        }
        
      } else if (!legacy_behavior$1) {
        exit$3 = 1;
      }
      if (exit$3 === 1) {
        incompatible_flag(pct_ind, str_ind, symb, "'_'");
      }
      
    }
    return fmt_result;
  };
  const parse_after_precision = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    const parse_conv = function (padprec) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, prec, padprec, Caml_string.get(str, str_ind));
    };
    if (!/* tag */ (typeof pad === "number" || typeof pad === "string")) {
      return parse_conv(pad);
    }
    if (/* tag */ (typeof prec === "number" || typeof prec === "string") && prec === /* No_precision */ 0) {
      return parse_conv(/* No_padding */ 0);
    }
    if (minus) {
      if (/* tag */ typeof prec === "number" || typeof prec === "string") {
        return parse_conv({
          TAG: /* Arg_padding */ 1,
          _0: /* Left */ 0
        });
      } else {
        return parse_conv({
          TAG: /* Lit_padding */ 0,
          _0: /* Left */ 0,
          _1: prec._0
        });
      }
    } else if (/* tag */ typeof prec === "number" || typeof prec === "string") {
      return parse_conv({
        TAG: /* Arg_padding */ 1,
        _0: /* Right */ 1
      });
    } else {
      return parse_conv({
        TAG: /* Lit_padding */ 0,
        _0: /* Right */ 1,
        _1: prec._0
      });
    }
  };
  const counter_of_char = function (symb) {
    if (symb >= 108) {
      if (symb < 111) {
        switch (symb) {
          case 108 :
            return /* Line_counter */ 0;
          case 109 :
            break;
          case 110 :
            return /* Char_counter */ 1;
        }
      }
      
    } else if (symb === 76) {
      return /* Token_counter */ 2;
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "camlinternalFormat.cppo.ml",
            2902,
            34
          ]
        });
  };
  const parse_char_set = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    const char_set = Stdlib__Bytes.make(32, /* '\\000' */0);
    const add_range = function (c, c$p) {
      for (let i = c; i <= c$p; ++i) {
        add_in_char_set(char_set, Stdlib.char_of_int(i));
      }
    };
    const fail_single_percent = function (str_ind) {
      return Curry._2(failwith_message({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "invalid format ",
          _1: {
            TAG: /* Caml_string */ 3,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": '",
              _1: {
                TAG: /* Char_literal */ 12,
                _0: /* '%' */37,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: "' alone is not accepted in character sets, use ",
                  _1: {
                    TAG: /* Char_literal */ 12,
                    _0: /* '%' */37,
                    _1: {
                      TAG: /* Char_literal */ 12,
                      _0: /* '%' */37,
                      _1: {
                        TAG: /* String_literal */ 11,
                        _0: " instead at position ",
                        _1: {
                          TAG: /* Int */ 4,
                          _0: /* Int_d */ 0,
                          _1: /* No_padding */ 0,
                          _2: /* No_precision */ 0,
                          _3: {
                            TAG: /* Char_literal */ 12,
                            _0: /* '.' */46,
                            _1: /* End_of_format */ 0
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        _1: "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."
      }), str, str_ind);
    };
    const parse_char_set_after_char = function (_str_ind, end_ind, _c) {
      while (true) {
        const c = _c;
        const str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        const c$p = Caml_string.get(str, str_ind);
        let exit = 0;
        if (c$p >= 46) {
          if (c$p !== 64) {
            if (c$p === 93) {
              add_in_char_set(char_set, c);
              return str_ind + 1 | 0;
            }
            
          } else {
            exit = 2;
          }
        } else if (c$p !== 37) {
          if (c$p >= 45) {
            let str_ind$1 = str_ind + 1 | 0;
            if (str_ind$1 === end_ind) {
              invalid_format_message(end_ind, "unexpected end of format");
            }
            const c$p$1 = Caml_string.get(str, str_ind$1);
            if (c$p$1 !== 37) {
              if (c$p$1 !== 93) {
                add_range(c, c$p$1);
                return parse_char_set_content(str_ind$1 + 1 | 0, end_ind);
              } else {
                add_in_char_set(char_set, c);
                add_in_char_set(char_set, /* '-' */45);
                return str_ind$1 + 1 | 0;
              }
            }
            if ((str_ind$1 + 1 | 0) === end_ind) {
              invalid_format_message(end_ind, "unexpected end of format");
            }
            const c$p$2 = Caml_string.get(str, str_ind$1 + 1 | 0);
            if (c$p$2 !== 37 && c$p$2 !== 64) {
              return fail_single_percent(str_ind$1);
            }
            add_range(c, c$p$2);
            return parse_char_set_content(str_ind$1 + 2 | 0, end_ind);
          }
          
        } else {
          exit = 2;
        }
        if (exit === 2 && c === /* '%' */37) {
          add_in_char_set(char_set, c$p);
          return parse_char_set_content(str_ind + 1 | 0, end_ind);
        }
        if (c === /* '%' */37) {
          fail_single_percent(str_ind);
        }
        add_in_char_set(char_set, c);
        _c = c$p;
        _str_ind = str_ind + 1 | 0;
        continue;
      };
    };
    const parse_char_set_content = function (_str_ind, end_ind) {
      while (true) {
        const str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        const c = Caml_string.get(str, str_ind);
        if (c !== 45) {
          if (c !== 93) {
            return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
          } else {
            return str_ind + 1 | 0;
          }
        }
        add_in_char_set(char_set, /* '-' */45);
        _str_ind = str_ind + 1 | 0;
        continue;
      };
    };
    const parse_char_set_start = function (str_ind, end_ind) {
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      const c = Caml_string.get(str, str_ind);
      return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
    };
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    const match = Caml_string.get(str, str_ind);
    const match$1 = match !== 94 ? [
        str_ind,
        false
      ] : [
        str_ind + 1 | 0,
        true
      ];
    const next_ind = parse_char_set_start(match$1[0], end_ind);
    const char_set$1 = Stdlib__Bytes.to_string(char_set);
    return [
      next_ind,
      match$1[1] ? rev_char_set(char_set$1) : char_set$1
    ];
  };
  const is_int_base = function (symb) {
    switch (symb) {
      case 88 :
      case 100 :
      case 105 :
      case 111 :
      case 117 :
      case 120 :
        return true;
      default:
        return false;
    }
  };
  const compute_float_conv = function (pct_ind, str_ind, plus, hash, space, symb) {
    const flag = plus ? (
        space && !legacy_behavior$1 ? incompatible_flag(pct_ind, str_ind, /* ' ' */32, "'+'") : /* Float_flag_p */ 1
      ) : (
        space ? /* Float_flag_s */ 2 : /* Float_flag_ */ 0
      );
    let kind;
    let exit = 0;
    if (symb >= 73) {
      switch (symb) {
        case 101 :
          kind = /* Float_e */ 1;
          break;
        case 102 :
          kind = /* Float_f */ 0;
          break;
        case 103 :
          kind = /* Float_g */ 3;
          break;
        case 104 :
          kind = /* Float_h */ 6;
          break;
        default:
          exit = 1;
      }
    } else if (symb >= 69) {
      switch (symb) {
        case 69 :
          kind = /* Float_E */ 2;
          break;
        case 70 :
          exit = 1;
          break;
        case 71 :
          kind = /* Float_G */ 4;
          break;
        case 72 :
          kind = /* Float_H */ 7;
          break;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (hash) {
        if (symb !== 70) {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  2960,
                  11
                ]
              });
        }
        kind = /* Float_CF */ 8;
      } else {
        if (symb !== 70) {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  2960,
                  11
                ]
              });
        }
        kind = /* Float_F */ 5;
      }
    }
    return [
      flag,
      kind
    ];
  };
  const parse_flags = function (pct_ind, str_ind, end_ind, ign) {
    const zero = {
      contents: false
    };
    const minus = {
      contents: false
    };
    const plus = {
      contents: false
    };
    const space = {
      contents: false
    };
    const hash = {
      contents: false
    };
    const set_flag = function (str_ind, flag) {
      if (flag.contents && !legacy_behavior$1) {
        Curry._3(failwith_message({
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String_literal */ 11,
            _0: "invalid format ",
            _1: {
              TAG: /* Caml_string */ 3,
              _0: /* No_padding */ 0,
              _1: {
                TAG: /* String_literal */ 11,
                _0: ": at character number ",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: {
                    TAG: /* String_literal */ 11,
                    _0: ", duplicate flag ",
                    _1: {
                      TAG: /* Caml_char */ 1,
                      _0: /* End_of_format */ 0
                    }
                  }
                }
              }
            }
          },
          _1: "invalid format %S: at character number %d, duplicate flag %C"
        }), str, str_ind, Caml_string.get(str, str_ind));
      }
      flag.contents = true;
    };
    let _str_ind = str_ind;
    while (true) {
      const str_ind$1 = _str_ind;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      const match = Caml_string.get(str, str_ind$1);
      switch (match) {
        case 32 :
          set_flag(str_ind$1, space);
          _str_ind = str_ind$1 + 1 | 0;
          continue;
        case 35 :
          set_flag(str_ind$1, hash);
          _str_ind = str_ind$1 + 1 | 0;
          continue;
        case 43 :
          set_flag(str_ind$1, plus);
          _str_ind = str_ind$1 + 1 | 0;
          continue;
        case 45 :
          set_flag(str_ind$1, minus);
          _str_ind = str_ind$1 + 1 | 0;
          continue;
        case 48 :
          set_flag(str_ind$1, zero);
          _str_ind = str_ind$1 + 1 | 0;
          continue;
      }
      let zero$1 = zero.contents;
      let minus$1 = minus.contents;
      let plus$1 = plus.contents;
      let hash$1 = hash.contents;
      let space$1 = space.contents;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      const padty = zero$1 ? (
          minus$1 ? (
              legacy_behavior$1 ? /* Left */ 0 : incompatible_flag(pct_ind, str_ind$1, /* '-' */45, "0")
            ) : /* Zeros */ 2
        ) : (
          minus$1 ? /* Left */ 0 : /* Right */ 1
        );
      const match$1 = Caml_string.get(str, str_ind$1);
      if (match$1 >= 48) {
        if (match$1 < 58) {
          const match$2 = parse_positive(str_ind$1, end_ind, 0);
          return parse_after_padding(pct_ind, match$2[0], end_ind, minus$1, plus$1, hash$1, space$1, ign, {
            TAG: /* Lit_padding */ 0,
            _0: padty,
            _1: match$2[1]
          });
        }
        
      } else if (match$1 === 42) {
        return parse_after_padding(pct_ind, str_ind$1 + 1 | 0, end_ind, minus$1, plus$1, hash$1, space$1, ign, {
          TAG: /* Arg_padding */ 1,
          _0: padty
        });
      }
      switch (padty) {
        case /* Left */ 0 :
          if (!legacy_behavior$1) {
            invalid_format_without(str_ind$1 - 1 | 0, /* '-' */45, "padding");
          }
          return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, /* No_padding */ 0);
        case /* Right */ 1 :
          return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, /* No_padding */ 0);
        case /* Zeros */ 2 :
          return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, {
            TAG: /* Lit_padding */ 0,
            _0: /* Right */ 1,
            _1: 0
          });
      }
    };
  };
  const parse_tag = function (is_open_tag, str_ind, end_ind) {
    try {
      if (str_ind === end_ind) {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const match = Caml_string.get(str, str_ind);
      if (match !== 60) {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const ind = Stdlib__String.index_from(str, str_ind + 1 | 0, /* '>' */62);
      if (ind >= end_ind) {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const sub_str = Stdlib__String.sub(str, str_ind, (ind - str_ind | 0) + 1 | 0);
      const beg_ind = ind + 1 | 0;
      const fmt_rest = parse_literal(beg_ind, beg_ind, end_ind);
      const sub_fmt = parse_literal(str_ind, str_ind, ind + 1 | 0);
      const sub_format_0 = sub_fmt._0;
      const sub_format = {
        TAG: /* Format */ 0,
        _0: sub_format_0,
        _1: sub_str
      };
      const formatting = is_open_tag ? ({
          TAG: /* Open_tag */ 0,
          _0: sub_format
        }) : ({
          TAG: /* Open_box */ 1,
          _0: sub_format
        });
      return {
        TAG: /* Fmt_EBB */ 0,
        _0: {
          TAG: /* Formatting_gen */ 18,
          _0: formatting,
          _1: fmt_rest._0
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const fmt_rest$1 = parse_literal(str_ind, str_ind, end_ind);
        const sub_format$1 = {
          TAG: /* Format */ 0,
          _0: /* End_of_format */ 0,
          _1: ""
        };
        const formatting$1 = is_open_tag ? ({
            TAG: /* Open_tag */ 0,
            _0: sub_format$1
          }) : ({
            TAG: /* Open_box */ 1,
            _0: sub_format$1
          });
        return {
          TAG: /* Fmt_EBB */ 0,
          _0: {
            TAG: /* Formatting_gen */ 18,
            _0: formatting$1,
            _1: fmt_rest$1._0
          }
        };
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  return parse_literal(0, 0, str.length);
}

function format_of_string_fmtty(str, fmtty) {
  const fmt = fmt_ebb_of_string(undefined, str);
  try {
    return {
      TAG: /* Format */ 0,
      _0: type_format(fmt._0, fmtty),
      _1: str
    };
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Type_mismatch) {
      return Curry._2(failwith_message({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "bad input: format type mismatch between ",
          _1: {
            TAG: /* Caml_string */ 3,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: " and ",
              _1: {
                TAG: /* Caml_string */ 3,
                _0: /* No_padding */ 0,
                _1: /* End_of_format */ 0
              }
            }
          }
        },
        _1: "bad input: format type mismatch between %S and %S"
      }), str, string_of_fmtty(fmtty));
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function format_of_string_format(str, param) {
  const fmt = fmt_ebb_of_string(undefined, str);
  try {
    return {
      TAG: /* Format */ 0,
      _0: type_format(fmt._0, fmtty_of_fmt(param._0)),
      _1: str
    };
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Type_mismatch) {
      return Curry._2(failwith_message({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "bad input: format type mismatch between ",
          _1: {
            TAG: /* Caml_string */ 3,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: " and ",
              _1: {
                TAG: /* Caml_string */ 3,
                _0: /* No_padding */ 0,
                _1: /* End_of_format */ 0
              }
            }
          }
        },
        _1: "bad input: format type mismatch between %S and %S"
      }), str, param._1);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

export {
  is_in_char_set,
  rev_char_set,
  create_char_set,
  add_in_char_set,
  freeze_char_set,
  param_format_of_ignored_format,
  make_printf,
  make_iprintf,
  output_acc,
  bufput_acc,
  strput_acc,
  type_format,
  fmt_ebb_of_string,
  format_of_string_fmtty,
  format_of_string_format,
  char_of_iconv,
  string_of_formatting_lit,
  string_of_fmtty,
  string_of_fmt,
  open_box_of_string,
  symm,
  trans,
  recast,
}
/* No side effect */
`,yf=`// Generated by Melange


function erase_rel(rest) {
  if (/* tag */ typeof rest === "number" || typeof rest === "string") {
    return /* End_of_fmtty */ 0;
  }
  switch (rest.TAG) {
    case /* Char_ty */ 0 :
      return {
        TAG: /* Char_ty */ 0,
        _0: erase_rel(rest._0)
      };
    case /* String_ty */ 1 :
      return {
        TAG: /* String_ty */ 1,
        _0: erase_rel(rest._0)
      };
    case /* Int_ty */ 2 :
      return {
        TAG: /* Int_ty */ 2,
        _0: erase_rel(rest._0)
      };
    case /* Int32_ty */ 3 :
      return {
        TAG: /* Int32_ty */ 3,
        _0: erase_rel(rest._0)
      };
    case /* Nativeint_ty */ 4 :
      return {
        TAG: /* Nativeint_ty */ 4,
        _0: erase_rel(rest._0)
      };
    case /* Int64_ty */ 5 :
      return {
        TAG: /* Int64_ty */ 5,
        _0: erase_rel(rest._0)
      };
    case /* Float_ty */ 6 :
      return {
        TAG: /* Float_ty */ 6,
        _0: erase_rel(rest._0)
      };
    case /* Bool_ty */ 7 :
      return {
        TAG: /* Bool_ty */ 7,
        _0: erase_rel(rest._0)
      };
    case /* Format_arg_ty */ 8 :
      return {
        TAG: /* Format_arg_ty */ 8,
        _0: rest._0,
        _1: erase_rel(rest._1)
      };
    case /* Format_subst_ty */ 9 :
      const ty1 = rest._0;
      return {
        TAG: /* Format_subst_ty */ 9,
        _0: ty1,
        _1: ty1,
        _2: erase_rel(rest._2)
      };
    case /* Alpha_ty */ 10 :
      return {
        TAG: /* Alpha_ty */ 10,
        _0: erase_rel(rest._0)
      };
    case /* Theta_ty */ 11 :
      return {
        TAG: /* Theta_ty */ 11,
        _0: erase_rel(rest._0)
      };
    case /* Any_ty */ 12 :
      return {
        TAG: /* Any_ty */ 12,
        _0: erase_rel(rest._0)
      };
    case /* Reader_ty */ 13 :
      return {
        TAG: /* Reader_ty */ 13,
        _0: erase_rel(rest._0)
      };
    case /* Ignored_reader_ty */ 14 :
      return {
        TAG: /* Ignored_reader_ty */ 14,
        _0: erase_rel(rest._0)
      };
  }
}

function concat_fmtty(fmtty1, fmtty2) {
  if (/* tag */ typeof fmtty1 === "number" || typeof fmtty1 === "string") {
    return fmtty2;
  }
  switch (fmtty1.TAG) {
    case /* Char_ty */ 0 :
      return {
        TAG: /* Char_ty */ 0,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* String_ty */ 1 :
      return {
        TAG: /* String_ty */ 1,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Int_ty */ 2 :
      return {
        TAG: /* Int_ty */ 2,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Int32_ty */ 3 :
      return {
        TAG: /* Int32_ty */ 3,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Nativeint_ty */ 4 :
      return {
        TAG: /* Nativeint_ty */ 4,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Int64_ty */ 5 :
      return {
        TAG: /* Int64_ty */ 5,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Float_ty */ 6 :
      return {
        TAG: /* Float_ty */ 6,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Bool_ty */ 7 :
      return {
        TAG: /* Bool_ty */ 7,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Format_arg_ty */ 8 :
      return {
        TAG: /* Format_arg_ty */ 8,
        _0: fmtty1._0,
        _1: concat_fmtty(fmtty1._1, fmtty2)
      };
    case /* Format_subst_ty */ 9 :
      return {
        TAG: /* Format_subst_ty */ 9,
        _0: fmtty1._0,
        _1: fmtty1._1,
        _2: concat_fmtty(fmtty1._2, fmtty2)
      };
    case /* Alpha_ty */ 10 :
      return {
        TAG: /* Alpha_ty */ 10,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Theta_ty */ 11 :
      return {
        TAG: /* Theta_ty */ 11,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Any_ty */ 12 :
      return {
        TAG: /* Any_ty */ 12,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Reader_ty */ 13 :
      return {
        TAG: /* Reader_ty */ 13,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
    case /* Ignored_reader_ty */ 14 :
      return {
        TAG: /* Ignored_reader_ty */ 14,
        _0: concat_fmtty(fmtty1._0, fmtty2)
      };
  }
}

function concat_fmt(fmt1, fmt2) {
  if (/* tag */ typeof fmt1 === "number" || typeof fmt1 === "string") {
    return fmt2;
  }
  switch (fmt1.TAG) {
    case /* Char */ 0 :
      return {
        TAG: /* Char */ 0,
        _0: concat_fmt(fmt1._0, fmt2)
      };
    case /* Caml_char */ 1 :
      return {
        TAG: /* Caml_char */ 1,
        _0: concat_fmt(fmt1._0, fmt2)
      };
    case /* String */ 2 :
      return {
        TAG: /* String */ 2,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Caml_string */ 3 :
      return {
        TAG: /* Caml_string */ 3,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Int */ 4 :
      return {
        TAG: /* Int */ 4,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: fmt1._2,
        _3: concat_fmt(fmt1._3, fmt2)
      };
    case /* Int32 */ 5 :
      return {
        TAG: /* Int32 */ 5,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: fmt1._2,
        _3: concat_fmt(fmt1._3, fmt2)
      };
    case /* Nativeint */ 6 :
      return {
        TAG: /* Nativeint */ 6,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: fmt1._2,
        _3: concat_fmt(fmt1._3, fmt2)
      };
    case /* Int64 */ 7 :
      return {
        TAG: /* Int64 */ 7,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: fmt1._2,
        _3: concat_fmt(fmt1._3, fmt2)
      };
    case /* Float */ 8 :
      return {
        TAG: /* Float */ 8,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: fmt1._2,
        _3: concat_fmt(fmt1._3, fmt2)
      };
    case /* Bool */ 9 :
      return {
        TAG: /* Bool */ 9,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Flush */ 10 :
      return {
        TAG: /* Flush */ 10,
        _0: concat_fmt(fmt1._0, fmt2)
      };
    case /* String_literal */ 11 :
      return {
        TAG: /* String_literal */ 11,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Char_literal */ 12 :
      return {
        TAG: /* Char_literal */ 12,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Format_arg */ 13 :
      return {
        TAG: /* Format_arg */ 13,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: concat_fmt(fmt1._2, fmt2)
      };
    case /* Format_subst */ 14 :
      return {
        TAG: /* Format_subst */ 14,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: concat_fmt(fmt1._2, fmt2)
      };
    case /* Alpha */ 15 :
      return {
        TAG: /* Alpha */ 15,
        _0: concat_fmt(fmt1._0, fmt2)
      };
    case /* Theta */ 16 :
      return {
        TAG: /* Theta */ 16,
        _0: concat_fmt(fmt1._0, fmt2)
      };
    case /* Formatting_lit */ 17 :
      return {
        TAG: /* Formatting_lit */ 17,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Formatting_gen */ 18 :
      return {
        TAG: /* Formatting_gen */ 18,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Reader */ 19 :
      return {
        TAG: /* Reader */ 19,
        _0: concat_fmt(fmt1._0, fmt2)
      };
    case /* Scan_char_set */ 20 :
      return {
        TAG: /* Scan_char_set */ 20,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: concat_fmt(fmt1._2, fmt2)
      };
    case /* Scan_get_counter */ 21 :
      return {
        TAG: /* Scan_get_counter */ 21,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Scan_next_char */ 22 :
      return {
        TAG: /* Scan_next_char */ 22,
        _0: concat_fmt(fmt1._0, fmt2)
      };
    case /* Ignored_param */ 23 :
      return {
        TAG: /* Ignored_param */ 23,
        _0: fmt1._0,
        _1: concat_fmt(fmt1._1, fmt2)
      };
    case /* Custom */ 24 :
      return {
        TAG: /* Custom */ 24,
        _0: fmt1._0,
        _1: fmt1._1,
        _2: concat_fmt(fmt1._2, fmt2)
      };
  }
}

export {
  concat_fmtty,
  erase_rel,
  concat_fmt,
}
/* No side effect */
`,bf=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

const Undefined = /* @__PURE__ */ Caml_exceptions.create("CamlinternalLazy.Undefined");

function is_val(l) {
  return l.LAZY_DONE;
}

function forward_with_closure(blk, closure) {
  const result = closure();
  blk.VAL = result;
  blk.LAZY_DONE = true;
  return result;
}

function raise_undefined() {
  throw new Caml_js_exceptions.MelangeError(Undefined, {
        MEL_EXN_ID: Undefined
      });
}

function force_lazy_block(blk) {
  const closure = blk.VAL;
  blk.VAL = raise_undefined;
  try {
    return forward_with_closure(blk, closure);
  }
  catch (e){
    blk.VAL = (function () {
      throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
    });
    throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
  }
}

function force_val_lazy_block(blk) {
  const closure = blk.VAL;
  blk.VAL = raise_undefined;
  return forward_with_closure(blk, closure);
}

function force(lzv) {
  const lzv$1 = lzv;
  if (lzv$1.LAZY_DONE) {
    return lzv$1.VAL;
  } else {
    return force_lazy_block(lzv$1);
  }
}

function force_val(lzv) {
  if (lzv.LAZY_DONE) {
    return lzv.VAL;
  } else {
    return force_val_lazy_block(lzv);
  }
}

export {
  Undefined,
  force_lazy_block,
  force_val_lazy_block,
  force,
  force_val,
  is_val,
}
/* No side effect */
`,xf=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,vf=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_oo from "melange.js/caml_oo.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__List from "./list.js";

const new_object_tag_block = (function(size){
  var v = new Array(size)
  v.TAG = 248 // tag
  return v
}
);

function copy(o) {
  return Caml_oo.caml_set_oo_id(Caml_obj.caml_obj_dup(o));
}

const params = {
  compact_table: true,
  copy_parent: true,
  clean_when_copying: true,
  retry_count: 3,
  bucket_small_size: 16
};

function public_method_label(s) {
  let accu = 0;
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    accu = Math.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

const compare = Caml.caml_string_compare;

const funarg = {
  compare: compare
};

function height(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create(l, x, d, r) {
  const hl = height(l);
  const hr = height(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height(ll) >= height(lr)) {
      return create(ll, lv, ld, create(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
      return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height(rr) >= height(rl)) {
    return create(create(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
    return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
}

function add(x, data, m) {
  if (/* tag */ typeof m === "number" || typeof m === "string") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

function fold(f, _m, _accu) {
  while (true) {
    const accu = _accu;
    const m = _m;
    if (/* tag */ typeof m === "number" || typeof m === "string") {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
    _m = m.r;
    continue;
  };
}

const compare$1 = Caml.caml_string_compare;

const funarg$1 = {
  compare: compare$1
};

function height$1(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create$1(l, x, d, r) {
  const hl = height$1(l);
  const hr = height$1(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal$1(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height$1(ll) >= height$1(lr)) {
      return create$1(ll, lv, ld, create$1(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
      return create$1(create$1(ll, lv, ld, lr.l), lr.v, lr.d, create$1(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height$1(rr) >= height$1(rl)) {
    return create$1(create$1(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
    return create$1(create$1(l, x, d, rl.l), rl.v, rl.d, create$1(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
}

function add$1(x, data, m) {
  if (/* tag */ typeof m === "number" || typeof m === "string") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  const rr = add$1(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function find$1(x, _param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const c = Curry._2(funarg$1.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

const compare$2 = Caml.caml_int_compare;

const funarg$2 = {
  compare: compare$2
};

function height$2(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create$2(l, x, d, r) {
  const hl = height$2(l);
  const hr = height$2(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal$2(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height$2(ll) >= height$2(lr)) {
      return create$2(ll, lv, ld, create$2(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
      return create$2(create$2(ll, lv, ld, lr.l), lr.v, lr.d, create$2(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height$2(rr) >= height$2(rl)) {
    return create$2(create$2(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
    return create$2(create$2(l, x, d, rl.l), rl.v, rl.d, create$2(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
}

function add$2(x, data, m) {
  if (/* tag */ typeof m === "number" || typeof m === "string") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add$2(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$2(ll, v, d, r);
    }
  }
  const rr = add$2(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$2(l, v, d, rr);
  }
}

function find$2(x, _param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const c = Curry._2(funarg$2.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

const dummy_table = {
  size: 0,
  methods: [undefined],
  methods_by_name: /* Empty */ 0,
  methods_by_label: /* Empty */ 0,
  previous_states: /* [] */ 0,
  hidden_meths: /* [] */ 0,
  vars: /* Empty */ 0,
  initializers: /* [] */ 0
};

const table_count = {
  contents: 0
};

function fit_size(n) {
  if (n <= 2) {
    return n;
  } else {
    return (fit_size((n + 1 | 0) / 2 | 0) << 1);
  }
}

function new_table(pub_labels) {
  table_count.contents = table_count.contents + 1 | 0;
  const len = pub_labels.length;
  const methods = Caml_array.make((len << 1) + 2 | 0, /* DummyA */ 0);
  Caml_array.set(methods, 0, len);
  Caml_array.set(methods, 1, ((fit_size(len) << 5) / 8 | 0) - 1 | 0);
  for (let i = 0; i < len; ++i) {
    Caml_array.set(methods, (i << 1) + 3 | 0, Caml_array.get(pub_labels, i));
  }
  return {
    size: 2,
    methods: methods,
    methods_by_name: /* Empty */ 0,
    methods_by_label: /* Empty */ 0,
    previous_states: /* [] */ 0,
    hidden_meths: /* [] */ 0,
    vars: /* Empty */ 0,
    initializers: /* [] */ 0
  };
}

function resize(array, new_size) {
  const old_size = array.methods.length;
  if (new_size <= old_size) {
    return;
  }
  const new_buck = Caml_array.make(new_size, /* DummyA */ 0);
  Stdlib__Array.blit(array.methods, 0, new_buck, 0, old_size);
  array.methods = new_buck;
}

const method_count = {
  contents: 0
};

const inst_var_count = {
  contents: 0
};

function new_method(table) {
  const index = table.methods.length;
  resize(table, index + 1 | 0);
  return index;
}

function get_method_label(table, name) {
  try {
    return Curry._2(find$1, name, table.methods_by_name);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const label = new_method(table);
      table.methods_by_name = Curry._3(add$1, name, label, table.methods_by_name);
      table.methods_by_label = Curry._3(add$2, label, true, table.methods_by_label);
      return label;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_method_labels(table, names) {
  return Stdlib__Array.map((function (param) {
    return get_method_label(table, param);
  }), names);
}

function set_method(table, label, element) {
  method_count.contents = method_count.contents + 1 | 0;
  if (Curry._2(find$2, label, table.methods_by_label)) {
    resize(table, label + 1 | 0);
    return Caml_array.set(table.methods, label, element);
  } else {
    table.hidden_meths = {
      hd: [
        label,
        element
      ],
      tl: table.hidden_meths
    };
    return;
  }
}

function get_method(table, label) {
  try {
    return Stdlib__List.assoc(label, table.hidden_meths);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return Caml_array.get(table.methods, label);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function to_list(arr) {
  if (arr === 0) {
    return /* [] */ 0;
  } else {
    return Stdlib__Array.to_list(arr);
  }
}

function narrow(table, vars, virt_meths, concr_meths) {
  const vars$1 = to_list(vars);
  const virt_meths$1 = to_list(virt_meths);
  const concr_meths$1 = to_list(concr_meths);
  const virt_meth_labs = Stdlib__List.map((function (param) {
    return get_method_label(table, param);
  }), virt_meths$1);
  const concr_meth_labs = Stdlib__List.map((function (param) {
    return get_method_label(table, param);
  }), concr_meths$1);
  table.previous_states = {
    hd: [
      table.methods_by_name,
      table.methods_by_label,
      table.hidden_meths,
      table.vars,
      virt_meth_labs,
      vars$1
    ],
    tl: table.previous_states
  };
  table.vars = Curry._3(fold, (function (lab, info, tvars) {
    if (Stdlib__List.mem(lab, vars$1)) {
      return Curry._3(add, lab, info, tvars);
    } else {
      return tvars;
    }
  }), table.vars, /* Empty */ 0);
  const by_name = {
    contents: /* Empty */ 0
  };
  const by_label = {
    contents: /* Empty */ 0
  };
  Stdlib__List.iter2((function (met, label) {
    by_name.contents = Curry._3(add$1, met, label, by_name.contents);
    let tmp;
    try {
      tmp = Curry._2(find$2, label, table.methods_by_label);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        tmp = true;
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
    by_label.contents = Curry._3(add$2, label, tmp, by_label.contents);
  }), concr_meths$1, concr_meth_labs);
  Stdlib__List.iter2((function (met, label) {
    by_name.contents = Curry._3(add$1, met, label, by_name.contents);
    by_label.contents = Curry._3(add$2, label, false, by_label.contents);
  }), virt_meths$1, virt_meth_labs);
  table.methods_by_name = by_name.contents;
  table.methods_by_label = by_label.contents;
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
    if (Stdlib__List.mem(met[0], virt_meth_labs)) {
      return hm;
    } else {
      return {
        hd: met,
        tl: hm
      };
    }
  }), table.hidden_meths, /* [] */ 0);
}

function widen(table) {
  const match = Stdlib__List.hd(table.previous_states);
  const virt_meths = match[4];
  table.previous_states = Stdlib__List.tl(table.previous_states);
  table.vars = Stdlib__List.fold_left((function (s, v) {
    return Curry._3(add, v, Curry._2(find, v, table.vars), s);
  }), match[3], match[5]);
  table.methods_by_name = match[0];
  table.methods_by_label = match[1];
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
    if (Stdlib__List.mem(met[0], virt_meths)) {
      return hm;
    } else {
      return {
        hd: met,
        tl: hm
      };
    }
  }), table.hidden_meths, match[2]);
}

function new_slot(table) {
  const index = table.size;
  table.size = index + 1 | 0;
  return index;
}

function new_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const index = new_slot(table);
      if (name !== "") {
        table.vars = Curry._3(add, name, index, table.vars);
      }
      return index;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function to_array(arr) {
  if (Caml_obj.caml_equal(arr, 0)) {
    return [];
  } else {
    return arr;
  }
}

function new_methods_variables(table, meths, vals) {
  const meths$1 = to_array(meths);
  const nmeths = meths$1.length;
  const nvals = vals.length;
  const res = Caml_array.make(nmeths + nvals | 0, 0);
  for (let i = 0; i < nmeths; ++i) {
    Caml_array.set(res, i, get_method_label(table, Caml_array.get(meths$1, i)));
  }
  for (let i$1 = 0; i$1 < nvals; ++i$1) {
    Caml_array.set(res, i$1 + nmeths | 0, new_variable(table, Caml_array.get(vals, i$1)));
  }
  return res;
}

function get_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              295,
              50
            ]
          });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_variables(table, names) {
  return Stdlib__Array.map((function (param) {
    return get_variable(table, param);
  }), names);
}

function add_initializer(table, f) {
  table.initializers = {
    hd: f,
    tl: table.initializers
  };
}

function create_table(public_methods) {
  if (public_methods === 0) {
    return new_table([]);
  }
  const tags = Stdlib__Array.map(public_method_label, public_methods);
  const table = new_table(tags);
  Stdlib__Array.iteri((function (i, met) {
    const lab = (i << 1) + 2 | 0;
    table.methods_by_name = Curry._3(add$1, met, lab, table.methods_by_name);
    table.methods_by_label = Curry._3(add$2, lab, true, table.methods_by_label);
  }), public_methods);
  return table;
}

function init_class(table) {
  inst_var_count.contents = (inst_var_count.contents + table.size | 0) - 1 | 0;
  table.initializers = Stdlib__List.rev(table.initializers);
  resize(table, 3 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0);
}

function inherits(cla, vals, virt_meths, concr_meths, param, top) {
  const $$super = param[1];
  narrow(cla, vals, virt_meths, concr_meths);
  const init = top ? Curry._2($$super, cla, param[2]) : Curry._1($$super, cla);
  widen(cla);
  return Caml_array.concat({
    hd: [init],
    tl: {
      hd: Stdlib__Array.map((function (param) {
        return get_variable(cla, param);
      }), to_array(vals)),
      tl: {
        hd: Stdlib__Array.map((function (nm) {
          return get_method(cla, get_method_label(cla, nm));
        }), to_array(concr_meths)),
        tl: /* [] */ 0
      }
    }
  });
}

function make_class(pub_meths, class_init) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  return [
    Curry._1(env_init, 0),
    class_init,
    0
  ];
}

function make_class_store(pub_meths, class_init, init_table) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  init_table.class_init = class_init;
  init_table.env_init = env_init;
}

function create_object(table) {
  const obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function create_object_opt(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  const obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function iter_f(obj, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    Curry._1(param.hd, obj);
    _param = param.tl;
    continue;
  };
}

function run_initializers(obj, table) {
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */ 0)) {
    return iter_f(obj, inits);
  }
  
}

function run_initializers_opt(obj_0, obj, table) {
  if (obj_0) {
    return obj;
  }
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */ 0)) {
    iter_f(obj, inits);
  }
  return obj;
}

function create_object_and_run_initializers(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  const obj = create_object(table);
  run_initializers(obj, table);
  return obj;
}

function set_data(tables, v) {
  if (!/* tag */ (typeof tables === "number" || typeof tables === "string")) {
    tables.data = v;
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          439,
          13
        ]
      });
}

function set_next(tables, v) {
  if (!/* tag */ (typeof tables === "number" || typeof tables === "string")) {
    tables.next = v;
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          442,
          13
        ]
      });
}

function get_key(tables) {
  if (!/* tag */ (typeof tables === "number" || typeof tables === "string")) {
    return tables.key;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          445,
          13
        ]
      });
}

function get_data(tables) {
  if (!/* tag */ (typeof tables === "number" || typeof tables === "string")) {
    return tables.data;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          448,
          13
        ]
      });
}

function get_next(tables) {
  if (!/* tag */ (typeof tables === "number" || typeof tables === "string")) {
    return tables.next;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          451,
          13
        ]
      });
}

function build_path(n, keys, tables) {
  const res = {
    TAG: /* Cons */ 0,
    key: 0,
    data: /* Empty */ 0,
    next: /* Empty */ 0
  };
  let r = res;
  for (let i = 0; i <= n; ++i) {
    r = {
      TAG: /* Cons */ 0,
      key: Caml_array.get(keys, i),
      data: r,
      next: /* Empty */ 0
    };
  }
  set_data(tables, r);
  return res;
}

function lookup_keys(i, keys, tables) {
  if (i < 0) {
    return tables;
  }
  const key = Caml_array.get(keys, i);
  let _tables = tables;
  while (true) {
    const tables$1 = _tables;
    if (get_key(tables$1) === key) {
      const tables_data = get_data(tables$1);
      if (!/* tag */ (typeof tables_data === "number" || typeof tables_data === "string")) {
        return lookup_keys(i - 1 | 0, keys, tables_data);
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              469,
              17
            ]
          });
    }
    const next = get_next(tables$1);
    if (/* tag */ typeof next === "number" || typeof next === "string") {
      const next$1 = {
        TAG: /* Cons */ 0,
        key: key,
        data: /* Empty */ 0,
        next: /* Empty */ 0
      };
      set_next(tables$1, next$1);
      return build_path(i - 1 | 0, keys, next$1);
    }
    _tables = next;
    continue;
  };
}

function lookup_tables(root, keys) {
  const root_data = get_data(root);
  if (/* tag */ typeof root_data === "number" || typeof root_data === "string") {
    return build_path(keys.length - 1 | 0, keys, root);
  } else {
    return lookup_keys(keys.length - 1 | 0, keys, root_data);
  }
}

function new_cache(table) {
  const n = new_method(table);
  const n$1 = n % 2 === 0 || n > (2 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0) ? n : new_method(table);
  Caml_array.set(table.methods, n$1, 0);
  return n$1;
}

function method_impl(table, i, arr) {
  const next = function (param) {
    i.contents = i.contents + 1 | 0;
    return Caml_array.get(arr, i.contents);
  };
  const clo = next(undefined);
  if (!/* tag */ (typeof clo === "number" || typeof clo === "string")) {
    return clo;
  }
  switch (clo) {
    case /* GetConst */ 0 :
      const partial_arg = next(undefined);
      return function (param) {
        return partial_arg;
      };
    case /* GetVar */ 1 :
      const partial_arg$1 = next(undefined);
      return function (param) {
        return param[partial_arg$1];
      };
    case /* GetEnv */ 2 :
      const e = next(undefined);
      const n = next(undefined);
      return function (param) {
        return param[e][n];
      };
    case /* GetMeth */ 3 :
      const partial_arg$2 = next(undefined);
      return function (param) {
        return Curry._1(param[0][partial_arg$2], param);
      };
    case /* SetVar */ 4 :
      const partial_arg$3 = next(undefined);
      return function (param, param$1) {
        param[partial_arg$3] = param$1;
      };
    case /* AppConst */ 5 :
      const f = next(undefined);
      const x = next(undefined);
      return function (param) {
        return Curry._1(f, x);
      };
    case /* AppVar */ 6 :
      const f$1 = next(undefined);
      const n$1 = next(undefined);
      return function (param) {
        return Curry._1(f$1, param[n$1]);
      };
    case /* AppEnv */ 7 :
      const f$2 = next(undefined);
      const e$1 = next(undefined);
      const n$2 = next(undefined);
      return function (param) {
        return Curry._1(f$2, param[e$1][n$2]);
      };
    case /* AppMeth */ 8 :
      const f$3 = next(undefined);
      const n$3 = next(undefined);
      return function (param) {
        return Curry._1(f$3, Curry._1(param[0][n$3], param));
      };
    case /* AppConstConst */ 9 :
      const f$4 = next(undefined);
      const x$1 = next(undefined);
      const y = next(undefined);
      return function (param) {
        return Curry._2(f$4, x$1, y);
      };
    case /* AppConstVar */ 10 :
      const f$5 = next(undefined);
      const x$2 = next(undefined);
      const n$4 = next(undefined);
      return function (param) {
        return Curry._2(f$5, x$2, param[n$4]);
      };
    case /* AppConstEnv */ 11 :
      const f$6 = next(undefined);
      const x$3 = next(undefined);
      const e$2 = next(undefined);
      const n$5 = next(undefined);
      return function (param) {
        return Curry._2(f$6, x$3, param[e$2][n$5]);
      };
    case /* AppConstMeth */ 12 :
      const f$7 = next(undefined);
      const x$4 = next(undefined);
      const n$6 = next(undefined);
      return function (param) {
        return Curry._2(f$7, x$4, Curry._1(param[0][n$6], param));
      };
    case /* AppVarConst */ 13 :
      const f$8 = next(undefined);
      const n$7 = next(undefined);
      const x$5 = next(undefined);
      return function (param) {
        return Curry._2(f$8, param[n$7], x$5);
      };
    case /* AppEnvConst */ 14 :
      const f$9 = next(undefined);
      const e$3 = next(undefined);
      const n$8 = next(undefined);
      const x$6 = next(undefined);
      return function (param) {
        return Curry._2(f$9, param[e$3][n$8], x$6);
      };
    case /* AppMethConst */ 15 :
      const f$10 = next(undefined);
      const n$9 = next(undefined);
      const x$7 = next(undefined);
      return function (param) {
        return Curry._2(f$10, Curry._1(param[0][n$9], param), x$7);
      };
    case /* MethAppConst */ 16 :
      const n$10 = next(undefined);
      const x$8 = next(undefined);
      return function (param) {
        return Curry._2(param[0][n$10], param, x$8);
      };
    case /* MethAppVar */ 17 :
      const n$11 = next(undefined);
      const m = next(undefined);
      return function (param) {
        return Curry._2(param[0][n$11], param, param[m]);
      };
    case /* MethAppEnv */ 18 :
      const n$12 = next(undefined);
      const e$4 = next(undefined);
      const m$1 = next(undefined);
      return function (param) {
        return Curry._2(param[0][n$12], param, param[e$4][m$1]);
      };
    case /* MethAppMeth */ 19 :
      const n$13 = next(undefined);
      const m$2 = next(undefined);
      return function (param) {
        return Curry._2(param[0][n$13], param, Curry._1(param[0][m$2], param));
      };
    case /* SendConst */ 20 :
      const m$3 = next(undefined);
      const x$9 = next(undefined);
      const partial_arg$4 = new_cache(table);
      return function (param) {
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, x$9, m$3, 1), x$9, param[0], partial_arg$4);
      };
    case /* SendVar */ 21 :
      const m$4 = next(undefined);
      const n$14 = next(undefined);
      const partial_arg$5 = new_cache(table);
      return function (param) {
        const tmp = param[n$14];
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$4, 2), tmp, param[0], partial_arg$5);
      };
    case /* SendEnv */ 22 :
      const m$5 = next(undefined);
      const e$5 = next(undefined);
      const n$15 = next(undefined);
      const partial_arg$6 = new_cache(table);
      return function (param) {
        const tmp = param[e$5][n$15];
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$5, 3), tmp, param[0], partial_arg$6);
      };
    case /* SendMeth */ 23 :
      const m$6 = next(undefined);
      const n$16 = next(undefined);
      const partial_arg$7 = new_cache(table);
      return function (param) {
        const tmp = Curry._1(param[0][n$16], param);
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$6, 4), tmp, param[0], partial_arg$7);
      };
  }
}

function set_methods(table, methods) {
  const len = methods.length;
  const i = {
    contents: 0
  };
  while (i.contents < len) {
    const label = Caml_array.get(methods, i.contents);
    const clo = method_impl(table, i, methods);
    set_method(table, label, clo);
    i.contents = i.contents + 1 | 0;
  };
}

function stats(param) {
  return {
    classes: table_count.contents,
    methods: method_count.contents,
    inst_vars: inst_var_count.contents
  };
}

export {
  public_method_label,
  new_method,
  new_variable,
  new_methods_variables,
  get_variable,
  get_variables,
  get_method_label,
  get_method_labels,
  get_method,
  set_method,
  set_methods,
  narrow,
  widen,
  add_initializer,
  dummy_table,
  create_table,
  init_class,
  inherits,
  make_class,
  make_class_store,
  copy,
  create_object,
  create_object_opt,
  run_initializers,
  run_initializers_opt,
  create_object_and_run_initializers,
  lookup_tables,
  params,
  stats,
}
/* Vars Not a pure module */
`,$f=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function chr(n) {
  if (n < 0 || n > 255) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Char.chr"
        });
  }
  return n;
}

function escaped(c) {
  let exit = 0;
  if (c >= 40) {
    if (c === 92) {
      return "\\\\\\\\";
    }
    exit = c >= 127 ? 1 : 2;
  } else if (c >= 32) {
    if (c >= 39) {
      return "\\\\'";
    }
    exit = 2;
  } else if (c >= 14) {
    exit = 1;
  } else {
    switch (c) {
      case 8 :
        return "\\\\b";
      case 9 :
        return "\\\\t";
      case 10 :
        return "\\\\n";
      case 0 :
      case 1 :
      case 2 :
      case 3 :
      case 4 :
      case 5 :
      case 6 :
      case 7 :
      case 11 :
      case 12 :
        exit = 1;
        break;
      case 13 :
        return "\\\\r";
    }
  }
  switch (exit) {
    case 1 :
      const s = [
        0,
        0,
        0,
        0
      ];
      s[0] = /* '\\\\' */92;
      s[1] = 48 + (c / 100 | 0) | 0;
      s[2] = 48 + (c / 10 | 0) % 10 | 0;
      s[3] = 48 + c % 10 | 0;
      return Caml_bytes.bytes_to_string(s);
    case 2 :
      const s$1 = [0];
      s$1[0] = c;
      return Caml_bytes.bytes_to_string(s$1);
  }
}

function lowercase_ascii(c) {
  if (c > 90 || c < 65) {
    return c;
  } else {
    return c + 32 | 0;
  }
}

function uppercase_ascii(c) {
  if (c > 122 || c < 97) {
    return c;
  } else {
    return c - 32 | 0;
  }
}

function compare(c1, c2) {
  return c1 - c2 | 0;
}

function equal(c1, c2) {
  return (c1 - c2 | 0) === 0;
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

export {
  chr,
  escaped,
  lowercase_ascii,
  uppercase_ascii,
  compare,
  equal,
  seeded_hash,
  hash,
}
/* No side effect */
`,kf=`// Generated by Melange

import * as Caml_float from "melange.js/caml_float.js";

const one = {
  re: 1.0,
  im: 0.0
};

function add(x, y) {
  return {
    re: x.re + y.re,
    im: x.im + y.im
  };
}

function sub(x, y) {
  return {
    re: x.re - y.re,
    im: x.im - y.im
  };
}

function neg(x) {
  return {
    re: - x.re,
    im: - x.im
  };
}

function conj(x) {
  return {
    re: x.re,
    im: - x.im
  };
}

function mul(x, y) {
  return {
    re: x.re * y.re - x.im * y.im,
    im: x.re * y.im + x.im * y.re
  };
}

function div(x, y) {
  if (Math.abs(y.re) >= Math.abs(y.im)) {
    const r = y.im / y.re;
    const d = y.re + r * y.im;
    return {
      re: (x.re + r * x.im) / d,
      im: (x.im - r * x.re) / d
    };
  }
  const r$1 = y.re / y.im;
  const d$1 = y.im + r$1 * y.re;
  return {
    re: (r$1 * x.re + x.im) / d$1,
    im: (r$1 * x.im - x.re) / d$1
  };
}

function inv(x) {
  return div(one, x);
}

function norm2(x) {
  return x.re * x.re + x.im * x.im;
}

function norm(x) {
  return Caml_float.caml_hypot_float(x.re, x.im);
}

function arg(x) {
  return Math.atan2(x.im, x.re);
}

function polar(n, a) {
  return {
    re: Math.cos(a) * n,
    im: Math.sin(a) * n
  };
}

function sqrt(x) {
  if (x.re === 0.0 && x.im === 0.0) {
    return {
      re: 0.0,
      im: 0.0
    };
  }
  const r = Math.abs(x.re);
  const i = Math.abs(x.im);
  let w;
  if (r >= i) {
    const q = i / r;
    w = Math.sqrt(r) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + q * q)));
  } else {
    const q$1 = r / i;
    w = Math.sqrt(i) * Math.sqrt(0.5 * (q$1 + Math.sqrt(1.0 + q$1 * q$1)));
  }
  if (x.re >= 0.0) {
    return {
      re: w,
      im: 0.5 * x.im / w
    };
  } else {
    return {
      re: 0.5 * i / w,
      im: x.im >= 0.0 ? w : - w
    };
  }
}

function exp(x) {
  const e = Math.exp(x.re);
  return {
    re: e * Math.cos(x.im),
    im: e * Math.sin(x.im)
  };
}

function log(x) {
  return {
    re: Math.log(norm(x)),
    im: Math.atan2(x.im, x.re)
  };
}

function pow(x, y) {
  return exp(mul(y, log(x)));
}

const zero = {
  re: 0.0,
  im: 0.0
};

const i = {
  re: 0.0,
  im: 1.0
};

export {
  zero,
  one,
  i,
  neg,
  conj,
  add,
  sub,
  mul,
  inv,
  div,
  sqrt,
  norm2,
  norm,
  arg,
  polar,
  exp,
  log,
  pow,
}
/* No side effect */
`,Cf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_md5 from "melange.js/caml_md5.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Char from "./char.js";
import * as Stdlib__In_channel from "./in_channel.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__String from "./string.js";

function hex_of_string(d) {
  const char_hex = function (n) {
    return Stdlib__Char.chr(n < 10 ? /* '0' */48 + n | 0 : (/* 'a' */97 + n | 0) - 10 | 0);
  };
  const len = d.length;
  const result = Caml_bytes.caml_create_bytes((len << 1));
  for (let i = 0; i < len; ++i) {
    const x = Caml_string.get(d, i);
    result[(i << 1)] = char_hex((x >>> 4));
    result[(i << 1) + 1 | 0] = char_hex(x & 15);
  }
  return Caml_bytes.bytes_to_string(result);
}

function string_of_hex(s) {
  const digit = function (c) {
    if (c >= 65) {
      if (c >= 97) {
        if (c >= 103) {
          throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Digest.of_hex"
              });
        }
        return (c - /* 'a' */97 | 0) + 10 | 0;
      }
      if (c >= 71) {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Digest.of_hex"
            });
      }
      return (c - /* 'A' */65 | 0) + 10 | 0;
    }
    if (c > 57 || c < 48) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Digest.of_hex"
          });
    }
    return c - /* '0' */48 | 0;
  };
  const $$byte = function (i) {
    return (digit(Caml_string.get(s, i)) << 4) + digit(Caml_string.get(s, i + 1 | 0)) | 0;
  };
  const f = function (i) {
    return Stdlib__Char.chr($$byte((i << 1)));
  };
  const n = (s.length >> 1);
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.init(n, f));
}

function string(str) {
  return Caml_external_polyfill.resolve("caml_blake2_string")(16, "", str, 0, str.length);
}

function bytes(b) {
  return Caml_external_polyfill.resolve("caml_blake2_bytes")(16, "", b, 0, b.length);
}

function substring(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.substring"
        });
  }
  return Caml_external_polyfill.resolve("caml_blake2_string")(16, "", str, ofs, len);
}

function subbytes(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.subbytes"
        });
  }
  return Caml_external_polyfill.resolve("caml_blake2_bytes")(16, "", b, ofs, len);
}

function channel(ic, toread) {
  const buf = Caml_bytes.caml_create_bytes(4096);
  const ctx = Caml_external_polyfill.resolve("caml_blake2_create")(16, "");
  if (toread < 0) {
    let _param;
    while (true) {
      const n = Stdlib__In_channel.input(ic, buf, 0, 4096);
      if (n === 0) {
        return Caml_external_polyfill.resolve("caml_blake2_final")(ctx, 16);
      }
      Caml_external_polyfill.resolve("caml_blake2_update")(ctx, buf, 0, n);
      _param = undefined;
      continue;
    };
  }
  let _toread = toread;
  while (true) {
    const toread$1 = _toread;
    if (toread$1 === 0) {
      return Caml_external_polyfill.resolve("caml_blake2_final")(ctx, 16);
    }
    const n$1 = Stdlib__In_channel.input(ic, buf, 0, Stdlib__Int.min(4096, toread$1));
    if (n$1 === 0) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
            MEL_EXN_ID: Stdlib.End_of_file
          });
    }
    Caml_external_polyfill.resolve("caml_blake2_update")(ctx, buf, 0, n$1);
    _toread = toread$1 - n$1 | 0;
    continue;
  };
}

function file(filename) {
  return Stdlib__In_channel.with_open_bin(filename, (function (ic) {
    return channel(ic, -1);
  }));
}

const output = Stdlib.output_string;

function input(chan) {
  return Stdlib.really_input_string(chan, 16);
}

function to_hex(d) {
  if (d.length !== 16) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.to_hex"
        });
  }
  return hex_of_string(d);
}

function of_hex(s) {
  if (s.length !== 32) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.of_hex"
        });
  }
  return string_of_hex(s);
}

const BLAKE128 = {
  hash_length: 16,
  compare: Stdlib__String.compare,
  equal: Stdlib__String.equal,
  string: string,
  bytes: bytes,
  substring: substring,
  subbytes: subbytes,
  channel: channel,
  file: file,
  output: output,
  input: input,
  to_hex: to_hex,
  of_hex: of_hex
};

function string$1(str) {
  return Caml_external_polyfill.resolve("caml_blake2_string")(32, "", str, 0, str.length);
}

function bytes$1(b) {
  return Caml_external_polyfill.resolve("caml_blake2_bytes")(32, "", b, 0, b.length);
}

function substring$1(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.substring"
        });
  }
  return Caml_external_polyfill.resolve("caml_blake2_string")(32, "", str, ofs, len);
}

function subbytes$1(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.subbytes"
        });
  }
  return Caml_external_polyfill.resolve("caml_blake2_bytes")(32, "", b, ofs, len);
}

function channel$1(ic, toread) {
  const buf = Caml_bytes.caml_create_bytes(4096);
  const ctx = Caml_external_polyfill.resolve("caml_blake2_create")(32, "");
  if (toread < 0) {
    let _param;
    while (true) {
      const n = Stdlib__In_channel.input(ic, buf, 0, 4096);
      if (n === 0) {
        return Caml_external_polyfill.resolve("caml_blake2_final")(ctx, 32);
      }
      Caml_external_polyfill.resolve("caml_blake2_update")(ctx, buf, 0, n);
      _param = undefined;
      continue;
    };
  }
  let _toread = toread;
  while (true) {
    const toread$1 = _toread;
    if (toread$1 === 0) {
      return Caml_external_polyfill.resolve("caml_blake2_final")(ctx, 32);
    }
    const n$1 = Stdlib__In_channel.input(ic, buf, 0, Stdlib__Int.min(4096, toread$1));
    if (n$1 === 0) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
            MEL_EXN_ID: Stdlib.End_of_file
          });
    }
    Caml_external_polyfill.resolve("caml_blake2_update")(ctx, buf, 0, n$1);
    _toread = toread$1 - n$1 | 0;
    continue;
  };
}

function file$1(filename) {
  return Stdlib__In_channel.with_open_bin(filename, (function (ic) {
    return channel$1(ic, -1);
  }));
}

const output$1 = Stdlib.output_string;

function input$1(chan) {
  return Stdlib.really_input_string(chan, 32);
}

function to_hex$1(d) {
  if (d.length !== 32) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.to_hex"
        });
  }
  return hex_of_string(d);
}

function of_hex$1(s) {
  if (s.length !== 64) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.of_hex"
        });
  }
  return string_of_hex(s);
}

const BLAKE256 = {
  hash_length: 32,
  compare: Stdlib__String.compare,
  equal: Stdlib__String.equal,
  string: string$1,
  bytes: bytes$1,
  substring: substring$1,
  subbytes: subbytes$1,
  channel: channel$1,
  file: file$1,
  output: output$1,
  input: input$1,
  to_hex: to_hex$1,
  of_hex: of_hex$1
};

function string$2(str) {
  return Caml_external_polyfill.resolve("caml_blake2_string")(64, "", str, 0, str.length);
}

function bytes$2(b) {
  return Caml_external_polyfill.resolve("caml_blake2_bytes")(64, "", b, 0, b.length);
}

function substring$2(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.substring"
        });
  }
  return Caml_external_polyfill.resolve("caml_blake2_string")(64, "", str, ofs, len);
}

function subbytes$2(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.subbytes"
        });
  }
  return Caml_external_polyfill.resolve("caml_blake2_bytes")(64, "", b, ofs, len);
}

function channel$2(ic, toread) {
  const buf = Caml_bytes.caml_create_bytes(4096);
  const ctx = Caml_external_polyfill.resolve("caml_blake2_create")(64, "");
  if (toread < 0) {
    let _param;
    while (true) {
      const n = Stdlib__In_channel.input(ic, buf, 0, 4096);
      if (n === 0) {
        return Caml_external_polyfill.resolve("caml_blake2_final")(ctx, 64);
      }
      Caml_external_polyfill.resolve("caml_blake2_update")(ctx, buf, 0, n);
      _param = undefined;
      continue;
    };
  }
  let _toread = toread;
  while (true) {
    const toread$1 = _toread;
    if (toread$1 === 0) {
      return Caml_external_polyfill.resolve("caml_blake2_final")(ctx, 64);
    }
    const n$1 = Stdlib__In_channel.input(ic, buf, 0, Stdlib__Int.min(4096, toread$1));
    if (n$1 === 0) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
            MEL_EXN_ID: Stdlib.End_of_file
          });
    }
    Caml_external_polyfill.resolve("caml_blake2_update")(ctx, buf, 0, n$1);
    _toread = toread$1 - n$1 | 0;
    continue;
  };
}

function file$2(filename) {
  return Stdlib__In_channel.with_open_bin(filename, (function (ic) {
    return channel$2(ic, -1);
  }));
}

const output$2 = Stdlib.output_string;

function input$2(chan) {
  return Stdlib.really_input_string(chan, 64);
}

function to_hex$2(d) {
  if (d.length !== 64) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.to_hex"
        });
  }
  return hex_of_string(d);
}

function of_hex$2(s) {
  if (s.length !== 128) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.of_hex"
        });
  }
  return string_of_hex(s);
}

const BLAKE512 = {
  hash_length: 64,
  compare: Stdlib__String.compare,
  equal: Stdlib__String.equal,
  string: string$2,
  bytes: bytes$2,
  substring: substring$2,
  subbytes: subbytes$2,
  channel: channel$2,
  file: file$2,
  output: output$2,
  input: input$2,
  to_hex: to_hex$2,
  of_hex: of_hex$2
};

function string$3(str) {
  return Caml_md5.caml_md5_string(str, 0, str.length);
}

function bytes$3(b) {
  return Caml_md5.caml_md5_bytes(b, 0, b.length);
}

function substring$3(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.substring"
        });
  }
  return Caml_md5.caml_md5_string(str, ofs, len);
}

function subbytes$3(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.subbytes"
        });
  }
  return Caml_md5.caml_md5_bytes(b, ofs, len);
}

function file$3(filename) {
  return Stdlib__In_channel.with_open_bin(filename, (function (ic) {
    return Caml_external_polyfill.resolve("caml_md5_chan")(ic, -1);
  }));
}

const output$3 = Stdlib.output_string;

function input$3(chan) {
  return Stdlib.really_input_string(chan, 16);
}

function to_hex$3(d) {
  if (d.length !== 16) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.to_hex"
        });
  }
  return hex_of_string(d);
}

function of_hex$3(s) {
  if (s.length !== 32) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.from_hex"
        });
  }
  return string_of_hex(s);
}

const compare = Stdlib__String.compare;

const equal = Stdlib__String.equal;

function channel$3(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_md5_chan")(prim0, prim1);
}

const from_hex = of_hex$3;

function MD5_channel(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_md5_chan")(prim0, prim1);
}

const MD5 = {
  hash_length: 16,
  compare: Stdlib__String.compare,
  equal: Stdlib__String.equal,
  string: string$3,
  bytes: bytes$3,
  substring: substring$3,
  subbytes: subbytes$3,
  channel: MD5_channel,
  file: file$3,
  output: output$3,
  input: input$3,
  to_hex: to_hex$3,
  of_hex: of_hex$3
};

export {
  compare,
  equal,
  string$3 as string,
  bytes$3 as bytes,
  substring$3 as substring,
  subbytes$3 as subbytes,
  channel$3 as channel,
  file$3 as file,
  output$3 as output,
  input$3 as input,
  to_hex$3 as to_hex,
  of_hex$3 as of_hex,
  from_hex,
  BLAKE128,
  BLAKE256,
  BLAKE512,
  MD5,
}
/* Stdlib__In_channel Not a pure module */
`,Ef=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printexc from "./printexc.js";
import * as Stdlib__Queue from "./queue.js";

const atomic_lock = {
  contents: false
};

function atomically(f) {
  atomic_lock.contents = true;
  return Stdlib__Fun.protect((function (param) {
    atomic_lock.contents = false;
  }), f);
}

const first_spawn_queue = {
  length: 0,
  first: /* Nil */ 0,
  last: /* Nil */ 0
};

const first_spawn_occurred = {
  contents: false
};

function before_first_spawn(f) {
  atomically(function (param) {
    if (first_spawn_occurred.contents) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Domain.before_first_spawn"
          });
    }
    Stdlib__Queue.push(f, first_spawn_queue);
  });
}

function maybe_first_spawn(param) {
  atomically(function (param) {
    if (first_spawn_occurred.contents) {
      return;
    }
    first_spawn_occurred.contents = true;
    while (first_spawn_queue.length !== 0) {
      const f = Stdlib__Queue.take(first_spawn_queue);
      Curry._1(f, undefined);
    };
  });
}

const at_exit_table = {
  contents: /* [] */ 0
};

function at_exit(f) {
  atomically(function (param) {
    at_exit_table.contents = {
      hd: f,
      tl: at_exit_table.contents
    };
  });
}

function get_id(t) {
  return t.id;
}

function self(param) {
  return 0;
}

function cpu_relax(param) {
  
}

function is_main_domain(param) {
  return true;
}

function self_index(param) {
  return 0;
}

function recommended_domain_count(param) {
  return 1;
}

const all_keys = {
  contents: /* [] */ 0
};

function new_key(split_from_parent, init) {
  const key = {
    table: undefined,
    split_from_parent: split_from_parent,
    init: init
  };
  atomically(function (param) {
    all_keys.contents = {
      hd: {
        TAG: /* Key */ 0,
        _0: key
      },
      tl: all_keys.contents
    };
  });
  return key;
}

function get(key) {
  const v = key.table;
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  const v$1 = Curry._1(key.init, undefined);
  atomically(function (param) {
    key.table = Caml_option.some(v$1);
  });
  return v$1;
}

function set(key, v) {
  atomically(function (param) {
    key.table = Caml_option.some(v);
  });
}

function prepare_split_keys_before_spawn(param) {
  return Stdlib__List.filter_map((function (key) {
    let key$1 = key._0;
    const split = key$1.split_from_parent;
    if (split === undefined) {
      return;
    }
    const current = get(key$1);
    const child = Curry._1(split, current);
    return {
      TAG: /* Key_value */ 0,
      _0: key$1,
      _1: child
    };
  }), all_keys.contents);
}

function perform_split_after_spawn(split_keys) {
  const perform_split = function (param) {
    set(param._0, param._1);
  };
  Stdlib__List.iter(perform_split, split_keys);
}

const next_id = {
  contents: 0
};

function spawn(f) {
  maybe_first_spawn(undefined);
  const status = {
    contents: /* Running */ 0
  };
  const split_keys = prepare_split_keys_before_spawn(undefined);
  const handle = new Promise((function (resolve, reject) {
        let param = [
          split_keys,
          status
        ];
        const status$1 = param[1];
        perform_split_after_spawn(param[0]);
        let exit = 0;
        let v;
        try {
          v = Curry._1(f, undefined);
          exit = 1;
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          let bt;
          status$1.contents = {
            TAG: /* Error */ 1,
            _0: exn,
            _1: bt
          };
          reject(exn);
        }
        if (exit === 1) {
          status$1.contents = {
            TAG: /* Return */ 0,
            _0: v
          };
          resolve(v);
        }
        const at_exit_callbacks = atomically(function (param) {
          return at_exit_table.contents;
        });
        try {
          Stdlib__List.iter((function (f) {
            Curry._1(f, undefined);
          }), at_exit_callbacks);
          return;
        }
        catch (raw_exn$1){
          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          const match = status$1.contents;
          if (/* tag */ typeof match === "number" || typeof match === "string") {
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/stdlib/domain.ml",
                    77,
                    19
                  ]
                });
          }
          if (match.TAG !== /* Return */ 0) {
            return;
          }
          let bt$1;
          status$1.contents = {
            TAG: /* Error */ 1,
            _0: exn$1,
            _1: bt$1
          };
          return;
        }
      }));
  return {
    id: (next_id.contents = next_id.contents + 1 | 0, next_id.contents),
    handle: handle,
    status: status
  };
}

function join(t) {
  return t.handle.then(function (param) {
    const v = t.status.contents;
    if (/* tag */ typeof v === "number" || typeof v === "string") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/stdlib/domain.ml",
              181,
              17
            ]
          });
    }
    if (v.TAG === /* Return */ 0) {
      return Promise.resolve(v._0);
    }
    throw new Caml_js_exceptions.MelangeError(v._0.MEL_EXN_ID, v._0);
  }).catch(function (param) {
    const match = t.status.contents;
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/stdlib/domain.ml",
              188,
              30
            ]
          });
    }
    if (match.TAG === /* Return */ 0) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/stdlib/domain.ml",
              188,
              30
            ]
          });
    }
    throw new Caml_js_exceptions.MelangeError(match._0.MEL_EXN_ID, match._0);
  });
}

const DLS = {
  new_key: new_key,
  get: get,
  set: set
};

export {
  spawn,
  join,
  get_id,
  self,
  before_first_spawn,
  at_exit,
  cpu_relax,
  is_main_domain,
  recommended_domain_count,
  self_index,
  DLS,
}
/* Stdlib__Fun Not a pure module */
`,Af=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as CamlinternalOO from "./camlinternalOO.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Obj from "./obj.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Sys from "./sys.js";

const object_tables = {
  TAG: /* Cons */ 0,
  key: undefined,
  data: undefined,
  next: undefined
};

function fresh(param) {
  const r = {
    contents: undefined
  };
  if (!object_tables.key) {
    const $$class = CamlinternalOO.create_table(0);
    const x = CamlinternalOO.new_variable($$class, "x");
    const env_init = function (env) {
      const self = CamlinternalOO.create_object_opt(undefined, $$class);
      self[x] = env[1];
      return self;
    };
    CamlinternalOO.init_class($$class);
    object_tables.key = env_init;
  }
  const envs = [
    undefined,
    r
  ];
  const dummy = Curry._1(object_tables.key, envs);
  r.contents = Caml_option.some(dummy);
  return {
    TAG: /* Fresh */ 0,
    _0: dummy
  };
}

function make(n, x, dummy) {
  if (x.TAG !== Stdlib__Obj.double_tag) {
    return Caml_array.make(n, x);
  }
  const arr = Caml_array.make(n, dummy);
  Stdlib__Array.fill(arr, 0, n, x);
  return arr;
}

function copy(a, dummy) {
  if (a.TAG !== Stdlib__Obj.double_array_tag) {
    return Stdlib__Array.copy(a);
  }
  const n = a.length;
  const arr = Caml_array.make(n, dummy);
  for (let i = 0; i < n; ++i) {
    arr[i] = a[i];
  }
  return arr;
}

function unsafe_nocopy(a, dummy) {
  if (a.TAG !== Stdlib__Obj.double_array_tag) {
    return a;
  } else {
    return copy(a, dummy);
  }
}

function init(n, f, dummy) {
  const arr = Caml_array.make(n, dummy);
  for (let i = 0; i < n; ++i) {
    arr[i] = Curry._1(f, i);
  }
  return arr;
}

function blit_array(src, src_pos, dst, dst_pos, len) {
  if (src.TAG !== Stdlib__Obj.double_array_tag) {
    return Stdlib__Array.blit(src, src_pos, dst, dst_pos, len);
  }
  for (let i = 0; i < len; ++i) {
    Caml_array.set(dst, dst_pos + i | 0, Caml_array.get(src, src_pos + i | 0));
  }
}

function blit(src, src_dummy, src_pos, dst, dst_dummy, dst_pos, len) {
  if (src_dummy === dst_dummy) {
    return Stdlib__Array.blit(src, src_pos, dst, dst_pos, len);
  }
  if (len < 0 || src_pos < 0 || (src_pos + len | 0) < 0 || (src_pos + len | 0) > src.length || dst_pos < 0 || (dst_pos + len | 0) < 0 || (dst_pos + len | 0) > dst.length) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/dynarray.ml",
            289,
            13
          ]
        });
  }
  if (src === dst) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/dynarray.ml",
            299,
            8
          ]
        });
  }
  for (let i = 0; i < len; ++i) {
    dst[dst_pos + i | 0] = src[src_pos + i | 0];
  }
}

function prefix(arr, n) {
  return Stdlib__Array.sub(arr, 0, n);
}

function extend(arr, length, dummy, new_capacity) {
  const new_arr = Caml_array.make(new_capacity, dummy);
  Stdlib__Array.blit(arr, 0, new_arr, 0, length);
  return new_arr;
}

const Dummy_Array = {
  make: make,
  init: init,
  copy: copy,
  unsafe_nocopy: unsafe_nocopy,
  blit_array: blit_array,
  blit: blit,
  prefix: prefix,
  extend: extend
};

const global_dummy = fresh(undefined);

function index_out_of_bounds(f, i, length) {
  if (length === 0) {
    return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": index ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: " out of bounds (empty dynarray)",
                _1: /* End_of_format */ 0
              }
            }
          }
        }
      },
      _1: "Dynarray.%s: index %d out of bounds (empty dynarray)"
    }), f, i);
  } else {
    return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": index ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: " out of bounds (0..",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: {
                    TAG: /* Char_literal */ 12,
                    _0: /* ')' */41,
                    _1: /* End_of_format */ 0
                  }
                }
              }
            }
          }
        }
      },
      _1: "Dynarray.%s: index %d out of bounds (0..%d)"
    }), f, i, length - 1 | 0);
  }
}

function negative_length_requested(f, n) {
  return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": negative length ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " requested",
              _1: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: negative length %d requested"
  }), f, n);
}

function negative_capacity_requested(f, n) {
  return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": negative capacity ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " requested",
              _1: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: negative capacity %d requested"
  }), f, n);
}

function requested_length_out_of_bounds(f, requested_length) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": cannot grow to requested length ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " (max_array_length is ",
              _1: {
                TAG: /* Int */ 4,
                _0: /* Int_d */ 0,
                _1: /* No_padding */ 0,
                _2: /* No_precision */ 0,
                _3: {
                  TAG: /* Char_literal */ 12,
                  _0: /* ')' */41,
                  _1: /* End_of_format */ 0
                }
              }
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: cannot grow to requested length %d (max_array_length is %d)"
  }), f, requested_length, Stdlib__Sys.max_array_length);
}

const invalid_state_description = "Invalid dynarray (unsynchronized concurrent length change)";

function missing_element(i, length) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* String_literal */ 11,
        _0: ": missing element at position ",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: " < length ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "%s: missing element at position %d < length %d"
  }), invalid_state_description, i, length);
}

function invalid_length(length, capacity) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* String_literal */ 11,
        _0: ": length ",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: " > capacity ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "%s: length %d > capacity %d"
  }), invalid_state_description, length, capacity);
}

function empty_dynarray(f) {
  return Curry._1(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": empty array",
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "Dynarray.%s: empty array"
  }), f);
}

function check_same_length(f, a, length) {
  const length_a = a.length;
  if (length !== length_a) {
    return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": a length change from ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: " to ",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: {
                    TAG: /* String_literal */ 11,
                    _0: " occurred during iteration",
                    _1: /* End_of_format */ 0
                  }
                }
              }
            }
          }
        }
      },
      _1: "Dynarray.%s: a length change from %d to %d occurred during iteration"
    }), f, length, length_a);
  }
  
}

function create(param) {
  return {
    length: 0,
    arr: [],
    dummy: global_dummy._0
  };
}

function make$1(n, x) {
  if (n < 0) {
    negative_length_requested("make", n);
  }
  const dummy = global_dummy._0;
  const arr = Curry._3(Dummy_Array.make, n, x, dummy);
  return {
    length: n,
    arr: arr,
    dummy: dummy
  };
}

function init$1(n, f) {
  if (n < 0) {
    negative_length_requested("init", n);
  }
  const dummy = global_dummy._0;
  const arr = Curry._3(Dummy_Array.init, n, f, dummy);
  return {
    length: n,
    arr: arr,
    dummy: dummy
  };
}

function get(a, i) {
  const v = Caml_array.get(a.arr, i);
  if (v === a.dummy) {
    let f = "get";
    let length = a.length;
    if (i < length) {
      return missing_element(i, length);
    } else {
      return index_out_of_bounds(f, i, length);
    }
  } else {
    return v;
  }
}

function set(a, i, x) {
  const length = a.length;
  const arr = a.arr;
  if (i >= length) {
    return index_out_of_bounds("set", i, length);
  } else {
    return Caml_array.set(arr, i, x);
  }
}

function length(a) {
  return a.length;
}

function is_empty(a) {
  return a.length === 0;
}

function copy$1(param) {
  const length = param.length;
  const arr = param.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const arr$1 = Curry._2(Dummy_Array.prefix, arr, length);
  return {
    length: length,
    arr: arr$1,
    dummy: param.dummy
  };
}

function get_last(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    empty_dynarray("get_last");
  }
  const i = length - 1 | 0;
  const v = arr[i];
  if (v === a.dummy) {
    return missing_element(i, length);
  } else {
    return v;
  }
}

function find_last(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    return;
  }
  const i = length - 1 | 0;
  const v = arr[i];
  return Caml_option.some(v === a.dummy ? missing_element(i, length) : v);
}

function pop_last(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  const last = length - 1 | 0;
  const v = arr[last];
  const v$1 = v === dummy ? missing_element(last, length) : v;
  arr[last] = dummy;
  a.length = last;
  return v$1;
}

function pop_last_opt(a) {
  let x;
  try {
    x = pop_last(a);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return Caml_option.some(x);
}

function remove_last(a) {
  const last = a.length - 1 | 0;
  if (last >= 0) {
    a.length = last;
    return Caml_array.set(a.arr, last, a.dummy);
  }
  
}

function truncate(a, n) {
  if (n < 0) {
    negative_length_requested("truncate", n);
  }
  const length = a.length;
  const arr = a.arr;
  if (length <= n) {
    return;
  } else {
    a.length = n;
    return Stdlib__Array.fill(arr, n, length - n | 0, a.dummy);
  }
}

function clear(a) {
  truncate(a, 0);
}

function capacity(a) {
  return a.arr.length;
}

function next_capacity(n) {
  const n$p = n <= 512 ? (n << 1) : n + (n / 2 | 0) | 0;
  return Caml.caml_int_min(8 > n$p ? 8 : n$p, Stdlib__Sys.max_array_length);
}

function ensure_capacity(a, capacity_request) {
  const arr = a.arr;
  const cur_capacity = arr.length;
  if (capacity_request < 0) {
    return negative_capacity_requested("ensure_capacity", capacity_request);
  }
  if (cur_capacity >= capacity_request) {
    return;
  }
  if (capacity_request > Stdlib__Sys.max_array_length) {
    requested_length_out_of_bounds("ensure_capacity", capacity_request);
  }
  const new_capacity = Caml.caml_int_max(next_capacity(cur_capacity), capacity_request);
  if (new_capacity <= 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/dynarray.ml",
            606,
            4
          ]
        });
  }
  const new_arr = Curry._4(Dummy_Array.extend, arr, a.length, a.dummy, new_capacity);
  a.arr = new_arr;
  if (0 > capacity_request) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/dynarray.ml",
            611,
            4
          ]
        });
  }
  if (capacity_request <= new_arr.length) {
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/dynarray.ml",
          612,
          4
        ]
      });
}

function ensure_extra_capacity(a, extra_capacity_request) {
  ensure_capacity(a, a.length + extra_capacity_request | 0);
}

function fit_capacity(a) {
  if (a.arr.length === a.length) {
    return;
  } else {
    a.arr = Curry._2(Dummy_Array.prefix, a.arr, a.length);
    return;
  }
}

function set_capacity(a, n) {
  if (n < 0) {
    negative_capacity_requested("set_capacity", n);
  }
  const arr = a.arr;
  const cur_capacity = arr.length;
  if (n < cur_capacity) {
    a.length = a.length < n ? a.length : n;
    a.arr = Curry._2(Dummy_Array.prefix, arr, n);
    return;
  } else if (n > cur_capacity) {
    a.arr = Curry._4(Dummy_Array.extend, arr, a.length, a.dummy, n);
    return;
  } else {
    return;
  }
}

function reset(a) {
  a.length = 0;
  a.arr = [];
}

function add_last(a, x) {
  const length = a.length;
  const arr = a.arr;
  if (length >= arr.length ? false : (a.length = length + 1 | 0, arr[length] = x, true)) {
    return;
  }
  while (true) {
    ensure_extra_capacity(a, 1);
    const length$1 = a.length;
    const arr$1 = a.arr;
    if (length$1 >= arr$1.length ? false : (a.length = length$1 + 1 | 0, arr$1[length$1] = x, true)) {
      return;
    }
    continue;
  };
}

function append_list(a, _li) {
  while (true) {
    const li = _li;
    if (!li) {
      return;
    }
    add_last(a, li.hd);
    _li = li.tl;
    continue;
  };
}

function append_iter(a, iter, b) {
  return Curry._2(iter, (function (x) {
    add_last(a, x);
  }), b);
}

function append_seq(a, seq) {
  Stdlib__Seq.iter((function (x) {
    add_last(a, x);
  }), seq);
}

function blit_assume_room(src, src_pos, src_length, dst, dst_pos, dst_length, blit_length) {
  const src_arr = src.arr;
  const dst_arr = dst.arr;
  check_same_length("blit", src, src_length);
  check_same_length("blit", dst, dst_length);
  if ((dst_pos + blit_length | 0) > dst_length) {
    dst.length = dst_pos + blit_length | 0;
  }
  Curry._7(Dummy_Array.blit, src_arr, src.dummy, src_pos, dst_arr, dst.dummy, dst_pos, blit_length);
}

function blit$1(src, src_pos, dst, dst_pos, len) {
  const src_length = src.length;
  const dst_length = dst.length;
  if (len < 0) {
    Curry._1(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.blit: invalid blit length (",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* Char_literal */ 12,
            _0: /* ')' */41,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "Dynarray.blit: invalid blit length (%d)"
    }), len);
  }
  if (src_pos < 0 || (src_pos + len | 0) > src_length) {
    Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.blit: invalid source region (",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: "..",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ") in source dynarray of length ",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: /* End_of_format */ 0
                }
              }
            }
          }
        }
      },
      _1: "Dynarray.blit: invalid source region (%d..%d) in source dynarray of length %d"
    }), src_pos, src_pos + len | 0, src_length);
  }
  if (dst_pos < 0 || dst_pos > dst_length) {
    Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.blit: invalid target region (",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: "..",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ") in target dynarray of length ",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: /* End_of_format */ 0
                }
              }
            }
          }
        }
      },
      _1: "Dynarray.blit: invalid target region (%d..%d) in target dynarray of length %d"
    }), dst_pos, dst_pos + len | 0, dst_length);
  }
  ensure_capacity(dst, dst_pos + len | 0);
  blit_assume_room(src, src_pos, src_length, dst, dst_pos, dst_length, len);
}

function append_array_if_room(a, b) {
  const length_a = a.length;
  const arr = a.arr;
  const length_b = b.length;
  if ((length_a + length_b | 0) > arr.length) {
    return false;
  } else {
    a.length = length_a + length_b | 0;
    Curry._5(Dummy_Array.blit_array, b, 0, arr, length_a, length_b);
    return true;
  }
}

function append_array(a, b) {
  if (append_array_if_room(a, b)) {
    return;
  }
  while (true) {
    ensure_extra_capacity(a, b.length);
    if (append_array_if_room(a, b)) {
      return;
    }
    continue;
  };
}

function append_if_room(a, b, length_b) {
  const length_a = a.length;
  const arr_a = a.arr;
  if ((length_a + length_b | 0) > arr_a.length) {
    return false;
  } else {
    blit_assume_room(b, 0, length_b, a, length_a, length_a, length_b);
    check_same_length("append", b, length_b);
    return true;
  }
}

function append(a, b) {
  const length_b = b.length;
  if (append_if_room(a, b, length_b)) {
    return;
  }
  while (true) {
    ensure_extra_capacity(a, length_b);
    check_same_length("append", b, length_b);
    if (append_if_room(a, b, length_b)) {
      return;
    }
    continue;
  };
}

function iter_(f, k, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  for (let i = 0; i < length; ++i) {
    const v = arr[i];
    Curry._1(k, v === dummy ? missing_element(i, length) : v);
  }
  check_same_length(f, a, length);
}

function iter(k, a) {
  iter_("iter", k, a);
}

function iteri(k, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  for (let i = 0; i < length; ++i) {
    const v = arr[i];
    Curry._2(k, i, v === dummy ? missing_element(i, length) : v);
  }
  check_same_length("iteri", a, length);
}

function map(f, a) {
  const length = a.length;
  const arr_in = a.arr;
  const dummy = a.dummy;
  const capacity = arr_in.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const arr_out = Caml_array.make(length, dummy);
  for (let i = 0; i < length; ++i) {
    const v = arr_in[i];
    arr_out[i] = Curry._1(f, v === dummy ? missing_element(i, length) : v);
  }
  const res = {
    length: length,
    arr: arr_out,
    dummy: dummy
  };
  check_same_length("map", a, length);
  return res;
}

function mapi(f, a) {
  const length = a.length;
  const arr_in = a.arr;
  const dummy = a.dummy;
  const capacity = arr_in.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const arr_out = Caml_array.make(length, dummy);
  for (let i = 0; i < length; ++i) {
    const v = arr_in[i];
    arr_out[i] = Curry._2(f, i, v === dummy ? missing_element(i, length) : v);
  }
  const res = {
    length: length,
    arr: arr_out,
    dummy: dummy
  };
  check_same_length("mapi", a, length);
  return res;
}

function fold_left(f, acc, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let r = acc;
  for (let i = 0; i < length; ++i) {
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    r = Curry._2(f, r, v$1);
  }
  check_same_length("fold_left", a, length);
  return r;
}

function fold_right(f, a, acc) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let r = acc;
  for (let i = length - 1 | 0; i >= 0; --i) {
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    r = Curry._2(f, v$1, r);
  }
  check_same_length("fold_right", a, length);
  return r;
}

function exists(p, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (p, arr, dummy, _i, length) {
    while (true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const v = arr[i];
      if (Curry._1(p, v === dummy ? missing_element(i, length) : v)) {
        return true;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(p, arr, a.dummy, 0, length);
  check_same_length("exists", a, length);
  return res;
}

function for_all(p, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (p, arr, dummy, _i, length) {
    while (true) {
      const i = _i;
      if (i === length) {
        return true;
      }
      const v = arr[i];
      if (!Curry._1(p, v === dummy ? missing_element(i, length) : v)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(p, arr, a.dummy, 0, length);
  check_same_length("for_all", a, length);
  return res;
}

function filter(f, a) {
  const b = create(undefined);
  iter_("filter", (function (x) {
    if (Curry._1(f, x)) {
      return add_last(b, x);
    }
    
  }), a);
  return b;
}

function filter_map(f, a) {
  const b = create(undefined);
  iter_("filter_map", (function (x) {
    const y = Curry._1(f, x);
    if (y !== undefined) {
      return add_last(b, Caml_option.valFromOption(y));
    }
    
  }), a);
  return b;
}

function mem(x, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const v = arr[i];
      if (Caml_obj.caml_equal(v === dummy ? missing_element(i, length) : v, x)) {
        return true;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("mem", a, length);
  return res;
}

function memq(x, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const v = arr[i];
      if ((
          v === dummy ? missing_element(i, length) : v
        ) === x) {
        return true;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("memq", a, length);
  return res;
}

function find_opt(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const x = v === dummy ? missing_element(i, length) : v;
      if (Curry._1(p, x)) {
        return Caml_option.some(x);
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_opt", a, length);
  return res;
}

function find_index(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const x = v === dummy ? missing_element(i, length) : v;
      if (Curry._1(p, x)) {
        return i;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_index", a, length);
  return res;
}

function find_map(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const r = Curry._1(p, v === dummy ? missing_element(i, length) : v);
      if (r !== undefined) {
        return r;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_map", a, length);
  return res;
}

function find_mapi(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const r = Curry._2(p, i, v === dummy ? missing_element(i, length) : v);
      if (r !== undefined) {
        return r;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_mapi", a, length);
  return res;
}

function equal(eq, a1, a2) {
  const length = a1.length;
  const arr1 = a1.arr;
  const dum1 = a1.dummy;
  const len2 = a2.length;
  const arr2 = a2.arr;
  if (length !== len2) {
    return false;
  }
  const dum2 = a2.dummy;
  const capacity = arr1.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const capacity$1 = arr2.length;
  if (length > capacity$1) {
    invalid_length(length, capacity$1);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return true;
      }
      const v = arr1[i];
      const v$1 = arr2[i];
      if (!Curry._2(eq, v === dum1 ? missing_element(i, length) : v, v$1 === dum2 ? missing_element(i, length) : v$1)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const r = loop(0);
  check_same_length("equal", a1, length);
  check_same_length("equal", a2, length);
  return r;
}

function compare(cmp, a1, a2) {
  const length = a1.length;
  const arr1 = a1.arr;
  const dum1 = a1.dummy;
  const len2 = a2.length;
  const arr2 = a2.arr;
  if (length !== len2) {
    return length - len2 | 0;
  }
  const dum2 = a2.dummy;
  const capacity = arr1.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const capacity$1 = arr2.length;
  if (length > capacity$1) {
    invalid_length(length, capacity$1);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return 0;
      }
      const v = arr1[i];
      const v$1 = arr2[i];
      const c = Curry._2(cmp, v === dum1 ? missing_element(i, length) : v, v$1 === dum2 ? missing_element(i, length) : v$1);
      if (c !== 0) {
        return c;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const r = loop(0);
  check_same_length("compare", a1, length);
  check_same_length("compare", a2, length);
  return r;
}

function of_array(a) {
  const length = a.length;
  const dummy = global_dummy._0;
  const arr = Curry._2(Dummy_Array.copy, a, dummy);
  return {
    length: length,
    arr: arr,
    dummy: dummy
  };
}

function to_array(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const res = Stdlib__Array.init(length, (function (i) {
    const v = arr[i];
    if (v === dummy) {
      return missing_element(i, length);
    } else {
      return v;
    }
  }));
  check_same_length("to_array", a, length);
  return res;
}

function of_list(li) {
  const a = Stdlib__Array.of_list(li);
  const length = a.length;
  const dummy = global_dummy._0;
  const arr = Curry._2(Dummy_Array.unsafe_nocopy, a, dummy);
  return {
    length: length,
    arr: arr,
    dummy: dummy
  };
}

function to_list(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let l = /* [] */ 0;
  for (let i = length - 1 | 0; i >= 0; --i) {
    const v = arr[i];
    l = {
      hd: v === dummy ? missing_element(i, length) : v,
      tl: l
    };
  }
  check_same_length("to_list", a, length);
  return l;
}

function of_seq(seq) {
  const init = create(undefined);
  append_seq(init, seq);
  return init;
}

function to_seq(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const aux = function (i, param) {
    check_same_length("to_seq", a, length);
    if (i >= length) {
      return /* Nil */ 0;
    }
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: v$1,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seq_reentrant(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const v = get(a, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: v,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seq_rev(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const aux = function (i, param) {
    check_same_length("to_seq_rev", a, length);
    if (i < 0) {
      return /* Nil */ 0;
    }
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    const partial_arg = i - 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: v$1,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  const partial_arg = length - 1 | 0;
  return function (param) {
    return aux(partial_arg, param);
  };
}

function to_seq_rev_reentrant(a) {
  const aux = function (_i, _param) {
    while (true) {
      const i = _i;
      if (i < 0) {
        return /* Nil */ 0;
      }
      if (i >= a.length) {
        _param = undefined;
        _i = a.length - 1 | 0;
        continue;
      }
      const v = get(a, i);
      const partial_arg = i - 1 | 0;
      return {
        TAG: /* Cons */ 0,
        _0: v,
        _1: (function (param) {
          return aux(partial_arg, param);
        })
      };
    };
  };
  const partial_arg = a.length - 1 | 0;
  return function (param) {
    return aux(partial_arg, param);
  };
}

export {
  create,
  make$1 as make,
  init$1 as init,
  get,
  set,
  length,
  is_empty,
  get_last,
  find_last,
  copy$1 as copy,
  add_last,
  append_array,
  append_list,
  append,
  append_seq,
  append_iter,
  blit$1 as blit,
  pop_last_opt,
  pop_last,
  remove_last,
  truncate,
  clear,
  iter,
  iteri,
  map,
  mapi,
  fold_left,
  fold_right,
  filter,
  filter_map,
  exists,
  for_all,
  mem,
  memq,
  find_opt,
  find_index,
  find_map,
  find_mapi,
  equal,
  compare,
  of_array,
  to_array,
  of_list,
  to_list,
  of_seq,
  to_seq,
  to_seq_reentrant,
  to_seq_rev,
  to_seq_rev_reentrant,
  capacity,
  ensure_capacity,
  ensure_extra_capacity,
  fit_capacity,
  set_capacity,
  reset,
}
/* global_dummy Not a pure module */
`,wf=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function left(v) {
  return {
    TAG: /* Left */ 0,
    _0: v
  };
}

function right(v) {
  return {
    TAG: /* Right */ 1,
    _0: v
  };
}

function is_left(param) {
  if (param.TAG === /* Left */ 0) {
    return true;
  } else {
    return false;
  }
}

function is_right(param) {
  if (param.TAG === /* Left */ 0) {
    return false;
  } else {
    return true;
  }
}

function find_left(v) {
  if (v.TAG === /* Left */ 0) {
    return Caml_option.some(v._0);
  }
  
}

function find_right(v) {
  if (v.TAG === /* Left */ 0) {
    return;
  } else {
    return Caml_option.some(v._0);
  }
}

function map_left(f, v) {
  if (v.TAG === /* Left */ 0) {
    return {
      TAG: /* Left */ 0,
      _0: Curry._1(f, v._0)
    };
  } else {
    return v;
  }
}

function map_right(f, e) {
  if (e.TAG === /* Left */ 0) {
    return e;
  } else {
    return {
      TAG: /* Right */ 1,
      _0: Curry._1(f, e._0)
    };
  }
}

function map(left, right, v) {
  if (v.TAG === /* Left */ 0) {
    return {
      TAG: /* Left */ 0,
      _0: Curry._1(left, v._0)
    };
  } else {
    return {
      TAG: /* Right */ 1,
      _0: Curry._1(right, v._0)
    };
  }
}

function fold(left, right, v) {
  if (v.TAG === /* Left */ 0) {
    return Curry._1(left, v._0);
  } else {
    return Curry._1(right, v._0);
  }
}

function equal(left, right, e1, e2) {
  if (e1.TAG === /* Left */ 0) {
    if (e2.TAG === /* Left */ 0) {
      return Curry._2(left, e1._0, e2._0);
    } else {
      return false;
    }
  } else if (e2.TAG === /* Left */ 0) {
    return false;
  } else {
    return Curry._2(right, e1._0, e2._0);
  }
}

function compare(left, right, e1, e2) {
  if (e1.TAG === /* Left */ 0) {
    if (e2.TAG === /* Left */ 0) {
      return Curry._2(left, e1._0, e2._0);
    } else {
      return -1;
    }
  } else if (e2.TAG === /* Left */ 0) {
    return 1;
  } else {
    return Curry._2(right, e1._0, e2._0);
  }
}

const iter = fold;

const for_all = fold;

export {
  left,
  right,
  is_left,
  is_right,
  find_left,
  find_right,
  map_left,
  map_right,
  map,
  fold,
  iter,
  for_all,
  equal,
  compare,
}
/* No side effect */
`,Sf=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as CamlinternalLazy from "./camlinternalLazy.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Hashtbl from "./hashtbl.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Obj from "./obj.js";
import * as Stdlib__Random from "./random.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Sys from "./sys.js";

function set_key(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function check_key(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 0);
}

function get_data(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make(key, data) {
  const eph = Stdlib__Obj.Ephemeron.create(1);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key(eph, key);
  return eph;
}

function query(eph, key) {
  const k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k !== undefined && Caml_option.valFromOption(k) === key) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded(H) {
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  const seeded_hash = H.seeded_hash;
  const equal = function (c, k) {
    const k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(H.equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init(undefined);
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$1,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function Make(H) {
  const equal = H.equal;
  const seeded_hash = function (_seed, x) {
    return Curry._1(H.hash, x);
  };
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  const equal$1 = function (c, k) {
    const k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init(undefined);
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal$1(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$2,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function make$1(param) {
  return {
    contents: /* [] */ 0
  };
}

function add(b, k, d) {
  b.contents = {
    hd: make(k, d),
    tl: b.contents
  };
}

function test_key(k, e) {
  const x = Stdlib__Obj.Ephemeron.get_key(e, 0);
  if (x !== undefined) {
    return Caml_option.valFromOption(x) === k;
  } else {
    return false;
  }
}

function remove(b, k) {
  let _l = b.contents;
  let _acc = /* [] */ 0;
  while (true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return;
    }
    const h = l.hd;
    if (test_key(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue;
  };
}

function find(b, k) {
  const e = Stdlib__List.find_opt((function (param) {
    return test_key(k, param);
  }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length(b) {
  return Stdlib__List.length(b.contents);
}

function clear(b) {
  b.contents = /* [] */ 0;
}

function set_key1(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function set_key2(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 1, k);
}

function get_data$1(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$2(key1, key2, data) {
  const eph = Stdlib__Obj.Ephemeron.create(2);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key1(eph, key1);
  set_key2(eph, key2);
  return eph;
}

function query$1(eph, key1, key2) {
  const k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k === undefined) {
    return;
  }
  if (Caml_option.valFromOption(k) !== key1) {
    return;
  }
  const k$1 = Stdlib__Obj.Ephemeron.get_key(eph, 1);
  if (k$1 !== undefined && Caml_option.valFromOption(k$1) === key2) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded$1(H1, H2) {
  const create = function (param, d) {
    const c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  const seeded_hash = function (seed, param) {
    return Curry._2(H1.seeded_hash, seed, param[0]) + Math.imul(Curry._2(H2.seeded_hash, seed, param[1]), 65599) | 0;
  };
  const equal = function (c, param) {
    const match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    const match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(H1.equal, param[0], Caml_option.valFromOption(match)) && Curry._2(H2.equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init(undefined);
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$1(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$1,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function Make$1(H1, H2) {
  const equal = H2.equal;
  const equal$1 = H1.equal;
  const create = function (param, d) {
    const c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  const seeded_hash = function (seed, param) {
    return Curry._1(H1.hash, param[0]) + Math.imul(Curry._1(H2.hash, param[1]), 65599) | 0;
  };
  const equal$2 = function (c, param) {
    const match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    const match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(equal$1, param[0], Caml_option.valFromOption(match)) && Curry._2(equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init(undefined);
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$2(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$1(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal$2(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal$2(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$2,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function make$3(param) {
  return {
    contents: /* [] */ 0
  };
}

function add$1(b, k1, k2, d) {
  b.contents = {
    hd: make$2(k1, k2, d),
    tl: b.contents
  };
}

function test_keys(k1, k2, e) {
  const match = Stdlib__Obj.Ephemeron.get_key(e, 0);
  const match$1 = Stdlib__Obj.Ephemeron.get_key(e, 1);
  if (match !== undefined && match$1 !== undefined && Caml_option.valFromOption(match) === k1) {
    return Caml_option.valFromOption(match$1) === k2;
  } else {
    return false;
  }
}

function remove$1(b, k1, k2) {
  let _l = b.contents;
  let _acc = /* [] */ 0;
  while (true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return;
    }
    const h = l.hd;
    if (test_keys(k1, k2, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue;
  };
}

function find$1(b, k1, k2) {
  const e = Stdlib__List.find_opt((function (param) {
    return test_keys(k1, k2, param);
  }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$1(b) {
  return Stdlib__List.length(b.contents);
}

function clear$1(b) {
  b.contents = /* [] */ 0;
}

function set_key$1(t, n, k) {
  Stdlib__Obj.Ephemeron.set_key(t, n, k);
}

function get_data$2(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$4(keys, data) {
  const l = keys.length;
  const eph = Stdlib__Obj.Ephemeron.create(l);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  for (let i = 0; i < l; ++i) {
    set_key$1(eph, i, Caml_array.get(keys, i));
  }
  return eph;
}

function query$2(eph, keys) {
  const l = Stdlib__Obj.Ephemeron.length(eph);
  try {
    if (l !== keys.length) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
            MEL_EXN_ID: Stdlib.Exit
          });
    }
    for (let i = 0; i < l; ++i) {
      const k = Stdlib__Obj.Ephemeron.get_key(eph, i);
      if (k !== undefined) {
        if (Caml_option.valFromOption(k) !== Caml_array.get(keys, i)) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                MEL_EXN_ID: Stdlib.Exit
              });
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
      }
    }
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function MakeSeeded$2(H) {
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  const seeded_hash = function (seed, k) {
    let h = 0;
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      h = Math.imul(Curry._2(H.seeded_hash, seed, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  const equal = function (c, k) {
    const len = k.length;
    const len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */ 1;
    }
    let _i = len - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return /* ETrue */ 0;
      }
      const ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */ 2;
      }
      if (!Curry._2(H.equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */ 1;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const check_key = function (c) {
    let _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init(undefined);
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$2(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              for (let i$1 = 0, i_finish = key.length; i$1 < i_finish; ++i$1) {
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$1,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function Make$2(H) {
  const equal = H.equal;
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  const seeded_hash = function (seed, k) {
    let h = 0;
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      h = Math.imul(Curry._1(H.hash, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  const equal$1 = function (c, k) {
    const len = k.length;
    const len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */ 1;
    }
    let _i = len - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return /* ETrue */ 0;
      }
      const ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */ 2;
      }
      if (!Curry._2(equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */ 1;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const check_key = function (c) {
    let _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init(undefined);
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$2(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              for (let i$1 = 0, i_finish = key.length; i$1 < i_finish; ++i$1) {
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal$1(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$2,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function make$5(param) {
  return {
    contents: /* [] */ 0
  };
}

function add$2(b, k, d) {
  b.contents = {
    hd: make$4(k, d),
    tl: b.contents
  };
}

function test_keys$1(k, e) {
  try {
    if (Stdlib__Obj.Ephemeron.length(e) !== k.length) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
            MEL_EXN_ID: Stdlib.Exit
          });
    }
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      const x = Stdlib__Obj.Ephemeron.get_key(e, i);
      if (x !== undefined) {
        if (Caml_option.valFromOption(x) !== Caml_array.get(k, i)) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                MEL_EXN_ID: Stdlib.Exit
              });
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
      }
    }
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function remove$2(b, k) {
  let _l = b.contents;
  let _acc = /* [] */ 0;
  while (true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return;
    }
    const h = l.hd;
    if (test_keys$1(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue;
  };
}

function find$2(b, k) {
  const e = Stdlib__List.find_opt((function (param) {
    return test_keys$1(k, param);
  }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$2(b) {
  return Stdlib__List.length(b.contents);
}

function clear$2(b) {
  b.contents = /* [] */ 0;
}

const K1_Bucket = {
  make: make$1,
  add: add,
  remove: remove,
  find: find,
  length: length,
  clear: clear
};

const K1 = {
  make: make,
  query: query,
  Make: Make,
  MakeSeeded: MakeSeeded,
  Bucket: K1_Bucket
};

const K2_Bucket = {
  make: make$3,
  add: add$1,
  remove: remove$1,
  find: find$1,
  length: length$1,
  clear: clear$1
};

const K2 = {
  make: make$2,
  query: query$1,
  Make: Make$1,
  MakeSeeded: MakeSeeded$1,
  Bucket: K2_Bucket
};

const Kn_Bucket = {
  make: make$5,
  add: add$2,
  remove: remove$2,
  find: find$2,
  length: length$2,
  clear: clear$2
};

const Kn = {
  make: make$4,
  query: query$2,
  Make: Make$2,
  MakeSeeded: MakeSeeded$2,
  Bucket: Kn_Bucket
};

export {
  K1,
  K2,
  Kn,
}
/* Stdlib__Hashtbl Not a pure module */
`,Bf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Caml_sys from "melange.js/caml_sys.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Domain from "./domain.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__Random from "./random.js";
import * as Stdlib__String from "./string.js";
import * as Stdlib__Sys from "./sys.js";

function generic_quote(quotequote, s) {
  const l = s.length;
  const b = Stdlib__Buffer.create(l + 20 | 0);
  Stdlib__Buffer.add_char(b, /* '\\'' */39);
  for (let i = 0; i < l; ++i) {
    if (Caml_string.get(s, i) === /* '\\'' */39) {
      Stdlib__Buffer.add_string(b, quotequote);
    } else {
      Stdlib__Buffer.add_char(b, Caml_string.get(s, i));
    }
  }
  Stdlib__Buffer.add_char(b, /* '\\'' */39);
  return Stdlib__Buffer.contents(b);
}

function generic_basename(is_dir_sep, current_dir_name, name) {
  if (name === "") {
    return current_dir_name;
  } else {
    let _n = name.length - 1 | 0;
    while (true) {
      const n = _n;
      if (n < 0) {
        return Stdlib__String.sub(name, 0, 1);
      }
      if (!Curry._2(is_dir_sep, name, n)) {
        let _n$1 = n;
        let p = n + 1 | 0;
        while (true) {
          const n$1 = _n$1;
          if (n$1 < 0) {
            return Stdlib__String.sub(name, 0, p);
          }
          if (Curry._2(is_dir_sep, name, n$1)) {
            return Stdlib__String.sub(name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
          }
          _n$1 = n$1 - 1 | 0;
          continue;
        };
      }
      _n = n - 1 | 0;
      continue;
    };
  }
}

function generic_dirname(is_dir_sep, current_dir_name, name) {
  if (name === "") {
    return current_dir_name;
  } else {
    let _n = name.length - 1 | 0;
    while (true) {
      const n = _n;
      if (n < 0) {
        return Stdlib__String.sub(name, 0, 1);
      }
      if (!Curry._2(is_dir_sep, name, n)) {
        let _n$1 = n;
        while (true) {
          const n$1 = _n$1;
          if (n$1 < 0) {
            return current_dir_name;
          }
          if (Curry._2(is_dir_sep, name, n$1)) {
            let _n$2 = n$1;
            while (true) {
              const n$2 = _n$2;
              if (n$2 < 0) {
                return Stdlib__String.sub(name, 0, 1);
              }
              if (!Curry._2(is_dir_sep, name, n$2)) {
                return Stdlib__String.sub(name, 0, n$2 + 1 | 0);
              }
              _n$2 = n$2 - 1 | 0;
              continue;
            };
          }
          _n$1 = n$1 - 1 | 0;
          continue;
        };
      }
      _n = n - 1 | 0;
      continue;
    };
  }
}

const current_dir_name = ".";

function is_dir_sep(s, i) {
  return Caml_string.get(s, i) === /* '/' */47;
}

function is_relative(n) {
  if (n.length < 1) {
    return true;
  } else {
    return Caml_string.get(n, 0) !== /* '/' */47;
  }
}

function is_implicit(n) {
  if (is_relative(n) && (n.length < 2 || Stdlib__String.sub(n, 0, 2) !== "./")) {
    if (n.length < 3) {
      return true;
    } else {
      return Stdlib__String.sub(n, 0, 3) !== "../";
    }
  } else {
    return false;
  }
}

function check_suffix(name, suff) {
  return Stdlib__String.ends_with(suff, name);
}

function chop_suffix_opt(suffix, filename) {
  const len_s = suffix.length;
  const len_f = filename.length;
  if (len_f < len_s) {
    return;
  }
  const r = Stdlib__String.sub(filename, len_f - len_s | 0, len_s);
  if (r === suffix) {
    return Stdlib__String.sub(filename, 0, len_f - len_s | 0);
  }
  
}

let temp_dir_name;

try {
  temp_dir_name = Caml_sys.caml_sys_getenv("TMPDIR");
}
catch (raw_exn){
  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.MEL_EXN_ID === Stdlib.Not_found) {
    temp_dir_name = "/tmp";
  } else {
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function quote(param) {
  return generic_quote("'\\\\''", param);
}

function quote_command(cmd, stdin, stdout, stderr, args) {
  return Stdlib__String.concat(" ", Stdlib__List.map(quote, {
    hd: cmd,
    tl: args
  })) + ((
    stdin !== undefined ? " <" + generic_quote("'\\\\''", stdin) : ""
  ) + ((
    stdout !== undefined ? " >" + generic_quote("'\\\\''", stdout) : ""
  ) + (
    stderr !== undefined ? (
        Caml_obj.caml_equal(stderr, stdout) ? " 2>&1" : " 2>" + generic_quote("'\\\\''", stderr)
      ) : ""
  )));
}

function basename(param) {
  return generic_basename(is_dir_sep, current_dir_name, param);
}

function dirname(param) {
  return generic_dirname(is_dir_sep, current_dir_name, param);
}

const Unix = {
  $$null: "/dev/null",
  current_dir_name: current_dir_name,
  parent_dir_name: "..",
  dir_sep: "/",
  is_dir_sep: is_dir_sep,
  is_relative: is_relative,
  is_implicit: is_implicit,
  check_suffix: check_suffix,
  chop_suffix_opt: chop_suffix_opt,
  temp_dir_name: temp_dir_name,
  quote: quote,
  quote_command: quote_command,
  basename: basename,
  dirname: dirname
};

const current_dir_name$1 = ".";

function is_dir_sep$1(s, i) {
  const c = Caml_string.get(s, i);
  if (c === /* '/' */47 || c === /* '\\\\' */92) {
    return true;
  } else {
    return c === /* ':' */58;
  }
}

function is_relative$1(n) {
  if ((n.length < 1 || Caml_string.get(n, 0) !== /* '/' */47) && (n.length < 1 || Caml_string.get(n, 0) !== /* '\\\\' */92)) {
    if (n.length < 2) {
      return true;
    } else {
      return Caml_string.get(n, 1) !== /* ':' */58;
    }
  } else {
    return false;
  }
}

function is_implicit$1(n) {
  if (is_relative$1(n) && (n.length < 2 || Stdlib__String.sub(n, 0, 2) !== "./") && (n.length < 2 || Stdlib__String.sub(n, 0, 2) !== ".\\\\") && (n.length < 3 || Stdlib__String.sub(n, 0, 3) !== "../")) {
    if (n.length < 3) {
      return true;
    } else {
      return Stdlib__String.sub(n, 0, 3) !== "..\\\\";
    }
  } else {
    return false;
  }
}

function check_suffix$1(name, suff) {
  if (name.length < suff.length) {
    return false;
  }
  const s = Stdlib__String.sub(name, name.length - suff.length | 0, suff.length);
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(s))) === Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(suff)));
}

function chop_suffix_opt$1(suffix, filename) {
  const len_s = suffix.length;
  const len_f = filename.length;
  if (len_f < len_s) {
    return;
  }
  const r = Stdlib__String.sub(filename, len_f - len_s | 0, len_s);
  if (Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(r))) === Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(suffix)))) {
    return Stdlib__String.sub(filename, 0, len_f - len_s | 0);
  }
  
}

let temp_dir_name$1;

try {
  temp_dir_name$1 = Caml_sys.caml_sys_getenv("TEMP");
}
catch (raw_exn$1){
  const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
  if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
    temp_dir_name$1 = ".";
  } else {
    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
  }
}

function quote$1(s) {
  const l = s.length;
  const b = Stdlib__Buffer.create(l + 20 | 0);
  Stdlib__Buffer.add_char(b, /* '"' */34);
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === l) {
        return Stdlib__Buffer.add_char(b, /* '"' */34);
      }
      const c = Caml_string.get(s, i);
      if (c === 34) {
        return loop_bs(0, i);
      }
      if (c === 92) {
        return loop_bs(0, i);
      }
      Stdlib__Buffer.add_char(b, c);
      _i = i + 1 | 0;
      continue;
    };
  };
  const loop_bs = function (_n, _i) {
    while (true) {
      const i = _i;
      const n = _n;
      if (i === l) {
        Stdlib__Buffer.add_char(b, /* '"' */34);
        return add_bs(n);
      }
      const match = Caml_string.get(s, i);
      if (match !== 34) {
        if (match !== 92) {
          add_bs(n);
          return loop(i);
        }
        _i = i + 1 | 0;
        _n = n + 1 | 0;
        continue;
      }
      add_bs((n << 1) + 1 | 0);
      Stdlib__Buffer.add_char(b, /* '"' */34);
      return loop(i + 1 | 0);
    };
  };
  const add_bs = function (n) {
    for (let _j = 1; _j <= n; ++_j) {
      Stdlib__Buffer.add_char(b, /* '\\\\' */92);
    }
  };
  loop(0);
  return Stdlib__Buffer.contents(b);
}

function quote_cmd(s) {
  const b = Stdlib__Buffer.create(s.length + 20 | 0);
  Stdlib__String.iter((function (c) {
    if (c >= 62) {
      if (c > 123 || c < 63) {
        if (c >= 125) {
          return Stdlib__Buffer.add_char(b, c);
        }
        
      } else if (c !== 94) {
        return Stdlib__Buffer.add_char(b, c);
      }
      
    } else if (c >= 42) {
      if (c !== 60) {
        return Stdlib__Buffer.add_char(b, c);
      }
      
    } else {
      if (c < 33) {
        return Stdlib__Buffer.add_char(b, c);
      }
      switch (c) {
        case 35 :
        case 36 :
        case 39 :
          return Stdlib__Buffer.add_char(b, c);
        case 33 :
        case 34 :
        case 37 :
        case 38 :
        case 40 :
        case 41 :
          break;
      }
    }
    Stdlib__Buffer.add_char(b, /* '^' */94);
    Stdlib__Buffer.add_char(b, c);
  }), s);
  return Stdlib__Buffer.contents(b);
}

function quote_cmd_filename(f) {
  const f$1 = Stdlib__String.contains(f, /* '/' */47) ? Stdlib__String.map((function (c) {
      if (c !== 47) {
        return c;
      } else {
        return /* '\\\\' */92;
      }
    }), f) : f;
  const f$2 = function (param) {
    if (param !== 34) {
      return param === 37;
    } else {
      return true;
    }
  };
  if (!Stdlib__Bytes.exists(f$2, Caml_bytes.bytes_of_string(f$1))) {
    if (Stdlib__String.contains(f$1, /* ' ' */32)) {
      return Stdlib__String.concat("", {
        hd: "\\"",
        tl: {
          hd: f$1,
          tl: {
            hd: "\\"",
            tl: /* [] */ 0
          }
        }
      });
    } else {
      return f$1;
    }
  }
  const s = "Filename.quote_command: bad file name " + f$1;
  throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: s
      });
}

function quote_command$1(cmd, stdin, stdout, stderr, args) {
  return Stdlib__String.concat("", {
    hd: "\\"",
    tl: {
      hd: quote_cmd_filename(cmd),
      tl: {
        hd: " ",
        tl: {
          hd: quote_cmd(Stdlib__String.concat(" ", Stdlib__List.map(quote$1, args))),
          tl: {
            hd: stdin !== undefined ? " <" + quote_cmd_filename(stdin) : "",
            tl: {
              hd: stdout !== undefined ? " >" + quote_cmd_filename(stdout) : "",
              tl: {
                hd: stderr !== undefined ? (
                    Caml_obj.caml_equal(stderr, stdout) ? " 2>&1" : " 2>" + quote_cmd_filename(stderr)
                  ) : "",
                tl: {
                  hd: "\\"",
                  tl: /* [] */ 0
                }
              }
            }
          }
        }
      }
    }
  });
}

function has_drive(s) {
  const is_letter = function (param) {
    if (param >= 91) {
      return !(param > 122 || param < 97);
    } else {
      return param >= 65;
    }
  };
  if (s.length >= 2 && is_letter(Caml_string.get(s, 0))) {
    return Caml_string.get(s, 1) === /* ':' */58;
  } else {
    return false;
  }
}

function drive_and_path(s) {
  if (has_drive(s)) {
    return [
      Stdlib__String.sub(s, 0, 2),
      Stdlib__String.sub(s, 2, s.length - 2 | 0)
    ];
  } else {
    return [
      "",
      s
    ];
  }
}

function dirname$1(s) {
  const match = drive_and_path(s);
  const dir = generic_dirname(is_dir_sep$1, current_dir_name$1, match[1]);
  return match[0] + dir;
}

function basename$1(s) {
  const match = drive_and_path(s);
  return generic_basename(is_dir_sep$1, current_dir_name$1, match[1]);
}

const Win32 = {
  $$null: "NUL",
  current_dir_name: current_dir_name$1,
  parent_dir_name: "..",
  dir_sep: "\\\\",
  is_dir_sep: is_dir_sep$1,
  is_relative: is_relative$1,
  is_implicit: is_implicit$1,
  check_suffix: check_suffix$1,
  chop_suffix_opt: chop_suffix_opt$1,
  temp_dir_name: temp_dir_name$1,
  quote: quote$1,
  quote_command: quote_command$1,
  basename: basename$1,
  dirname: dirname$1
};

const current_dir_name$2 = ".";

function basename$2(param) {
  return generic_basename(is_dir_sep$1, current_dir_name$2, param);
}

function dirname$2(param) {
  return generic_dirname(is_dir_sep$1, current_dir_name$2, param);
}

const Cygwin = {
  $$null: "/dev/null",
  current_dir_name: current_dir_name$2,
  parent_dir_name: "..",
  dir_sep: "/",
  is_dir_sep: is_dir_sep$1,
  is_relative: is_relative$1,
  is_implicit: is_implicit$1,
  check_suffix: check_suffix$1,
  chop_suffix_opt: chop_suffix_opt$1,
  temp_dir_name: temp_dir_name,
  quote: quote,
  quote_command: quote_command,
  basename: basename$2,
  dirname: dirname$2
};

let Sysdeps;

switch (Stdlib__Sys.os_type) {
  case "Cygwin" :
    Sysdeps = Cygwin;
    break;
  case "Win32" :
    Sysdeps = Win32;
    break;
  default:
    Sysdeps = Unix;
}

const dir_sep = Sysdeps.dir_sep;

const is_dir_sep$2 = Sysdeps.is_dir_sep;

const check_suffix$2 = Sysdeps.check_suffix;

const temp_dir_name$2 = Sysdeps.temp_dir_name;

function concat(dirname, filename) {
  const l = dirname.length;
  if (l === 0 || Curry._2(is_dir_sep$2, dirname, l - 1 | 0)) {
    return dirname + filename;
  } else {
    return dirname + (dir_sep + filename);
  }
}

function chop_suffix(name, suff) {
  if (Curry._2(check_suffix$2, name, suff)) {
    return Stdlib__String.sub(name, 0, name.length - suff.length | 0);
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Filename.chop_suffix"
      });
}

function extension_len(name) {
  let _i = name.length - 1 | 0;
  while (true) {
    const i = _i;
    if (i < 0 || Curry._2(is_dir_sep$2, name, i)) {
      return 0;
    }
    if (Caml_string.get(name, i) === /* '.' */46) {
      let _i$1 = i - 1 | 0;
      while (true) {
        const i$1 = _i$1;
        if (i$1 < 0 || Curry._2(is_dir_sep$2, name, i$1)) {
          return 0;
        }
        if (Caml_string.get(name, i$1) !== /* '.' */46) {
          return name.length - i | 0;
        }
        _i$1 = i$1 - 1 | 0;
        continue;
      };
    }
    _i = i - 1 | 0;
    continue;
  };
}

function extension(name) {
  const l = extension_len(name);
  if (l === 0) {
    return "";
  } else {
    return Stdlib__String.sub(name, name.length - l | 0, l);
  }
}

function chop_extension(name) {
  const l = extension_len(name);
  if (l === 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Filename.chop_extension"
        });
  }
  return Stdlib__String.sub(name, 0, name.length - l | 0);
}

function remove_extension(name) {
  const l = extension_len(name);
  if (l === 0) {
    return name;
  } else {
    return Stdlib__String.sub(name, 0, name.length - l | 0);
  }
}

const prng_key = Stdlib__Domain.DLS.new_key(undefined, Stdlib__Random.State.make_self_init);

function temp_file_name(temp_dir, prefix, suffix) {
  const random_state = Stdlib__Domain.DLS.get(prng_key);
  const rnd = Stdlib__Random.State.bits(random_state) & 16777215;
  return concat(temp_dir, Curry._3(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_x */ 6,
        _1: {
          TAG: /* Lit_padding */ 0,
          _0: /* Zeros */ 2,
          _1: 6
        },
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "%s%06x%s"
  }), prefix, rnd, suffix));
}

const current_temp_dir_name = Stdlib__Domain.DLS.new_key((function (prim) {
  return prim;
}), (function (param) {
  return temp_dir_name$2;
}));

function set_temp_dir_name(s) {
  Stdlib__Domain.DLS.set(current_temp_dir_name, s);
}

function get_temp_dir_name(param) {
  return Stdlib__Domain.DLS.get(current_temp_dir_name);
}

function temp_file(temp_dirOpt, prefix, suffix) {
  const temp_dir = temp_dirOpt !== undefined ? temp_dirOpt : Stdlib__Domain.DLS.get(current_temp_dir_name);
  let _counter = 0;
  while (true) {
    const counter = _counter;
    const name = temp_file_name(temp_dir, prefix, suffix);
    try {
      Caml_external_polyfill.resolve("caml_sys_close")(Caml_external_polyfill.resolve("caml_sys_open")(name, {
        hd: /* Open_wronly */ 1,
        tl: {
          hd: /* Open_creat */ 3,
          tl: {
            hd: /* Open_excl */ 5,
            tl: /* [] */ 0
          }
        }
      }, 384));
      return name;
    }
    catch (raw_e){
      const e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.MEL_EXN_ID === Stdlib.Sys_error) {
        if (counter >= 20) {
          throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
        }
        _counter = counter + 1 | 0;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
    }
  };
}

function open_temp_file(modeOpt, permsOpt, temp_dirOpt, prefix, suffix) {
  const mode = modeOpt !== undefined ? modeOpt : ({
      hd: /* Open_text */ 7,
      tl: /* [] */ 0
    });
  const perms = permsOpt !== undefined ? permsOpt : 384;
  const temp_dir = temp_dirOpt !== undefined ? temp_dirOpt : Stdlib__Domain.DLS.get(current_temp_dir_name);
  let _counter = 0;
  while (true) {
    const counter = _counter;
    const name = temp_file_name(temp_dir, prefix, suffix);
    try {
      return [
        name,
        Stdlib.open_out_gen({
          hd: /* Open_wronly */ 1,
          tl: {
            hd: /* Open_creat */ 3,
            tl: {
              hd: /* Open_excl */ 5,
              tl: mode
            }
          }
        }, perms, name)
      ];
    }
    catch (raw_e){
      const e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.MEL_EXN_ID === Stdlib.Sys_error) {
        if (counter >= 20) {
          throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
        }
        _counter = counter + 1 | 0;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
    }
  };
}

function temp_dir(temp_dirOpt, permsOpt, prefix, suffix) {
  const temp_dir$1 = temp_dirOpt !== undefined ? temp_dirOpt : Stdlib__Domain.DLS.get(current_temp_dir_name);
  const perms = permsOpt !== undefined ? permsOpt : 448;
  let _counter = 0;
  while (true) {
    const counter = _counter;
    const name = temp_file_name(temp_dir$1, prefix, suffix);
    try {
      Caml_external_polyfill.resolve("caml_sys_mkdir")(name, perms);
      return name;
    }
    catch (raw_e){
      const e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.MEL_EXN_ID === Stdlib.Sys_error) {
        if (counter >= 20) {
          throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
        }
        _counter = counter + 1 | 0;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
    }
  };
}

const current_dir_name$3 = Sysdeps.current_dir_name;

const parent_dir_name = Sysdeps.parent_dir_name;

const is_relative$2 = Sysdeps.is_relative;

const is_implicit$2 = Sysdeps.is_implicit;

const chop_suffix_opt$2 = Sysdeps.chop_suffix_opt;

const basename$3 = Sysdeps.basename;

const dirname$3 = Sysdeps.dirname;

const $$null = Sysdeps.$$null;

const quote$2 = Sysdeps.quote;

const quote_command$2 = Sysdeps.quote_command;

export {
  current_dir_name$3 as current_dir_name,
  parent_dir_name,
  dir_sep,
  concat,
  is_relative$2 as is_relative,
  is_implicit$2 as is_implicit,
  check_suffix$2 as check_suffix,
  chop_suffix,
  chop_suffix_opt$2 as chop_suffix_opt,
  extension,
  remove_extension,
  chop_extension,
  basename$3 as basename,
  dirname$3 as dirname,
  $$null,
  temp_file,
  open_temp_file,
  temp_dir,
  get_temp_dir_name,
  set_temp_dir_name,
  quote$2 as quote,
  quote_command$2 as quote_command,
}
/* temp_dir_name Not a pure module */
`,If=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

const nan = Number.NaN;

const signaling_nan = Caml_int64.float_of_bits([
  2146435072,
  1
]);

function is_finite(x) {
  return x - x === 0;
}

function is_infinite(x) {
  return 1 / x === 0;
}

function is_nan(x) {
  return x !== x;
}

function is_integer(x) {
  if (x === Caml_external_polyfill.resolve("caml_trunc_float")(x)) {
    return is_finite(x);
  } else {
    return false;
  }
}

function succ(x) {
  return Caml_external_polyfill.resolve("caml_nextafter_float")(x, Stdlib.infinity);
}

function pred(x) {
  return Caml_external_polyfill.resolve("caml_nextafter_float")(x, Stdlib.neg_infinity);
}

function equal(x, y) {
  return Caml.caml_float_compare(x, y) === 0;
}

function min(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (y !== y) {
      return y;
    } else {
      return x;
    }
  } else if (x !== x) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (x !== x) {
      return x;
    } else {
      return y;
    }
  } else if (y !== y) {
    return y;
  } else {
    return x;
  }
}

function min_max(x, y) {
  if (x !== x || y !== y) {
    return [
      nan,
      nan
    ];
  } else if (y > x || y >= 0 && x < 0) {
    return [
      x,
      y
    ];
  } else {
    return [
      y,
      x
    ];
  }
}

function min_num(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (x !== x) {
      return y;
    } else {
      return x;
    }
  } else if (y !== y) {
    return x;
  } else {
    return y;
  }
}

function max_num(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (y !== y) {
      return x;
    } else {
      return y;
    }
  } else if (x !== x) {
    return y;
  } else {
    return x;
  }
}

function min_max_num(x, y) {
  if (x !== x) {
    return [
      y,
      y
    ];
  } else if (y !== y) {
    return [
      x,
      x
    ];
  } else if (y > x || y >= 0 && x < 0) {
    return [
      x,
      y
    ];
  } else {
    return [
      y,
      x
    ];
  }
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function check(a, ofs, len, msg) {
  if (!(ofs < 0 || len < 0 || (ofs + len | 0) < 0 || (ofs + len | 0) > a.length)) {
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: msg
      });
}

function init(l, f) {
  if (l < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.init"
        });
  }
  const res = Caml_array.make_float(l);
  for (let i = 0; i < l; ++i) {
    res[i] = Curry._1(f, i);
  }
  return res;
}

function make_matrix(sx, sy, v) {
  if (sy < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.make_matrix"
        });
  }
  const res = Caml_array.make(sx, Caml_array.make_float(0));
  if (sy > 0) {
    for (let x = 0; x < sx; ++x) {
      res[x] = Caml_external_polyfill.resolve("caml_floatarray_make")(sy, v);
    }
  }
  return res;
}

function init_matrix(sx, sy, f) {
  if (sy < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.init_matrix"
        });
  }
  const res = Caml_array.make(sx, Caml_array.make_float(0));
  if (sy > 0) {
    for (let x = 0; x < sx; ++x) {
      const row = Caml_array.make_float(sy);
      for (let y = 0; y < sy; ++y) {
        row[y] = Curry._2(f, x, y);
      }
      res[x] = row;
    }
  }
  return res;
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Float.Array.concat"
      });
}

function sum_lengths(_acc, _param) {
  while (true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return acc;
    }
    _param = param.tl;
    _acc = ensure_ge(param.hd.length + acc | 0, acc);
    continue;
  };
}

function concat(l) {
  const len = sum_lengths(0, l);
  const result = Caml_array.make_float(len);
  const loop = function (_l, _i) {
    while (true) {
      const i = _i;
      const l = _l;
      if (l) {
        const hd = l.hd;
        const hlen = hd.length;
        Caml_external_polyfill.resolve("caml_floatarray_blit")(hd, 0, result, i, hlen);
        _i = i + hlen | 0;
        _l = l.tl;
        continue;
      }
      if (i === len) {
        return;
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "float.cppo.ml",
              313,
              14
            ]
          });
    };
  };
  loop(l, 0);
  return result;
}

function sub(a, ofs, len) {
  check(a, ofs, len, "Float.Array.sub");
  const result = Caml_array.make_float(len);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a, ofs, result, 0, len);
  return result;
}

function copy(a) {
  const l = a.length;
  const result = Caml_array.make_float(l);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a, 0, result, 0, l);
  return result;
}

function append(a1, a2) {
  const l1 = a1.length;
  const l2 = a2.length;
  const result = Caml_array.make_float(l1 + l2 | 0);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a1, 0, result, 0, l1);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a2, 0, result, l1, l2);
  return result;
}

function fill(a, ofs, len, v) {
  check(a, ofs, len, "Float.Array.fill");
  for (let i = ofs, i_finish = ofs + len | 0; i < i_finish; ++i) {
    a[i] = v;
  }
}

function blit(src, sofs, dst, dofs, len) {
  check(src, sofs, len, "Float.array.blit");
  check(dst, dofs, len, "Float.array.blit");
  Caml_external_polyfill.resolve("caml_floatarray_blit")(src, sofs, dst, dofs, len);
}

function to_list(a) {
  return Stdlib__List.init(a.length, (function (param) {
    return a[param];
  }));
}

function of_list(l) {
  const result = Caml_array.make_float(Stdlib__List.length(l));
  let _i = 0;
  let _l = l;
  while (true) {
    const l$1 = _l;
    const i = _i;
    if (!l$1) {
      return result;
    }
    result[i] = l$1.hd;
    _l = l$1.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function iter(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._1(f, a[i]);
  }
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.iter2: arrays must have the same length"
        });
  }
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._2(f, a[i], b[i]);
  }
}

function map(f, a) {
  const l = a.length;
  const r = Caml_array.make_float(l);
  for (let i = 0; i < l; ++i) {
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_inplace(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    a[i] = Curry._1(f, a[i]);
  }
}

function map2(f, a, b) {
  const la = a.length;
  const lb = b.length;
  if (la !== lb) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.map2: arrays must have the same length"
        });
  }
  const r = Caml_array.make_float(la);
  for (let i = 0; i < la; ++i) {
    r[i] = Curry._2(f, a[i], b[i]);
  }
  return r;
}

function iteri(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._2(f, i, a[i]);
  }
}

function mapi(f, a) {
  const l = a.length;
  const r = Caml_array.make_float(l);
  for (let i = 0; i < l; ++i) {
    r[i] = Curry._2(f, i, a[i]);
  }
  return r;
}

function mapi_inplace(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    a[i] = Curry._2(f, i, a[i]);
  }
}

function fold_left(f, x, a) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  let r = x;
  for (let i = a.length - 1 | 0; i >= 0; --i) {
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function for_all(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function mem(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Caml.caml_float_compare(a[i], x) === 0) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function mem_ieee(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_opt(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const x = a[i];
    if (Curry._1(p, x)) {
      return x;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_index(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    if (Curry._1(p, a[i])) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_map(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = Curry._1(f, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_mapi(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = Curry._2(f, i, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  };
}

const Bottom = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Float.Array.Bottom");

function sort(cmp, a) {
  const maxson = function (l, i) {
    const i31 = ((i + i | 0) + i | 0) + 1 | 0;
    let x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.get(a, x), Caml_array.get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw new Caml_js_exceptions.MelangeError(Bottom, {
          MEL_EXN_ID: Bottom,
          _1: i
        });
  };
  const trickle = function (l, i, e) {
    try {
      let _i = i;
      while (true) {
        const i$1 = _i;
        const j = maxson(l, i$1);
        if (Curry._2(cmp, Caml_array.get(a, j), e) <= 0) {
          return Caml_array.set(a, i$1, e);
        }
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue;
      };
    }
    catch (raw_i){
      const i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.MEL_EXN_ID === Bottom) {
        return Caml_array.set(a, i$2._1, e);
      }
      throw new Caml_js_exceptions.MelangeError(i$2.MEL_EXN_ID, i$2);
    }
  };
  const bubble = function (l, i) {
    try {
      let _i = i;
      while (true) {
        const i$1 = _i;
        const j = maxson(l, i$1);
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue;
      };
    }
    catch (raw_i){
      const i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.MEL_EXN_ID === Bottom) {
        return i$2._1;
      }
      throw new Caml_js_exceptions.MelangeError(i$2.MEL_EXN_ID, i$2);
    }
  };
  const trickleup = function (_i, e) {
    while (true) {
      const i = _i;
      const father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "float.cppo.ml",
                560,
                6
              ]
            });
      }
      if (Curry._2(cmp, Caml_array.get(a, father), e) >= 0) {
        return Caml_array.set(a, i, e);
      }
      Caml_array.set(a, i, Caml_array.get(a, father));
      if (father <= 0) {
        return Caml_array.set(a, 0, e);
      }
      _i = father;
      continue;
    };
  };
  const l = a.length;
  for (let i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i) {
    trickle(l, i, Caml_array.get(a, i));
  }
  for (let i$1 = l - 1 | 0; i$1 >= 2; --i$1) {
    const e = Caml_array.get(a, i$1);
    Caml_array.set(a, i$1, Caml_array.get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return;
  }
  const e$1 = Caml_array.get(a, 1);
  Caml_array.set(a, 1, Caml_array.get(a, 0));
  Caml_array.set(a, 0, e$1);
}

function stable_sort(cmp, a) {
  const merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    const src1r = src1ofs + src1len | 0;
    const src2r = src2ofs + src2len | 0;
    let _i1 = src1ofs;
    let _s1 = Caml_array.get(a, src1ofs);
    let _i2 = src2ofs;
    let _s2 = Caml_array.get(src2, src2ofs);
    let _d = dstofs;
    while (true) {
      const d = _d;
      const s2 = _s2;
      const i2 = _i2;
      const s1 = _s1;
      const i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.set(dst, d, s1);
        const i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Caml_array.get(a, i1$1);
        _i1 = i1$1;
        continue;
      }
      Caml_array.set(dst, d, s2);
      const i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Caml_array.get(src2, i2$1);
      _i2 = i2$1;
      continue;
    };
  };
  const isortto = function (srcofs, dst, dstofs, len) {
    for (let i = 0; i < len; ++i) {
      const e = Caml_array.get(a, srcofs + i | 0);
      let j = (dstofs + i | 0) - 1 | 0;
      while (j >= dstofs && Curry._2(cmp, Caml_array.get(dst, j), e) > 0) {
        Caml_array.set(dst, j + 1 | 0, Caml_array.get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.set(dst, j + 1 | 0, e);
    }
  };
  const sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    const l1 = len / 2 | 0;
    const l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  const l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  const l1 = l / 2 | 0;
  const l2 = l - l1 | 0;
  const t = Caml_array.make_float(l2);
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  merge(l2, l1, t, 0, l2, a, 0);
}

function shuffle(rand, a) {
  for (let i = a.length - 1 | 0; i >= 1; --i) {
    const j = Curry._1(rand, i + 1 | 0);
    const v = a[i];
    a[i] = Caml_array.get(a, j);
    a[j] = v;
  }
}

function to_seq(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: [
        i,
        x
      ],
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq(i) {
  let l = Stdlib__Seq.fold_left((function (acc, x) {
    return {
      hd: x,
      tl: acc
    };
  }), /* [] */ 0, i);
  const len = Stdlib__List.length(l);
  const a = Caml_array.make_float(len);
  let _i = len - 1 | 0;
  let _param = l;
  while (true) {
    const param = _param;
    const i$1 = _i;
    if (!param) {
      return a;
    }
    a[i$1] = param.hd;
    _param = param.tl;
    _i = i$1 - 1 | 0;
    continue;
  };
}

function map_to_array(f, a) {
  const l = a.length;
  if (l === 0) {
    return [];
  }
  const r = Caml_array.make(l, Curry._1(f, a[0]));
  for (let i = 1; i < l; ++i) {
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_from_array(f, a) {
  const l = a.length;
  const r = Caml_array.make_float(l);
  for (let i = 0; i < l; ++i) {
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

const zero = 0;

const one = 1;

const minus_one = -1;

const infinity = Stdlib.infinity;

const neg_infinity = Stdlib.neg_infinity;

const quiet_nan = nan;

const pi = 3.14159265358979312;

const max_float = Stdlib.max_float;

const min_float = Stdlib.min_float;

const epsilon = Stdlib.epsilon_float;

const of_string_opt = Stdlib.float_of_string_opt;

const to_string = Stdlib.string_of_float;

const compare = Caml.caml_float_compare;

function Array_length(prim) {
  return prim.length;
}

const Array_get = Caml_array.get;

const Array_set = Caml_array.set;

function Array_make(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_floatarray_make")(prim0, prim1);
}

const Array_create = Caml_array.make_float;

const $$Array = {
  length: Array_length,
  get: Array_get,
  set: Array_set,
  make: Array_make,
  create: Array_create,
  init: init,
  make_matrix: make_matrix,
  init_matrix: init_matrix,
  append: append,
  concat: concat,
  sub: sub,
  copy: copy,
  fill: fill,
  blit: blit,
  to_list: to_list,
  of_list: of_list,
  iter: iter,
  iteri: iteri,
  map: map,
  map_inplace: map_inplace,
  mapi: mapi,
  mapi_inplace: mapi_inplace,
  fold_left: fold_left,
  fold_right: fold_right,
  iter2: iter2,
  map2: map2,
  for_all: for_all,
  exists: exists,
  mem: mem,
  mem_ieee: mem_ieee,
  find_opt: find_opt,
  find_index: find_index,
  find_map: find_map,
  find_mapi: find_mapi,
  sort: sort,
  stable_sort: stable_sort,
  fast_sort: stable_sort,
  shuffle: shuffle,
  to_seq: to_seq,
  to_seqi: to_seqi,
  of_seq: of_seq,
  map_to_array: map_to_array,
  map_from_array: map_from_array
};

export {
  zero,
  one,
  minus_one,
  succ,
  pred,
  infinity,
  neg_infinity,
  nan,
  signaling_nan,
  quiet_nan,
  pi,
  max_float,
  min_float,
  epsilon,
  is_finite,
  is_infinite,
  is_nan,
  is_integer,
  of_string_opt,
  to_string,
  compare,
  equal,
  min,
  max,
  min_max,
  min_num,
  max_num,
  min_max_num,
  seeded_hash,
  hash,
  $$Array,
}
/* nan Not a pure module */
`,jf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as CamlinternalFormat from "./camlinternalFormat.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Domain from "./domain.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Queue from "./queue.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Stack from "./stack.js";
import * as Stdlib__String from "./string.js";

function id(x) {
  return x;
}

const String_tag = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Format.String_tag");

function pp_enqueue(state, token) {
  state.pp_right_total = state.pp_right_total + token.length | 0;
  Stdlib__Queue.add(token, state.pp_queue);
}

function pp_clear_queue(state) {
  state.pp_left_total = 1;
  state.pp_right_total = 1;
  Stdlib__Queue.clear(state.pp_queue);
}

function pp_output_string(state, s) {
  Curry._3(state.pp_out_string, s, 0, s.length);
}

function pp_output_substring(state, pos, len, s) {
  Curry._3(state.pp_out_string, s, pos, len);
}

function format_pp_text(state, size, text) {
  state.pp_space_left = state.pp_space_left - size | 0;
  pp_output_string(state, text);
  state.pp_is_new_line = false;
}

function format_string(state, s) {
  if (s !== "") {
    return format_pp_text(state, s.length, s);
  }
  
}

function break_new_line(state, param, width) {
  format_string(state, param[0]);
  Curry._1(state.pp_out_newline, undefined);
  state.pp_is_new_line = true;
  const indent = (state.pp_margin - width | 0) + param[1] | 0;
  const real_indent = Stdlib__Int.min(state.pp_max_indent, indent);
  state.pp_current_indent = real_indent;
  state.pp_space_left = state.pp_margin - state.pp_current_indent | 0;
  Curry._1(state.pp_out_indent, state.pp_current_indent);
  format_string(state, param[2]);
}

function break_line(state, width) {
  break_new_line(state, [
    "",
    0,
    ""
  ], width);
}

function break_same_line(state, param) {
  const width = param[1];
  format_string(state, param[0]);
  state.pp_space_left = state.pp_space_left - width | 0;
  Curry._1(state.pp_out_spaces, width);
  format_string(state, param[2]);
}

function pp_force_break_line(state) {
  const match = Stdlib__Stack.top_opt(state.pp_format_stack);
  if (match === undefined) {
    return Curry._1(state.pp_out_newline, undefined);
  }
  const width = match.width;
  if (width <= state.pp_space_left) {
    return;
  }
  switch (match.box_type) {
    case /* Pp_hbox */ 0 :
    case /* Pp_fits */ 5 :
      return;
    default:
      return break_line(state, width);
  }
}

function format_pp_token(state, size, s) {
  if (/* tag */ typeof s === "number" || typeof s === "string") {
    switch (s) {
      case /* Pp_stab */ 0 :
        const match = Stdlib__Stack.top_opt(state.pp_tbox_stack);
        if (match === undefined) {
          return;
        }
        const tabs = match._0;
        const add_tab = function (n, ls) {
          if (!ls) {
            return {
              hd: n,
              tl: /* [] */ 0
            };
          }
          const x = ls.hd;
          if (Caml_obj.caml_lessthan(n, x)) {
            return {
              hd: n,
              tl: ls
            };
          } else {
            return {
              hd: x,
              tl: add_tab(n, ls.tl)
            };
          }
        };
        tabs.contents = add_tab(state.pp_margin - state.pp_space_left | 0, tabs.contents);
        return;
      case /* Pp_end */ 1 :
        Stdlib__Stack.pop_opt(state.pp_format_stack);
        return;
      case /* Pp_tend */ 2 :
        Stdlib__Stack.pop_opt(state.pp_tbox_stack);
        return;
      case /* Pp_newline */ 3 :
        const match$1 = Stdlib__Stack.top_opt(state.pp_format_stack);
        if (match$1 !== undefined) {
          return break_line(state, match$1.width);
        } else {
          return Curry._1(state.pp_out_newline, undefined);
        }
      case /* Pp_if_newline */ 4 :
        if (state.pp_current_indent !== (state.pp_margin - state.pp_space_left | 0)) {
          const match$2 = Stdlib__Queue.take_opt(state.pp_queue);
          if (match$2 === undefined) {
            return;
          }
          const size$1 = match$2.size;
          state.pp_left_total = state.pp_left_total - match$2.length | 0;
          state.pp_space_left = state.pp_space_left + size$1 | 0;
          return;
        } else {
          return;
        }
      case /* Pp_close_tag */ 5 :
        const tag_name = Stdlib__Stack.pop_opt(state.pp_mark_stack);
        if (tag_name === undefined) {
          return;
        }
        const marker = Curry._1(state.pp_mark_close_tag, Caml_option.valFromOption(tag_name));
        return pp_output_string(state, marker);
    }
  } else {
    switch (s.TAG) {
      case /* Pp_text */ 0 :
        return format_pp_text(state, size, s._0);
      case /* Pp_substring */ 1 :
        let pos = s.pos;
        let len = s.len;
        let source = s.source;
        state.pp_space_left = state.pp_space_left - size | 0;
        pp_output_substring(state, pos, len, source);
        state.pp_is_new_line = false;
        return;
      case /* Pp_break */ 2 :
        const breaks = s.breaks;
        const before = breaks[0];
        const fits = s.fits;
        const match$3 = Stdlib__Stack.top_opt(state.pp_format_stack);
        if (match$3 === undefined) {
          return;
        }
        const width = match$3.width;
        switch (match$3.box_type) {
          case /* Pp_vbox */ 1 :
          case /* Pp_hvbox */ 2 :
            return break_new_line(state, breaks, width);
          case /* Pp_hovbox */ 3 :
            if ((size + before.length | 0) > state.pp_space_left) {
              return break_new_line(state, breaks, width);
            } else {
              return break_same_line(state, fits);
            }
          case /* Pp_box */ 4 :
            if (state.pp_is_new_line || !((size + before.length | 0) > state.pp_space_left || state.pp_current_indent > ((state.pp_margin - width | 0) + breaks[1] | 0))) {
              return break_same_line(state, fits);
            } else {
              return break_new_line(state, breaks, width);
            }
          case /* Pp_hbox */ 0 :
          case /* Pp_fits */ 5 :
            return break_same_line(state, fits);
        }
      case /* Pp_tbreak */ 3 :
        const insertion_point = state.pp_margin - state.pp_space_left | 0;
        const match$4 = Stdlib__Stack.top_opt(state.pp_tbox_stack);
        if (match$4 === undefined) {
          return;
        }
        const tabs$1 = match$4._0;
        const match$5 = tabs$1.contents;
        let tab;
        if (match$5) {
          const first = match$5.hd;
          const find = function (_param) {
            while (true) {
              const param = _param;
              if (!param) {
                return first;
              }
              const head = param.hd;
              if (head >= insertion_point) {
                return head;
              }
              _param = param.tl;
              continue;
            };
          };
          tab = find(tabs$1.contents);
        } else {
          tab = insertion_point;
        }
        const offset = tab - insertion_point | 0;
        if (offset >= 0) {
          return break_same_line(state, [
            "",
            offset + s._0 | 0,
            ""
          ]);
        } else {
          return break_new_line(state, [
            "",
            tab + s._1 | 0,
            ""
          ], state.pp_margin);
        }
      case /* Pp_begin */ 4 :
        const ty = s._1;
        const insertion_point$1 = state.pp_margin - state.pp_space_left | 0;
        if (insertion_point$1 > state.pp_max_indent) {
          pp_force_break_line(state);
        }
        const width$1 = state.pp_space_left - s._0 | 0;
        let box_type;
        box_type = ty === /* Pp_vbox */ 1 ? /* Pp_vbox */ 1 : (
            size > state.pp_space_left ? ty : /* Pp_fits */ 5
          );
        return Stdlib__Stack.push({
          box_type: box_type,
          width: width$1
        }, state.pp_format_stack);
      case /* Pp_tbegin */ 5 :
        return Stdlib__Stack.push(s._0, state.pp_tbox_stack);
      case /* Pp_open_tag */ 6 :
        const tag_name$1 = s._0;
        const marker$1 = Curry._1(state.pp_mark_open_tag, tag_name$1);
        pp_output_string(state, marker$1);
        return Stdlib__Stack.push(tag_name$1, state.pp_mark_stack);
    }
  }
}

function advance_left(state) {
  while (true) {
    const match = Stdlib__Queue.peek_opt(state.pp_queue);
    if (match === undefined) {
      return;
    }
    const size = match.size;
    const pending_count = state.pp_right_total - state.pp_left_total | 0;
    if (!(size >= 0 || pending_count >= state.pp_space_left)) {
      return;
    }
    Stdlib__Queue.take(state.pp_queue);
    const size$1 = size >= 0 ? size : 1000000010;
    format_pp_token(state, size$1, match.token);
    state.pp_left_total = match.length + state.pp_left_total | 0;
    continue;
  };
}

function enqueue_advance(state, tok) {
  pp_enqueue(state, tok);
  advance_left(state);
}

function enqueue_string_as(state, size, s) {
  enqueue_advance(state, {
    size: size,
    token: {
      TAG: /* Pp_text */ 0,
      _0: s
    },
    length: size
  });
}

function initialize_scan_stack(stack) {
  Stdlib__Stack.clear(stack);
  const queue_elem = {
    size: -1,
    token: {
      TAG: /* Pp_text */ 0,
      _0: ""
    },
    length: 0
  };
  Stdlib__Stack.push({
    left_total: -1,
    queue_elem: queue_elem
  }, stack);
}

function set_size(state, ty) {
  const match = Stdlib__Stack.top_opt(state.pp_scan_stack);
  if (match === undefined) {
    return;
  }
  const queue_elem = match.queue_elem;
  const size = queue_elem.size;
  if (match.left_total < state.pp_left_total) {
    return initialize_scan_stack(state.pp_scan_stack);
  }
  const match$1 = queue_elem.token;
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    return;
  }
  switch (match$1.TAG) {
    case /* Pp_break */ 2 :
    case /* Pp_tbreak */ 3 :
      break;
    case /* Pp_begin */ 4 :
      if (!ty) {
        queue_elem.size = state.pp_right_total + size | 0;
        Stdlib__Stack.pop_opt(state.pp_scan_stack);
        return;
      } else {
        return;
      }
    default:
      return;
  }
  if (ty) {
    queue_elem.size = state.pp_right_total + size | 0;
    Stdlib__Stack.pop_opt(state.pp_scan_stack);
    return;
  }
  
}

function scan_push(state, b, token) {
  pp_enqueue(state, token);
  if (b) {
    set_size(state, true);
  }
  const elem_left_total = state.pp_right_total;
  const elem = {
    left_total: elem_left_total,
    queue_elem: token
  };
  Stdlib__Stack.push(elem, state.pp_scan_stack);
}

function pp_open_box_gen(state, indent, br_ty) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    if (state.pp_curr_depth === state.pp_max_boxes) {
      let s = state.pp_ellipsis;
      return enqueue_string_as(state, s.length, s);
    } else {
      return;
    }
  }
  const size = -state.pp_right_total | 0;
  const elem = {
    size: size,
    token: {
      TAG: /* Pp_begin */ 4,
      _0: indent,
      _1: br_ty
    },
    length: 0
  };
  scan_push(state, false, elem);
}

function pp_close_box(state, param) {
  if (state.pp_curr_depth > 1) {
    if (state.pp_curr_depth < state.pp_max_boxes) {
      pp_enqueue(state, {
        size: 0,
        token: /* Pp_end */ 1,
        length: 0
      });
      set_size(state, true);
      set_size(state, false);
    }
    state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
    return;
  }
  
}

function pp_open_stag(state, tag_name) {
  if (state.pp_print_tags) {
    Stdlib__Stack.push(tag_name, state.pp_tag_stack);
    Curry._1(state.pp_print_open_tag, tag_name);
  }
  if (!state.pp_mark_tags) {
    return;
  }
  const token = {
    TAG: /* Pp_open_tag */ 6,
    _0: tag_name
  };
  pp_enqueue(state, {
    size: 0,
    token: token,
    length: 0
  });
}

function pp_close_stag(state, param) {
  if (state.pp_mark_tags) {
    pp_enqueue(state, {
      size: 0,
      token: /* Pp_close_tag */ 5,
      length: 0
    });
  }
  if (!state.pp_print_tags) {
    return;
  }
  const tag_name = Stdlib__Stack.pop_opt(state.pp_tag_stack);
  if (tag_name !== undefined) {
    return Curry._1(state.pp_print_close_tag, Caml_option.valFromOption(tag_name));
  }
  
}

function pp_set_print_tags(state, b) {
  state.pp_print_tags = b;
}

function pp_set_mark_tags(state, b) {
  state.pp_mark_tags = b;
}

function pp_get_print_tags(state, param) {
  return state.pp_print_tags;
}

function pp_get_mark_tags(state, param) {
  return state.pp_mark_tags;
}

function pp_set_tags(state, b) {
  state.pp_print_tags = b;
  state.pp_mark_tags = b;
}

function pp_get_formatter_stag_functions(state, param) {
  return {
    mark_open_stag: state.pp_mark_open_tag,
    mark_close_stag: state.pp_mark_close_tag,
    print_open_stag: state.pp_print_open_tag,
    print_close_stag: state.pp_print_close_tag
  };
}

function pp_set_formatter_stag_functions(state, param) {
  state.pp_mark_open_tag = param.mark_open_stag;
  state.pp_mark_close_tag = param.mark_close_stag;
  state.pp_print_open_tag = param.print_open_stag;
  state.pp_print_close_tag = param.print_close_stag;
}

function pp_rinit(state) {
  pp_clear_queue(state);
  initialize_scan_stack(state.pp_scan_stack);
  Stdlib__Stack.clear(state.pp_format_stack);
  Stdlib__Stack.clear(state.pp_tbox_stack);
  Stdlib__Stack.clear(state.pp_tag_stack);
  Stdlib__Stack.clear(state.pp_mark_stack);
  state.pp_current_indent = 0;
  state.pp_curr_depth = 0;
  state.pp_space_left = state.pp_margin;
  pp_open_box_gen(state, 0, /* Pp_hovbox */ 3);
}

function clear_tag_stack(state) {
  const s = state.pp_tag_stack;
  const f = function (param) {
    pp_close_stag(state, undefined);
  };
  Stdlib__List.iter(f, s.c);
}

function pp_flush_queue(state, end_with_newline) {
  clear_tag_stack(state);
  while (state.pp_curr_depth > 1) {
    pp_close_box(state, undefined);
  };
  state.pp_right_total = 1000000010;
  advance_left(state);
  if (end_with_newline) {
    Curry._1(state.pp_out_newline, undefined);
  }
  pp_rinit(state);
}

function pp_print_as_size(state, size, s) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_string_as(state, size, s);
  }
  
}

const pp_print_as = pp_print_as_size;

function pp_print_string(state, s) {
  pp_print_as(state, s.length, s);
}

function pp_print_substring_as(pos, len, state, size, s) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    const token = {
      TAG: /* Pp_substring */ 1,
      source: s,
      pos: pos,
      len: len
    };
    return enqueue_advance(state, {
      size: size,
      token: token,
      length: size
    });
  }
  
}

function pp_print_substring(pos, len, state, s) {
  pp_print_substring_as(pos, len, state, len, s);
}

function pp_print_bytes(state, s) {
  pp_print_as(state, s.length, Stdlib__Bytes.to_string(s));
}

function pp_print_int(state, i) {
  pp_print_string(state, Caml_format.caml_format_int("%d", i));
}

function pp_print_float(state, f) {
  pp_print_string(state, Stdlib.string_of_float(f));
}

function pp_print_bool(state, b) {
  pp_print_string(state, b ? "true" : "false");
}

function pp_print_char(state, c) {
  pp_print_as(state, 1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
}

function pp_print_nothing(_state, param) {
  
}

function pp_open_hbox(state, param) {
  pp_open_box_gen(state, 0, /* Pp_hbox */ 0);
}

function pp_open_vbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_vbox */ 1);
}

function pp_open_hvbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_hvbox */ 2);
}

function pp_open_hovbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_hovbox */ 3);
}

function pp_open_box(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_box */ 4);
}

function pp_print_newline(state, param) {
  pp_flush_queue(state, true);
  Curry._1(state.pp_out_flush, undefined);
}

function pp_print_flush(state, param) {
  pp_flush_queue(state, false);
  Curry._1(state.pp_out_flush, undefined);
}

function pp_force_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
      size: 0,
      token: /* Pp_newline */ 3,
      length: 0
    });
  }
  
}

function pp_print_if_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
      size: 0,
      token: /* Pp_if_newline */ 4,
      length: 0
    });
  }
  
}

function pp_print_custom_break(state, fits, breaks) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const size = -state.pp_right_total | 0;
  const token = {
    TAG: /* Pp_break */ 2,
    fits: fits,
    breaks: breaks
  };
  const length = (fits[0].length + fits[1] | 0) + fits[2].length | 0;
  const elem = {
    size: size,
    token: token,
    length: length
  };
  scan_push(state, true, elem);
}

function pp_print_break(state, width, offset) {
  pp_print_custom_break(state, [
    "",
    width,
    ""
  ], [
    "",
    offset,
    ""
  ]);
}

function pp_print_space(state, param) {
  pp_print_break(state, 1, 0);
}

function pp_print_cut(state, param) {
  pp_print_break(state, 0, 0);
}

function pp_open_tbox(state, param) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const elem = {
    size: 0,
    token: {
      TAG: /* Pp_tbegin */ 5,
      _0: {
        TAG: /* Pp_tbox */ 0,
        _0: {
          contents: /* [] */ 0
        }
      }
    },
    length: 0
  };
  enqueue_advance(state, elem);
}

function pp_close_tbox(state, param) {
  if (state.pp_curr_depth <= 1) {
    return;
  }
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const elem = {
    size: 0,
    token: /* Pp_tend */ 2,
    length: 0
  };
  enqueue_advance(state, elem);
  state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
}

function pp_print_tbreak(state, width, offset) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const size = -state.pp_right_total | 0;
  const elem = {
    size: size,
    token: {
      TAG: /* Pp_tbreak */ 3,
      _0: width,
      _1: offset
    },
    length: width
  };
  scan_push(state, true, elem);
}

function pp_print_tab(state, param) {
  pp_print_tbreak(state, 0, 0);
}

function pp_set_tab(state, param) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const elem = {
    size: 0,
    token: /* Pp_stab */ 0,
    length: 0
  };
  enqueue_advance(state, elem);
}

function pp_set_max_boxes(state, n) {
  if (n > 1) {
    state.pp_max_boxes = n;
    return;
  }
  
}

function pp_get_max_boxes(state, param) {
  return state.pp_max_boxes;
}

function pp_over_max_boxes(state, param) {
  return state.pp_curr_depth === state.pp_max_boxes;
}

function pp_set_ellipsis_text(state, s) {
  state.pp_ellipsis = s;
}

function pp_get_ellipsis_text(state, param) {
  return state.pp_ellipsis;
}

function pp_limit(n) {
  if (n < 1000000010) {
    return n;
  } else {
    return 1000000009;
  }
}

function pp_set_max_indent(state, n) {
  if (n > 1) {
    let n$1 = state.pp_margin - n | 0;
    if (n$1 < 1) {
      return;
    }
    const n$2 = pp_limit(n$1);
    state.pp_min_space_left = n$2;
    state.pp_max_indent = state.pp_margin - state.pp_min_space_left | 0;
    return pp_rinit(state);
  }
  
}

function pp_get_max_indent(state, param) {
  return state.pp_max_indent;
}

function pp_set_margin(state, n) {
  if (n < 1) {
    return;
  }
  const n$1 = pp_limit(n);
  state.pp_margin = n$1;
  const new_max_indent = state.pp_max_indent <= state.pp_margin ? state.pp_max_indent : Stdlib__Int.max(Stdlib__Int.max(state.pp_margin - state.pp_min_space_left | 0, state.pp_margin / 2 | 0), 1);
  pp_set_max_indent(state, new_max_indent);
}

function validate_geometry(param) {
  const max_indent = param.max_indent;
  if (max_indent < 2) {
    return {
      TAG: /* Error */ 1,
      _0: "max_indent < 2"
    };
  }
  const margin = param.margin;
  if (margin <= max_indent) {
    return {
      TAG: /* Error */ 1,
      _0: "margin <= max_indent"
    };
  } else if (margin >= 1000000010) {
    return {
      TAG: /* Error */ 1,
      _0: "margin >= pp_infinity"
    };
  } else {
    return {
      TAG: /* Ok */ 0,
      _0: undefined
    };
  }
}

function check_geometry(geometry) {
  const match = validate_geometry(geometry);
  if (match.TAG === /* Ok */ 0) {
    return true;
  } else {
    return false;
  }
}

function pp_get_margin(state, param) {
  return state.pp_margin;
}

function pp_set_full_geometry(state, param) {
  pp_set_margin(state, param.margin);
  pp_set_max_indent(state, param.max_indent);
}

function pp_set_geometry(state, max_indent, margin) {
  const geometry = {
    max_indent: max_indent,
    margin: margin
  };
  const msg = validate_geometry(geometry);
  if (msg.TAG === /* Ok */ 0) {
    return pp_set_full_geometry(state, geometry);
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
        MEL_EXN_ID: Stdlib.Invalid_argument,
        _1: "Format.pp_set_geometry: " + msg._0
      });
}

function pp_safe_set_geometry(state, max_indent, margin) {
  const geometry = {
    max_indent: max_indent,
    margin: margin
  };
  const _msg = validate_geometry(geometry);
  if (_msg.TAG === /* Ok */ 0) {
    return pp_set_full_geometry(state, geometry);
  }
  
}

function pp_get_geometry(state, param) {
  return {
    max_indent: state.pp_max_indent,
    margin: state.pp_margin
  };
}

function pp_update_geometry(state, update) {
  const geometry = pp_get_geometry(state, undefined);
  pp_set_full_geometry(state, Curry._1(update, geometry));
}

function pp_set_formatter_out_functions(state, param) {
  state.pp_out_string = param.out_string;
  state.pp_out_flush = param.out_flush;
  state.pp_out_newline = param.out_newline;
  state.pp_out_spaces = param.out_spaces;
  state.pp_out_indent = param.out_indent;
}

function pp_get_formatter_out_functions(state, param) {
  return {
    out_string: state.pp_out_string,
    out_flush: state.pp_out_flush,
    out_newline: state.pp_out_newline,
    out_spaces: state.pp_out_spaces,
    out_indent: state.pp_out_indent
  };
}

function pp_set_formatter_output_functions(state, f, g) {
  state.pp_out_string = f;
  state.pp_out_flush = g;
}

function pp_get_formatter_output_functions(state, param) {
  return [
    state.pp_out_string,
    state.pp_out_flush
  ];
}

function display_newline(state, param) {
  Curry._3(state.pp_out_string, "\\n", 0, 1);
}

const blank_line = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(80, /* ' ' */32));

function display_blanks(state, _n) {
  while (true) {
    const n = _n;
    if (n <= 0) {
      return;
    }
    if (n <= 80) {
      return Curry._3(state.pp_out_string, blank_line, 0, n);
    }
    Curry._3(state.pp_out_string, blank_line, 0, 80);
    _n = n - 80 | 0;
    continue;
  };
}

function pp_set_formatter_out_channel(state, oc) {
  state.pp_out_string = (function (param, param$1, param$2) {
    return Stdlib.output_substring(oc, param, param$1, param$2);
  });
  state.pp_out_flush = (function (param) {
    Caml_io.caml_ml_flush(oc);
  });
  state.pp_out_newline = (function (param) {
    return display_newline(state, param);
  });
  state.pp_out_spaces = (function (param) {
    return display_blanks(state, param);
  });
  state.pp_out_indent = (function (param) {
    return display_blanks(state, param);
  });
}

function default_pp_mark_open_tag(s) {
  if (s.MEL_EXN_ID === String_tag) {
    return "<" + (s._1 + ">");
  } else {
    return "";
  }
}

function default_pp_mark_close_tag(s) {
  if (s.MEL_EXN_ID === String_tag) {
    return "</" + (s._1 + ">");
  } else {
    return "";
  }
}

function default_pp_print_open_tag(prim) {
  
}

function default_pp_print_close_tag(prim) {
  
}

function pp_make_formatter(f, g, h, i, j) {
  const pp_queue = {
    length: 0,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
  const sys_tok = {
    size: -1,
    token: {
      TAG: /* Pp_begin */ 4,
      _0: 0,
      _1: /* Pp_hovbox */ 3
    },
    length: 0
  };
  Stdlib__Queue.add(sys_tok, pp_queue);
  const scan_stack = {
    c: /* [] */ 0,
    len: 0
  };
  initialize_scan_stack(scan_stack);
  Stdlib__Stack.push({
    left_total: 1,
    queue_elem: sys_tok
  }, scan_stack);
  return {
    pp_scan_stack: scan_stack,
    pp_format_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_tbox_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_tag_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_mark_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_margin: 78,
    pp_min_space_left: 10,
    pp_max_indent: 68,
    pp_space_left: 78,
    pp_current_indent: 0,
    pp_is_new_line: true,
    pp_left_total: 1,
    pp_right_total: 1,
    pp_curr_depth: 1,
    pp_max_boxes: Stdlib.max_int,
    pp_ellipsis: ".",
    pp_out_string: f,
    pp_out_flush: g,
    pp_out_newline: h,
    pp_out_spaces: i,
    pp_out_indent: j,
    pp_print_tags: false,
    pp_mark_tags: false,
    pp_mark_open_tag: default_pp_mark_open_tag,
    pp_mark_close_tag: default_pp_mark_close_tag,
    pp_print_open_tag: default_pp_print_open_tag,
    pp_print_close_tag: default_pp_print_close_tag,
    pp_queue: pp_queue
  };
}

function formatter_of_out_functions(out_funs) {
  return pp_make_formatter(out_funs.out_string, out_funs.out_flush, out_funs.out_newline, out_funs.out_spaces, out_funs.out_indent);
}

function make_formatter(output, flush) {
  const ppf = pp_make_formatter(output, flush, (function (prim) {
    
  }), (function (prim) {
    
  }), (function (prim) {
    
  }));
  ppf.pp_out_newline = (function (param) {
    return display_newline(ppf, param);
  });
  ppf.pp_out_spaces = (function (param) {
    return display_blanks(ppf, param);
  });
  ppf.pp_out_indent = (function (param) {
    return display_blanks(ppf, param);
  });
  return ppf;
}

function formatter_of_out_channel(oc) {
  return make_formatter((function (param, param$1, param$2) {
    return Stdlib.output_substring(oc, param, param$1, param$2);
  }), (function (param) {
    Caml_io.caml_ml_flush(oc);
  }));
}

function formatter_of_buffer(b) {
  return make_formatter((function (param, param$1, param$2) {
    return Stdlib__Buffer.add_substring(b, param, param$1, param$2);
  }), (function (prim) {
    
  }));
}

function pp_make_buffer(param) {
  return Stdlib__Buffer.create(512);
}

const stdbuf = Stdlib__Buffer.create(512);

const std_formatter = formatter_of_out_channel(Stdlib.stdout);

const err_formatter = formatter_of_out_channel(Stdlib.stderr);

const str_formatter = formatter_of_buffer(stdbuf);

const stdbuf_key = Stdlib__Domain.DLS.new_key(undefined, pp_make_buffer);

Stdlib__Domain.DLS.set(stdbuf_key, stdbuf);

const str_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  return formatter_of_buffer(Stdlib__Domain.DLS.get(stdbuf_key));
}));

Stdlib__Domain.DLS.set(str_formatter_key, str_formatter);

function buffered_out_string(key, str, ofs, len) {
  Stdlib__Buffer.add_substring(Stdlib__Domain.DLS.get(key), str, ofs, len);
}

function buffered_out_flush(oc, key, param) {
  const buf = Stdlib__Domain.DLS.get(key);
  const len = buf.position;
  const str = Stdlib__Buffer.contents(buf);
  Stdlib.output_substring(oc, str, 0, len);
  Caml_io.caml_ml_flush(oc);
  buf.position = 0;
}

const std_buf_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  return Stdlib__Buffer.create(512);
}));

const err_buf_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  return Stdlib__Buffer.create(512);
}));

const std_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  const ppf = pp_make_formatter((function (param, param$1, param$2) {
    return buffered_out_string(std_buf_key, param, param$1, param$2);
  }), (function (param) {
    return buffered_out_flush(Stdlib.stdout, std_buf_key, param);
  }), (function (prim) {
    
  }), (function (prim) {
    
  }), (function (prim) {
    
  }));
  ppf.pp_out_newline = (function (param) {
    return display_newline(ppf, param);
  });
  ppf.pp_out_spaces = (function (param) {
    return display_blanks(ppf, param);
  });
  ppf.pp_out_indent = (function (param) {
    return display_blanks(ppf, param);
  });
  Stdlib__Domain.at_exit(function (param) {
    return pp_print_flush(ppf, param);
  });
  return ppf;
}));

Stdlib__Domain.DLS.set(std_formatter_key, std_formatter);

const err_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  const ppf = pp_make_formatter((function (param, param$1, param$2) {
    return buffered_out_string(err_buf_key, param, param$1, param$2);
  }), (function (param) {
    return buffered_out_flush(Stdlib.stderr, err_buf_key, param);
  }), (function (prim) {
    
  }), (function (prim) {
    
  }), (function (prim) {
    
  }));
  ppf.pp_out_newline = (function (param) {
    return display_newline(ppf, param);
  });
  ppf.pp_out_spaces = (function (param) {
    return display_blanks(ppf, param);
  });
  ppf.pp_out_indent = (function (param) {
    return display_blanks(ppf, param);
  });
  Stdlib__Domain.at_exit(function (param) {
    return pp_print_flush(ppf, param);
  });
  return ppf;
}));

Stdlib__Domain.DLS.set(err_formatter_key, err_formatter);

function get_std_formatter(param) {
  return Stdlib__Domain.DLS.get(std_formatter_key);
}

function get_err_formatter(param) {
  return Stdlib__Domain.DLS.get(err_formatter_key);
}

function get_str_formatter(param) {
  return Stdlib__Domain.DLS.get(str_formatter_key);
}

function get_stdbuf(param) {
  return Stdlib__Domain.DLS.get(stdbuf_key);
}

function flush_buffer_formatter(buf, ppf) {
  pp_flush_queue(ppf, false);
  const s = Stdlib__Buffer.contents(buf);
  Stdlib__Buffer.reset(buf);
  return s;
}

function flush_str_formatter(param) {
  const stdbuf = Stdlib__Domain.DLS.get(stdbuf_key);
  const str_formatter = Stdlib__Domain.DLS.get(str_formatter_key);
  return flush_buffer_formatter(stdbuf, str_formatter);
}

function make_synchronized_formatter(output, flush) {
  return Stdlib__Domain.DLS.new_key(undefined, (function (param) {
    const buf = Stdlib__Buffer.create(512);
    const output$p = function (param, param$1, param$2) {
      return Stdlib__Buffer.add_substring(buf, param, param$1, param$2);
    };
    const flush$p = function (param) {
      Curry._3(output, Stdlib__Buffer.contents(buf), 0, buf.position);
      buf.position = 0;
      Curry._1(flush, undefined);
    };
    return make_formatter(output$p, flush$p);
  }));
}

function synchronized_formatter_of_out_channel(oc) {
  return make_synchronized_formatter((function (param, param$1, param$2) {
    return Stdlib.output_substring(oc, param, param$1, param$2);
  }), (function (param) {
    Caml_io.caml_ml_flush(oc);
  }));
}

function make_symbolic_output_buffer(param) {
  return {
    symbolic_output_contents: /* [] */ 0
  };
}

function clear_symbolic_output_buffer(sob) {
  sob.symbolic_output_contents = /* [] */ 0;
}

function get_symbolic_output_buffer(sob) {
  return Stdlib__List.rev(sob.symbolic_output_contents);
}

function flush_symbolic_output_buffer(sob) {
  const items = Stdlib__List.rev(sob.symbolic_output_contents);
  sob.symbolic_output_contents = /* [] */ 0;
  return items;
}

function add_symbolic_output_item(sob, item) {
  sob.symbolic_output_contents = {
    hd: item,
    tl: sob.symbolic_output_contents
  };
}

function formatter_of_symbolic_output_buffer(sob) {
  const f = function (param, param$1, param$2) {
    return add_symbolic_output_item(sob, {
      TAG: /* Output_string */ 0,
      _0: Stdlib__String.sub(param, param$1, param$2)
    });
  };
  const g = function (param) {
    return add_symbolic_output_item(sob, /* Output_flush */ 0);
  };
  const h = function (param) {
    return add_symbolic_output_item(sob, /* Output_newline */ 1);
  };
  const i = function (param) {
    return add_symbolic_output_item(sob, {
      TAG: /* Output_spaces */ 1,
      _0: param
    });
  };
  const j = function (param) {
    return add_symbolic_output_item(sob, {
      TAG: /* Output_indent */ 2,
      _0: param
    });
  };
  return pp_make_formatter(f, g, h, i, j);
}

function open_hbox(v) {
  pp_open_hbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_vbox(v) {
  pp_open_vbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_hvbox(v) {
  pp_open_hvbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_hovbox(v) {
  pp_open_hovbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_box(v) {
  pp_open_box(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_box(v) {
  pp_close_box(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_stag(v) {
  pp_open_stag(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_stag(v) {
  pp_close_stag(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_as(v, w) {
  pp_print_as(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function print_string(v) {
  pp_print_string(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_substring(pos, len, v) {
  pp_print_substring(pos, len, Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_substring_as(pos, len, as_len, v) {
  pp_print_substring_as(pos, len, Stdlib__Domain.DLS.get(std_formatter_key), as_len, v);
}

function print_bytes(v) {
  pp_print_bytes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_int(v) {
  const state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, Caml_format.caml_format_int("%d", v));
}

function print_float(v) {
  const state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, Stdlib.string_of_float(v));
}

function print_char(v) {
  pp_print_char(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_bool(v) {
  const state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, v ? "true" : "false");
}

function print_break(v, w) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function print_cut(v) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), 0, 0);
}

function print_space(v) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), 1, 0);
}

function force_newline(v) {
  pp_force_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_flush(v) {
  pp_print_flush(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_newline(v) {
  pp_print_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_if_newline(v) {
  pp_print_if_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_tbox(v) {
  pp_open_tbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_tbox(v) {
  pp_close_tbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_tbreak(v, w) {
  pp_print_tbreak(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function set_tab(v) {
  pp_set_tab(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_tab(v) {
  pp_print_tbreak(Stdlib__Domain.DLS.get(std_formatter_key), 0, 0);
}

function set_margin(v) {
  pp_set_margin(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_margin(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_margin;
}

function set_max_indent(v) {
  pp_set_max_indent(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_max_indent(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_max_indent;
}

function set_geometry(max_indent, margin) {
  pp_set_geometry(Stdlib__Domain.DLS.get(std_formatter_key), max_indent, margin);
}

function safe_set_geometry(max_indent, margin) {
  pp_safe_set_geometry(Stdlib__Domain.DLS.get(std_formatter_key), max_indent, margin);
}

function get_geometry(v) {
  return pp_get_geometry(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function update_geometry(v) {
  pp_update_geometry(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_max_boxes(v) {
  pp_set_max_boxes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_max_boxes(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_max_boxes;
}

function over_max_boxes(v) {
  return pp_over_max_boxes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_ellipsis_text(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_ellipsis = v;
}

function get_ellipsis_text(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_ellipsis;
}

function set_formatter_out_channel(v) {
  pp_set_formatter_out_channel(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_out_functions(v) {
  pp_set_formatter_out_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_formatter_out_functions(v) {
  return pp_get_formatter_out_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_output_functions(v, w) {
  pp_set_formatter_output_functions(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function get_formatter_output_functions(v) {
  return pp_get_formatter_output_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_stag_functions(v) {
  pp_set_formatter_stag_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_formatter_stag_functions(v) {
  return pp_get_formatter_stag_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_print_tags(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_print_tags = v;
}

function get_print_tags(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_print_tags;
}

function set_mark_tags(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_mark_tags = v;
}

function get_mark_tags(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_mark_tags;
}

function set_tags(v) {
  pp_set_tags(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function pp_print_iter(pp_sepOpt, iter, pp_v, ppf, v) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  const is_first = {
    contents: true
  };
  const pp_v$1 = function (v) {
    if (is_first.contents) {
      is_first.contents = false;
    } else {
      Curry._2(pp_sep, ppf, undefined);
    }
    return Curry._2(pp_v, ppf, v);
  };
  return Curry._2(iter, pp_v$1, v);
}

function pp_print_list(pp_sepOpt, pp_v, ppf, v) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__List.iter, pp_v, ppf, v);
}

function pp_print_array(pp_sepOpt, pp_v, ppf, v) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__Array.iter, pp_v, ppf, v);
}

function pp_print_seq(pp_sepOpt, pp_v, ppf, seq) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__Seq.iter, pp_v, ppf, seq);
}

function pp_print_text(ppf, s) {
  const len = s.length;
  const left = {
    contents: 0
  };
  const right = {
    contents: 0
  };
  const flush = function (param) {
    pp_print_substring(left.contents, right.contents - left.contents | 0, ppf, s);
    right.contents = right.contents + 1 | 0;
    left.contents = right.contents;
  };
  while (right.contents !== len) {
    const match = Caml_string.get(s, right.contents);
    if (match !== 10) {
      if (match !== 32) {
        right.contents = right.contents + 1 | 0;
      } else {
        flush(undefined);
        pp_print_break(ppf, 1, 0);
      }
    } else {
      flush(undefined);
      pp_force_newline(ppf, undefined);
    }
  };
  if (left.contents !== len) {
    return flush(undefined);
  }
  
}

function pp_print_option(noneOpt, pp_v, ppf, v) {
  const none = noneOpt !== undefined ? noneOpt : (function (param, param$1) {
      
    });
  if (v !== undefined) {
    return Curry._2(pp_v, ppf, Caml_option.valFromOption(v));
  } else {
    return Curry._2(none, ppf, undefined);
  }
}

function pp_print_result(ok, error, ppf, v) {
  if (v.TAG === /* Ok */ 0) {
    return Curry._2(ok, ppf, v._0);
  } else {
    return Curry._2(error, ppf, v._0);
  }
}

function pp_print_either(left, right, ppf, l) {
  if (l.TAG === /* Left */ 0) {
    return Curry._2(left, ppf, l._0);
  } else {
    return Curry._2(right, ppf, l._0);
  }
}

function compute_tag(output, tag_acc) {
  const buf = Stdlib__Buffer.create(16);
  const ppf = formatter_of_buffer(buf);
  Curry._2(output, ppf, tag_acc);
  pp_print_flush(ppf, undefined);
  const len = buf.position;
  if (len < 2) {
    return Stdlib__Buffer.contents(buf);
  } else {
    return Stdlib__Buffer.sub(buf, 1, len - 2 | 0);
  }
}

function output_formatting_lit(ppf, fmting_lit) {
  if (/* tag */ typeof fmting_lit === "number" || typeof fmting_lit === "string") {
    switch (fmting_lit) {
      case /* Close_box */ 0 :
        return pp_close_box(ppf, undefined);
      case /* Close_tag */ 1 :
        return pp_close_stag(ppf, undefined);
      case /* FFlush */ 2 :
        return pp_print_flush(ppf, undefined);
      case /* Force_newline */ 3 :
        return pp_force_newline(ppf, undefined);
      case /* Flush_newline */ 4 :
        return pp_print_newline(ppf, undefined);
      case /* Escaped_at */ 5 :
        return pp_print_char(ppf, /* '@' */64);
      case /* Escaped_percent */ 6 :
        return pp_print_char(ppf, /* '%' */37);
    }
  } else {
    switch (fmting_lit.TAG) {
      case /* Break */ 0 :
        return pp_print_break(ppf, fmting_lit._1, fmting_lit._2);
      case /* Magic_size */ 1 :
        return;
      case /* Scan_indic */ 2 :
        pp_print_char(ppf, /* '@' */64);
        return pp_print_char(ppf, fmting_lit._0);
    }
  }
}

function output_acc(ppf, acc) {
  let exit = 0;
  let p;
  let size;
  let s;
  let p$1;
  let size$1;
  let c;
  if (/* tag */ typeof acc === "number" || typeof acc === "string") {
    return;
  }
  switch (acc.TAG) {
    case /* Acc_formatting_lit */ 0 :
      output_acc(ppf, acc._0);
      return output_formatting_lit(ppf, acc._1);
    case /* Acc_formatting_gen */ 1 :
      const acc$p = acc._1;
      const p$2 = acc._0;
      if (acc$p.TAG === /* Acc_open_tag */ 0) {
        output_acc(ppf, p$2);
        return pp_open_stag(ppf, {
          MEL_EXN_ID: String_tag,
          _1: compute_tag(output_acc, acc$p._0)
        });
      }
      output_acc(ppf, p$2);
      const match = CamlinternalFormat.open_box_of_string(compute_tag(output_acc, acc$p._0));
      return pp_open_box_gen(ppf, match[0], match[1]);
    case /* Acc_string_literal */ 2 :
      const p$3 = acc._0;
      let exit$1 = 0;
      if (/* tag */ typeof p$3 === "number" || typeof p$3 === "string" || p$3.TAG !== /* Acc_formatting_lit */ 0) {
        exit$1 = 3;
      } else {
        const match$1 = p$3._1;
        if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string" || match$1.TAG !== /* Magic_size */ 1) {
          exit$1 = 3;
        } else {
          p = p$3._0;
          size = match$1._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$1 === 3) {
        output_acc(ppf, p$3);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_char_literal */ 3 :
      const p$4 = acc._0;
      let exit$2 = 0;
      if (/* tag */ typeof p$4 === "number" || typeof p$4 === "string" || p$4.TAG !== /* Acc_formatting_lit */ 0) {
        exit$2 = 3;
      } else {
        const match$2 = p$4._1;
        if (/* tag */ typeof match$2 === "number" || typeof match$2 === "string" || match$2.TAG !== /* Magic_size */ 1) {
          exit$2 = 3;
        } else {
          p$1 = p$4._0;
          size$1 = match$2._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$2 === 3) {
        output_acc(ppf, p$4);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_data_string */ 4 :
      const p$5 = acc._0;
      let exit$3 = 0;
      if (/* tag */ typeof p$5 === "number" || typeof p$5 === "string" || p$5.TAG !== /* Acc_formatting_lit */ 0) {
        exit$3 = 3;
      } else {
        const match$3 = p$5._1;
        if (/* tag */ typeof match$3 === "number" || typeof match$3 === "string" || match$3.TAG !== /* Magic_size */ 1) {
          exit$3 = 3;
        } else {
          p = p$5._0;
          size = match$3._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$3 === 3) {
        output_acc(ppf, p$5);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_data_char */ 5 :
      const p$6 = acc._0;
      let exit$4 = 0;
      if (/* tag */ typeof p$6 === "number" || typeof p$6 === "string" || p$6.TAG !== /* Acc_formatting_lit */ 0) {
        exit$4 = 3;
      } else {
        const match$4 = p$6._1;
        if (/* tag */ typeof match$4 === "number" || typeof match$4 === "string" || match$4.TAG !== /* Magic_size */ 1) {
          exit$4 = 3;
        } else {
          p$1 = p$6._0;
          size$1 = match$4._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$4 === 3) {
        output_acc(ppf, p$6);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_delay */ 6 :
      output_acc(ppf, acc._0);
      return Curry._1(acc._1, ppf);
    case /* Acc_flush */ 7 :
      output_acc(ppf, acc._0);
      return pp_print_flush(ppf, undefined);
    case /* Acc_invalid_arg */ 8 :
      output_acc(ppf, acc._0);
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: acc._1
          });
  }
  switch (exit) {
    case 1 :
      output_acc(ppf, p);
      return pp_print_as_size(ppf, size, s);
    case 2 :
      output_acc(ppf, p$1);
      return pp_print_as_size(ppf, size$1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
  }
}

function strput_acc(ppf, acc) {
  let exit = 0;
  let p;
  let size;
  let s;
  let p$1;
  let size$1;
  let c;
  if (/* tag */ typeof acc === "number" || typeof acc === "string") {
    return;
  }
  switch (acc.TAG) {
    case /* Acc_formatting_lit */ 0 :
      strput_acc(ppf, acc._0);
      return output_formatting_lit(ppf, acc._1);
    case /* Acc_formatting_gen */ 1 :
      const acc$p = acc._1;
      const p$2 = acc._0;
      if (acc$p.TAG === /* Acc_open_tag */ 0) {
        strput_acc(ppf, p$2);
        return pp_open_stag(ppf, {
          MEL_EXN_ID: String_tag,
          _1: compute_tag(strput_acc, acc$p._0)
        });
      }
      strput_acc(ppf, p$2);
      const match = CamlinternalFormat.open_box_of_string(compute_tag(strput_acc, acc$p._0));
      return pp_open_box_gen(ppf, match[0], match[1]);
    case /* Acc_string_literal */ 2 :
      const p$3 = acc._0;
      let exit$1 = 0;
      if (/* tag */ typeof p$3 === "number" || typeof p$3 === "string" || p$3.TAG !== /* Acc_formatting_lit */ 0) {
        exit$1 = 3;
      } else {
        const match$1 = p$3._1;
        if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string" || match$1.TAG !== /* Magic_size */ 1) {
          exit$1 = 3;
        } else {
          p = p$3._0;
          size = match$1._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$1 === 3) {
        strput_acc(ppf, p$3);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_char_literal */ 3 :
      const p$4 = acc._0;
      let exit$2 = 0;
      if (/* tag */ typeof p$4 === "number" || typeof p$4 === "string" || p$4.TAG !== /* Acc_formatting_lit */ 0) {
        exit$2 = 3;
      } else {
        const match$2 = p$4._1;
        if (/* tag */ typeof match$2 === "number" || typeof match$2 === "string" || match$2.TAG !== /* Magic_size */ 1) {
          exit$2 = 3;
        } else {
          p$1 = p$4._0;
          size$1 = match$2._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$2 === 3) {
        strput_acc(ppf, p$4);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_data_string */ 4 :
      const p$5 = acc._0;
      let exit$3 = 0;
      if (/* tag */ typeof p$5 === "number" || typeof p$5 === "string" || p$5.TAG !== /* Acc_formatting_lit */ 0) {
        exit$3 = 3;
      } else {
        const match$3 = p$5._1;
        if (/* tag */ typeof match$3 === "number" || typeof match$3 === "string" || match$3.TAG !== /* Magic_size */ 1) {
          exit$3 = 3;
        } else {
          p = p$5._0;
          size = match$3._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$3 === 3) {
        strput_acc(ppf, p$5);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_data_char */ 5 :
      const p$6 = acc._0;
      let exit$4 = 0;
      if (/* tag */ typeof p$6 === "number" || typeof p$6 === "string" || p$6.TAG !== /* Acc_formatting_lit */ 0) {
        exit$4 = 3;
      } else {
        const match$4 = p$6._1;
        if (/* tag */ typeof match$4 === "number" || typeof match$4 === "string" || match$4.TAG !== /* Magic_size */ 1) {
          exit$4 = 3;
        } else {
          p$1 = p$6._0;
          size$1 = match$4._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$4 === 3) {
        strput_acc(ppf, p$6);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_delay */ 6 :
      const p$7 = acc._0;
      let exit$5 = 0;
      if (/* tag */ typeof p$7 === "number" || typeof p$7 === "string" || p$7.TAG !== /* Acc_formatting_lit */ 0) {
        exit$5 = 3;
      } else {
        const match$5 = p$7._1;
        if (/* tag */ typeof match$5 === "number" || typeof match$5 === "string") {
          exit$5 = 3;
        } else {
          if (match$5.TAG === /* Magic_size */ 1) {
            strput_acc(ppf, p$7._0);
            return pp_print_as_size(ppf, match$5._1, Curry._1(acc._1, undefined));
          }
          exit$5 = 3;
        }
      }
      if (exit$5 === 3) {
        strput_acc(ppf, p$7);
        return pp_print_string(ppf, Curry._1(acc._1, undefined));
      }
      break;
    case /* Acc_flush */ 7 :
      strput_acc(ppf, acc._0);
      return pp_print_flush(ppf, undefined);
    case /* Acc_invalid_arg */ 8 :
      strput_acc(ppf, acc._0);
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: acc._1
          });
  }
  switch (exit) {
    case 1 :
      strput_acc(ppf, p);
      return pp_print_as_size(ppf, size, s);
    case 2 :
      strput_acc(ppf, p$1);
      return pp_print_as_size(ppf, size$1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
  }
}

function kfprintf(k, ppf, param) {
  return CamlinternalFormat.make_printf((function (acc) {
    output_acc(ppf, acc);
    return Curry._1(k, ppf);
  }), /* End_of_acc */ 0, param._0);
}

function ikfprintf(k, ppf, param) {
  return CamlinternalFormat.make_iprintf(k, ppf, param._0);
}

function ifprintf(_ppf, param) {
  return CamlinternalFormat.make_iprintf((function (prim) {
    
  }), undefined, param._0);
}

function fprintf(ppf) {
  return function (param) {
    return kfprintf((function (prim) {
      
    }), ppf, param);
  };
}

function printf(param) {
  return CamlinternalFormat.make_printf((function (acc) {
    output_acc(Stdlib__Domain.DLS.get(std_formatter_key), acc);
  }), /* End_of_acc */ 0, param._0);
}

function eprintf(param) {
  return CamlinternalFormat.make_printf((function (acc) {
    output_acc(Stdlib__Domain.DLS.get(err_formatter_key), acc);
  }), /* End_of_acc */ 0, param._0);
}

function kdprintf(k, param) {
  return CamlinternalFormat.make_printf((function (acc) {
    return Curry._1(k, (function (ppf) {
      output_acc(ppf, acc);
    }));
  }), /* End_of_acc */ 0, param._0);
}

function dprintf(fmt) {
  return kdprintf((function (i) {
    return i;
  }), fmt);
}

function ksprintf(k, param) {
  const b = Stdlib__Buffer.create(512);
  const ppf = formatter_of_buffer(b);
  const k$1 = function (acc) {
    strput_acc(ppf, acc);
    return Curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return CamlinternalFormat.make_printf(k$1, /* End_of_acc */ 0, param._0);
}

function sprintf(fmt) {
  return ksprintf(id, fmt);
}

function kasprintf(k, param) {
  const b = Stdlib__Buffer.create(512);
  const ppf = formatter_of_buffer(b);
  const k$1 = function (acc) {
    output_acc(ppf, acc);
    return Curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return CamlinternalFormat.make_printf(k$1, /* End_of_acc */ 0, param._0);
}

function asprintf(fmt) {
  return kasprintf(id, fmt);
}

function flush_standard_formatters(param) {
  pp_print_flush(Stdlib__Domain.DLS.get(std_formatter_key), undefined);
  pp_print_flush(Stdlib__Domain.DLS.get(err_formatter_key), undefined);
}

Stdlib.at_exit(flush_standard_formatters);

Stdlib__Domain.before_first_spawn(function (param) {
  flush_standard_formatters(undefined);
  const fs = pp_get_formatter_out_functions(std_formatter, undefined);
  pp_set_formatter_out_functions(std_formatter, {
    out_string: (function (param, param$1, param$2) {
      return buffered_out_string(std_buf_key, param, param$1, param$2);
    }),
    out_flush: (function (param) {
      return buffered_out_flush(Stdlib.stdout, std_buf_key, param);
    }),
    out_newline: fs.out_newline,
    out_spaces: fs.out_spaces,
    out_indent: fs.out_indent
  });
  const fs$1 = pp_get_formatter_out_functions(err_formatter, undefined);
  pp_set_formatter_out_functions(err_formatter, {
    out_string: (function (param, param$1, param$2) {
      return buffered_out_string(err_buf_key, param, param$1, param$2);
    }),
    out_flush: (function (param) {
      return buffered_out_flush(Stdlib.stderr, err_buf_key, param);
    }),
    out_newline: fs$1.out_newline,
    out_spaces: fs$1.out_spaces,
    out_indent: fs$1.out_indent
  });
});

const pp_infinity = 1000000010;

export {
  pp_open_box,
  open_box,
  pp_close_box,
  close_box,
  pp_open_hbox,
  open_hbox,
  pp_open_vbox,
  open_vbox,
  pp_open_hvbox,
  open_hvbox,
  pp_open_hovbox,
  open_hovbox,
  pp_print_string,
  print_string,
  pp_print_substring,
  print_substring,
  pp_print_bytes,
  print_bytes,
  pp_print_as,
  print_as,
  pp_print_substring_as,
  print_substring_as,
  pp_print_int,
  print_int,
  pp_print_float,
  print_float,
  pp_print_char,
  print_char,
  pp_print_bool,
  print_bool,
  pp_print_nothing,
  pp_print_space,
  print_space,
  pp_print_cut,
  print_cut,
  pp_print_break,
  print_break,
  pp_print_custom_break,
  pp_force_newline,
  force_newline,
  pp_print_if_newline,
  print_if_newline,
  pp_print_flush,
  print_flush,
  pp_print_newline,
  print_newline,
  pp_infinity,
  pp_set_margin,
  set_margin,
  pp_get_margin,
  get_margin,
  pp_set_max_indent,
  set_max_indent,
  pp_get_max_indent,
  get_max_indent,
  check_geometry,
  pp_set_geometry,
  set_geometry,
  pp_safe_set_geometry,
  safe_set_geometry,
  pp_update_geometry,
  update_geometry,
  pp_get_geometry,
  get_geometry,
  pp_set_max_boxes,
  set_max_boxes,
  pp_get_max_boxes,
  get_max_boxes,
  pp_over_max_boxes,
  over_max_boxes,
  pp_open_tbox,
  open_tbox,
  pp_close_tbox,
  close_tbox,
  pp_set_tab,
  set_tab,
  pp_print_tab,
  print_tab,
  pp_print_tbreak,
  print_tbreak,
  pp_set_ellipsis_text,
  set_ellipsis_text,
  pp_get_ellipsis_text,
  get_ellipsis_text,
  String_tag,
  pp_open_stag,
  open_stag,
  pp_close_stag,
  close_stag,
  pp_set_tags,
  set_tags,
  pp_set_print_tags,
  set_print_tags,
  pp_set_mark_tags,
  set_mark_tags,
  pp_get_print_tags,
  get_print_tags,
  pp_get_mark_tags,
  get_mark_tags,
  pp_set_formatter_out_channel,
  set_formatter_out_channel,
  pp_set_formatter_output_functions,
  set_formatter_output_functions,
  pp_get_formatter_output_functions,
  get_formatter_output_functions,
  pp_set_formatter_out_functions,
  set_formatter_out_functions,
  pp_get_formatter_out_functions,
  get_formatter_out_functions,
  pp_set_formatter_stag_functions,
  set_formatter_stag_functions,
  pp_get_formatter_stag_functions,
  get_formatter_stag_functions,
  formatter_of_out_channel,
  synchronized_formatter_of_out_channel,
  std_formatter,
  get_std_formatter,
  err_formatter,
  get_err_formatter,
  formatter_of_buffer,
  stdbuf,
  get_stdbuf,
  str_formatter,
  get_str_formatter,
  flush_str_formatter,
  make_formatter,
  make_synchronized_formatter,
  formatter_of_out_functions,
  make_symbolic_output_buffer,
  clear_symbolic_output_buffer,
  get_symbolic_output_buffer,
  flush_symbolic_output_buffer,
  add_symbolic_output_item,
  formatter_of_symbolic_output_buffer,
  pp_print_iter,
  pp_print_list,
  pp_print_array,
  pp_print_seq,
  pp_print_text,
  pp_print_option,
  pp_print_result,
  pp_print_either,
  fprintf,
  printf,
  eprintf,
  sprintf,
  asprintf,
  dprintf,
  ifprintf,
  kfprintf,
  kdprintf,
  ikfprintf,
  ksprintf,
  kasprintf,
}
/* blank_line Not a pure module */
`,Mf=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Printexc from "./printexc.js";

function $$const(c, param) {
  return c;
}

function compose(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function flip(f, x, y) {
  return Curry._2(f, y, x);
}

function negate(p, v) {
  return !Curry._1(p, v);
}

const Finally_raised = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Fun.Finally_raised");

Stdlib__Printexc.register_printer(function (exn) {
  if (exn.MEL_EXN_ID === Finally_raised) {
    return "Fun.Finally_raised: " + Stdlib__Printexc.to_string(exn._1);
  }
  
});

function protect($$finally, work) {
  const finally_no_exn = function (param) {
    try {
      return Curry._1($$finally, undefined);
    }
    catch (raw_e){
      const e = Caml_js_exceptions.internalToOCamlException(raw_e);
      let bt;
      const exn = {
        MEL_EXN_ID: Finally_raised,
        _1: e
      };
      Caml_external_polyfill.resolve("caml_restore_raw_backtrace")(exn, bt);
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  let result;
  try {
    result = Curry._1(work, undefined);
  }
  catch (raw_work_exn){
    const work_exn = Caml_js_exceptions.internalToOCamlException(raw_work_exn);
    let work_bt;
    finally_no_exn(undefined);
    Caml_external_polyfill.resolve("caml_restore_raw_backtrace")(work_exn, work_bt);
    throw new Caml_js_exceptions.MelangeError(work_exn.MEL_EXN_ID, work_exn);
  }
  finally_no_exn(undefined);
  return result;
}

export {
  $$const,
  compose,
  flip,
  negate,
  protect,
  Finally_raised,
}
/*  Not a pure module */
`,Lf=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Atomic from "./atomic.js";
import * as Stdlib__Domain from "./domain.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__Sys from "./sys.js";

function eventlog_pause(param) {
  
}

function eventlog_resume(param) {
  
}

function print_stat(c) {
  const st = Caml_external_polyfill.resolve("caml_gc_stat")(undefined);
  Curry._1(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "minor_collections:      ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "minor_collections:      %d\\n"
  }), st.minor_collections);
  Curry._1(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "major_collections:      ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "major_collections:      %d\\n"
  }), st.major_collections);
  Curry._1(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "compactions:            ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "compactions:            %d\\n"
  }), st.compactions);
  Curry._1(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "forced_major_collections: ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "forced_major_collections: %d\\n"
  }), st.forced_major_collections);
  Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* Char_literal */ 12,
      _0: /* '\\n' */10,
      _1: /* End_of_format */ 0
    },
    _1: "\\n"
  });
  const l1 = Curry._1(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* Float */ 8,
      _0: [
        /* Float_flag_ */ 0,
        /* Float_f */ 0
      ],
      _1: /* No_padding */ 0,
      _2: {
        TAG: /* Lit_precision */ 0,
        _0: 0
      },
      _3: /* End_of_format */ 0
    },
    _1: "%.0f"
  }), st.minor_words).length;
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "minor_words:    ",
      _1: {
        TAG: /* Float */ 8,
        _0: [
          /* Float_flag_ */ 0,
          /* Float_f */ 0
        ],
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: {
          TAG: /* Lit_precision */ 0,
          _0: 0
        },
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "minor_words:    %*.0f\\n"
  }), l1, st.minor_words);
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "promoted_words: ",
      _1: {
        TAG: /* Float */ 8,
        _0: [
          /* Float_flag_ */ 0,
          /* Float_f */ 0
        ],
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: {
          TAG: /* Lit_precision */ 0,
          _0: 0
        },
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "promoted_words: %*.0f\\n"
  }), l1, st.promoted_words);
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "major_words:    ",
      _1: {
        TAG: /* Float */ 8,
        _0: [
          /* Float_flag_ */ 0,
          /* Float_f */ 0
        ],
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: {
          TAG: /* Lit_precision */ 0,
          _0: 0
        },
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "major_words:    %*.0f\\n"
  }), l1, st.major_words);
  Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* Char_literal */ 12,
      _0: /* '\\n' */10,
      _1: /* End_of_format */ 0
    },
    _1: "\\n"
  });
  const l2 = Curry._1(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* Int */ 4,
      _0: /* Int_d */ 0,
      _1: /* No_padding */ 0,
      _2: /* No_precision */ 0,
      _3: /* End_of_format */ 0
    },
    _1: "%d"
  }), st.top_heap_words).length;
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "top_heap_words: ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "top_heap_words: %*d\\n"
  }), l2, st.top_heap_words);
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "heap_words:     ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "heap_words:     %*d\\n"
  }), l2, st.heap_words);
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "live_words:     ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "live_words:     %*d\\n"
  }), l2, st.live_words);
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "free_words:     ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "free_words:     %*d\\n"
  }), l2, st.free_words);
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "largest_free:   ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "largest_free:   %*d\\n"
  }), l2, st.largest_free);
  Curry._2(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "fragments:      ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: {
          TAG: /* Arg_padding */ 1,
          _0: /* Right */ 1
        },
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "fragments:      %*d\\n"
  }), l2, st.fragments);
  Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* Char_literal */ 12,
      _0: /* '\\n' */10,
      _1: /* End_of_format */ 0
    },
    _1: "\\n"
  });
  Curry._1(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "live_blocks: ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "live_blocks: %d\\n"
  }), st.live_blocks);
  Curry._1(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "free_blocks: ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "free_blocks: %d\\n"
  }), st.free_blocks);
  Curry._1(Stdlib__Printf.fprintf(c, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "heap_chunks: ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "heap_chunks: %d\\n"
  }), st.heap_chunks);
}

function allocated_bytes(param) {
  const match = Caml_external_polyfill.resolve("caml_gc_counters")(undefined);
  return (match[0] + match[2] - match[1]) * (Stdlib__Sys.word_size / 8 | 0);
}

function call_alarm(arec) {
  if (!Stdlib__Atomic.get(arec.active)) {
    return;
  }
  const $$finally = function (param) {
    Caml_external_polyfill.resolve("caml_final_register")(call_alarm, arec);
  };
  Stdlib__Fun.protect($$finally, arec.f);
}

function delete_alarm(a) {
  Stdlib__Atomic.set(a, false);
}

function create_alarm(f) {
  const alarm = Stdlib__Atomic.make(true);
  Stdlib__Domain.at_exit(function (param) {
    Stdlib__Atomic.set(alarm, false);
  });
  const arec = {
    active: alarm,
    f: f
  };
  Caml_external_polyfill.resolve("caml_final_register")(call_alarm, arec);
  return alarm;
}

function null_tracker_alloc_minor(param) {
  
}

function null_tracker_alloc_major(param) {
  
}

function null_tracker_promote(param) {
  
}

function null_tracker_dealloc_minor(param) {
  
}

function null_tracker_dealloc_major(param) {
  
}

const null_tracker = {
  alloc_minor: null_tracker_alloc_minor,
  alloc_major: null_tracker_alloc_major,
  promote: null_tracker_promote,
  dealloc_minor: null_tracker_dealloc_minor,
  dealloc_major: null_tracker_dealloc_major
};

function start(sampling_rate, callstack_sizeOpt, tracker) {
  const callstack_size = callstack_sizeOpt !== undefined ? callstack_sizeOpt : Stdlib.max_int;
  return Caml_external_polyfill.resolve("caml_memprof_start")(sampling_rate, callstack_size, tracker);
}

function finalise(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_final_register")(prim0, prim1);
}

function finalise_last(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_final_register_called_without_value")(prim0, prim1);
}

function finalise_release(prim) {
  return Caml_external_polyfill.resolve("caml_final_release")(prim);
}

function Memprof_stop(prim) {
  return Caml_external_polyfill.resolve("caml_memprof_stop")(prim);
}

function Memprof_discard(prim) {
  return Caml_external_polyfill.resolve("caml_memprof_discard")(prim);
}

const Memprof = {
  null_tracker: null_tracker,
  start: start,
  stop: Memprof_stop,
  discard: Memprof_discard
};

export {
  print_stat,
  allocated_bytes,
  finalise,
  finalise_last,
  finalise_release,
  create_alarm,
  delete_alarm,
  eventlog_pause,
  eventlog_resume,
  Memprof,
}
/* Stdlib__Domain Not a pure module */
`,Tf=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Atomic from "./atomic.js";
import * as Stdlib__Domain from "./domain.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Random from "./random.js";
import * as Stdlib__Seq from "./seq.js";

function flip_ongoing_traversal(h) {
  h.initial_size = -h.initial_size | 0;
}

const randomized = Stdlib__Atomic.make(false);

function randomize(param) {
  Stdlib__Atomic.set(randomized, true);
}

function is_randomized(param) {
  return Stdlib__Atomic.get(randomized);
}

const prng_key = Stdlib__Domain.DLS.new_key(undefined, Stdlib__Random.State.make_self_init);

function power_2_above(_x, n) {
  while (true) {
    const x = _x;
    if (x >= n) {
      return x;
    }
    if ((x << 1) < x) {
      return x;
    }
    _x = (x << 1);
    continue;
  };
}

function create(randomOpt, initial_size) {
  const random = randomOpt !== undefined ? randomOpt : Stdlib__Atomic.get(randomized);
  const s = power_2_above(16, initial_size);
  const seed = random ? Stdlib__Random.State.bits(Stdlib__Domain.DLS.get(prng_key)) : 0;
  return {
    size: 0,
    data: Caml_array.make(s, /* Empty */ 0),
    seed: seed,
    initial_size: s
  };
}

function clear(h) {
  if (h.size > 0) {
    h.size = 0;
    return Stdlib__Array.fill(h.data, 0, h.data.length, /* Empty */ 0);
  }
  
}

function reset(h) {
  const len = h.data.length;
  if (len === Stdlib.abs(h.initial_size)) {
    return clear(h);
  } else {
    h.size = 0;
    h.data = Caml_array.make(Stdlib.abs(h.initial_size), /* Empty */ 0);
    return;
  }
}

function copy_bucketlist(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return /* Empty */ 0;
  }
  const key = param.key;
  const data = param.data;
  const next = param.next;
  const loop = function (_prec, _param) {
    while (true) {
      const param = _param;
      const prec = _prec;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const key = param.key;
      const data = param.data;
      const next = param.next;
      const r = {
        TAG: /* Cons */ 0,
        key: key,
        data: data,
        next: next
      };
      if (/* tag */ typeof prec === "number" || typeof prec === "string") {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "hashtbl.cppo.ml",
                110,
                23
              ]
            });
      }
      prec.next = r;
      _param = next;
      _prec = r;
      continue;
    };
  };
  const r = {
    TAG: /* Cons */ 0,
    key: key,
    data: data,
    next: next
  };
  loop(r, next);
  return r;
}

function copy(h) {
  return {
    size: h.size,
    data: Stdlib__Array.map(copy_bucketlist, h.data),
    seed: h.seed,
    initial_size: h.initial_size
  };
}

function length(h) {
  return h.size;
}

function insert_all_buckets(indexfun, inplace, odata, ndata) {
  const nsize = ndata.length;
  const ndata_tail = Caml_array.make(nsize, /* Empty */ 0);
  const insert_bucket = function (_cell) {
    while (true) {
      const cell = _cell;
      if (/* tag */ typeof cell === "number" || typeof cell === "string") {
        return;
      }
      const key = cell.key;
      const data = cell.data;
      const next = cell.next;
      const cell$1 = inplace ? cell : ({
          TAG: /* Cons */ 0,
          key: key,
          data: data,
          next: /* Empty */ 0
        });
      const nidx = Curry._1(indexfun, key);
      const tail = Caml_array.get(ndata_tail, nidx);
      if (/* tag */ typeof tail === "number" || typeof tail === "string") {
        Caml_array.set(ndata, nidx, cell$1);
      } else {
        tail.next = cell$1;
      }
      Caml_array.set(ndata_tail, nidx, cell$1);
      _cell = next;
      continue;
    };
  };
  for (let i = 0, i_finish = odata.length; i < i_finish; ++i) {
    insert_bucket(Caml_array.get(odata, i));
  }
  if (!inplace) {
    return;
  }
  for (let i$1 = 0; i$1 < nsize; ++i$1) {
    const tail = Caml_array.get(ndata_tail, i$1);
    if (!/* tag */ (typeof tail === "number" || typeof tail === "string")) {
      tail.next = /* Empty */ 0;
    }
    
  }
}

function resize(indexfun, h) {
  const odata = h.data;
  const osize = odata.length;
  const nsize = (osize << 1);
  if (nsize < osize) {
    return;
  }
  const ndata = Caml_array.make(nsize, /* Empty */ 0);
  const inplace = h.initial_size >= 0;
  h.data = ndata;
  insert_all_buckets(Curry._1(indexfun, h), inplace, odata, ndata);
}

function iter(f, h) {
  const do_bucket = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const key = param.key;
      const data = param.data;
      const next = param.next;
      Curry._2(f, key, data);
      _param = next;
      continue;
    };
  };
  const old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      do_bucket(Caml_array.get(d, i));
    }
    if (!old_trav) {
      return flip_ongoing_traversal(h);
    } else {
      return;
    }
  }
  catch (exn){
    if (old_trav) {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    flip_ongoing_traversal(h);
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function filter_map_inplace_bucket(f, h, i, _prec, _slot) {
  while (true) {
    const slot = _slot;
    const prec = _prec;
    if (/* tag */ typeof slot === "number" || typeof slot === "string") {
      if (/* tag */ typeof prec === "number" || typeof prec === "string") {
        return Caml_array.set(h.data, i, /* Empty */ 0);
      } else {
        prec.next = /* Empty */ 0;
        return;
      }
    }
    const key = slot.key;
    const data = slot.data;
    const next = slot.next;
    const data$1 = Curry._2(f, key, data);
    if (data$1 !== undefined) {
      if (/* tag */ typeof prec === "number" || typeof prec === "string") {
        Caml_array.set(h.data, i, slot);
      } else {
        prec.next = slot;
      }
      slot.data = Caml_option.valFromOption(data$1);
      _slot = next;
      _prec = slot;
      continue;
    }
    h.size = h.size - 1 | 0;
    _slot = next;
    continue;
  };
}

function filter_map_inplace(f, h) {
  const d = h.data;
  const old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      filter_map_inplace_bucket(f, h, i, /* Empty */ 0, Caml_array.get(h.data, i));
    }
    if (!old_trav) {
      return flip_ongoing_traversal(h);
    } else {
      return;
    }
  }
  catch (exn){
    if (old_trav) {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    flip_ongoing_traversal(h);
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function fold(f, h, init) {
  const do_bucket = function (_b, _accu) {
    while (true) {
      const accu = _accu;
      const b = _b;
      if (/* tag */ typeof b === "number" || typeof b === "string") {
        return accu;
      }
      const key = b.key;
      const data = b.data;
      const next = b.next;
      _accu = Curry._3(f, key, data, accu);
      _b = next;
      continue;
    };
  };
  const old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    const d = h.data;
    let accu = init;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    if (!old_trav) {
      flip_ongoing_traversal(h);
    }
    return accu;
  }
  catch (exn){
    if (old_trav) {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    flip_ongoing_traversal(h);
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function bucket_length(_accu, _param) {
  while (true) {
    const param = _param;
    const accu = _accu;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return accu;
    }
    const next = param.next;
    _param = next;
    _accu = accu + 1 | 0;
    continue;
  };
}

function stats(h) {
  const mbl = Stdlib__Array.fold_left((function (m, b) {
    return Stdlib__Int.max(m, bucket_length(0, b));
  }), 0, h.data);
  const histo = Caml_array.make(mbl + 1 | 0, 0);
  Stdlib__Array.iter((function (b) {
    const l = bucket_length(0, b);
    Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
  }), h.data);
  return {
    num_bindings: h.size,
    num_buckets: h.data.length,
    max_bucket_length: mbl,
    bucket_histogram: histo
  };
}

function to_seq(tbl) {
  const tbl_data = tbl.data;
  const aux = function (_i, _buck, _param) {
    while (true) {
      const buck = _buck;
      const i = _i;
      if (/* tag */ typeof buck === "number" || typeof buck === "string") {
        if (i === tbl_data.length) {
          return /* Nil */ 0;
        }
        _param = undefined;
        _buck = Caml_array.get(tbl_data, i);
        _i = i + 1 | 0;
        continue;
      }
      const key = buck.key;
      const data = buck.data;
      const next = buck.next;
      return {
        TAG: /* Cons */ 0,
        _0: [
          key,
          data
        ],
        _1: (function (param) {
          return aux(i, next, param);
        })
      };
    };
  };
  return function (param) {
    return aux(0, /* Empty */ 0, param);
  };
}

function to_seq_keys(m) {
  const partial_arg = to_seq(m);
  return function (param) {
    return Stdlib__Seq.map((function (prim) {
      return prim[0];
    }), partial_arg, param);
  };
}

function to_seq_values(m) {
  const partial_arg = to_seq(m);
  return function (param) {
    return Stdlib__Seq.map((function (prim) {
      return prim[1];
    }), partial_arg, param);
  };
}

function MakeSeeded(H) {
  const key_index = function (h, key) {
    return Curry._2(H.seeded_hash, h.seed, key) & (h.data.length - 1 | 0);
  };
  const add = function (h, key, data) {
    const i = key_index(h, key);
    const bucket = {
      TAG: /* Cons */ 0,
      key: key,
      data: data,
      next: Caml_array.get(h.data, i)
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(key_index, h);
    }
    
  };
  const remove = function (h, key) {
    const i = key_index(h, key);
    let _prec = /* Empty */ 0;
    let _c = Caml_array.get(h.data, i);
    while (true) {
      const c = _c;
      const prec = _prec;
      if (/* tag */ typeof c === "number" || typeof c === "string") {
        return;
      }
      const k = c.key;
      const next = c.next;
      if (Curry._2(H.equal, k, key)) {
        h.size = h.size - 1 | 0;
        if (/* tag */ typeof prec === "number" || typeof prec === "string") {
          return Caml_array.set(h.data, i, next);
        } else {
          prec.next = next;
          return;
        }
      }
      _c = next;
      _prec = c;
      continue;
    };
  };
  const find = function (h, key) {
    const match = Caml_array.get(h.data, key_index(h, key));
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const k1 = match.key;
    const d1 = match.data;
    const next1 = match.next;
    if (Curry._2(H.equal, key, k1)) {
      return d1;
    }
    if (/* tag */ typeof next1 === "number" || typeof next1 === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const k2 = next1.key;
    const d2 = next1.data;
    const next2 = next1.next;
    if (Curry._2(H.equal, key, k2)) {
      return d2;
    }
    if (/* tag */ typeof next2 === "number" || typeof next2 === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const k3 = next2.key;
    const d3 = next2.data;
    const next3 = next2.next;
    if (Curry._2(H.equal, key, k3)) {
      return d3;
    } else {
      let _param = next3;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        const k = param.key;
        const data = param.data;
        const next = param.next;
        if (Curry._2(H.equal, key, k)) {
          return data;
        }
        _param = next;
        continue;
      };
    }
  };
  const find_opt = function (h, key) {
    const match = Caml_array.get(h.data, key_index(h, key));
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    const k1 = match.key;
    const d1 = match.data;
    const next1 = match.next;
    if (Curry._2(H.equal, key, k1)) {
      return Caml_option.some(d1);
    }
    if (/* tag */ typeof next1 === "number" || typeof next1 === "string") {
      return;
    }
    const k2 = next1.key;
    const d2 = next1.data;
    const next2 = next1.next;
    if (Curry._2(H.equal, key, k2)) {
      return Caml_option.some(d2);
    }
    if (/* tag */ typeof next2 === "number" || typeof next2 === "string") {
      return;
    }
    const k3 = next2.key;
    const d3 = next2.data;
    const next3 = next2.next;
    if (Curry._2(H.equal, key, k3)) {
      return Caml_option.some(d3);
    } else {
      let _param = next3;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return;
        }
        const k = param.key;
        const data = param.data;
        const next = param.next;
        if (Curry._2(H.equal, key, k)) {
          return Caml_option.some(data);
        }
        _param = next;
        continue;
      };
    }
  };
  const find_all = function (h, key) {
    const find_in_bucket_dps = function (_dst, _offset, _param) {
      while (true) {
        const dst = _dst;
        const offset = _offset;
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          dst[offset] = /* [] */ 0;
          return;
        }
        const k = param.key;
        const d = param.data;
        const next = param.next;
        if (Curry._2(H.equal, k, key)) {
          const block = {
            hd: d,
            tl: 24029
          };
          dst[offset] = block;
          _param = next;
          _offset = "tl";
          _dst = block;
          continue;
        }
        _param = next;
        continue;
      };
    };
    let _param = Caml_array.get(h.data, key_index(h, key));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return /* [] */ 0;
      }
      const k = param.key;
      const d = param.data;
      const next = param.next;
      if (Curry._2(H.equal, k, key)) {
        const block = {
          hd: d,
          tl: 24029
        };
        find_in_bucket_dps(block, "tl", next);
        return block;
      }
      _param = next;
      continue;
    };
  };
  const replace_bucket = function (key, data, _slot) {
    while (true) {
      const slot = _slot;
      if (/* tag */ typeof slot === "number" || typeof slot === "string") {
        return true;
      }
      const k = slot.key;
      const next = slot.next;
      if (Curry._2(H.equal, k, key)) {
        slot.key = key;
        slot.data = data;
        return false;
      }
      _slot = next;
      continue;
    };
  };
  const replace = function (h, key, data) {
    const i = key_index(h, key);
    const l = Caml_array.get(h.data, i);
    if (replace_bucket(key, data, l)) {
      Caml_array.set(h.data, i, {
        TAG: /* Cons */ 0,
        key: key,
        data: data,
        next: l
      });
      h.size = h.size + 1 | 0;
      if (h.size > (h.data.length << 1)) {
        return resize(key_index, h);
      } else {
        return;
      }
    }
    
  };
  const mem = function (h, key) {
    let _param = Caml_array.get(h.data, key_index(h, key));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      const k = param.key;
      const next = param.next;
      if (Curry._2(H.equal, k, key)) {
        return true;
      }
      _param = next;
      continue;
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const of_seq = function (i) {
    const tbl = create(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    iter: iter,
    filter_map_inplace: filter_map_inplace,
    fold: fold,
    length: length,
    stats: stats,
    to_seq: to_seq,
    to_seq_keys: to_seq_keys,
    to_seq_values: to_seq_values,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq
  };
}

function Make(H) {
  const equal = H.equal;
  const key_index = function (h, key) {
    return Curry._1(H.hash, key) & (h.data.length - 1 | 0);
  };
  const add = function (h, key, data) {
    const i = key_index(h, key);
    const bucket = {
      TAG: /* Cons */ 0,
      key: key,
      data: data,
      next: Caml_array.get(h.data, i)
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(key_index, h);
    }
    
  };
  const remove = function (h, key) {
    const i = key_index(h, key);
    let _prec = /* Empty */ 0;
    let _c = Caml_array.get(h.data, i);
    while (true) {
      const c = _c;
      const prec = _prec;
      if (/* tag */ typeof c === "number" || typeof c === "string") {
        return;
      }
      const k = c.key;
      const next = c.next;
      if (Curry._2(equal, k, key)) {
        h.size = h.size - 1 | 0;
        if (/* tag */ typeof prec === "number" || typeof prec === "string") {
          return Caml_array.set(h.data, i, next);
        } else {
          prec.next = next;
          return;
        }
      }
      _c = next;
      _prec = c;
      continue;
    };
  };
  const find = function (h, key) {
    const match = Caml_array.get(h.data, key_index(h, key));
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const k1 = match.key;
    const d1 = match.data;
    const next1 = match.next;
    if (Curry._2(equal, key, k1)) {
      return d1;
    }
    if (/* tag */ typeof next1 === "number" || typeof next1 === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const k2 = next1.key;
    const d2 = next1.data;
    const next2 = next1.next;
    if (Curry._2(equal, key, k2)) {
      return d2;
    }
    if (/* tag */ typeof next2 === "number" || typeof next2 === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const k3 = next2.key;
    const d3 = next2.data;
    const next3 = next2.next;
    if (Curry._2(equal, key, k3)) {
      return d3;
    } else {
      let _param = next3;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
        }
        const k = param.key;
        const data = param.data;
        const next = param.next;
        if (Curry._2(equal, key, k)) {
          return data;
        }
        _param = next;
        continue;
      };
    }
  };
  const find_opt = function (h, key) {
    const match = Caml_array.get(h.data, key_index(h, key));
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    const k1 = match.key;
    const d1 = match.data;
    const next1 = match.next;
    if (Curry._2(equal, key, k1)) {
      return Caml_option.some(d1);
    }
    if (/* tag */ typeof next1 === "number" || typeof next1 === "string") {
      return;
    }
    const k2 = next1.key;
    const d2 = next1.data;
    const next2 = next1.next;
    if (Curry._2(equal, key, k2)) {
      return Caml_option.some(d2);
    }
    if (/* tag */ typeof next2 === "number" || typeof next2 === "string") {
      return;
    }
    const k3 = next2.key;
    const d3 = next2.data;
    const next3 = next2.next;
    if (Curry._2(equal, key, k3)) {
      return Caml_option.some(d3);
    } else {
      let _param = next3;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          return;
        }
        const k = param.key;
        const data = param.data;
        const next = param.next;
        if (Curry._2(equal, key, k)) {
          return Caml_option.some(data);
        }
        _param = next;
        continue;
      };
    }
  };
  const find_all = function (h, key) {
    const find_in_bucket_dps = function (_dst, _offset, _param) {
      while (true) {
        const param = _param;
        const offset = _offset;
        const dst = _dst;
        if (/* tag */ typeof param === "number" || typeof param === "string") {
          dst[offset] = /* [] */ 0;
          return;
        }
        const k = param.key;
        const d = param.data;
        const next = param.next;
        if (Curry._2(equal, k, key)) {
          const block = {
            hd: d,
            tl: 24029
          };
          dst[offset] = block;
          _param = next;
          _offset = "tl";
          _dst = block;
          continue;
        }
        _param = next;
        continue;
      };
    };
    let _param = Caml_array.get(h.data, key_index(h, key));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return /* [] */ 0;
      }
      const k = param.key;
      const d = param.data;
      const next = param.next;
      if (Curry._2(equal, k, key)) {
        const block = {
          hd: d,
          tl: 24029
        };
        find_in_bucket_dps(block, "tl", next);
        return block;
      }
      _param = next;
      continue;
    };
  };
  const replace_bucket = function (key, data, _slot) {
    while (true) {
      const slot = _slot;
      if (/* tag */ typeof slot === "number" || typeof slot === "string") {
        return true;
      }
      const k = slot.key;
      const next = slot.next;
      if (Curry._2(equal, k, key)) {
        slot.key = key;
        slot.data = data;
        return false;
      }
      _slot = next;
      continue;
    };
  };
  const replace = function (h, key, data) {
    const i = key_index(h, key);
    const l = Caml_array.get(h.data, i);
    if (replace_bucket(key, data, l)) {
      Caml_array.set(h.data, i, {
        TAG: /* Cons */ 0,
        key: key,
        data: data,
        next: l
      });
      h.size = h.size + 1 | 0;
      if (h.size > (h.data.length << 1)) {
        return resize(key_index, h);
      } else {
        return;
      }
    }
    
  };
  const mem = function (h, key) {
    let _param = Caml_array.get(h.data, key_index(h, key));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      const k = param.key;
      const next = param.next;
      if (Curry._2(equal, k, key)) {
        return true;
      }
      _param = next;
      continue;
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const create$1 = function (sz) {
    return create(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$1,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    iter: iter,
    filter_map_inplace: filter_map_inplace,
    fold: fold,
    length: length,
    stats: stats,
    to_seq: to_seq,
    to_seq_keys: to_seq_keys,
    to_seq_values: to_seq_values,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq
  };
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function hash_param(n1, n2, x) {
  return Caml_hash.caml_hash(n1, n2, 0, x);
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function key_index(h, key) {
  return Caml_hash.caml_hash(10, 100, h.seed, key) & (h.data.length - 1 | 0);
}

function add(h, key, data) {
  const i = key_index(h, key);
  const bucket = {
    TAG: /* Cons */ 0,
    key: key,
    data: data,
    next: Caml_array.get(h.data, i)
  };
  Caml_array.set(h.data, i, bucket);
  h.size = h.size + 1 | 0;
  if (h.size > (h.data.length << 1)) {
    return resize(key_index, h);
  }
  
}

function remove(h, key) {
  const i = key_index(h, key);
  let _prec = /* Empty */ 0;
  let _c = Caml_array.get(h.data, i);
  while (true) {
    const c = _c;
    const prec = _prec;
    if (/* tag */ typeof c === "number" || typeof c === "string") {
      return;
    }
    const k = c.key;
    const next = c.next;
    if (Caml_obj.caml_equal(k, key)) {
      h.size = h.size - 1 | 0;
      if (/* tag */ typeof prec === "number" || typeof prec === "string") {
        return Caml_array.set(h.data, i, next);
      } else {
        prec.next = next;
        return;
      }
    }
    _c = next;
    _prec = c;
    continue;
  };
}

function find(h, key) {
  const match = Caml_array.get(h.data, key_index(h, key));
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  const k1 = match.key;
  const d1 = match.data;
  const next1 = match.next;
  if (Caml_obj.caml_equal(key, k1)) {
    return d1;
  }
  if (/* tag */ typeof next1 === "number" || typeof next1 === "string") {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  const k2 = next1.key;
  const d2 = next1.data;
  const next2 = next1.next;
  if (Caml_obj.caml_equal(key, k2)) {
    return d2;
  }
  if (/* tag */ typeof next2 === "number" || typeof next2 === "string") {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  const k3 = next2.key;
  const d3 = next2.data;
  const next3 = next2.next;
  if (Caml_obj.caml_equal(key, k3)) {
    return d3;
  } else {
    let _param = next3;
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const k = param.key;
      const data = param.data;
      const next = param.next;
      if (Caml_obj.caml_equal(key, k)) {
        return data;
      }
      _param = next;
      continue;
    };
  }
}

function find_opt(h, key) {
  const match = Caml_array.get(h.data, key_index(h, key));
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return;
  }
  const k1 = match.key;
  const d1 = match.data;
  const next1 = match.next;
  if (Caml_obj.caml_equal(key, k1)) {
    return Caml_option.some(d1);
  }
  if (/* tag */ typeof next1 === "number" || typeof next1 === "string") {
    return;
  }
  const k2 = next1.key;
  const d2 = next1.data;
  const next2 = next1.next;
  if (Caml_obj.caml_equal(key, k2)) {
    return Caml_option.some(d2);
  }
  if (/* tag */ typeof next2 === "number" || typeof next2 === "string") {
    return;
  }
  const k3 = next2.key;
  const d3 = next2.data;
  const next3 = next2.next;
  if (Caml_obj.caml_equal(key, k3)) {
    return Caml_option.some(d3);
  } else {
    let _param = next3;
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const k = param.key;
      const data = param.data;
      const next = param.next;
      if (Caml_obj.caml_equal(key, k)) {
        return Caml_option.some(data);
      }
      _param = next;
      continue;
    };
  }
}

function find_all(h, key) {
  const find_in_bucket_dps = function (_dst, _offset, _param) {
    while (true) {
      const dst = _dst;
      const offset = _offset;
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        dst[offset] = /* [] */ 0;
        return;
      }
      const k = param.key;
      const data = param.data;
      const next = param.next;
      if (Caml_obj.caml_equal(k, key)) {
        const block = {
          hd: data,
          tl: 24029
        };
        dst[offset] = block;
        _param = next;
        _offset = "tl";
        _dst = block;
        continue;
      }
      _param = next;
      continue;
    };
  };
  let _param = Caml_array.get(h.data, key_index(h, key));
  while (true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return /* [] */ 0;
    }
    const k = param.key;
    const data = param.data;
    const next = param.next;
    if (Caml_obj.caml_equal(k, key)) {
      const block = {
        hd: data,
        tl: 24029
      };
      find_in_bucket_dps(block, "tl", next);
      return block;
    }
    _param = next;
    continue;
  };
}

function replace_bucket(key, data, _slot) {
  while (true) {
    const slot = _slot;
    if (/* tag */ typeof slot === "number" || typeof slot === "string") {
      return true;
    }
    const k = slot.key;
    const next = slot.next;
    if (Caml_obj.caml_equal(k, key)) {
      slot.key = key;
      slot.data = data;
      return false;
    }
    _slot = next;
    continue;
  };
}

function replace(h, key, data) {
  const i = key_index(h, key);
  const l = Caml_array.get(h.data, i);
  if (replace_bucket(key, data, l)) {
    Caml_array.set(h.data, i, {
      TAG: /* Cons */ 0,
      key: key,
      data: data,
      next: l
    });
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(key_index, h);
    } else {
      return;
    }
  }
  
}

function mem(h, key) {
  let _param = Caml_array.get(h.data, key_index(h, key));
  while (true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return false;
    }
    const k = param.key;
    const next = param.next;
    if (Caml_obj.caml_equal(k, key)) {
      return true;
    }
    _param = next;
    continue;
  };
}

function add_seq(tbl, i) {
  Stdlib__Seq.iter((function (param) {
    add(tbl, param[0], param[1]);
  }), i);
}

function replace_seq(tbl, i) {
  Stdlib__Seq.iter((function (param) {
    replace(tbl, param[0], param[1]);
  }), i);
}

function of_seq(i) {
  const tbl = create(undefined, 16);
  replace_seq(tbl, i);
  return tbl;
}

function rebuild(randomOpt, h) {
  const random = randomOpt !== undefined ? randomOpt : Stdlib__Atomic.get(randomized);
  const s = power_2_above(16, h.data.length);
  const seed = random ? Stdlib__Random.State.bits(Stdlib__Domain.DLS.get(prng_key)) : h.seed;
  const h$p = {
    size: h.size,
    data: Caml_array.make(s, /* Empty */ 0),
    seed: seed,
    initial_size: h.initial_size
  };
  insert_all_buckets((function (param) {
    return key_index(h$p, param);
  }), false, h.data, h$p.data);
  return h$p;
}

const seeded_hash_param = Caml_hash.caml_hash;

export {
  create,
  clear,
  reset,
  copy,
  add,
  find,
  find_opt,
  find_all,
  mem,
  remove,
  replace,
  iter,
  filter_map_inplace,
  fold,
  length,
  randomize,
  is_randomized,
  rebuild,
  stats,
  to_seq,
  to_seq_keys,
  to_seq_values,
  add_seq,
  replace_seq,
  of_seq,
  Make,
  MakeSeeded,
  hash,
  seeded_hash,
  hash_param,
  seeded_hash_param,
}
/* randomized Not a pure module */
`,Nf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__Sys from "./sys.js";

function with_open(openfun, s, f) {
  const ic = Curry._1(openfun, s);
  return Stdlib__Fun.protect((function (param) {
    Stdlib.close_in_noerr(ic);
  }), (function (param) {
    return Curry._1(f, ic);
  }));
}

function with_open_bin(s, f) {
  return with_open(Stdlib.open_in_bin, s, f);
}

function with_open_text(s, f) {
  return with_open(Stdlib.open_in, s, f);
}

function with_open_gen(flags, perm, s, f) {
  return with_open((function (param) {
    return Stdlib.open_in_gen(flags, perm, param);
  }), s, f);
}

const seek = Stdlib.LargeFile.seek_in;

const pos = Stdlib.LargeFile.pos_in;

const length = Stdlib.LargeFile.in_channel_length;

function input_char(ic) {
  let c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return c;
}

function input_byte(ic) {
  let n;
  try {
    n = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return n;
}

function input_line(ic) {
  let s;
  try {
    s = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return s;
}

function really_input(ic, buf, pos, len) {
  try {
    Stdlib.really_input(ic, buf, pos, len);
    return Caml_option.some(undefined);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function really_input_string(ic, len) {
  let s;
  try {
    s = Stdlib.really_input_string(ic, len);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return s;
}

function read_upto(ic, buf, ofs, len) {
  const loop = function (_ofs, _len) {
    while (true) {
      const len = _len;
      const ofs = _ofs;
      if (len === 0) {
        return ofs;
      }
      const r = Stdlib.input(ic, buf, ofs, len);
      if (r === 0) {
        return ofs;
      }
      _len = len - r | 0;
      _ofs = ofs + r | 0;
      continue;
    };
  };
  return loop(ofs, len) - ofs | 0;
}

function ensure(buf, ofs, n) {
  const len = buf.length;
  if (len >= (ofs + n | 0)) {
    return buf;
  }
  let new_len = len;
  while (new_len < (ofs + n | 0)) {
    new_len = (new_len << 1) + 1 | 0;
  };
  const new_len$1 = new_len;
  let new_len$2;
  if (new_len$1 <= Stdlib__Sys.max_string_length) {
    new_len$2 = new_len$1;
  } else if (ofs < Stdlib__Sys.max_string_length) {
    new_len$2 = Stdlib__Sys.max_string_length;
  } else {
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "In_channel.input_all: channel content is larger than maximum string length"
        });
  }
  const new_buf = Caml_bytes.caml_create_bytes(new_len$2);
  Stdlib__Bytes.blit(buf, 0, new_buf, 0, ofs);
  return new_buf;
}

function input_all(ic) {
  let initial_size;
  try {
    initial_size = Caml_external_polyfill.resolve("caml_ml_channel_size")(ic) - Caml_external_polyfill.resolve("caml_ml_pos_in")(ic) | 0;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Sys_error) {
      initial_size = -1;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  const initial_size$1 = initial_size < 0 ? 65536 : initial_size;
  const initial_size$2 = initial_size$1 <= Stdlib__Sys.max_string_length ? initial_size$1 : Stdlib__Sys.max_string_length;
  const buf = Caml_bytes.caml_create_bytes(initial_size$2);
  const nread = read_upto(ic, buf, 0, initial_size$2);
  if (nread < initial_size$2) {
    return Stdlib__Bytes.sub_string(buf, 0, nread);
  }
  let c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.End_of_file) {
      return Caml_bytes.bytes_to_string(buf);
    }
    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
  }
  const buf$1 = ensure(buf, nread, 65537);
  Caml_bytes.set(buf$1, nread, c);
  let _buf = buf$1;
  let _ofs = nread + 1 | 0;
  while (true) {
    const ofs = _ofs;
    const buf$2 = _buf;
    const buf$3 = ensure(buf$2, ofs, 65536);
    const rem = buf$3.length - ofs | 0;
    const r = read_upto(ic, buf$3, ofs, rem);
    if (r < rem) {
      return Stdlib__Bytes.sub_string(buf$3, 0, ofs + r | 0);
    }
    _ofs = ofs + rem | 0;
    _buf = buf$3;
    continue;
  };
}

function input_lines_dps(_dst, _offset, ic) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    let line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        dst[offset] = /* [] */ 0;
        return;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      dst[offset] = undefined;
      return;
    }
    const block = {
      hd: line,
      tl: 24029
    };
    dst[offset] = block;
    _offset = "tl";
    _dst = block;
    continue;
  };
}

function input_lines(ic) {
  let line;
  try {
    line = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return /* [] */ 0;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  const block = {
    hd: line,
    tl: 24029
  };
  input_lines_dps(block, "tl", ic);
  return block;
}

function fold_lines(f, _accu, ic) {
  while (true) {
    const accu = _accu;
    let line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        return accu;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    _accu = Curry._2(f, accu, line);
    continue;
  };
}

const stdin = Stdlib.stdin;

const open_bin = Stdlib.open_in_bin;

const open_text = Stdlib.open_in;

const open_gen = Stdlib.open_in_gen;

const close = Stdlib.close_in;

const close_noerr = Stdlib.close_in_noerr;

const input = Stdlib.input;

const set_binary_mode = Stdlib.set_binary_mode_in;

function is_binary_mode(prim) {
  return Caml_external_polyfill.resolve("caml_ml_is_binary_mode")(prim);
}

function isatty(prim) {
  return Caml_external_polyfill.resolve("caml_sys_isatty")(prim);
}

export {
  stdin,
  open_bin,
  open_text,
  open_gen,
  with_open_bin,
  with_open_text,
  with_open_gen,
  close,
  close_noerr,
  input_char,
  input_byte,
  input_line,
  really_input_string,
  input_all,
  input_lines,
  input,
  really_input,
  fold_lines,
  seek,
  pos,
  length,
  set_binary_mode,
  is_binary_mode,
  isatty,
}
/* Stdlib__Fun Not a pure module */
`,Df=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_hash from "melange.js/caml_hash.js";

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

const min_int = -2147483648;

function lognot(x) {
  return x ^ -1;
}

function equal(prim0, prim1) {
  return prim0 === prim1;
}

const compare = Caml.caml_int_compare;

function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function to_string(x) {
  return Caml_format.caml_format_int("%d", x);
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

const zero = 0;

const one = 1;

const minus_one = -1;

const max_int = 2147483647;

export {
  zero,
  one,
  minus_one,
  abs,
  max_int,
  min_int,
  lognot,
  equal,
  compare,
  min,
  max,
  to_string,
  seeded_hash,
  hash,
}
/* No side effect */
`,Of=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Sys from "./sys.js";

function succ(n) {
  return n + 1 | 0;
}

function pred(n) {
  return n - 1 | 0;
}

function abs(n) {
  if (n >= 0) {
    return n;
  } else {
    return -n | 0;
  }
}

function lognot(n) {
  return n ^ -1;
}

let unsigned_to_int;

if (Stdlib__Sys.word_size !== 32) {
  if (Stdlib__Sys.word_size !== 64) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/int32.ml",
            69,
            6
          ]
        });
  }
  unsigned_to_int = (function (n) {
    return n & -1;
  });
} else {
  unsigned_to_int = (function (n) {
    if (n >= 0 && n <= Stdlib.max_int) {
      return n;
    }
    
  });
}

function to_string(n) {
  return Caml_format.caml_int32_format("%d", n);
}

function of_string_opt(s) {
  try {
    return Caml_format.caml_int32_of_string(s);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const compare = Caml.caml_int_compare;

function equal(x, y) {
  return x === y;
}

function unsigned_compare(n, m) {
  return Caml.caml_int_compare(n - -2147483648 | 0, m - -2147483648 | 0);
}

function unsigned_lt(n, m) {
  return (n - -2147483648 | 0) < (m - -2147483648 | 0);
}

function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function unsigned_div(n, d) {
  if (d < 0) {
    if (unsigned_lt(n, d)) {
      return 0;
    } else {
      return 1;
    }
  }
  const q = (((n >>> 1) / d | 0) << 1);
  const r = n - Math.imul(q, d) | 0;
  if (unsigned_lt(r, d)) {
    return q;
  } else {
    return q + 1 | 0;
  }
}

function unsigned_rem(n, d) {
  return n - Math.imul(unsigned_div(n, d), d) | 0;
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

const zero = 0;

const one = 1;

const minus_one = -1;

const max_int = 2147483647;

const min_int = -2147483648;

export {
  zero,
  one,
  minus_one,
  unsigned_div,
  unsigned_rem,
  succ,
  pred,
  abs,
  max_int,
  min_int,
  lognot,
  unsigned_to_int,
  of_string_opt,
  to_string,
  compare,
  unsigned_compare,
  equal,
  min,
  max,
  seeded_hash,
  hash,
}
/* unsigned_to_int Not a pure module */
`,zf=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Stdlib from "./stdlib.js";

const zero = Caml_int64.zero;

const one = Caml_int64.one;

function succ(n) {
  return Caml_int64.add(n, Caml_int64.one);
}

function pred(n) {
  return Caml_int64.sub(n, Caml_int64.one);
}

function abs(n) {
  if (Caml.i64_ge(n, Caml_int64.zero)) {
    return n;
  } else {
    return Caml_int64.neg(n);
  }
}

const min_int = Caml_int64.min_int;

function lognot(n) {
  return Caml_int64.xor(n, Caml_int64.neg_one);
}

const max_int = Caml_int64.of_int32(Stdlib.max_int);

function unsigned_to_int(n) {
  if (Caml.i64_ge(n, Caml_int64.zero) && Caml.i64_le(n, max_int)) {
    return Caml_int64.to_int32(n);
  }
  
}

function to_string(n) {
  return Caml_format.caml_int64_format("%d", n);
}

function of_string_opt(s) {
  try {
    return Caml_format.caml_int64_of_string(s);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const compare = Caml_int64.compare;

const equal = Caml.i64_eq;

function unsigned_compare(n, m) {
  return Caml_int64.compare(Caml_int64.sub(n, min_int), Caml_int64.sub(m, min_int));
}

function unsigned_lt(n, m) {
  return Caml.i64_lt(Caml_int64.sub(n, min_int), Caml_int64.sub(m, min_int));
}

function min(x, y) {
  if (Caml.i64_le(x, y)) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (Caml.i64_ge(x, y)) {
    return x;
  } else {
    return y;
  }
}

function unsigned_div(n, d) {
  if (Caml.i64_lt(d, zero)) {
    if (unsigned_lt(n, d)) {
      return zero;
    } else {
      return one;
    }
  }
  const q = Caml_int64.lsl_(Caml_int64.div(Caml_int64.lsr_(n, 1), d), 1);
  const r = Caml_int64.sub(n, Caml_int64.mul(q, d));
  if (unsigned_lt(r, d)) {
    return q;
  } else {
    return Caml_int64.add(q, Caml_int64.one);
  }
}

function unsigned_rem(n, d) {
  return Caml_int64.sub(n, Caml_int64.mul(unsigned_div(n, d), d));
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

const minus_one = Caml_int64.neg_one;

const max_int$1 = Caml_int64.max_int;

export {
  zero,
  one,
  minus_one,
  unsigned_div,
  unsigned_rem,
  succ,
  pred,
  abs,
  max_int$1 as max_int,
  min_int,
  lognot,
  unsigned_to_int,
  of_string_opt,
  to_string,
  compare,
  unsigned_compare,
  equal,
  min,
  max,
  seeded_hash,
  hash,
}
/* No side effect */
`,Gf=`// Generated by Melange

import * as CamlinternalLazy from "./camlinternalLazy.js";
import * as Curry from "melange.js/curry.js";

function from_fun(f) {
  return {
    LAZY_DONE: false,
    VAL: (function () {
      return Curry._1(f, undefined);
    })
  };
}

function from_val(v) {
  return {
    LAZY_DONE: true,
    VAL: v
  };
}

function map(f, x) {
  return {
    LAZY_DONE: false,
    VAL: (function () {
      return Curry._1(f, CamlinternalLazy.force(x));
    })
  };
}

function map_val(f, x) {
  if (CamlinternalLazy.is_val(x)) {
    return {
      LAZY_DONE: true,
      VAL: Curry._1(f, CamlinternalLazy.force(x))
    };
  } else {
    return {
      LAZY_DONE: false,
      VAL: (function () {
        return Curry._1(f, CamlinternalLazy.force(x));
      })
    };
  }
}

const Undefined = CamlinternalLazy.Undefined;

const is_val = CamlinternalLazy.is_val;

const force_val = CamlinternalLazy.force_val;

export {
  Undefined,
  map,
  is_val,
  from_val,
  map_val,
  from_fun,
  force_val,
}
/* No side effect */
`,Ff=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_lexer from "melange.js/caml_lexer.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";

const dummy_pos = {
  pos_fname: "",
  pos_lnum: 0,
  pos_bol: 0,
  pos_cnum: -1
};

function engine(tbl, state, buf) {
  const result = Caml_lexer.caml_lex_engine(tbl, state, buf);
  if (result >= 0 && buf.lex_curr_p !== dummy_pos) {
    buf.lex_start_p = buf.lex_curr_p;
    const init = buf.lex_curr_p;
    buf.lex_curr_p = {
      pos_fname: init.pos_fname,
      pos_lnum: init.pos_lnum,
      pos_bol: init.pos_bol,
      pos_cnum: buf.lex_abs_pos + buf.lex_curr_pos | 0
    };
  }
  return result;
}

function new_engine(tbl, state, buf) {
  const result = Caml_lexer.caml_new_lex_engine(tbl, state, buf);
  if (result >= 0 && buf.lex_curr_p !== dummy_pos) {
    buf.lex_start_p = buf.lex_curr_p;
    const init = buf.lex_curr_p;
    buf.lex_curr_p = {
      pos_fname: init.pos_fname,
      pos_lnum: init.pos_lnum,
      pos_bol: init.pos_bol,
      pos_cnum: buf.lex_abs_pos + buf.lex_curr_pos | 0
    };
  }
  return result;
}

const zero_pos = {
  pos_fname: "",
  pos_lnum: 1,
  pos_bol: 0,
  pos_cnum: 0
};

function from_function(with_positionsOpt, f) {
  const with_positions = with_positionsOpt !== undefined ? with_positionsOpt : true;
  const partial_arg = Caml_bytes.caml_create_bytes(512);
  return {
    refill_buff: (function (param) {
      const read = Curry._2(f, partial_arg, partial_arg.length);
      const n = read > 0 ? read : (param.lex_eof_reached = true, 0);
      if ((param.lex_buffer_len + n | 0) > param.lex_buffer.length) {
        if (((param.lex_buffer_len - param.lex_start_pos | 0) + n | 0) <= param.lex_buffer.length) {
          Stdlib__Bytes.blit(param.lex_buffer, param.lex_start_pos, param.lex_buffer, 0, param.lex_buffer_len - param.lex_start_pos | 0);
        } else {
          const newlen = (param.lex_buffer.length << 1);
          if (((param.lex_buffer_len - param.lex_start_pos | 0) + n | 0) > newlen) {
            throw new Caml_js_exceptions.MelangeError("Failure", {
                  MEL_EXN_ID: "Failure",
                  _1: "Lexing.lex_refill: cannot grow buffer"
                });
          }
          const newbuf = Caml_bytes.caml_create_bytes(newlen);
          Stdlib__Bytes.blit(param.lex_buffer, param.lex_start_pos, newbuf, 0, param.lex_buffer_len - param.lex_start_pos | 0);
          param.lex_buffer = newbuf;
        }
        const s = param.lex_start_pos;
        param.lex_abs_pos = param.lex_abs_pos + s | 0;
        param.lex_curr_pos = param.lex_curr_pos - s | 0;
        param.lex_start_pos = 0;
        param.lex_last_pos = param.lex_last_pos - s | 0;
        param.lex_buffer_len = param.lex_buffer_len - s | 0;
        const t = param.lex_mem;
        for (let i = 0, i_finish = t.length; i < i_finish; ++i) {
          const v = Caml_array.get(t, i);
          if (v >= 0) {
            Caml_array.set(t, i, v - s | 0);
          }
          
        }
      }
      Stdlib__Bytes.blit(partial_arg, 0, param.lex_buffer, param.lex_buffer_len, n);
      param.lex_buffer_len = param.lex_buffer_len + n | 0;
    }),
    lex_buffer: Caml_bytes.caml_create_bytes(1024),
    lex_buffer_len: 0,
    lex_abs_pos: 0,
    lex_start_pos: 0,
    lex_curr_pos: 0,
    lex_last_pos: 0,
    lex_last_action: 0,
    lex_eof_reached: false,
    lex_mem: [],
    lex_start_p: with_positions ? zero_pos : dummy_pos,
    lex_curr_p: with_positions ? zero_pos : dummy_pos
  };
}

function from_channel(with_positions, ic) {
  return from_function(with_positions, (function (buf, n) {
    return Stdlib.input(ic, buf, 0, n);
  }));
}

function from_string(with_positionsOpt, s) {
  const with_positions = with_positionsOpt !== undefined ? with_positionsOpt : true;
  const lex_buffer = Stdlib__Bytes.of_string(s);
  return {
    refill_buff: (function (lexbuf) {
      lexbuf.lex_eof_reached = true;
    }),
    lex_buffer: lex_buffer,
    lex_buffer_len: lex_buffer.length,
    lex_abs_pos: 0,
    lex_start_pos: 0,
    lex_curr_pos: 0,
    lex_last_pos: 0,
    lex_last_action: 0,
    lex_eof_reached: true,
    lex_mem: [],
    lex_start_p: with_positions ? zero_pos : dummy_pos,
    lex_curr_p: with_positions ? zero_pos : dummy_pos
  };
}

function set_position(lexbuf, position) {
  lexbuf.lex_curr_p = {
    pos_fname: lexbuf.lex_curr_p.pos_fname,
    pos_lnum: position.pos_lnum,
    pos_bol: position.pos_bol,
    pos_cnum: position.pos_cnum
  };
  lexbuf.lex_abs_pos = position.pos_cnum;
}

function set_filename(lexbuf, fname) {
  const init = lexbuf.lex_curr_p;
  lexbuf.lex_curr_p = {
    pos_fname: fname,
    pos_lnum: init.pos_lnum,
    pos_bol: init.pos_bol,
    pos_cnum: init.pos_cnum
  };
}

function with_positions(lexbuf) {
  return lexbuf.lex_curr_p !== dummy_pos;
}

function lexeme(lexbuf) {
  const len = lexbuf.lex_curr_pos - lexbuf.lex_start_pos | 0;
  return Stdlib__Bytes.sub_string(lexbuf.lex_buffer, lexbuf.lex_start_pos, len);
}

function sub_lexeme(lexbuf, i1, i2) {
  const len = i2 - i1 | 0;
  return Stdlib__Bytes.sub_string(lexbuf.lex_buffer, i1, len);
}

function sub_lexeme_opt(lexbuf, i1, i2) {
  if (i1 < 0) {
    return;
  }
  const len = i2 - i1 | 0;
  return Stdlib__Bytes.sub_string(lexbuf.lex_buffer, i1, len);
}

function sub_lexeme_char(lexbuf, i) {
  return Caml_bytes.get(lexbuf.lex_buffer, i);
}

function sub_lexeme_char_opt(lexbuf, i) {
  if (i >= 0) {
    return Caml_bytes.get(lexbuf.lex_buffer, i);
  }
  
}

function lexeme_char(lexbuf, i) {
  return Caml_bytes.get(lexbuf.lex_buffer, lexbuf.lex_start_pos + i | 0);
}

function lexeme_start(lexbuf) {
  return lexbuf.lex_start_p.pos_cnum;
}

function lexeme_end(lexbuf) {
  return lexbuf.lex_curr_p.pos_cnum;
}

function lexeme_start_p(lexbuf) {
  return lexbuf.lex_start_p;
}

function lexeme_end_p(lexbuf) {
  return lexbuf.lex_curr_p;
}

function new_line(lexbuf) {
  const lcp = lexbuf.lex_curr_p;
  if (lcp !== dummy_pos) {
    lexbuf.lex_curr_p = {
      pos_fname: lcp.pos_fname,
      pos_lnum: lcp.pos_lnum + 1 | 0,
      pos_bol: lcp.pos_cnum,
      pos_cnum: lcp.pos_cnum
    };
    return;
  }
  
}

function flush_input(lb) {
  lb.lex_curr_pos = 0;
  lb.lex_abs_pos = 0;
  const lcp = lb.lex_curr_p;
  if (lcp !== dummy_pos) {
    lb.lex_curr_p = {
      pos_fname: lcp.pos_fname,
      pos_lnum: 1,
      pos_bol: 0,
      pos_cnum: 0
    };
  }
  lb.lex_buffer_len = 0;
}

export {
  dummy_pos,
  from_channel,
  from_string,
  from_function,
  set_position,
  set_filename,
  with_positions,
  lexeme,
  lexeme_char,
  lexeme_start,
  lexeme_end,
  lexeme_start_p,
  lexeme_end_p,
  new_line,
  flush_input,
  sub_lexeme,
  sub_lexeme_opt,
  sub_lexeme_char,
  sub_lexeme_char_opt,
  engine,
  new_engine,
}
/* No side effect */
`,Pf=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";

function length(l) {
  let _len = 0;
  let _param = l;
  while (true) {
    const param = _param;
    const len = _len;
    if (!param) {
      return len;
    }
    _param = param.tl;
    _len = len + 1 | 0;
    continue;
  };
}

function cons(a, l) {
  return {
    hd: a,
    tl: l
  };
}

function hd(param) {
  if (param) {
    return param.hd;
  }
  throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "hd"
      });
}

function tl(param) {
  if (param) {
    return param.tl;
  }
  throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "tl"
      });
}

function nth(l, n) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.nth"
        });
  }
  let _l = l;
  let _n = n;
  while (true) {
    const n$1 = _n;
    const l$1 = _l;
    if (l$1) {
      if (n$1 === 0) {
        return l$1.hd;
      }
      _n = n$1 - 1 | 0;
      _l = l$1.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "nth"
        });
  };
}

function nth_opt(l, n) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.nth"
        });
  }
  let _l = l;
  let _n = n;
  while (true) {
    const n$1 = _n;
    const l$1 = _l;
    if (!l$1) {
      return;
    }
    if (n$1 === 0) {
      return Caml_option.some(l$1.hd);
    }
    _n = n$1 - 1 | 0;
    _l = l$1.tl;
    continue;
  };
}

function rev_append(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue;
  };
}

function rev(l) {
  return rev_append(l, /* [] */ 0);
}

function init_dps(_dst, _offset, _i, last, f) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const i = _i;
    if (i > last) {
      dst[offset] = /* [] */ 0;
      return;
    }
    if (i === last) {
      dst[offset] = {
        hd: Curry._1(f, i),
        tl: /* [] */ 0
      };
      return;
    }
    const r1 = Curry._1(f, i);
    const r2 = Curry._1(f, i + 1 | 0);
    const block = {
      hd: r2,
      tl: 24029
    };
    dst[offset] = {
      hd: r1,
      tl: block
    };
    _i = i + 2 | 0;
    _offset = "tl";
    _dst = block;
    continue;
  };
}

function init(len, f) {
  if (len < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.init"
        });
  }
  let i = 0;
  let last = len - 1 | 0;
  if (i > last) {
    return /* [] */ 0;
  }
  if (i === last) {
    return {
      hd: Curry._1(f, i),
      tl: /* [] */ 0
    };
  }
  const r1 = Curry._1(f, i);
  const r2 = Curry._1(f, i + 1 | 0);
  const block = {
    hd: r2,
    tl: 24029
  };
  return {
    hd: r1,
    tl: (init_dps(block, "tl", i + 2 | 0, last, f), block)
  };
}

function flatten(param) {
  if (param) {
    return Stdlib.$at(param.hd, flatten(param.tl));
  } else {
    return /* [] */ 0;
  }
}

function map_dps(_dst, _offset, f, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */ 0;
      return;
    }
    const match = param.tl;
    const a1 = param.hd;
    if (match) {
      const r1 = Curry._1(f, a1);
      const r2 = Curry._1(f, match.hd);
      const block = {
        hd: r2,
        tl: 24029
      };
      dst[offset] = {
        hd: r1,
        tl: block
      };
      _param = match.tl;
      _offset = "tl";
      _dst = block;
      continue;
    }
    const r1$1 = Curry._1(f, a1);
    dst[offset] = {
      hd: r1$1,
      tl: /* [] */ 0
    };
    return;
  };
}

function map(f, param) {
  if (!param) {
    return /* [] */ 0;
  }
  const match = param.tl;
  const a1 = param.hd;
  if (match) {
    const r1 = Curry._1(f, a1);
    const r2 = Curry._1(f, match.hd);
    const block = {
      hd: r2,
      tl: 24029
    };
    return {
      hd: r1,
      tl: (map_dps(block, "tl", f, match.tl), block)
    };
  }
  const r1$1 = Curry._1(f, a1);
  return {
    hd: r1$1,
    tl: /* [] */ 0
  };
}

function mapi_dps(_dst, _offset, _i, f, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const i = _i;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */ 0;
      return;
    }
    const match = param.tl;
    const a1 = param.hd;
    if (match) {
      const r1 = Curry._2(f, i, a1);
      const r2 = Curry._2(f, i + 1 | 0, match.hd);
      const block = {
        hd: r2,
        tl: 24029
      };
      dst[offset] = {
        hd: r1,
        tl: block
      };
      _param = match.tl;
      _i = i + 2 | 0;
      _offset = "tl";
      _dst = block;
      continue;
    }
    const r1$1 = Curry._2(f, i, a1);
    dst[offset] = {
      hd: r1$1,
      tl: /* [] */ 0
    };
    return;
  };
}

function mapi(f, l) {
  let i = 0;
  if (!l) {
    return /* [] */ 0;
  }
  const match = l.tl;
  const a1 = l.hd;
  if (match) {
    const r1 = Curry._2(f, i, a1);
    const r2 = Curry._2(f, i + 1 | 0, match.hd);
    const block = {
      hd: r2,
      tl: 24029
    };
    return {
      hd: r1,
      tl: (mapi_dps(block, "tl", i + 2 | 0, f, match.tl), block)
    };
  }
  const r1$1 = Curry._2(f, i, a1);
  return {
    hd: r1$1,
    tl: /* [] */ 0
  };
}

function rev_map(f, l) {
  let _accu = /* [] */ 0;
  let _param = l;
  while (true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = {
      hd: Curry._1(f, param.hd),
      tl: accu
    };
    continue;
  };
}

function iter(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    Curry._1(f, param.hd);
    _param = param.tl;
    continue;
  };
}

function iteri(f, l) {
  let _i = 0;
  let _param = l;
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return;
    }
    Curry._2(f, i, param.hd);
    _param = param.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function fold_left(f, _accu, _l) {
  while (true) {
    const l = _l;
    const accu = _accu;
    if (!l) {
      return accu;
    }
    _l = l.tl;
    _accu = Curry._2(f, accu, l.hd);
    continue;
  };
}

function fold_right(f, l, accu) {
  if (l) {
    return Curry._2(f, l.hd, fold_right(f, l.tl, accu));
  } else {
    return accu;
  }
}

function map2_dps(_dst, _offset, f, _l1, _l2) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const l1 = _l1;
    const l2 = _l2;
    if (l1) {
      const match = l1.tl;
      const a1 = l1.hd;
      if (match) {
        if (l2) {
          const match$1 = l2.tl;
          if (match$1) {
            const r1 = Curry._2(f, a1, l2.hd);
            const r2 = Curry._2(f, match.hd, match$1.hd);
            const block = {
              hd: r2,
              tl: 24029
            };
            dst[offset] = {
              hd: r1,
              tl: block
            };
            _l2 = match$1.tl;
            _l1 = match.tl;
            _offset = "tl";
            _dst = block;
            continue;
          }
          throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "List.map2"
              });
        }
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.map2"
            });
      }
      if (l2) {
        if (l2.tl) {
          throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "List.map2"
              });
        }
        const r1$1 = Curry._2(f, a1, l2.hd);
        dst[offset] = {
          hd: r1$1,
          tl: /* [] */ 0
        };
        return;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.map2"
          });
    }
    if (l2) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.map2"
          });
    }
    dst[offset] = /* [] */ 0;
    return;
  };
}

function map2(f, l1, l2) {
  if (l1) {
    const match = l1.tl;
    const a1 = l1.hd;
    if (match) {
      if (l2) {
        const match$1 = l2.tl;
        if (match$1) {
          const r1 = Curry._2(f, a1, l2.hd);
          const r2 = Curry._2(f, match.hd, match$1.hd);
          const block = {
            hd: r2,
            tl: 24029
          };
          return {
            hd: r1,
            tl: (map2_dps(block, "tl", f, match.tl, match$1.tl), block)
          };
        }
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.map2"
            });
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.map2"
          });
    }
    if (l2) {
      if (l2.tl) {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.map2"
            });
      }
      const r1$1 = Curry._2(f, a1, l2.hd);
      return {
        hd: r1$1,
        tl: /* [] */ 0
      };
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.map2"
        });
  }
  if (!l2) {
    return /* [] */ 0;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.map2"
      });
}

function rev_map2(f, l1, l2) {
  let _accu = /* [] */ 0;
  let _l1 = l1;
  let _l2 = l2;
  while (true) {
    const l2$1 = _l2;
    const l1$1 = _l1;
    const accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1.tl;
        _l1 = l1$1.tl;
        _accu = {
          hd: Curry._2(f, l1$1.hd, l2$1.hd),
          tl: accu
        };
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2"
          });
    }
    if (l2$1) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2"
          });
    }
    return accu;
  };
}

function iter2(f, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (l1) {
      if (l2) {
        Curry._2(f, l1.hd, l2.hd);
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.iter2"
          });
    }
    if (!l2) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.iter2"
        });
  };
}

function fold_left2(f, _accu, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    const accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2.tl;
        _l1 = l1.tl;
        _accu = Curry._3(f, accu, l1.hd, l2.hd);
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2"
          });
    }
    if (l2) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2"
          });
    }
    return accu;
  };
}

function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return Curry._3(f, l1.hd, l2.hd, fold_right2(f, l1.tl, l2.tl, accu));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2"
        });
  }
  if (l2) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2"
        });
  }
  return accu;
}

function for_all(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return true;
    }
    if (!Curry._1(p, param.hd)) {
      return false;
    }
    _param = param.tl;
    continue;
  };
}

function exists(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (Curry._1(p, param.hd)) {
      return true;
    }
    _param = param.tl;
    continue;
  };
}

function for_all2(p, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (l1) {
      if (l2) {
        if (!Curry._2(p, l1.hd, l2.hd)) {
          return false;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.for_all2"
          });
    }
    if (!l2) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.for_all2"
        });
  };
}

function exists2(p, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(p, l1.hd, l2.hd)) {
          return true;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.exists2"
          });
    }
    if (!l2) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.exists2"
        });
  };
}

function mem(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (Caml_obj.caml_equal(param.hd, x)) {
      return true;
    }
    _param = param.tl;
    continue;
  };
}

function memq(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (param.hd === x) {
      return true;
    }
    _param = param.tl;
    continue;
  };
}

function assoc(x, _param) {
  while (true) {
    const param = _param;
    if (param) {
      const match = param.hd;
      if (Caml_obj.caml_equal(match[0], x)) {
        return match[1];
      }
      _param = param.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function assoc_opt(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const match = param.hd;
    if (Caml_obj.caml_equal(match[0], x)) {
      return Caml_option.some(match[1]);
    }
    _param = param.tl;
    continue;
  };
}

function assq(x, _param) {
  while (true) {
    const param = _param;
    if (param) {
      const match = param.hd;
      if (match[0] === x) {
        return match[1];
      }
      _param = param.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function assq_opt(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const match = param.hd;
    if (match[0] === x) {
      return Caml_option.some(match[1]);
    }
    _param = param.tl;
    continue;
  };
}

function mem_assoc(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (Caml_obj.caml_equal(param.hd[0], x)) {
      return true;
    }
    _param = param.tl;
    continue;
  };
}

function mem_assq(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (param.hd[0] === x) {
      return true;
    }
    _param = param.tl;
    continue;
  };
}

function remove_assoc(x, param) {
  if (!param) {
    return /* [] */ 0;
  }
  const l = param.tl;
  const pair = param.hd;
  if (Caml_obj.caml_equal(pair[0], x)) {
    return l;
  } else {
    return {
      hd: pair,
      tl: remove_assoc(x, l)
    };
  }
}

function remove_assq(x, param) {
  if (!param) {
    return /* [] */ 0;
  }
  const l = param.tl;
  const pair = param.hd;
  if (pair[0] === x) {
    return l;
  } else {
    return {
      hd: pair,
      tl: remove_assq(x, l)
    };
  }
}

function find(p, _param) {
  while (true) {
    const param = _param;
    if (param) {
      const x = param.hd;
      if (Curry._1(p, x)) {
        return x;
      }
      _param = param.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  };
}

function find_opt(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const x = param.hd;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _param = param.tl;
    continue;
  };
}

function find_index(p) {
  return function (param) {
    let _i = 0;
    let _param = param;
    while (true) {
      const param$1 = _param;
      const i = _i;
      if (!param$1) {
        return;
      }
      if (Curry._1(p, param$1.hd)) {
        return i;
      }
      _param = param$1.tl;
      _i = i + 1 | 0;
      continue;
    };
  };
}

function find_map(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const result = Curry._1(f, param.hd);
    if (result !== undefined) {
      return result;
    }
    _param = param.tl;
    continue;
  };
}

function find_mapi(f) {
  return function (param) {
    let _i = 0;
    let _param = param;
    while (true) {
      const param$1 = _param;
      const i = _i;
      if (!param$1) {
        return;
      }
      const result = Curry._2(f, i, param$1.hd);
      if (result !== undefined) {
        return result;
      }
      _param = param$1.tl;
      _i = i + 1 | 0;
      continue;
    };
  };
}

function find_all(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return /* [] */ 0;
    }
    const l = param.tl;
    const x = param.hd;
    if (Curry._1(p, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      find_all_dps(block, "tl", p, l);
      return block;
    }
    _param = l;
    continue;
  };
}

function find_all_dps(_dst, _offset, p, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */ 0;
      return;
    }
    const l = param.tl;
    const x = param.hd;
    if (Curry._1(p, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _offset = "tl";
      _dst = block;
      continue;
    }
    _param = l;
    continue;
  };
}

function filteri_dps(_dst, _offset, p, _i, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const i = _i;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */ 0;
      return;
    }
    const l = param.tl;
    const x = param.hd;
    const i$p = i + 1 | 0;
    if (Curry._2(p, i, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _i = i$p;
      _offset = "tl";
      _dst = block;
      continue;
    }
    _param = l;
    _i = i$p;
    continue;
  };
}

function filteri(p, l) {
  let _i = 0;
  let _param = l;
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return /* [] */ 0;
    }
    const l$1 = param.tl;
    const x = param.hd;
    const i$p = i + 1 | 0;
    if (Curry._2(p, i, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      filteri_dps(block, "tl", p, i$p, l$1);
      return block;
    }
    _param = l$1;
    _i = i$p;
    continue;
  };
}

function filter_map(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return /* [] */ 0;
    }
    const l = param.tl;
    const v = Curry._1(f, param.hd);
    if (v !== undefined) {
      const block = {
        hd: Caml_option.valFromOption(v),
        tl: 24029
      };
      filter_map_dps(block, "tl", f, l);
      return block;
    }
    _param = l;
    continue;
  };
}

function filter_map_dps(_dst, _offset, f, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */ 0;
      return;
    }
    const l = param.tl;
    const v = Curry._1(f, param.hd);
    if (v !== undefined) {
      const block = {
        hd: Caml_option.valFromOption(v),
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _offset = "tl";
      _dst = block;
      continue;
    }
    _param = l;
    continue;
  };
}

function concat_map(f, param) {
  if (param) {
    let ys = Curry._1(f, param.hd);
    let xs = param.tl;
    if (!ys) {
      return concat_map(f, xs);
    }
    const block = {
      hd: ys.hd,
      tl: 24029
    };
    prepend_concat_map_dps(block, "tl", ys.tl, f, xs);
    return block;
  } else {
    return /* [] */ 0;
  }
}

function prepend_concat_map_dps(_dst, _offset, _ys, f, xs) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const ys = _ys;
    if (!ys) {
      if (xs) {
        return prepend_concat_map_dps(dst, offset, Curry._1(f, xs.hd), f, xs.tl);
      } else {
        dst[offset] = /* [] */ 0;
        return;
      }
    }
    const block = {
      hd: ys.hd,
      tl: 24029
    };
    dst[offset] = block;
    _ys = ys.tl;
    _offset = "tl";
    _dst = block;
    continue;
  };
}

function take(n, l) {
  const aux_dps = function (_dst, _offset, _n, _l) {
    while (true) {
      const dst = _dst;
      const offset = _offset;
      const n = _n;
      const l = _l;
      if (n === 0) {
        dst[offset] = /* [] */ 0;
        return;
      }
      if (!l) {
        dst[offset] = /* [] */ 0;
        return;
      }
      const block = {
        hd: l.hd,
        tl: 24029
      };
      dst[offset] = block;
      _l = l.tl;
      _n = n - 1 | 0;
      _offset = "tl";
      _dst = block;
      continue;
    };
  };
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.take"
        });
  }
  if (n === 0) {
    return /* [] */ 0;
  }
  if (!l) {
    return /* [] */ 0;
  }
  const block = {
    hd: l.hd,
    tl: 24029
  };
  aux_dps(block, "tl", n - 1 | 0, l.tl);
  return block;
}

function drop(n, l) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.drop"
        });
  }
  let _i = 0;
  let _rest = l;
  while (true) {
    const rest = _rest;
    const i = _i;
    if (!rest) {
      return rest;
    }
    if (i >= n) {
      return rest;
    }
    _rest = rest.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function take_while(p, l) {
  const aux_dps = function (_dst, _offset, __rest) {
    while (true) {
      const dst = _dst;
      const offset = _offset;
      const _rest = __rest;
      if (!_rest) {
        dst[offset] = /* [] */ 0;
        return;
      }
      const x = _rest.hd;
      if (!Curry._1(p, x)) {
        dst[offset] = /* [] */ 0;
        return;
      }
      const block = {
        hd: x,
        tl: 24029
      };
      dst[offset] = block;
      __rest = _rest.tl;
      _offset = "tl";
      _dst = block;
      continue;
    };
  };
  if (!l) {
    return /* [] */ 0;
  }
  const x = l.hd;
  if (!Curry._1(p, x)) {
    return /* [] */ 0;
  }
  const block = {
    hd: x,
    tl: 24029
  };
  aux_dps(block, "tl", l.tl);
  return block;
}

function drop_while(p, _rest) {
  while (true) {
    const rest = _rest;
    if (!rest) {
      return rest;
    }
    if (!Curry._1(p, rest.hd)) {
      return rest;
    }
    _rest = rest.tl;
    continue;
  };
}

function fold_left_map(f, accu, l) {
  let _accu = accu;
  let _l_accu = /* [] */ 0;
  let _param = l;
  while (true) {
    const param = _param;
    const l_accu = _l_accu;
    const accu$1 = _accu;
    if (!param) {
      return [
        accu$1,
        rev_append(l_accu, /* [] */ 0)
      ];
    }
    const match = Curry._2(f, accu$1, param.hd);
    _param = param.tl;
    _l_accu = {
      hd: match[1],
      tl: l_accu
    };
    _accu = match[0];
    continue;
  };
}

function partition(p, l) {
  let _yes = /* [] */ 0;
  let _no = /* [] */ 0;
  let _param = l;
  while (true) {
    const param = _param;
    const no = _no;
    const yes = _yes;
    if (!param) {
      return [
        rev_append(yes, /* [] */ 0),
        rev_append(no, /* [] */ 0)
      ];
    }
    const l$1 = param.tl;
    const x = param.hd;
    if (Curry._1(p, x)) {
      _param = l$1;
      _yes = {
        hd: x,
        tl: yes
      };
      continue;
    }
    _param = l$1;
    _no = {
      hd: x,
      tl: no
    };
    continue;
  };
}

function partition_map(p, l) {
  let _left = /* [] */ 0;
  let _right = /* [] */ 0;
  let _param = l;
  while (true) {
    const param = _param;
    const right = _right;
    const left = _left;
    if (!param) {
      return [
        rev_append(left, /* [] */ 0),
        rev_append(right, /* [] */ 0)
      ];
    }
    const l$1 = param.tl;
    const v = Curry._1(p, param.hd);
    if (v.TAG === /* Left */ 0) {
      _param = l$1;
      _left = {
        hd: v._0,
        tl: left
      };
      continue;
    }
    _param = l$1;
    _right = {
      hd: v._0,
      tl: right
    };
    continue;
  };
}

function split(param) {
  if (!param) {
    return [
      /* [] */ 0,
      /* [] */ 0
    ];
  }
  const match = param.hd;
  const match$1 = split(param.tl);
  return [
    {
      hd: match[0],
      tl: match$1[0]
    },
    {
      hd: match[1],
      tl: match$1[1]
    }
  ];
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return {
        hd: [
          l1.hd,
          l2.hd
        ],
        tl: combine(l1.tl, l2.tl)
      };
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.combine"
        });
  }
  if (!l2) {
    return /* [] */ 0;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.combine"
      });
}

function merge(cmp, l1, l2) {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  const h2 = l2.hd;
  const h1 = l1.hd;
  if (Curry._2(cmp, h1, h2) <= 0) {
    return {
      hd: h1,
      tl: merge(cmp, l1.tl, l2)
    };
  } else {
    return {
      hd: h2,
      tl: merge(cmp, l1, l2.tl)
    };
  }
}

function stable_sort(cmp, l) {
  const rev_merge = function (_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const h2 = l2.hd;
      const h1 = l1.hd;
      if (Curry._2(cmp, h1, h2) <= 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2.tl;
      continue;
    };
  };
  const rev_merge_rev = function (_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const h2 = l2.hd;
      const h1 = l1.hd;
      if (Curry._2(cmp, h1, h2) > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2.tl;
      continue;
    };
  };
  const sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        const match = l.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l.hd;
            const s = Curry._2(cmp, x1, x2) <= 0 ? (
                Curry._2(cmp, x2, x3) <= 0 ? ({
                    hd: x1,
                    tl: {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: /* [] */ 0
                      }
                    }
                  }) : (
                    Curry._2(cmp, x1, x3) <= 0 ? ({
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  )
              ) : (
                Curry._2(cmp, x1, x3) <= 0 ? ({
                    hd: x2,
                    tl: {
                      hd: x1,
                      tl: {
                        hd: x3,
                        tl: /* [] */ 0
                      }
                    }
                  }) : (
                    Curry._2(cmp, x2, x3) <= 0 ? ({
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  )
              );
            return [
              s,
              match$1.tl
            ];
          }
          
        }
        
      }
      
    } else if (l) {
      const match$2 = l.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l.hd;
        const s$1 = Curry._2(cmp, x1$1, x2$1) <= 0 ? ({
            hd: x1$1,
            tl: {
              hd: x2$1,
              tl: /* [] */ 0
            }
          }) : ({
            hd: x2$1,
            tl: {
              hd: x1$1,
              tl: /* [] */ 0
            }
          });
        return [
          s$1,
          match$2.tl
        ];
      }
      
    }
    const n1 = (n >> 1);
    const n2 = n - n1 | 0;
    const match$3 = rev_sort(n1, l);
    const match$4 = rev_sort(n2, match$3[1]);
    return [
      rev_merge_rev(match$3[0], match$4[0], /* [] */ 0),
      match$4[1]
    ];
  };
  const rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        const match = l.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l.hd;
            const s = Curry._2(cmp, x1, x2) > 0 ? (
                Curry._2(cmp, x2, x3) > 0 ? ({
                    hd: x1,
                    tl: {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: /* [] */ 0
                      }
                    }
                  }) : (
                    Curry._2(cmp, x1, x3) > 0 ? ({
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  )
              ) : (
                Curry._2(cmp, x1, x3) > 0 ? ({
                    hd: x2,
                    tl: {
                      hd: x1,
                      tl: {
                        hd: x3,
                        tl: /* [] */ 0
                      }
                    }
                  }) : (
                    Curry._2(cmp, x2, x3) > 0 ? ({
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  )
              );
            return [
              s,
              match$1.tl
            ];
          }
          
        }
        
      }
      
    } else if (l) {
      const match$2 = l.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l.hd;
        const s$1 = Curry._2(cmp, x1$1, x2$1) > 0 ? ({
            hd: x1$1,
            tl: {
              hd: x2$1,
              tl: /* [] */ 0
            }
          }) : ({
            hd: x2$1,
            tl: {
              hd: x1$1,
              tl: /* [] */ 0
            }
          });
        return [
          s$1,
          match$2.tl
        ];
      }
      
    }
    const n1 = (n >> 1);
    const n2 = n - n1 | 0;
    const match$3 = sort(n1, l);
    const match$4 = sort(n2, match$3[1]);
    return [
      rev_merge(match$3[0], match$4[0], /* [] */ 0),
      match$4[1]
    ];
  };
  const len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l)[0];
  }
}

function sort_uniq(cmp, l) {
  const rev_merge = function (_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const t2 = l2.tl;
      const h2 = l2.hd;
      const t1 = l1.tl;
      const h1 = l1.hd;
      const c = Curry._2(cmp, h1, h2);
      if (c === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue;
      }
      if (c < 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue;
    };
  };
  const rev_merge_rev = function (_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const t2 = l2.tl;
      const h2 = l2.hd;
      const t1 = l1.tl;
      const h1 = l1.hd;
      const c = Curry._2(cmp, h1, h2);
      if (c === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue;
      }
      if (c > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue;
    };
  };
  const sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        const match = l.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l.hd;
            const c = Curry._2(cmp, x1, x2);
            let s;
            if (c === 0) {
              const c$1 = Curry._2(cmp, x2, x3);
              s = c$1 === 0 ? ({
                  hd: x2,
                  tl: /* [] */ 0
                }) : (
                  c$1 < 0 ? ({
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: /* [] */ 0
                      }
                    }) : ({
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: /* [] */ 0
                      }
                    })
                );
            } else if (c < 0) {
              const c$2 = Curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: /* [] */ 0
                  }
                };
              } else if (c$2 < 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x3,
                      tl: /* [] */ 0
                    }
                  }
                };
              } else {
                const c$3 = Curry._2(cmp, x1, x3);
                s = c$3 === 0 ? ({
                    hd: x1,
                    tl: {
                      hd: x2,
                      tl: /* [] */ 0
                    }
                  }) : (
                    c$3 < 0 ? ({
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  );
              }
            } else {
              const c$4 = Curry._2(cmp, x1, x3);
              if (c$4 === 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: /* [] */ 0
                  }
                };
              } else if (c$4 < 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x3,
                      tl: /* [] */ 0
                    }
                  }
                };
              } else {
                const c$5 = Curry._2(cmp, x2, x3);
                s = c$5 === 0 ? ({
                    hd: x2,
                    tl: {
                      hd: x1,
                      tl: /* [] */ 0
                    }
                  }) : (
                    c$5 < 0 ? ({
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  );
              }
            }
            return [
              s,
              match$1.tl
            ];
          }
          
        }
        
      }
      
    } else if (l) {
      const match$2 = l.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l.hd;
        const c$6 = Curry._2(cmp, x1$1, x2$1);
        const s$1 = c$6 === 0 ? ({
            hd: x1$1,
            tl: /* [] */ 0
          }) : (
            c$6 < 0 ? ({
                hd: x1$1,
                tl: {
                  hd: x2$1,
                  tl: /* [] */ 0
                }
              }) : ({
                hd: x2$1,
                tl: {
                  hd: x1$1,
                  tl: /* [] */ 0
                }
              })
          );
        return [
          s$1,
          match$2.tl
        ];
      }
      
    }
    const n1 = (n >> 1);
    const n2 = n - n1 | 0;
    const match$3 = rev_sort(n1, l);
    const match$4 = rev_sort(n2, match$3[1]);
    return [
      rev_merge_rev(match$3[0], match$4[0], /* [] */ 0),
      match$4[1]
    ];
  };
  const rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        const match = l.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l.hd;
            const c = Curry._2(cmp, x1, x2);
            let s;
            if (c === 0) {
              const c$1 = Curry._2(cmp, x2, x3);
              s = c$1 === 0 ? ({
                  hd: x2,
                  tl: /* [] */ 0
                }) : (
                  c$1 > 0 ? ({
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: /* [] */ 0
                      }
                    }) : ({
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: /* [] */ 0
                      }
                    })
                );
            } else if (c > 0) {
              const c$2 = Curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: /* [] */ 0
                  }
                };
              } else if (c$2 > 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x3,
                      tl: /* [] */ 0
                    }
                  }
                };
              } else {
                const c$3 = Curry._2(cmp, x1, x3);
                s = c$3 === 0 ? ({
                    hd: x1,
                    tl: {
                      hd: x2,
                      tl: /* [] */ 0
                    }
                  }) : (
                    c$3 > 0 ? ({
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  );
              }
            } else {
              const c$4 = Curry._2(cmp, x1, x3);
              if (c$4 === 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: /* [] */ 0
                  }
                };
              } else if (c$4 > 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x3,
                      tl: /* [] */ 0
                    }
                  }
                };
              } else {
                const c$5 = Curry._2(cmp, x2, x3);
                s = c$5 === 0 ? ({
                    hd: x2,
                    tl: {
                      hd: x1,
                      tl: /* [] */ 0
                    }
                  }) : (
                    c$5 > 0 ? ({
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x1,
                            tl: /* [] */ 0
                          }
                        }
                      })
                  );
              }
            }
            return [
              s,
              match$1.tl
            ];
          }
          
        }
        
      }
      
    } else if (l) {
      const match$2 = l.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l.hd;
        const c$6 = Curry._2(cmp, x1$1, x2$1);
        const s$1 = c$6 === 0 ? ({
            hd: x1$1,
            tl: /* [] */ 0
          }) : (
            c$6 > 0 ? ({
                hd: x1$1,
                tl: {
                  hd: x2$1,
                  tl: /* [] */ 0
                }
              }) : ({
                hd: x2$1,
                tl: {
                  hd: x1$1,
                  tl: /* [] */ 0
                }
              })
          );
        return [
          s$1,
          match$2.tl
        ];
      }
      
    }
    const n1 = (n >> 1);
    const n2 = n - n1 | 0;
    const match$3 = sort(n1, l);
    const match$4 = sort(n2, match$3[1]);
    return [
      rev_merge(match$3[0], match$4[0], /* [] */ 0),
      match$4[1]
    ];
  };
  const len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l)[0];
  }
}

function compare_lengths(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function compare_length_with(_l, _n) {
  while (true) {
    const n = _n;
    const l = _l;
    if (!l) {
      if (n === 0) {
        return 0;
      } else if (n > 0) {
        return -1;
      } else {
        return 1;
      }
    }
    if (n <= 0) {
      return 1;
    }
    _n = n - 1 | 0;
    _l = l.tl;
    continue;
  };
}

function is_empty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function equal(eq, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!Curry._2(eq, l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function compare(cmp, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    const c = Curry._2(cmp, l1.hd, l2.hd);
    if (c !== 0) {
      return c;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function to_seq(l) {
  const aux = function (l, param) {
    if (!l) {
      return /* Nil */ 0;
    }
    const tail = l.tl;
    return {
      TAG: /* Cons */ 0,
      _0: l.hd,
      _1: (function (param) {
        return aux(tail, param);
      })
    };
  };
  return function (param) {
    return aux(l, param);
  };
}

function of_seq_dps(_dst, _offset, _seq) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const seq = _seq;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      dst[offset] = /* [] */ 0;
      return;
    }
    const x1 = match._0;
    const match$1 = Curry._1(match._1, undefined);
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      dst[offset] = {
        hd: x1,
        tl: /* [] */ 0
      };
      return;
    }
    const block = {
      hd: match$1._0,
      tl: 24029
    };
    dst[offset] = {
      hd: x1,
      tl: block
    };
    _seq = match$1._1;
    _offset = "tl";
    _dst = block;
    continue;
  };
}

function of_seq(seq) {
  const match = Curry._1(seq, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* [] */ 0;
  }
  const x1 = match._0;
  const match$1 = Curry._1(match._1, undefined);
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    return {
      hd: x1,
      tl: /* [] */ 0
    };
  }
  const block = {
    hd: match$1._0,
    tl: 24029
  };
  return {
    hd: x1,
    tl: (of_seq_dps(block, "tl", match$1._1), block)
  };
}

const append = Stdlib.$at;

const concat = flatten;

const filter = find_all;

const sort = stable_sort;

const fast_sort = stable_sort;

export {
  length,
  compare_lengths,
  compare_length_with,
  is_empty,
  cons,
  hd,
  tl,
  nth,
  nth_opt,
  rev,
  init,
  append,
  rev_append,
  concat,
  flatten,
  equal,
  compare,
  iter,
  iteri,
  map,
  mapi,
  rev_map,
  filter_map,
  concat_map,
  fold_left_map,
  fold_left,
  fold_right,
  iter2,
  map2,
  rev_map2,
  fold_left2,
  fold_right2,
  for_all,
  exists,
  for_all2,
  exists2,
  mem,
  memq,
  find,
  find_opt,
  find_index,
  find_map,
  find_mapi,
  filter,
  find_all,
  filteri,
  take,
  drop,
  take_while,
  drop_while,
  partition,
  partition_map,
  assoc,
  assoc_opt,
  assq,
  assq_opt,
  mem_assoc,
  mem_assq,
  remove_assoc,
  remove_assq,
  split,
  combine,
  sort,
  stable_sort,
  fast_sort,
  sort_uniq,
  merge,
  to_seq,
  of_seq,
}
/* No side effect */
`,Uf=`// Generated by Melange

import * as Stdlib__List from "./list.js";

const length = Stdlib__List.length;

const compare_lengths = Stdlib__List.compare_lengths;

const compare_length_with = Stdlib__List.compare_length_with;

const is_empty = Stdlib__List.is_empty;

const cons = Stdlib__List.cons;

const hd = Stdlib__List.hd;

const tl = Stdlib__List.tl;

const nth = Stdlib__List.nth;

const nth_opt = Stdlib__List.nth_opt;

const rev = Stdlib__List.rev;

const init = Stdlib__List.init;

const append = Stdlib__List.append;

const rev_append = Stdlib__List.rev_append;

const concat = Stdlib__List.concat;

const flatten = Stdlib__List.flatten;

const equal = Stdlib__List.equal;

const compare = Stdlib__List.compare;

const iter = Stdlib__List.iter;

const iteri = Stdlib__List.iteri;

const map = Stdlib__List.map;

const mapi = Stdlib__List.mapi;

const rev_map = Stdlib__List.rev_map;

const filter_map = Stdlib__List.filter_map;

const concat_map = Stdlib__List.concat_map;

const fold_left_map = Stdlib__List.fold_left_map;

const fold_left = Stdlib__List.fold_left;

const fold_right = Stdlib__List.fold_right;

const iter2 = Stdlib__List.iter2;

const map2 = Stdlib__List.map2;

const rev_map2 = Stdlib__List.rev_map2;

const fold_left2 = Stdlib__List.fold_left2;

const fold_right2 = Stdlib__List.fold_right2;

const for_all = Stdlib__List.for_all;

const exists = Stdlib__List.exists;

const for_all2 = Stdlib__List.for_all2;

const exists2 = Stdlib__List.exists2;

const mem = Stdlib__List.mem;

const memq = Stdlib__List.memq;

const find = Stdlib__List.find;

const find_opt = Stdlib__List.find_opt;

const find_index = Stdlib__List.find_index;

const find_map = Stdlib__List.find_map;

const find_mapi = Stdlib__List.find_mapi;

const filter = Stdlib__List.filter;

const find_all = Stdlib__List.find_all;

const filteri = Stdlib__List.filteri;

const take = Stdlib__List.take;

const drop = Stdlib__List.drop;

const take_while = Stdlib__List.take_while;

const drop_while = Stdlib__List.drop_while;

const partition = Stdlib__List.partition;

const partition_map = Stdlib__List.partition_map;

const assoc = Stdlib__List.assoc;

const assoc_opt = Stdlib__List.assoc_opt;

const assq = Stdlib__List.assq;

const assq_opt = Stdlib__List.assq_opt;

const mem_assoc = Stdlib__List.mem_assoc;

const mem_assq = Stdlib__List.mem_assq;

const remove_assoc = Stdlib__List.remove_assoc;

const remove_assq = Stdlib__List.remove_assq;

const split = Stdlib__List.split;

const combine = Stdlib__List.combine;

const sort = Stdlib__List.sort;

const stable_sort = Stdlib__List.stable_sort;

const fast_sort = Stdlib__List.fast_sort;

const sort_uniq = Stdlib__List.sort_uniq;

const merge = Stdlib__List.merge;

const to_seq = Stdlib__List.to_seq;

const of_seq = Stdlib__List.of_seq;

export {
  length,
  compare_lengths,
  compare_length_with,
  is_empty,
  cons,
  hd,
  tl,
  nth,
  nth_opt,
  rev,
  init,
  append,
  rev_append,
  concat,
  flatten,
  equal,
  compare,
  iter,
  iteri,
  map,
  mapi,
  rev_map,
  filter_map,
  concat_map,
  fold_left_map,
  fold_left,
  fold_right,
  iter2,
  map2,
  rev_map2,
  fold_left2,
  fold_right2,
  for_all,
  exists,
  for_all2,
  exists2,
  mem,
  memq,
  find,
  find_opt,
  find_index,
  find_map,
  find_mapi,
  filter,
  find_all,
  filteri,
  take,
  drop,
  take_while,
  drop_while,
  partition,
  partition_map,
  assoc,
  assoc_opt,
  assq,
  assq_opt,
  mem_assoc,
  mem_assq,
  remove_assoc,
  remove_assq,
  split,
  combine,
  sort,
  stable_sort,
  fast_sort,
  sort_uniq,
  merge,
  to_seq,
  of_seq,
}
/* No side effect */
`,Rf=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

function Make(funarg) {
  const height = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return 0;
    } else {
      return param.h;
    }
  };
  const create = function (l, x, d, r) {
    const hl = height(l);
    const hr = height(r);
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  };
  const singleton = function (x, d) {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: d,
      r: /* Empty */ 0,
      h: 1
    };
  };
  const bal = function (l, x, d, r) {
    let hl;
    hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
    let hr;
    hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
    if (hl > (hr + 2 | 0)) {
      if (/* tag */ typeof l === "number" || typeof l === "string") {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
      }
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height(ll) >= height(lr)) {
        return create(ll, lv, ld, create(lr, x, d, r));
      }
      if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
        return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    if (hr <= (hl + 2 | 0)) {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: d,
        r: r,
        h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
      };
    }
    if (/* tag */ typeof r === "number" || typeof r === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height(rr) >= height(rl)) {
      return create(create(l, x, d, rl), rv, rd, rr);
    }
    if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
      return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  };
  const is_empty = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return true;
    } else {
      return false;
    }
  };
  const add = function (x, data, m) {
    if (/* tag */ typeof m === "number" || typeof m === "string") {
      return {
        TAG: /* Node */ 0,
        l: /* Empty */ 0,
        v: x,
        d: data,
        r: /* Empty */ 0,
        h: 1
      };
    }
    const r = m.r;
    const d = m.d;
    const v = m.v;
    const l = m.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      if (d === data) {
        return m;
      } else {
        return {
          TAG: /* Node */ 0,
          l: l,
          v: x,
          d: data,
          r: r,
          h: m.h
        };
      }
    }
    if (c < 0) {
      const ll = add(x, data, l);
      if (l === ll) {
        return m;
      } else {
        return bal(ll, v, d, r);
      }
    }
    const rr = add(x, data, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  };
  const find = function (x, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue;
    };
  };
  const find_first = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _d0 = param.d;
        let _param$1 = param.l;
        while (true) {
          const param$1 = _param$1;
          const d0 = _d0;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return [
              v0,
              d0
            ];
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _d0 = param$1.d;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.r;
          continue;
        };
      }
      _param = param.r;
      continue;
    };
  };
  const find_first_opt = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _d0 = param.d;
        let _param$1 = param.l;
        while (true) {
          const param$1 = _param$1;
          const d0 = _d0;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return [
              v0,
              d0
            ];
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _d0 = param$1.d;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.r;
          continue;
        };
      }
      _param = param.r;
      continue;
    };
  };
  const find_last = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _d0 = param.d;
        let _param$1 = param.r;
        while (true) {
          const param$1 = _param$1;
          const d0 = _d0;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return [
              v0,
              d0
            ];
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _d0 = param$1.d;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.l;
          continue;
        };
      }
      _param = param.l;
      continue;
    };
  };
  const find_last_opt = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _d0 = param.d;
        let _param$1 = param.r;
        while (true) {
          const param$1 = _param$1;
          const d0 = _d0;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return [
              v0,
              d0
            ];
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _d0 = param$1.d;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.l;
          continue;
        };
      }
      _param = param.l;
      continue;
    };
  };
  const find_opt = function (x, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return Caml_option.some(param.d);
      }
      _param = c < 0 ? param.l : param.r;
      continue;
    };
  };
  const mem = function (x, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      const c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return true;
      }
      _param = c < 0 ? param.l : param.r;
      continue;
    };
  };
  const min_binding = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const l = param.l;
      if (/* tag */ typeof l === "number" || typeof l === "string") {
        return [
          param.v,
          param.d
        ];
      }
      _param = l;
      continue;
    };
  };
  const min_binding_opt = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const l = param.l;
      if (/* tag */ typeof l === "number" || typeof l === "string") {
        return [
          param.v,
          param.d
        ];
      }
      _param = l;
      continue;
    };
  };
  const max_binding = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      let tmp = param.r;
      if (/* tag */ typeof tmp === "number" || typeof tmp === "string") {
        return [
          param.v,
          param.d
        ];
      }
      _param = param.r;
      continue;
    };
  };
  const max_binding_opt = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      let tmp = param.r;
      if (/* tag */ typeof tmp === "number" || typeof tmp === "string") {
        return [
          param.v,
          param.d
        ];
      }
      _param = param.r;
      continue;
    };
  };
  const remove_min_binding = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.remove_min_elt"
          });
    }
    const l = param.l;
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      return param.r;
    } else {
      return bal(remove_min_binding(l), param.v, param.d, param.r);
    }
  };
  const merge = function (t1, t2) {
    if (/* tag */ typeof t1 === "number" || typeof t1 === "string") {
      return t2;
    }
    if (/* tag */ typeof t2 === "number" || typeof t2 === "string") {
      return t1;
    }
    const match = min_binding(t2);
    return bal(t1, match[0], match[1], remove_min_binding(t2));
  };
  const remove = function (x, m) {
    if (/* tag */ typeof m === "number" || typeof m === "string") {
      return /* Empty */ 0;
    }
    const r = m.r;
    const d = m.d;
    const v = m.v;
    const l = m.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return merge(l, r);
    }
    if (c < 0) {
      const ll = remove(x, l);
      if (l === ll) {
        return m;
      } else {
        return bal(ll, v, d, r);
      }
    }
    const rr = remove(x, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  };
  const update = function (x, f, m) {
    if (/* tag */ typeof m === "number" || typeof m === "string") {
      const data = Curry._1(f, undefined);
      if (data !== undefined) {
        return {
          TAG: /* Node */ 0,
          l: /* Empty */ 0,
          v: x,
          d: Caml_option.valFromOption(data),
          r: /* Empty */ 0,
          h: 1
        };
      } else {
        return /* Empty */ 0;
      }
    }
    const r = m.r;
    const d = m.d;
    const v = m.v;
    const l = m.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      const data$1 = Curry._1(f, Caml_option.some(d));
      if (data$1 === undefined) {
        return merge(l, r);
      }
      const data$2 = Caml_option.valFromOption(data$1);
      if (d === data$2) {
        return m;
      } else {
        return {
          TAG: /* Node */ 0,
          l: l,
          v: x,
          d: data$2,
          r: r,
          h: m.h
        };
      }
    }
    if (c < 0) {
      const ll = update(x, f, l);
      if (l === ll) {
        return m;
      } else {
        return bal(ll, v, d, r);
      }
    }
    const rr = update(x, f, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  };
  const add_to_list = function (x, data, m) {
    const add = function (l) {
      if (l !== undefined) {
        return {
          hd: data,
          tl: l
        };
      } else {
        return {
          hd: data,
          tl: /* [] */ 0
        };
      }
    };
    return update(x, add, m);
  };
  const iter = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      iter(f, param.l);
      Curry._2(f, param.v, param.d);
      _param = param.r;
      continue;
    };
  };
  const map = function (f, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return /* Empty */ 0;
    }
    const l$p = map(f, param.l);
    const d$p = Curry._1(f, param.d);
    const r$p = map(f, param.r);
    return {
      TAG: /* Node */ 0,
      l: l$p,
      v: param.v,
      d: d$p,
      r: r$p,
      h: param.h
    };
  };
  const mapi = function (f, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return /* Empty */ 0;
    }
    const v = param.v;
    const l$p = mapi(f, param.l);
    const d$p = Curry._2(f, v, param.d);
    const r$p = mapi(f, param.r);
    return {
      TAG: /* Node */ 0,
      l: l$p,
      v: v,
      d: d$p,
      r: r$p,
      h: param.h
    };
  };
  const fold = function (f, _m, _accu) {
    while (true) {
      const accu = _accu;
      const m = _m;
      if (/* tag */ typeof m === "number" || typeof m === "string") {
        return accu;
      }
      _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
      _m = m.r;
      continue;
    };
  };
  const for_all = function (p, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return true;
      }
      if (!Curry._2(p, param.v, param.d)) {
        return false;
      }
      if (!for_all(p, param.l)) {
        return false;
      }
      _param = param.r;
      continue;
    };
  };
  const exists = function (p, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (Curry._2(p, param.v, param.d)) {
        return true;
      }
      if (exists(p, param.l)) {
        return true;
      }
      _param = param.r;
      continue;
    };
  };
  const add_min_binding = function (k, x, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return singleton(k, x);
    } else {
      return bal(add_min_binding(k, x, param.l), param.v, param.d, param.r);
    }
  };
  const add_max_binding = function (k, x, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return singleton(k, x);
    } else {
      return bal(param.l, param.v, param.d, add_max_binding(k, x, param.r));
    }
  };
  const join = function (l, v, d, r) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      return add_min_binding(v, d, r);
    }
    const lh = l.h;
    if (/* tag */ typeof r === "number" || typeof r === "string") {
      return add_max_binding(v, d, l);
    }
    const rh = r.h;
    if (lh > (rh + 2 | 0)) {
      return bal(l.l, l.v, l.d, join(l.r, v, d, r));
    } else if (rh > (lh + 2 | 0)) {
      return bal(join(l, v, d, r.l), r.v, r.d, r.r);
    } else {
      return create(l, v, d, r);
    }
  };
  const concat = function (t1, t2) {
    if (/* tag */ typeof t1 === "number" || typeof t1 === "string") {
      return t2;
    }
    if (/* tag */ typeof t2 === "number" || typeof t2 === "string") {
      return t1;
    }
    const match = min_binding(t2);
    return join(t1, match[0], match[1], remove_min_binding(t2));
  };
  const concat_or_join = function (t1, v, d, t2) {
    if (d !== undefined) {
      return join(t1, v, Caml_option.valFromOption(d), t2);
    } else {
      return concat(t1, t2);
    }
  };
  const split = function (x, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return [
        /* Empty */ 0,
        undefined,
        /* Empty */ 0
      ];
    }
    const r = param.r;
    const d = param.d;
    const v = param.v;
    const l = param.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return [
        l,
        Caml_option.some(d),
        r
      ];
    }
    if (c < 0) {
      const match = split(x, l);
      return [
        match[0],
        match[1],
        join(match[2], v, d, r)
      ];
    }
    const match$1 = split(x, r);
    return [
      join(l, v, d, match$1[0]),
      match$1[1],
      match$1[2]
    ];
  };
  const merge$1 = function (f, s1, s2) {
    if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
      if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
        return /* Empty */ 0;
      }
      
    } else {
      const v1 = s1.v;
      if (s1.h >= height(s2)) {
        const match = split(v1, s2);
        return concat_or_join(merge$1(f, s1.l, match[0]), v1, Curry._3(f, v1, Caml_option.some(s1.d), match[1]), merge$1(f, s1.r, match[2]));
      }
      
    }
    if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/stdlib/map.ml",
              408,
              10
            ]
          });
    }
    const v2 = s2.v;
    const match$1 = split(v2, s1);
    return concat_or_join(merge$1(f, match$1[0], s2.l), v2, Curry._3(f, v2, match$1[1], Caml_option.some(s2.d)), merge$1(f, match$1[2], s2.r));
  };
  const union = function (f, s1, s2) {
    if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
      return s2;
    }
    const d1 = s1.d;
    const v1 = s1.v;
    if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
      return s1;
    }
    const d2 = s2.d;
    const v2 = s2.v;
    if (s1.h >= s2.h) {
      const match = split(v1, s2);
      const d2$1 = match[1];
      const l = union(f, s1.l, match[0]);
      const r = union(f, s1.r, match[2]);
      if (d2$1 !== undefined) {
        return concat_or_join(l, v1, Curry._3(f, v1, d1, Caml_option.valFromOption(d2$1)), r);
      } else {
        return join(l, v1, d1, r);
      }
    }
    const match$1 = split(v2, s1);
    const d1$1 = match$1[1];
    const l$1 = union(f, match$1[0], s2.l);
    const r$1 = union(f, match$1[2], s2.r);
    if (d1$1 !== undefined) {
      return concat_or_join(l$1, v2, Curry._3(f, v2, Caml_option.valFromOption(d1$1), d2), r$1);
    } else {
      return join(l$1, v2, d2, r$1);
    }
  };
  const filter = function (p, m) {
    if (/* tag */ typeof m === "number" || typeof m === "string") {
      return /* Empty */ 0;
    }
    const r = m.r;
    const d = m.d;
    const v = m.v;
    const l = m.l;
    const l$p = filter(p, l);
    const pvd = Curry._2(p, v, d);
    const r$p = filter(p, r);
    if (pvd) {
      if (l === l$p && r === r$p) {
        return m;
      } else {
        return join(l$p, v, d, r$p);
      }
    } else {
      return concat(l$p, r$p);
    }
  };
  const filter_map = function (f, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return /* Empty */ 0;
    }
    const v = param.v;
    const l$p = filter_map(f, param.l);
    const fvd = Curry._2(f, v, param.d);
    const r$p = filter_map(f, param.r);
    if (fvd !== undefined) {
      return join(l$p, v, Caml_option.valFromOption(fvd), r$p);
    } else {
      return concat(l$p, r$p);
    }
  };
  const partition = function (p, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return [
        /* Empty */ 0,
        /* Empty */ 0
      ];
    }
    const d = param.d;
    const v = param.v;
    const match = partition(p, param.l);
    const lf = match[1];
    const lt = match[0];
    const pvd = Curry._2(p, v, d);
    const match$1 = partition(p, param.r);
    const rf = match$1[1];
    const rt = match$1[0];
    if (pvd) {
      return [
        join(lt, v, d, rt),
        concat(lf, rf)
      ];
    } else {
      return [
        concat(lt, rt),
        join(lf, v, d, rf)
      ];
    }
  };
  const cons_enum = function (_m, _e) {
    while (true) {
      const e = _e;
      const m = _m;
      if (/* tag */ typeof m === "number" || typeof m === "string") {
        return e;
      }
      _e = {
        TAG: /* More */ 0,
        _0: m.v,
        _1: m.d,
        _2: m.r,
        _3: e
      };
      _m = m.l;
      continue;
    };
  };
  const compare = function (cmp, m1, m2) {
    let _e1 = cons_enum(m1, /* End */ 0);
    let _e2 = cons_enum(m2, /* End */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (/* tag */ typeof e1 === "number" || typeof e1 === "string") {
        if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
          return 0;
        } else {
          return -1;
        }
      }
      if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
        return 1;
      }
      const c = Curry._2(funarg.compare, e1._0, e2._0);
      if (c !== 0) {
        return c;
      }
      const c$1 = Curry._2(cmp, e1._1, e2._1);
      if (c$1 !== 0) {
        return c$1;
      }
      _e2 = cons_enum(e2._2, e2._3);
      _e1 = cons_enum(e1._2, e1._3);
      continue;
    };
  };
  const equal = function (cmp, m1, m2) {
    let _e1 = cons_enum(m1, /* End */ 0);
    let _e2 = cons_enum(m2, /* End */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (/* tag */ typeof e1 === "number" || typeof e1 === "string") {
        if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
          return true;
        } else {
          return false;
        }
      }
      if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
        return false;
      }
      if (Curry._2(funarg.compare, e1._0, e2._0) !== 0) {
        return false;
      }
      if (!Curry._2(cmp, e1._1, e2._1)) {
        return false;
      }
      _e2 = cons_enum(e2._2, e2._3);
      _e1 = cons_enum(e1._2, e1._3);
      continue;
    };
  };
  const cardinal = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return 0;
    } else {
      return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
    }
  };
  const bindings_aux = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param.l;
      _accu = {
        hd: [
          param.v,
          param.d
        ],
        tl: bindings_aux(accu, param.r)
      };
      continue;
    };
  };
  const bindings = function (s) {
    return bindings_aux(/* [] */ 0, s);
  };
  const of_list = function (bs) {
    return Stdlib__List.fold_left((function (m, param) {
      return add(param[0], param[1], m);
    }), /* Empty */ 0, bs);
  };
  const add_seq = function (i, m) {
    return Stdlib__Seq.fold_left((function (m, param) {
      return add(param[0], param[1], m);
    }), m, i);
  };
  const of_seq = function (i) {
    return add_seq(i, /* Empty */ 0);
  };
  const seq_of_enum_ = function (c, param) {
    if (/* tag */ typeof c === "number" || typeof c === "string") {
      return /* Nil */ 0;
    }
    const partial_arg = cons_enum(c._2, c._3);
    return {
      TAG: /* Cons */ 0,
      _0: [
        c._0,
        c._1
      ],
      _1: (function (param) {
        return seq_of_enum_(partial_arg, param);
      })
    };
  };
  const to_seq = function (m) {
    const partial_arg = cons_enum(m, /* End */ 0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  const snoc_enum = function (_s, _e) {
    while (true) {
      const e = _e;
      const s = _s;
      if (/* tag */ typeof s === "number" || typeof s === "string") {
        return e;
      }
      _e = {
        TAG: /* More */ 0,
        _0: s.v,
        _1: s.d,
        _2: s.l,
        _3: e
      };
      _s = s.r;
      continue;
    };
  };
  const rev_seq_of_enum_ = function (c, param) {
    if (/* tag */ typeof c === "number" || typeof c === "string") {
      return /* Nil */ 0;
    }
    const partial_arg = snoc_enum(c._2, c._3);
    return {
      TAG: /* Cons */ 0,
      _0: [
        c._0,
        c._1
      ],
      _1: (function (param) {
        return rev_seq_of_enum_(partial_arg, param);
      })
    };
  };
  const to_rev_seq = function (c) {
    const partial_arg = snoc_enum(c, /* End */ 0);
    return function (param) {
      return rev_seq_of_enum_(partial_arg, param);
    };
  };
  const to_seq_from = function (low, m) {
    const aux = function (low, _m, _c) {
      while (true) {
        const c = _c;
        const m = _m;
        if (/* tag */ typeof m === "number" || typeof m === "string") {
          return c;
        }
        const r = m.r;
        const d = m.d;
        const v = m.v;
        const n = Curry._2(funarg.compare, v, low);
        if (n === 0) {
          return {
            TAG: /* More */ 0,
            _0: v,
            _1: d,
            _2: r,
            _3: c
          };
        }
        if (n < 0) {
          _m = r;
          continue;
        }
        _c = {
          TAG: /* More */ 0,
          _0: v,
          _1: d,
          _2: r,
          _3: c
        };
        _m = m.l;
        continue;
      };
    };
    const partial_arg = aux(low, m, /* End */ 0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  return {
    empty: /* Empty */ 0,
    add: add,
    add_to_list: add_to_list,
    update: update,
    singleton: singleton,
    remove: remove,
    merge: merge$1,
    union: union,
    cardinal: cardinal,
    bindings: bindings,
    min_binding: min_binding,
    min_binding_opt: min_binding_opt,
    max_binding: max_binding,
    max_binding_opt: max_binding_opt,
    choose: min_binding,
    choose_opt: min_binding_opt,
    find: find,
    find_opt: find_opt,
    find_first: find_first,
    find_first_opt: find_first_opt,
    find_last: find_last,
    find_last_opt: find_last_opt,
    iter: iter,
    fold: fold,
    map: map,
    mapi: mapi,
    filter: filter,
    filter_map: filter_map,
    partition: partition,
    split: split,
    is_empty: is_empty,
    mem: mem,
    equal: equal,
    compare: compare,
    for_all: for_all,
    exists: exists,
    to_list: bindings,
    of_list: of_list,
    to_seq: to_seq,
    to_rev_seq: to_rev_seq,
    to_seq_from: to_seq_from,
    add_seq: add_seq,
    of_seq: of_seq
  };
}

export {
  Make,
}
/* No side effect */
`,Vf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function to_buffer(buff, ofs, len, v, flags) {
  if (ofs < 0 || len < 0 || ofs > (buff.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.to_buffer: substring out of bounds"
        });
  }
  return Caml_external_polyfill.resolve("caml_output_value_to_buffer")(buff, ofs, len, v, flags);
}

function data_size(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 16 | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.data_size"
        });
  }
  return Caml_external_polyfill.resolve("caml_marshal_data_size")(buff, ofs);
}

function total_size(buff, ofs) {
  return 16 + data_size(buff, ofs) | 0;
}

function from_bytes(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 16 | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.from_bytes"
        });
  }
  const len = Caml_external_polyfill.resolve("caml_marshal_data_size")(buff, ofs);
  if (ofs > (buff.length - (16 + len | 0) | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.from_bytes"
        });
  }
  return Caml_external_polyfill.resolve("caml_input_value_from_bytes")(buff, ofs);
}

function from_string(buff, ofs) {
  return from_bytes(Caml_bytes.bytes_of_string(buff), ofs);
}

function to_channel(prim0, prim1, prim2) {
  return Caml_external_polyfill.resolve("caml_output_value")(prim0, prim1, prim2);
}

function from_channel(prim) {
  return Caml_external_polyfill.resolve("caml_input_value")(prim);
}

const header_size = 16;

export {
  to_channel,
  to_buffer,
  from_channel,
  from_bytes,
  from_string,
  header_size,
  data_size,
  total_size,
}
/* No side effect */
`,qf=`// Generated by Melange

import * as Stdlib__Hashtbl from "./hashtbl.js";
import * as Stdlib__Map from "./map.js";
import * as Stdlib__Set from "./set.js";

const Hashtbl = Stdlib__Hashtbl;

const $$Map = Stdlib__Map;

const $$Set = Stdlib__Set;

export {
  Hashtbl,
  $$Map,
  $$Set,
}
/* Stdlib__Hashtbl Not a pure module */
`,Xf=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";

function create(param) {
  return {
    contents: false
  };
}

function lock(t) {
  t.contents = true;
}

function try_lock(t) {
  if (t.contents) {
    return false;
  } else {
    t.contents = true;
    return true;
  }
}

function unlock(t) {
  t.contents = false;
}

function protect(m, f) {
  m.contents = true;
  let x;
  try {
    x = Curry._1(f, undefined);
  }
  catch (e){
    m.contents = false;
    throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
  }
  m.contents = false;
  return x;
}

export {
  create,
  lock,
  try_lock,
  unlock,
  protect,
}
/* No side effect */
`,Wf=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Stdlib__Sys from "./sys.js";

function is_block(a) {
  return typeof a !== "number";
}

function double_field(x, i) {
  return Caml_external_polyfill.resolve("caml_floatarray_get")(x, i);
}

function set_double_field(x, i, v) {
  Caml_external_polyfill.resolve("caml_floatarray_set")(x, i, v);
}

function of_val(x) {
  const slot = typeof x !== "number" && x.TAG !== 248 && (x.length | 0) >= 1 ? x[0] : x;
  let name;
  if (typeof slot !== "number" && slot.TAG === 248) {
    name = slot[0];
  } else {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Obj.extension_constructor"
        });
  }
  if (name.TAG === 252) {
    return slot;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Obj.extension_constructor"
      });
}

function name(slot) {
  return slot[0];
}

function id(slot) {
  return slot[1];
}

const Extension_constructor = {
  of_val: of_val,
  name: name,
  id: id
};

const max_ephe_length = Stdlib__Sys.max_array_length - 2 | 0;

function create(l) {
  if (!(0 <= l && l <= max_ephe_length)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Obj.Ephemeron.create"
        });
  }
  return Caml_external_polyfill.resolve("caml_ephe_create")(l);
}

function length(x) {
  return (x.length | 0) - 2 | 0;
}

function raise_if_invalid_offset(e, o, msg) {
  if (0 <= o && o < ((e.length | 0) - 2 | 0)) {
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: msg
      });
}

function get_key(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.get_key");
  return Caml_external_polyfill.resolve("caml_ephe_get_key")(e, o);
}

function get_key_copy(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.get_key_copy");
  return Caml_external_polyfill.resolve("caml_ephe_get_key_copy")(e, o);
}

function set_key(e, o, x) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.set_key");
  Caml_external_polyfill.resolve("caml_ephe_set_key")(e, o, x);
}

function unset_key(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.unset_key");
  Caml_external_polyfill.resolve("caml_ephe_unset_key")(e, o);
}

function check_key(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.check_key");
  return Caml_external_polyfill.resolve("caml_ephe_check_key")(e, o);
}

function blit_key(e1, o1, e2, o2, l) {
  if (l < 0 || o1 < 0 || o1 > (((e1.length | 0) - 2 | 0) - l | 0) || o2 < 0 || o2 > (((e2.length | 0) - 2 | 0) - l | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Obj.Ephemeron.blit_key"
        });
  }
  if (l !== 0) {
    return Caml_external_polyfill.resolve("caml_ephe_blit_key")(e1, o1, e2, o2, l);
  }
  
}

const first_non_constant_constructor_tag = 0;

const last_non_constant_constructor_tag = 243;

const forcing_tag = 244;

const cont_tag = 245;

const lazy_tag = 246;

const closure_tag = 247;

const object_tag = 248;

const infix_tag = 249;

const forward_tag = 250;

const no_scan_tag = 251;

const abstract_tag = 251;

const string_tag = 252;

const double_tag = 253;

const double_array_tag = 254;

const custom_tag = 255;

const int_tag = 1000;

const out_of_heap_tag = 1001;

const unaligned_tag = 1002;

function Ephemeron_get_data(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_get_data")(prim);
}

function Ephemeron_get_data_copy(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_get_data_copy")(prim);
}

function Ephemeron_set_data(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ephe_set_data")(prim0, prim1);
}

function Ephemeron_unset_data(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_unset_data")(prim);
}

function Ephemeron_check_data(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_check_data")(prim);
}

function Ephemeron_blit_data(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ephe_blit_data")(prim0, prim1);
}

const Ephemeron = {
  create: create,
  length: length,
  get_key: get_key,
  get_key_copy: get_key_copy,
  set_key: set_key,
  unset_key: unset_key,
  check_key: check_key,
  blit_key: blit_key,
  get_data: Ephemeron_get_data,
  get_data_copy: Ephemeron_get_data_copy,
  set_data: Ephemeron_set_data,
  unset_data: Ephemeron_unset_data,
  check_data: Ephemeron_check_data,
  blit_data: Ephemeron_blit_data,
  max_ephe_length: max_ephe_length
};

export {
  is_block,
  double_field,
  set_double_field,
  first_non_constant_constructor_tag,
  last_non_constant_constructor_tag,
  forcing_tag,
  cont_tag,
  lazy_tag,
  closure_tag,
  object_tag,
  infix_tag,
  forward_tag,
  no_scan_tag,
  abstract_tag,
  string_tag,
  double_tag,
  double_array_tag,
  custom_tag,
  int_tag,
  out_of_heap_tag,
  unaligned_tag,
  Extension_constructor,
  Ephemeron,
}
/* No side effect */
`,Kf=`// Generated by Melange

import * as CamlinternalOO from "./camlinternalOO.js";

const copy = CamlinternalOO.copy;

const new_method = CamlinternalOO.public_method_label;

const public_method_label = CamlinternalOO.public_method_label;

export {
  copy,
  new_method,
  public_method_label,
}
/* CamlinternalOO Not a pure module */
`,Hf=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

function some(v) {
  return Caml_option.some(v);
}

function value(o, $$default) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  } else {
    return $$default;
  }
}

function get(v) {
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "option is None"
      });
}

function bind(o, f) {
  if (o !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(o));
  }
  
}

function join(o) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  }
  
}

function map(f, o) {
  if (o !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(o)));
  }
  
}

function fold(none, some, v) {
  if (v !== undefined) {
    return Curry._1(some, Caml_option.valFromOption(v));
  } else {
    return none;
  }
}

function iter(f, v) {
  if (v !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(v));
  }
  
}

function is_none(param) {
  return param === undefined;
}

function is_some(param) {
  return param !== undefined;
}

function equal(eq, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(eq, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return false;
    }
  } else {
    return o1 === undefined;
  }
}

function compare(cmp, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(cmp, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return 1;
    }
  } else if (o1 !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function to_result(none, v) {
  if (v !== undefined) {
    return {
      TAG: /* Ok */ 0,
      _0: Caml_option.valFromOption(v)
    };
  } else {
    return {
      TAG: /* Error */ 1,
      _0: none
    };
  }
}

function to_list(v) {
  if (v !== undefined) {
    return {
      hd: Caml_option.valFromOption(v),
      tl: /* [] */ 0
    };
  } else {
    return /* [] */ 0;
  }
}

function to_seq(v) {
  if (v === undefined) {
    return Stdlib__Seq.empty;
  }
  const partial_arg = Caml_option.valFromOption(v);
  return function (param) {
    return Stdlib__Seq.$$return(partial_arg, param);
  };
}

let none;

export {
  none,
  some,
  value,
  get,
  bind,
  join,
  map,
  fold,
  iter,
  is_none,
  is_some,
  equal,
  compare,
  to_result,
  to_list,
  to_seq,
}
/* No side effect */
`,Yf=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Fun from "./fun.js";

function with_open(openfun, s, f) {
  const oc = Curry._1(openfun, s);
  return Stdlib__Fun.protect((function (param) {
    Stdlib.close_out_noerr(oc);
  }), (function (param) {
    return Curry._1(f, oc);
  }));
}

function with_open_bin(s, f) {
  return with_open(Stdlib.open_out_bin, s, f);
}

function with_open_text(s, f) {
  return with_open(Stdlib.open_out, s, f);
}

function with_open_gen(flags, perm, s, f) {
  return with_open((function (param) {
    return Stdlib.open_out_gen(flags, perm, param);
  }), s, f);
}

const seek = Stdlib.LargeFile.seek_out;

const pos = Stdlib.LargeFile.pos_out;

const length = Stdlib.LargeFile.out_channel_length;

const stdout = Stdlib.stdout;

const stderr = Stdlib.stderr;

const open_bin = Stdlib.open_out_bin;

const open_text = Stdlib.open_out;

const open_gen = Stdlib.open_out_gen;

const close = Stdlib.close_out;

const close_noerr = Stdlib.close_out_noerr;

const output_char = Stdlib.output_char;

const output_byte = Stdlib.output_byte;

const output_string = Stdlib.output_string;

const output_bytes = Stdlib.output_bytes;

const output = Stdlib.output;

const output_substring = Stdlib.output_substring;

const flush = Stdlib.flush;

const flush_all = Stdlib.flush_all;

const set_binary_mode = Stdlib.set_binary_mode_out;

function is_binary_mode(prim) {
  return Caml_external_polyfill.resolve("caml_ml_is_binary_mode")(prim);
}

function set_buffered(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_buffered")(prim0, prim1);
}

function is_buffered(prim) {
  return Caml_external_polyfill.resolve("caml_ml_is_buffered")(prim);
}

function isatty(prim) {
  return Caml_external_polyfill.resolve("caml_sys_isatty")(prim);
}

export {
  stdout,
  stderr,
  open_bin,
  open_text,
  open_gen,
  with_open_bin,
  with_open_text,
  with_open_gen,
  close,
  close_noerr,
  output_char,
  output_byte,
  output_string,
  output_bytes,
  output,
  output_substring,
  flush,
  flush_all,
  seek,
  pos,
  length,
  set_binary_mode,
  is_binary_mode,
  set_buffered,
  is_buffered,
  isatty,
}
/* Stdlib__Fun Not a pure module */
`,Jf=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_parser from "melange.js/caml_parser.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Lexing from "./lexing.js";

const YYexit = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Parsing.YYexit");

const Parse_error = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Parsing.Parse_error");

const env = {
  s_stack: Caml_array.make(100, 0),
  v_stack: Caml_array.make(100, undefined),
  symb_start_stack: Caml_array.make(100, Stdlib__Lexing.dummy_pos),
  symb_end_stack: Caml_array.make(100, Stdlib__Lexing.dummy_pos),
  stacksize: 100,
  stackbase: 0,
  curr_char: 0,
  lval: undefined,
  symb_start: Stdlib__Lexing.dummy_pos,
  symb_end: Stdlib__Lexing.dummy_pos,
  asp: 0,
  rule_len: 0,
  rule_number: 0,
  sp: 0,
  state: 0,
  errflag: 0
};

function grow_stacks(param) {
  const oldsize = env.stacksize;
  const newsize = (oldsize << 1);
  const new_s = Caml_array.make(newsize, 0);
  const new_v = Caml_array.make(newsize, undefined);
  const new_start = Caml_array.make(newsize, Stdlib__Lexing.dummy_pos);
  const new_end = Caml_array.make(newsize, Stdlib__Lexing.dummy_pos);
  Stdlib__Array.blit(env.s_stack, 0, new_s, 0, oldsize);
  env.s_stack = new_s;
  Stdlib__Array.blit(env.v_stack, 0, new_v, 0, oldsize);
  env.v_stack = new_v;
  Stdlib__Array.blit(env.symb_start_stack, 0, new_start, 0, oldsize);
  env.symb_start_stack = new_start;
  Stdlib__Array.blit(env.symb_end_stack, 0, new_end, 0, oldsize);
  env.symb_end_stack = new_end;
  env.stacksize = newsize;
}

function clear_parser(param) {
  Stdlib__Array.fill(env.v_stack, 0, env.stacksize, undefined);
  env.lval = undefined;
}

const current_lookahead_fun = {
  contents: (function (param) {
    return false;
  })
};

function yyparse(tables, start, lexer, lexbuf) {
  const init_asp = env.asp;
  const init_sp = env.sp;
  const init_stackbase = env.stackbase;
  const init_state = env.state;
  const init_curr_char = env.curr_char;
  const init_lval = env.lval;
  const init_errflag = env.errflag;
  env.stackbase = env.sp + 1 | 0;
  env.curr_char = start;
  env.symb_end = lexbuf.lex_curr_p;
  try {
    let _cmd = /* Start */ 0;
    let _arg;
    while (true) {
      const arg = _arg;
      const cmd = _cmd;
      const match = Caml_parser.caml_parse_engine(tables, env, cmd, arg);
      switch (match) {
        case /* Read_token */ 0 :
          const t = Curry._1(lexer, lexbuf);
          env.symb_start = lexbuf.lex_start_p;
          env.symb_end = lexbuf.lex_curr_p;
          _arg = t;
          _cmd = /* Token_read */ 1;
          continue;
        case /* Raise_parse_error */ 1 :
          throw new Caml_js_exceptions.MelangeError(Parse_error, {
                MEL_EXN_ID: Parse_error
              });
        case /* Grow_stacks_1 */ 2 :
          grow_stacks(undefined);
          _arg = undefined;
          _cmd = /* Stacks_grown_1 */ 2;
          continue;
        case /* Grow_stacks_2 */ 3 :
          grow_stacks(undefined);
          _arg = undefined;
          _cmd = /* Stacks_grown_2 */ 3;
          continue;
        case /* Compute_semantic_action */ 4 :
          let match$1;
          try {
            match$1 = [
              /* Semantic_action_computed */ 4,
              Curry._1(Caml_array.get(tables.actions, env.rule_number), env)
            ];
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Parse_error) {
              match$1 = [
                /* Error_detected */ 5,
                undefined
              ];
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          _arg = match$1[1];
          _cmd = match$1[0];
          continue;
        case /* Call_error_function */ 5 :
          Curry._1(tables.error_function, "syntax error");
          _arg = undefined;
          _cmd = /* Error_detected */ 5;
          continue;
      }
    };
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    const curr_char = env.curr_char;
    env.asp = init_asp;
    env.sp = init_sp;
    env.stackbase = init_stackbase;
    env.state = init_state;
    env.curr_char = init_curr_char;
    env.lval = init_lval;
    env.errflag = init_errflag;
    if (exn$1.MEL_EXN_ID === YYexit) {
      return exn$1._1;
    }
    current_lookahead_fun.contents = (function (tok) {
      if (typeof tok !== "number") {
        return Caml_array.get(tables.transl_block, tok.TAG) === curr_char;
      } else {
        return Caml_array.get(tables.transl_const, tok) === curr_char;
      }
    });
    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
  }
}

function peek_val(env, n) {
  return Caml_array.get(env.v_stack, env.asp - n | 0);
}

function symbol_start_pos(param) {
  let _i = env.rule_len;
  while (true) {
    const i = _i;
    if (i <= 0) {
      return Caml_array.get(env.symb_end_stack, env.asp);
    }
    const st = Caml_array.get(env.symb_start_stack, (env.asp - i | 0) + 1 | 0);
    const en = Caml_array.get(env.symb_end_stack, (env.asp - i | 0) + 1 | 0);
    if (Caml_obj.caml_notequal(st, en)) {
      return st;
    }
    _i = i - 1 | 0;
    continue;
  };
}

function symbol_end_pos(param) {
  return Caml_array.get(env.symb_end_stack, env.asp);
}

function rhs_start_pos(n) {
  return Caml_array.get(env.symb_start_stack, env.asp - (env.rule_len - n | 0) | 0);
}

function rhs_end_pos(n) {
  return Caml_array.get(env.symb_end_stack, env.asp - (env.rule_len - n | 0) | 0);
}

function symbol_start(param) {
  return symbol_start_pos(undefined).pos_cnum;
}

function symbol_end(param) {
  return symbol_end_pos(undefined).pos_cnum;
}

function rhs_start(n) {
  return rhs_start_pos(n).pos_cnum;
}

function rhs_end(n) {
  return rhs_end_pos(n).pos_cnum;
}

function is_current_lookahead(tok) {
  return Curry._1(current_lookahead_fun.contents, tok);
}

function parse_error(param) {
  
}

const set_trace = Caml_parser.caml_set_parser_trace;

export {
  symbol_start,
  symbol_end,
  rhs_start,
  rhs_end,
  symbol_start_pos,
  symbol_end_pos,
  rhs_start_pos,
  rhs_end_pos,
  clear_parser,
  Parse_error,
  set_trace,
  YYexit,
  yyparse,
  peek_val,
  is_current_lookahead,
  parse_error,
}
/* No side effect */
`,Zf=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Atomic from "./atomic.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Printf from "./printf.js";

const printers = Stdlib__Atomic.make(/* [] */ 0);

const locfmt = {
  TAG: /* Format */ 0,
  _0: {
    TAG: /* String_literal */ 11,
    _0: "File \\"",
    _1: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* String_literal */ 11,
        _0: "\\", line ",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: ", characters ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* Char_literal */ 12,
                _0: /* '-' */45,
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: {
                    TAG: /* String_literal */ 11,
                    _0: ": ",
                    _1: {
                      TAG: /* String */ 2,
                      _0: /* No_padding */ 0,
                      _1: /* End_of_format */ 0
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  _1: "File \\"%s\\", line %d, characters %d-%d: %s"
};

const fields = (function(x){
  var s = ""
  var index = 1
  while ("_"+index in x){
    s += x ["_" + index];
    ++ index
  }
  if(index === 1){
    return s
  }
  return "(" + s + ")"
}
);

function use_printers(x) {
  let _param = Stdlib__Atomic.get(printers);
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const tl = param.tl;
    let s;
    try {
      s = Curry._1(param.hd, x);
    }
    catch (exn){
      _param = tl;
      continue;
    }
    if (s !== undefined) {
      return Caml_option.some(Caml_option.valFromOption(s));
    }
    _param = tl;
    continue;
  };
}

function to_string_default(x) {
  if (x.MEL_EXN_ID === Stdlib.Out_of_memory) {
    return "Out of memory";
  }
  if (x.MEL_EXN_ID === Stdlib.Stack_overflow) {
    return "Stack overflow";
  }
  if (x.MEL_EXN_ID === Stdlib.Match_failure) {
    const match = x._1;
    const $$char = match[2];
    return Curry._5(Stdlib__Printf.sprintf(locfmt), match[0], match[1], $$char, $$char + 5 | 0, "Pattern matching failed");
  }
  if (x.MEL_EXN_ID === Stdlib.Assert_failure) {
    const match$1 = x._1;
    const $$char$1 = match$1[2];
    return Curry._5(Stdlib__Printf.sprintf(locfmt), match$1[0], match$1[1], $$char$1, $$char$1 + 6 | 0, "Assertion failed");
  }
  if (x.MEL_EXN_ID === Stdlib.Undefined_recursive_module) {
    const match$2 = x._1;
    const $$char$2 = match$2[2];
    return Curry._5(Stdlib__Printf.sprintf(locfmt), match$2[0], match$2[1], $$char$2, $$char$2 + 6 | 0, "Undefined recursive module");
  }
  const constructor = Caml_exceptions.caml_exn_slot_name(x);
  return constructor + fields(x);
}

function to_string(e) {
  const s = use_printers(e);
  if (s !== undefined) {
    return s;
  } else {
    return to_string_default(e);
  }
}

function print(fct, arg) {
  try {
    return Curry._1(fct, arg);
  }
  catch (raw_x){
    const x = Caml_js_exceptions.internalToOCamlException(raw_x);
    Curry._1(Stdlib__Printf.eprintf({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Uncaught exception: ",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* Char_literal */ 12,
            _0: /* '\\n' */10,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "Uncaught exception: %s\\n"
    }), to_string(x));
    Caml_io.caml_ml_flush(Stdlib.stderr);
    throw new Caml_js_exceptions.MelangeError(x.MEL_EXN_ID, x);
  }
}

function $$catch(fct, arg) {
  try {
    return Curry._1(fct, arg);
  }
  catch (raw_x){
    const x = Caml_js_exceptions.internalToOCamlException(raw_x);
    Caml_io.caml_ml_flush(Stdlib.stdout);
    Curry._1(Stdlib__Printf.eprintf({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Uncaught exception: ",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* Char_literal */ 12,
            _0: /* '\\n' */10,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "Uncaught exception: %s\\n"
    }), to_string(x));
    return Stdlib.exit(2);
  }
}

function raw_backtrace_entries(bt) {
  return bt;
}

function convert_raw_backtrace_slot(param) {
  throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "convert_raw_backtrace_slot not implemented"
      });
}

function convert_raw_backtrace(bt) {
  try {
    return undefined;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function format_backtrace_slot(pos, slot) {
  const info = function (is_raise) {
    if (is_raise) {
      if (pos === 0) {
        return "Raised at";
      } else {
        return "Re-raised at";
      }
    } else if (pos === 0) {
      return "Raised by primitive operation at";
    } else {
      return "Called from";
    }
  };
  if (slot.TAG !== /* Known_location */ 0) {
    if (slot.is_raise) {
      return;
    } else {
      return Curry._1(Stdlib__Printf.sprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: " unknown location",
            _1: /* End_of_format */ 0
          }
        },
        _1: "%s unknown location"
      }), info(false));
    }
  }
  const lines = slot.start_lnum === slot.end_lnum ? Curry._1(Stdlib__Printf.sprintf({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* Char_literal */ 12,
        _0: /* ' ' */32,
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: /* End_of_format */ 0
        }
      },
      _1: " %d"
    }), slot.start_lnum) : Curry._2(Stdlib__Printf.sprintf({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "s ",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* Char_literal */ 12,
            _0: /* '-' */45,
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: /* End_of_format */ 0
            }
          }
        }
      },
      _1: "s %d-%d"
    }), slot.start_lnum, slot.end_lnum);
  return Curry._7(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* Char_literal */ 12,
        _0: /* ' ' */32,
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: " in file \\"",
            _1: {
              TAG: /* String */ 2,
              _0: /* No_padding */ 0,
              _1: {
                TAG: /* Char_literal */ 12,
                _0: /* '"' */34,
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* String_literal */ 11,
                    _0: ", line",
                    _1: {
                      TAG: /* String */ 2,
                      _0: /* No_padding */ 0,
                      _1: {
                        TAG: /* String_literal */ 11,
                        _0: ", characters ",
                        _1: {
                          TAG: /* Int */ 4,
                          _0: /* Int_d */ 0,
                          _1: /* No_padding */ 0,
                          _2: /* No_precision */ 0,
                          _3: {
                            TAG: /* Char_literal */ 12,
                            _0: /* '-' */45,
                            _1: {
                              TAG: /* Int */ 4,
                              _0: /* Int_d */ 0,
                              _1: /* No_padding */ 0,
                              _2: /* No_precision */ 0,
                              _3: /* End_of_format */ 0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    _1: "%s %s in file \\"%s\\"%s, line%s, characters %d-%d"
  }), info(slot.is_raise), slot.defname, slot.filename, slot.is_inline ? " (inlined)" : "", lines, slot.start_char, slot.end_char);
}

function print_raw_backtrace(outchan, raw_backtrace) {
  let backtrace = convert_raw_backtrace(raw_backtrace);
  if (backtrace === undefined) {
    return Stdlib__Printf.fprintf(outchan, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "(Program not linked with -g, cannot print stack backtrace)\\n",
        _1: /* End_of_format */ 0
      },
      _1: "(Program not linked with -g, cannot print stack backtrace)\\n"
    });
  }
  for (let i = 0, i_finish = backtrace.length; i < i_finish; ++i) {
    const str = format_backtrace_slot(i, Caml_array.get(backtrace, i));
    if (str !== undefined) {
      Curry._1(Stdlib__Printf.fprintf(outchan, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* Char_literal */ 12,
            _0: /* '\\n' */10,
            _1: /* End_of_format */ 0
          }
        },
        _1: "%s\\n"
      }), str);
    }
    
  }
}

function print_backtrace(outchan) {
  print_raw_backtrace(outchan, undefined);
}

function raw_backtrace_to_string(raw_backtrace) {
  let backtrace = convert_raw_backtrace(raw_backtrace);
  if (backtrace === undefined) {
    return "(Program not linked with -g, cannot print stack backtrace)\\n";
  }
  const b = Stdlib__Buffer.create(1024);
  for (let i = 0, i_finish = backtrace.length; i < i_finish; ++i) {
    const str = format_backtrace_slot(i, Caml_array.get(backtrace, i));
    if (str !== undefined) {
      Curry._1(Stdlib__Printf.bprintf(b, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* Char_literal */ 12,
            _0: /* '\\n' */10,
            _1: /* End_of_format */ 0
          }
        },
        _1: "%s\\n"
      }), str);
    }
    
  }
  return Stdlib__Buffer.contents(b);
}

function backtrace_slot_is_raise(l) {
  return l.is_raise;
}

function backtrace_slot_is_inline(l) {
  if (l.TAG === /* Known_location */ 0) {
    return l.is_inline;
  } else {
    return false;
  }
}

function backtrace_slot_location(l) {
  if (l.TAG === /* Known_location */ 0) {
    return {
      filename: l.filename,
      line_number: l.start_lnum,
      start_char: l.start_char,
      end_char: l.end_offset,
      end_line: l.end_lnum,
      end_col: l.end_char
    };
  }
  
}

function backtrace_slot_defname(l) {
  if (l.TAG === /* Known_location */ 0 && l.defname !== "") {
    return l.defname;
  }
  
}

function backtrace_slots(raw_backtrace) {
  const backtrace = convert_raw_backtrace(raw_backtrace);
  if (backtrace === undefined) {
    return;
  }
  const usable_slot = function (param) {
    if (param.TAG === /* Known_location */ 0) {
      return true;
    } else {
      return false;
    }
  };
  const exists_usable = function (_i) {
    while (true) {
      const i = _i;
      if (i === -1) {
        return false;
      }
      if (usable_slot(Caml_array.get(backtrace, i))) {
        return true;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  if (exists_usable(backtrace.length - 1 | 0)) {
    return backtrace;
  }
  
}

function backtrace_slots_of_raw_entry(entry) {
  return backtrace_slots([entry]);
}

function raw_backtrace_length(bt) {
  return bt.length;
}

function get_backtrace(param) {
  return raw_backtrace_to_string(undefined);
}

function register_printer(fn) {
  while (true) {
    const old_printers = Stdlib__Atomic.get(printers);
    const new_printers = {
      hd: fn,
      tl: old_printers
    };
    const success = Stdlib__Atomic.compare_and_set(printers, old_printers, new_printers);
    if (success) {
      return;
    }
    continue;
  };
}

const errors = [
  "",
  "(Cannot print locations:\\n bytecode executable program file not found)",
  "(Cannot print locations:\\n bytecode executable program file appears to be corrupt)",
  "(Cannot print locations:\\n bytecode executable program file has wrong magic number)",
  "(Cannot print locations:\\n bytecode executable program file cannot be opened;\\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"
];

function default_uncaught_exception_handler(exn, raw_backtrace) {
  Curry._1(Stdlib__Printf.eprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Fatal error: exception ",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* Char_literal */ 12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "Fatal error: exception %s\\n"
  }), to_string(exn));
  print_raw_backtrace(Stdlib.stderr, raw_backtrace);
  const status = Caml_external_polyfill.resolve("caml_ml_debug_info_status")(undefined);
  if (status < 0) {
    console.error(Caml_array.get(errors, Stdlib.abs(status)));
  }
  Caml_io.caml_ml_flush(Stdlib.stderr);
}

function set_uncaught_exception_handler(param) {
  
}

function record_backtrace(prim) {
  
}

function backtrace_status(prim) {
  
}

function get_raw_backtrace(prim) {
  
}

const Slot = {
  is_raise: backtrace_slot_is_raise,
  is_inline: backtrace_slot_is_inline,
  $$location: backtrace_slot_location,
  name: backtrace_slot_defname,
  format: format_backtrace_slot
};

function get_raw_backtrace_slot(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_raw_backtrace_slot")(prim0, prim1);
}

function get_raw_backtrace_next_slot(prim) {
  return Caml_external_polyfill.resolve("caml_raw_backtrace_next_slot")(prim);
}

const exn_slot_id = Caml_exceptions.caml_exn_slot_id;

const exn_slot_name = Caml_exceptions.caml_exn_slot_name;

export {
  to_string,
  to_string_default,
  print,
  $$catch,
  print_backtrace,
  get_backtrace,
  record_backtrace,
  backtrace_status,
  register_printer,
  use_printers,
  raw_backtrace_entries,
  get_raw_backtrace,
  print_raw_backtrace,
  raw_backtrace_to_string,
  default_uncaught_exception_handler,
  set_uncaught_exception_handler,
  backtrace_slots,
  backtrace_slots_of_raw_entry,
  Slot,
  raw_backtrace_length,
  get_raw_backtrace_slot,
  convert_raw_backtrace_slot,
  get_raw_backtrace_next_slot,
  exn_slot_id,
  exn_slot_name,
}
/* printers Not a pure module */
`,Qf=`// Generated by Melange

import * as CamlinternalFormat from "./camlinternalFormat.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";

function kfprintf(k, o, param) {
  return CamlinternalFormat.make_printf((function (acc) {
    CamlinternalFormat.output_acc(o, acc);
    return Curry._1(k, o);
  }), /* End_of_acc */ 0, param._0);
}

function kbprintf(k, b, param) {
  return CamlinternalFormat.make_printf((function (acc) {
    CamlinternalFormat.bufput_acc(b, acc);
    return Curry._1(k, b);
  }), /* End_of_acc */ 0, param._0);
}

function ikfprintf(k, oc, param) {
  return CamlinternalFormat.make_iprintf(k, oc, param._0);
}

function fprintf(oc, fmt) {
  return kfprintf((function (prim) {
    
  }), oc, fmt);
}

function bprintf(b, fmt) {
  return kbprintf((function (prim) {
    
  }), b, fmt);
}

function ifprintf(oc, fmt) {
  return ikfprintf((function (prim) {
    
  }), oc, fmt);
}

function ibprintf(b, fmt) {
  return ikfprintf((function (prim) {
    
  }), b, fmt);
}

function printf(fmt) {
  return fprintf(Stdlib.stdout, fmt);
}

function eprintf(fmt) {
  return fprintf(Stdlib.stderr, fmt);
}

function ksprintf(k, param) {
  const k$p = function (acc) {
    const buf = Stdlib__Buffer.create(64);
    CamlinternalFormat.strput_acc(buf, acc);
    return Curry._1(k, Stdlib__Buffer.contents(buf));
  };
  return CamlinternalFormat.make_printf(k$p, /* End_of_acc */ 0, param._0);
}

function sprintf(fmt) {
  return ksprintf((function (s) {
    return s;
  }), fmt);
}

const ikbprintf = ikfprintf;

const kprintf = ksprintf;

export {
  fprintf,
  printf,
  eprintf,
  sprintf,
  bprintf,
  ifprintf,
  ibprintf,
  kfprintf,
  ikfprintf,
  ksprintf,
  kbprintf,
  ikbprintf,
  kprintf,
}
/* No side effect */
`,nm=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

const Empty = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Queue.Empty");

function create(param) {
  return {
    length: 0,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
}

function clear(q) {
  q.length = 0;
  q.first = /* Nil */ 0;
  q.last = /* Nil */ 0;
}

function add(x, q) {
  const cell = {
    TAG: /* Cons */ 0,
    content: x,
    next: /* Nil */ 0
  };
  const last = q.last;
  if (/* tag */ typeof last === "number" || typeof last === "string") {
    q.length = 1;
    q.first = cell;
    q.last = cell;
    return;
  }
  q.length = q.length + 1 | 0;
  last.next = cell;
  q.last = cell;
}

function peek(q) {
  const match = q.first;
  if (!/* tag */ (typeof match === "number" || typeof match === "string")) {
    return match.content;
  }
  throw new Caml_js_exceptions.MelangeError(Empty, {
        MEL_EXN_ID: Empty
      });
}

function peek_opt(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return;
  } else {
    return Caml_option.some(match.content);
  }
}

function take(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    throw new Caml_js_exceptions.MelangeError(Empty, {
          MEL_EXN_ID: Empty
        });
  }
  const content = match.content;
  const match$1 = match.next;
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    clear(q);
    return content;
  }
  const next = match.next;
  q.length = q.length - 1 | 0;
  q.first = next;
  return content;
}

function take_opt(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return;
  }
  const content = match.content;
  const match$1 = match.next;
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    clear(q);
    return Caml_option.some(content);
  }
  const next = match.next;
  q.length = q.length - 1 | 0;
  q.first = next;
  return Caml_option.some(content);
}

function drop(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    throw new Caml_js_exceptions.MelangeError(Empty, {
          MEL_EXN_ID: Empty
        });
  }
  const match$1 = match.next;
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    return clear(q);
  }
  const next = match.next;
  q.length = q.length - 1 | 0;
  q.first = next;
}

function copy(q) {
  let q_res = {
    length: q.length,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
  let _prev = /* Nil */ 0;
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    const prev = _prev;
    if (/* tag */ typeof cell === "number" || typeof cell === "string") {
      q_res.last = prev;
      return q_res;
    }
    const next = cell.next;
    const res = {
      TAG: /* Cons */ 0,
      content: cell.content,
      next: /* Nil */ 0
    };
    if (/* tag */ typeof prev === "number" || typeof prev === "string") {
      q_res.first = res;
    } else {
      prev.next = res;
    }
    _cell = next;
    _prev = res;
    continue;
  };
}

function is_empty(q) {
  return q.length === 0;
}

function length(q) {
  return q.length;
}

function iter(f, q) {
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    if (/* tag */ typeof cell === "number" || typeof cell === "string") {
      return;
    }
    const next = cell.next;
    Curry._1(f, cell.content);
    _cell = next;
    continue;
  };
}

function fold(f, accu, q) {
  let _accu = accu;
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    const accu$1 = _accu;
    if (/* tag */ typeof cell === "number" || typeof cell === "string") {
      return accu$1;
    }
    const next = cell.next;
    const accu$2 = Curry._2(f, accu$1, cell.content);
    _cell = next;
    _accu = accu$2;
    continue;
  };
}

function transfer(q1, q2) {
  if (q1.length <= 0) {
    return;
  }
  const last = q2.last;
  if (/* tag */ typeof last === "number" || typeof last === "string") {
    q2.length = q1.length;
    q2.first = q1.first;
    q2.last = q1.last;
    return clear(q1);
  }
  q2.length = q2.length + q1.length | 0;
  last.next = q1.first;
  q2.last = q1.last;
  clear(q1);
}

function to_seq(q) {
  const aux = function (c, param) {
    if (/* tag */ typeof c === "number" || typeof c === "string") {
      return /* Nil */ 0;
    }
    const next = c.next;
    return {
      TAG: /* Cons */ 0,
      _0: c.content,
      _1: (function (param) {
        return aux(next, param);
      })
    };
  };
  const partial_arg = q.first;
  return function (param) {
    return aux(partial_arg, param);
  };
}

function add_seq(q, i) {
  Stdlib__Seq.iter((function (x) {
    add(x, q);
  }), i);
}

function of_seq(g) {
  const q = {
    length: 0,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
  add_seq(q, g);
  return q;
}

const push = add;

const pop = take;

const top = peek;

export {
  Empty,
  create,
  add,
  push,
  take,
  take_opt,
  pop,
  peek,
  peek_opt,
  top,
  drop,
  clear,
  copy,
  is_empty,
  length,
  iter,
  fold,
  transfer,
  to_seq,
  add_seq,
  of_seq,
}
/* No side effect */
`,tm=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Digest from "./digest.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Int32 from "./int32.js";
import * as Stdlib__Int64 from "./int64.js";

function random_seed(param) {
  return [(Math.floor(Math.random()*0x7fffffff)
    )];
}

function assign(st1, st2) {
  Stdlib__Array.blit(st2.st, 0, st1.st, 0, 55);
  st1.idx = st2.idx;
}

function full_init(s, seed) {
  const combine = function (accu, x) {
    return Stdlib__Digest.string(accu + Caml_format.caml_format_int("%d", x));
  };
  const extract = function (d) {
    return ((Caml_string.get(d, 0) + (Caml_string.get(d, 1) << 8) | 0) + (Caml_string.get(d, 2) << 16) | 0) + (Caml_string.get(d, 3) << 24) | 0;
  };
  const seed$1 = seed.length === 0 ? [0] : seed;
  const l = seed$1.length;
  for (let i = 0; i <= 54; ++i) {
    Caml_array.set(s.st, i, i);
  }
  let accu = "x";
  for (let i$1 = 0, i_finish = 54 + Stdlib__Int.max(55, l) | 0; i$1 <= i_finish; ++i$1) {
    const j = i$1 % 55;
    const k = i$1 % l;
    accu = combine(accu, Caml_array.get(seed$1, k));
    Caml_array.set(s.st, j, (Caml_array.get(s.st, j) ^ extract(accu)) & 1073741823);
  }
  s.idx = 0;
}

function make(seed) {
  const result = {
    st: Caml_array.make(55, 0),
    idx: 0
  };
  full_init(result, seed);
  return result;
}

function make_self_init(param) {
  return make(random_seed(undefined));
}

function copy(s) {
  const result = {
    st: Caml_array.make(55, 0),
    idx: 0
  };
  assign(result, s);
  return result;
}

function bits(s) {
  s.idx = (s.idx + 1 | 0) % 55;
  const curval = Caml_array.get(s.st, s.idx);
  const newval = Caml_array.get(s.st, (s.idx + 24 | 0) % 55) + (curval ^ (curval >>> 25) & 31) | 0;
  const newval30 = newval & 1073741823;
  Caml_array.set(s.st, s.idx, newval30);
  return newval30;
}

function intaux(s, n) {
  while (true) {
    const r = bits(s);
    const v = r % n;
    if ((r - v | 0) <= ((1073741823 - n | 0) + 1 | 0)) {
      return v;
    }
    continue;
  };
}

function $$int(s, bound) {
  if (bound > 1073741823 || bound <= 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.int"
        });
  }
  return intaux(s, bound);
}

function full_int(s, bound) {
  if (bound <= 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.full_int"
        });
  }
  if (bound > 1073741823) {
    while (true) {
      const b1 = bits(s);
      const b2 = bits(s);
      let match;
      if (bound <= 2147483647) {
        const bpos = ((b2 & 1073725440) << 1) | (b1 >>> 15);
        match = [
          bpos,
          2147483647
        ];
      } else {
        const b3 = bits(s);
        const bpos$1 = ((((b3 & 1073741312) << 12) | (b2 >>> 9)) << 20) | (b1 >>> 10);
        match = [
          bpos$1,
          Stdlib.max_int
        ];
      }
      const r = match[0];
      const v = r % bound;
      if ((r - v | 0) <= ((match[1] - bound | 0) + 1 | 0)) {
        return v;
      }
      continue;
    };
  } else {
    return intaux(s, bound);
  }
}

function int32(s, bound) {
  if (bound <= 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.int32"
        });
  }
  while (true) {
    const b1 = bits(s);
    const b2 = ((bits(s) & 1) << 30);
    const r = b1 | b2;
    const v = r % bound;
    if ((r - v | 0) <= ((Stdlib__Int32.max_int - bound | 0) + 1 | 0)) {
      return v;
    }
    continue;
  };
}

function int64(s, bound) {
  if (Caml.i64_le(bound, Caml_int64.zero)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.int64"
        });
  }
  while (true) {
    const b1 = Caml_int64.of_int32(bits(s));
    const b2 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s)), 30);
    const b3 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s) & 7), 60);
    const r = Caml_int64.or_(b1, Caml_int64.or_(b2, b3));
    const v = Caml_int64.mod_(r, bound);
    if (!Caml.i64_gt(Caml_int64.sub(r, v), Caml_int64.add(Caml_int64.sub(Stdlib__Int64.max_int, bound), Caml_int64.one))) {
      return v;
    }
    continue;
  };
}

function rawfloat(s) {
  const r1 = bits(s);
  const r2 = bits(s);
  return (r1 / 1073741824.0 + r2) / 1073741824.0;
}

function $$float(s, bound) {
  return rawfloat(s) * bound;
}

function bool(s) {
  return (bits(s) & 1) === 0;
}

function bits32(s) {
  const b1 = (bits(s) >>> 14);
  const b2 = (bits(s) >>> 14);
  return b1 | (b2 << 16);
}

function bits64(s) {
  const b1 = Caml_int64.lsr_(Caml_int64.of_int32(bits(s)), 9);
  const b2 = Caml_int64.lsr_(Caml_int64.of_int32(bits(s)), 9);
  const b3 = Caml_int64.lsr_(Caml_int64.of_int32(bits(s)), 8);
  return Caml_int64.or_(b1, Caml_int64.or_(Caml_int64.lsl_(b2, 21), Caml_int64.lsl_(b3, 42)));
}

const $$default = {
  st: [
    987910699,
    495797812,
    364182224,
    414272206,
    318284740,
    990407751,
    383018966,
    270373319,
    840823159,
    24560019,
    536292337,
    512266505,
    189156120,
    730249596,
    143776328,
    51606627,
    140166561,
    366354223,
    1003410265,
    700563762,
    981890670,
    913149062,
    526082594,
    1021425055,
    784300257,
    667753350,
    630144451,
    949649812,
    48546892,
    415514493,
    258888527,
    511570777,
    89983870,
    283659902,
    308386020,
    242688715,
    482270760,
    865188196,
    1027664170,
    207196989,
    193777847,
    619708188,
    671350186,
    149669678,
    257044018,
    87658204,
    558145612,
    183450813,
    28133145,
    901332182,
    710253903,
    510646120,
    652377910,
    409934019,
    801085050
  ],
  idx: 0
};

function bits$1(param) {
  return bits($$default);
}

function $$int$1(bound) {
  return $$int($$default, bound);
}

function full_int$1(bound) {
  return full_int($$default, bound);
}

function int32$1(bound) {
  return int32($$default, bound);
}

function int64$1(bound) {
  return int64($$default, bound);
}

function $$float$1(scale) {
  return rawfloat($$default) * scale;
}

function bool$1(param) {
  return bool($$default);
}

function bits32$1(param) {
  return bits32($$default);
}

function bits64$1(param) {
  return bits64($$default);
}

function full_init$1(seed) {
  full_init($$default, seed);
}

function init(seed) {
  full_init($$default, [seed]);
}

function self_init(param) {
  full_init$1(random_seed(undefined));
}

function get_state(param) {
  return copy($$default);
}

function set_state(s) {
  assign($$default, s);
}

const State = {
  make: make,
  make_self_init: make_self_init,
  copy: copy,
  bits: bits,
  $$int: $$int,
  full_int: full_int,
  int32: int32,
  int64: int64,
  $$float: $$float,
  bool: bool,
  bits32: bits32,
  bits64: bits64
};

export {
  init,
  full_init$1 as full_init,
  self_init,
  bits$1 as bits,
  $$int$1 as $$int,
  full_int$1 as full_int,
  int32$1 as int32,
  int64$1 as int64,
  $$float$1 as $$float,
  bool$1 as bool,
  bits32$1 as bits32,
  bits64$1 as bits64,
  State,
  get_state,
  set_state,
}
/* Stdlib__Digest Not a pure module */
`,em=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

function ok(v) {
  return {
    TAG: /* Ok */ 0,
    _0: v
  };
}

function error(e) {
  return {
    TAG: /* Error */ 1,
    _0: e
  };
}

function value(r, $$default) {
  if (r.TAG === /* Ok */ 0) {
    return r._0;
  } else {
    return $$default;
  }
}

function get_ok(v) {
  if (v.TAG === /* Ok */ 0) {
    return v._0;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "result is Error _"
      });
}

function get_error(e) {
  if (e.TAG !== /* Ok */ 0) {
    return e._0;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "result is Ok _"
      });
}

function bind(r, f) {
  if (r.TAG === /* Ok */ 0) {
    return Curry._1(f, r._0);
  } else {
    return r;
  }
}

function join(r) {
  if (r.TAG === /* Ok */ 0) {
    return r._0;
  } else {
    return r;
  }
}

function map(f, v) {
  if (v.TAG === /* Ok */ 0) {
    return {
      TAG: /* Ok */ 0,
      _0: Curry._1(f, v._0)
    };
  } else {
    return v;
  }
}

function map_error(f, e) {
  if (e.TAG === /* Ok */ 0) {
    return e;
  } else {
    return {
      TAG: /* Error */ 1,
      _0: Curry._1(f, e._0)
    };
  }
}

function fold(ok, error, v) {
  if (v.TAG === /* Ok */ 0) {
    return Curry._1(ok, v._0);
  } else {
    return Curry._1(error, v._0);
  }
}

function iter(f, v) {
  if (v.TAG === /* Ok */ 0) {
    return Curry._1(f, v._0);
  }
  
}

function iter_error(f, e) {
  if (e.TAG === /* Ok */ 0) {
    return;
  } else {
    return Curry._1(f, e._0);
  }
}

function is_ok(param) {
  if (param.TAG === /* Ok */ 0) {
    return true;
  } else {
    return false;
  }
}

function is_error(param) {
  if (param.TAG === /* Ok */ 0) {
    return false;
  } else {
    return true;
  }
}

function equal(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */ 0) {
    if (r1.TAG === /* Ok */ 0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return false;
    }
  } else if (r1.TAG === /* Ok */ 0) {
    return false;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function compare(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */ 0) {
    if (r1.TAG === /* Ok */ 0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return -1;
    }
  } else if (r1.TAG === /* Ok */ 0) {
    return 1;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function to_option(v) {
  if (v.TAG === /* Ok */ 0) {
    return Caml_option.some(v._0);
  }
  
}

function to_list(v) {
  if (v.TAG === /* Ok */ 0) {
    return {
      hd: v._0,
      tl: /* [] */ 0
    };
  } else {
    return /* [] */ 0;
  }
}

function to_seq(v) {
  if (v.TAG !== /* Ok */ 0) {
    return Stdlib__Seq.empty;
  }
  const partial_arg = v._0;
  return function (param) {
    return Stdlib__Seq.$$return(partial_arg, param);
  };
}

export {
  ok,
  error,
  value,
  get_ok,
  get_error,
  bind,
  join,
  map,
  map_error,
  fold,
  iter,
  iter_error,
  is_ok,
  is_error,
  equal,
  compare,
  to_option,
  to_list,
  to_seq,
}
/* No side effect */
`,rm=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as CamlinternalFormat from "./camlinternalFormat.js";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__String from "./string.js";

function next_char(ib) {
  try {
    const c = Curry._1(ib.ic_get_next_char, undefined);
    ib.ic_current_char = c;
    ib.ic_current_char_is_valid = true;
    ib.ic_char_count = ib.ic_char_count + 1 | 0;
    if (c === /* '\\n' */10) {
      ib.ic_line_count = ib.ic_line_count + 1 | 0;
    }
    return c;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      ib.ic_current_char = /* '\\000' */0;
      ib.ic_current_char_is_valid = false;
      ib.ic_eof = true;
      return /* '\\000' */0;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function peek_char(ib) {
  if (ib.ic_current_char_is_valid) {
    return ib.ic_current_char;
  } else {
    return next_char(ib);
  }
}

function checked_peek_char(ib) {
  const c = peek_char(ib);
  if (ib.ic_eof) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
          MEL_EXN_ID: Stdlib.End_of_file
        });
  }
  return c;
}

function end_of_input(ib) {
  peek_char(ib);
  return ib.ic_eof;
}

function beginning_of_input(ib) {
  return ib.ic_char_count === 0;
}

function name_of_input(ib) {
  const _ic = ib.ic_input_name;
  if (/* tag */ typeof _ic === "number" || typeof _ic === "string") {
    if (_ic === /* From_function */ 0) {
      return "unnamed function";
    } else {
      return "unnamed character string";
    }
  } else if (_ic.TAG === /* From_channel */ 0) {
    return "unnamed Stdlib input channel";
  } else {
    return _ic._0;
  }
}

function char_count(ib) {
  if (ib.ic_current_char_is_valid) {
    return ib.ic_char_count - 1 | 0;
  } else {
    return ib.ic_char_count;
  }
}

function token(ib) {
  const token_buffer = ib.ic_token_buffer;
  const tok = Stdlib__Buffer.contents(token_buffer);
  token_buffer.position = 0;
  ib.ic_token_count = ib.ic_token_count + 1 | 0;
  return tok;
}

function ignore_char(width, ib) {
  const width$1 = width - 1 | 0;
  ib.ic_current_char_is_valid = false;
  return width$1;
}

function store_char(width, ib, c) {
  Stdlib__Buffer.add_char(ib.ic_token_buffer, c);
  return ignore_char(width, ib);
}

function create(iname, next) {
  return {
    ic_eof: false,
    ic_current_char: /* '\\000' */0,
    ic_current_char_is_valid: false,
    ic_char_count: 0,
    ic_line_count: 0,
    ic_token_count: 0,
    ic_get_next_char: next,
    ic_token_buffer: Stdlib__Buffer.create(1024),
    ic_input_name: iname
  };
}

function from_string(s) {
  const i = {
    contents: 0
  };
  const len = s.length;
  const next = function (param) {
    if (i.contents >= len) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
            MEL_EXN_ID: Stdlib.End_of_file
          });
    }
    const c = Caml_string.get(s, i.contents);
    i.contents = i.contents + 1 | 0;
    return c;
  };
  return create(/* From_string */ 1, next);
}

function from_function(param) {
  return create(/* From_function */ 0, param);
}

const file_buffer_size = {
  contents: 1024
};

function scan_close_at_end(ic) {
  Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
        MEL_EXN_ID: Stdlib.End_of_file
      });
}

function scan_raise_at_end(_ic) {
  throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
        MEL_EXN_ID: Stdlib.End_of_file
      });
}

function from_ic(scan_close_ic, iname, ic) {
  const len = file_buffer_size.contents;
  const buf = Caml_bytes.caml_create_bytes(len);
  const i = {
    contents: 0
  };
  const lim = {
    contents: 0
  };
  const eof = {
    contents: false
  };
  const next = function (param) {
    if (i.contents < lim.contents) {
      const c = Caml_bytes.get(buf, i.contents);
      i.contents = i.contents + 1 | 0;
      return c;
    }
    if (eof.contents) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
            MEL_EXN_ID: Stdlib.End_of_file
          });
    }
    lim.contents = Stdlib.input(ic, buf, 0, len);
    if (lim.contents === 0) {
      eof.contents = true;
      return Curry._1(scan_close_ic, ic);
    } else {
      i.contents = 1;
      return Caml_bytes.get(buf, 0);
    }
  };
  return create(iname, next);
}

const stdin = from_ic(scan_raise_at_end, {
  TAG: /* From_file */ 1,
  _0: "-",
  _1: Stdlib.stdin
}, Stdlib.stdin);

function open_in_file(open_in, fname) {
  if (fname === "-") {
    return stdin;
  }
  const ic = Curry._1(open_in, fname);
  return from_ic(scan_close_at_end, {
    TAG: /* From_file */ 1,
    _0: fname,
    _1: ic
  }, ic);
}

function open_in(param) {
  return open_in_file(Stdlib.open_in, param);
}

function open_in_bin(param) {
  return open_in_file(Stdlib.open_in_bin, param);
}

function from_channel(ic) {
  return from_ic(scan_raise_at_end, {
    TAG: /* From_channel */ 0,
    _0: ic
  }, ic);
}

function close_in(ib) {
  const ic = ib.ic_input_name;
  if (/* tag */ typeof ic === "number" || typeof ic === "string") {
    return;
  } else if (ic.TAG === /* From_channel */ 0) {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(ic._0);
  } else {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(ic._1);
  }
}

const Scan_failure = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Scanf.Scan_failure");

function bad_input_escape(c) {
  const s = Curry._1(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "illegal escape character ",
      _1: {
        TAG: /* Caml_char */ 1,
        _0: /* End_of_format */ 0
      }
    },
    _1: "illegal escape character %C"
  }), c);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function bad_token_length(message) {
  const s = Curry._1(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "scanning of ",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: " failed: the specified length was too short for token",
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "scanning of %s failed: the specified length was too short for token"
  }), message);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function bad_hex_float(param) {
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: "not a valid float in hexadecimal notation"
      });
}

function character_mismatch_err(c, ci) {
  return Curry._2(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "looking for ",
      _1: {
        TAG: /* Caml_char */ 1,
        _0: {
          TAG: /* String_literal */ 11,
          _0: ", found ",
          _1: {
            TAG: /* Caml_char */ 1,
            _0: /* End_of_format */ 0
          }
        }
      }
    },
    _1: "looking for %C, found %C"
  }), c, ci);
}

function check_this_char(ib, c) {
  const ci = checked_peek_char(ib);
  if (ci === c) {
    ib.ic_current_char_is_valid = false;
    return;
  }
  const s = character_mismatch_err(c, ci);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function check_char(ib, c) {
  if (c !== 10) {
    if (c !== 32) {
      return check_this_char(ib, c);
    } else {
      while (true) {
        const c$1 = peek_char(ib);
        if (ib.ic_eof) {
          return;
        }
        if (c$1 > 13 || c$1 < 9) {
          if (c$1 !== 32) {
            return;
          }
          ib.ic_current_char_is_valid = false;
          continue;
        }
        if (c$1 === 12 || c$1 === 11) {
          return;
        }
        ib.ic_current_char_is_valid = false;
        continue;
      };
    }
  } else {
    const ci = checked_peek_char(ib);
    if (ci === 10) {
      ib.ic_current_char_is_valid = false;
      return;
    }
    if (ci !== 13) {
      const s = character_mismatch_err(/* '\\n' */10, ci);
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: s
          });
    }
    ib.ic_current_char_is_valid = false;
    return check_this_char(ib, /* '\\n' */10);
  }
}

function token_bool(ib) {
  const s = token(ib);
  switch (s) {
    case "false" :
      return false;
    case "true" :
      return true;
    default:
      const s$1 = Curry._1(Stdlib__Printf.sprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "invalid boolean '",
          _1: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* Char_literal */ 12,
              _0: /* '\\'' */39,
              _1: /* End_of_format */ 0
            }
          }
        },
        _1: "invalid boolean '%s'"
      }), s);
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: s$1
          });
  }
}

function integer_conversion_of_char(param) {
  switch (param) {
    case 98 :
      return /* B_conversion */ 0;
    case 100 :
      return /* D_conversion */ 1;
    case 105 :
      return /* I_conversion */ 2;
    case 111 :
      return /* O_conversion */ 3;
    case 117 :
      return /* U_conversion */ 4;
    case 88 :
    case 120 :
      return /* X_conversion */ 5;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/scanf.ml",
          516,
          9
        ]
      });
}

function token_int_literal(conv, ib) {
  let tok;
  switch (conv) {
    case /* B_conversion */ 0 :
      tok = "0b" + token(ib);
      break;
    case /* D_conversion */ 1 :
    case /* I_conversion */ 2 :
      tok = token(ib);
      break;
    case /* O_conversion */ 3 :
      tok = "0o" + token(ib);
      break;
    case /* U_conversion */ 4 :
      tok = "0u" + token(ib);
      break;
    case /* X_conversion */ 5 :
      tok = "0x" + token(ib);
      break;
  }
  const l = tok.length;
  if (l === 0 || Caml_string.get(tok, 0) !== /* '+' */43) {
    return tok;
  } else {
    return Stdlib__String.sub(tok, 1, l - 1 | 0);
  }
}

function token_float(ib) {
  return Caml_format.caml_float_of_string(token(ib));
}

function scan_decimal_digit_star(_width, ib) {
  while (true) {
    const width = _width;
    if (width === 0) {
      return width;
    }
    const c = peek_char(ib);
    if (ib.ic_eof) {
      return width;
    }
    if (c >= 58) {
      if (c !== 95) {
        return width;
      }
      const width$1 = ignore_char(width, ib);
      _width = width$1;
      continue;
    }
    if (c < 48) {
      return width;
    }
    const width$2 = store_char(width, ib, c);
    _width = width$2;
    continue;
  };
}

function scan_decimal_digit_plus(width, ib) {
  if (width === 0) {
    return bad_token_length("decimal digits");
  }
  const c = checked_peek_char(ib);
  if (c > 57 || c < 48) {
    const s = Curry._1(Stdlib__Printf.sprintf({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "character ",
        _1: {
          TAG: /* Caml_char */ 1,
          _0: {
            TAG: /* String_literal */ 11,
            _0: " is not a decimal digit",
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "character %C is not a decimal digit"
    }), c);
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: s
        });
  }
  const width$1 = store_char(width, ib, c);
  return scan_decimal_digit_star(width$1, ib);
}

function scan_digit_plus(basis, digitp, width, ib) {
  if (width === 0) {
    return bad_token_length("digits");
  }
  const c = checked_peek_char(ib);
  if (Curry._1(digitp, c)) {
    const width$1 = store_char(width, ib, c);
    let _width = width$1;
    while (true) {
      const width$2 = _width;
      if (width$2 === 0) {
        return width$2;
      }
      const c$1 = peek_char(ib);
      if (ib.ic_eof) {
        return width$2;
      }
      if (Curry._1(digitp, c$1)) {
        const width$3 = store_char(width$2, ib, c$1);
        _width = width$3;
        continue;
      }
      if (c$1 !== 95) {
        return width$2;
      }
      const width$4 = ignore_char(width$2, ib);
      _width = width$4;
      continue;
    };
  }
  const s = Curry._2(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "character ",
      _1: {
        TAG: /* Caml_char */ 1,
        _0: {
          TAG: /* String_literal */ 11,
          _0: " is not a valid ",
          _1: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: " digit",
              _1: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "character %C is not a valid %s digit"
  }), c, basis);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function is_binary_digit(param) {
  return param === 49 || param === 48;
}

function scan_binary_int(param, param$1) {
  return scan_digit_plus("binary", is_binary_digit, param, param$1);
}

function is_octal_digit(param) {
  return !(param > 55 || param < 48);
}

function scan_octal_int(param, param$1) {
  return scan_digit_plus("octal", is_octal_digit, param, param$1);
}

function is_hexa_digit(param) {
  if (param > 70 || param < 48) {
    return !(param > 102 || param < 97);
  } else {
    return param > 64 || param < 58;
  }
}

function scan_hexadecimal_int(param, param$1) {
  return scan_digit_plus("hexadecimal", is_hexa_digit, param, param$1);
}

function scan_sign(width, ib) {
  const c = checked_peek_char(ib);
  if (c !== 43 && c !== 45) {
    return width;
  } else {
    return store_char(width, ib, c);
  }
}

function scan_optionally_signed_decimal_int(width, ib) {
  const width$1 = scan_sign(width, ib);
  return scan_decimal_digit_plus(width$1, ib);
}

function scan_int_conversion(conv, width, ib) {
  switch (conv) {
    case /* B_conversion */ 0 :
      return scan_binary_int(width, ib);
    case /* D_conversion */ 1 :
      return scan_optionally_signed_decimal_int(width, ib);
    case /* I_conversion */ 2 :
      const width$1 = scan_sign(width, ib);
      const c = checked_peek_char(ib);
      if (c !== 48) {
        return scan_decimal_digit_plus(width$1, ib);
      }
      const width$2 = store_char(width$1, ib, c);
      if (width$2 === 0) {
        return width$2;
      }
      const c$1 = peek_char(ib);
      if (ib.ic_eof) {
        return width$2;
      } else if (c$1 >= 99) {
        if (c$1 !== 111) {
          if (c$1 !== 120) {
            return scan_decimal_digit_star(width$2, ib);
          } else {
            return scan_hexadecimal_int(store_char(width$2, ib, c$1), ib);
          }
        } else {
          return scan_octal_int(store_char(width$2, ib, c$1), ib);
        }
      } else if (c$1 !== 88) {
        if (c$1 >= 98) {
          return scan_binary_int(store_char(width$2, ib, c$1), ib);
        } else {
          return scan_decimal_digit_star(width$2, ib);
        }
      } else {
        return scan_hexadecimal_int(store_char(width$2, ib, c$1), ib);
      }
    case /* O_conversion */ 3 :
      return scan_octal_int(width, ib);
    case /* U_conversion */ 4 :
      return scan_decimal_digit_plus(width, ib);
    case /* X_conversion */ 5 :
      return scan_hexadecimal_int(width, ib);
  }
}

function scan_fractional_part(width, ib) {
  if (width === 0) {
    return width;
  }
  const c = peek_char(ib);
  if (ib.ic_eof || c > 57 || c < 48) {
    return width;
  } else {
    return scan_decimal_digit_star(store_char(width, ib, c), ib);
  }
}

function scan_exponent_part(width, ib) {
  if (width === 0) {
    return width;
  }
  const c = peek_char(ib);
  if (ib.ic_eof || c !== 69 && c !== 101) {
    return width;
  } else {
    return scan_optionally_signed_decimal_int(store_char(width, ib, c), ib);
  }
}

function scan_integer_part(width, ib) {
  const width$1 = scan_sign(width, ib);
  return scan_decimal_digit_star(width$1, ib);
}

function scan_float(width, precision, ib) {
  const width$1 = scan_integer_part(width, ib);
  if (width$1 === 0) {
    return [
      width$1,
      precision
    ];
  }
  const c = peek_char(ib);
  if (ib.ic_eof) {
    return [
      width$1,
      precision
    ];
  }
  if (c !== 46) {
    return [
      scan_exponent_part(width$1, ib),
      precision
    ];
  }
  const width$2 = store_char(width$1, ib, c);
  const precision$1 = Stdlib__Int.min(width$2, precision);
  const width$3 = width$2 - (precision$1 - scan_fractional_part(precision$1, ib) | 0) | 0;
  return [
    scan_exponent_part(width$3, ib),
    precision$1
  ];
}

function check_case_insensitive_string(width, ib, error, str) {
  const lowercase = function (c) {
    if (c > 90 || c < 65) {
      return c;
    } else {
      return Stdlib.char_of_int((c - /* 'A' */65 | 0) + /* 'a' */97 | 0);
    }
  };
  const len = str.length;
  let width$1 = width;
  for (let i = 0; i < len; ++i) {
    const c = peek_char(ib);
    if (lowercase(c) !== lowercase(Caml_string.get(str, i))) {
      Curry._1(error, undefined);
    }
    if (width$1 === 0) {
      Curry._1(error, undefined);
    }
    width$1 = store_char(width$1, ib, c);
  }
  return width$1;
}

function scan_hex_float(width, precision, ib) {
  if (width === 0 || end_of_input(ib)) {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "not a valid float in hexadecimal notation"
        });
  }
  const width$1 = scan_sign(width, ib);
  if (width$1 === 0 || end_of_input(ib)) {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "not a valid float in hexadecimal notation"
        });
  }
  const c = peek_char(ib);
  if (c >= 78) {
    if (c > 109 || c < 79) {
      if (c >= 111) {
        throw new Caml_js_exceptions.MelangeError(Scan_failure, {
              MEL_EXN_ID: Scan_failure,
              _1: "not a valid float in hexadecimal notation"
            });
      }
      const width$2 = store_char(width$1, ib, c);
      if (width$2 === 0 || end_of_input(ib)) {
        throw new Caml_js_exceptions.MelangeError(Scan_failure, {
              MEL_EXN_ID: Scan_failure,
              _1: "not a valid float in hexadecimal notation"
            });
      }
      return check_case_insensitive_string(width$2, ib, bad_hex_float, "an");
    }
    if (c !== 105) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: "not a valid float in hexadecimal notation"
          });
    }
    
  } else if (c !== 48) {
    if (c !== 73) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: "not a valid float in hexadecimal notation"
          });
    }
    
  } else {
    const width$3 = store_char(width$1, ib, c);
    if (width$3 === 0 || end_of_input(ib)) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: "not a valid float in hexadecimal notation"
          });
    }
    const width$4 = check_case_insensitive_string(width$3, ib, bad_hex_float, "x");
    if (width$4 === 0 || end_of_input(ib)) {
      return width$4;
    }
    const match = peek_char(ib);
    const width$5 = match > 80 || match < 46 ? (
        match !== 112 ? scan_hexadecimal_int(width$4, ib) : width$4
      ) : (
        match > 79 || match < 47 ? width$4 : scan_hexadecimal_int(width$4, ib)
      );
    if (width$5 === 0 || end_of_input(ib)) {
      return width$5;
    }
    const c$1 = peek_char(ib);
    let width$6;
    if (c$1 !== 46) {
      width$6 = width$5;
    } else {
      const width$7 = store_char(width$5, ib, c$1);
      if (width$7 === 0 || end_of_input(ib)) {
        width$6 = width$7;
      } else {
        const match$1 = peek_char(ib);
        if (match$1 !== 80 && match$1 !== 112) {
          const precision$1 = Stdlib__Int.min(width$7, precision);
          width$6 = width$7 - (precision$1 - scan_hexadecimal_int(precision$1, ib) | 0) | 0;
        } else {
          width$6 = width$7;
        }
      }
    }
    if (width$6 === 0 || end_of_input(ib)) {
      return width$6;
    }
    const c$2 = peek_char(ib);
    let exit = 0;
    if (c$2 !== 80) {
      if (c$2 !== 112) {
        return width$6;
      }
      exit = 2;
    } else {
      exit = 2;
    }
    if (exit === 2) {
      const width$8 = store_char(width$6, ib, c$2);
      if (width$8 === 0 || end_of_input(ib)) {
        throw new Caml_js_exceptions.MelangeError(Scan_failure, {
              MEL_EXN_ID: Scan_failure,
              _1: "not a valid float in hexadecimal notation"
            });
      }
      return scan_optionally_signed_decimal_int(width$8, ib);
    }
    
  }
  const width$9 = store_char(width$1, ib, c);
  if (width$9 === 0 || end_of_input(ib)) {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "not a valid float in hexadecimal notation"
        });
  }
  return check_case_insensitive_string(width$9, ib, bad_hex_float, "nfinity");
}

function scan_caml_float_rest(width, precision, ib) {
  if (width === 0 || end_of_input(ib)) {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token"
        });
  }
  const width$1 = scan_decimal_digit_star(width, ib);
  if (width$1 === 0 || end_of_input(ib)) {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token"
        });
  }
  const c = peek_char(ib);
  if (c > 101 || c < 69) {
    if (c !== 46) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token"
          });
    }
    const width$2 = store_char(width$1, ib, c);
    const precision$1 = Stdlib__Int.min(width$2, precision);
    const width_precision = scan_fractional_part(precision$1, ib);
    const frac_width = precision$1 - width_precision | 0;
    const width$3 = width$2 - frac_width | 0;
    return scan_exponent_part(width$3, ib);
  }
  if (c > 100 || c < 70) {
    return scan_exponent_part(width$1, ib);
  }
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: "no dot or exponent part found in float token"
      });
}

function scan_caml_float(width, precision, ib) {
  if (width === 0 || end_of_input(ib)) {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token"
        });
  }
  const width$1 = scan_sign(width, ib);
  if (width$1 === 0 || end_of_input(ib)) {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token"
        });
  }
  const c = peek_char(ib);
  if (c >= 49) {
    if (c >= 58) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token"
          });
    }
    const width$2 = store_char(width$1, ib, c);
    if (width$2 === 0 || end_of_input(ib)) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token"
          });
    }
    return scan_caml_float_rest(width$2, precision, ib);
  }
  if (c >= 48) {
    const width$3 = store_char(width$1, ib, c);
    if (width$3 === 0 || end_of_input(ib)) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token"
          });
    }
    const c$1 = peek_char(ib);
    let exit = 0;
    if (c$1 !== 88) {
      if (c$1 !== 120) {
        return scan_caml_float_rest(width$3, precision, ib);
      }
      exit = 1;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      const width$4 = store_char(width$3, ib, c$1);
      if (width$4 === 0 || end_of_input(ib)) {
        throw new Caml_js_exceptions.MelangeError(Scan_failure, {
              MEL_EXN_ID: Scan_failure,
              _1: "no dot or exponent part found in float token"
            });
      }
      const width$5 = scan_hexadecimal_int(width$4, ib);
      if (width$5 === 0 || end_of_input(ib)) {
        throw new Caml_js_exceptions.MelangeError(Scan_failure, {
              MEL_EXN_ID: Scan_failure,
              _1: "no dot or exponent part found in float token"
            });
      }
      const c$2 = peek_char(ib);
      let width$6;
      if (c$2 > 112 || c$2 < 80) {
        if (c$2 !== 46) {
          throw new Caml_js_exceptions.MelangeError(Scan_failure, {
                MEL_EXN_ID: Scan_failure,
                _1: "no dot or exponent part found in float token"
              });
        }
        const width$7 = store_char(width$5, ib, c$2);
        if (width$7 === 0 || end_of_input(ib)) {
          width$6 = width$7;
        } else {
          const match = peek_char(ib);
          if (match !== 80 && match !== 112) {
            const precision$1 = Stdlib__Int.min(width$7, precision);
            width$6 = width$7 - (precision$1 - scan_hexadecimal_int(precision$1, ib) | 0) | 0;
          } else {
            width$6 = width$7;
          }
        }
      } else if (c$2 > 111 || c$2 < 81) {
        width$6 = width$5;
      } else {
        throw new Caml_js_exceptions.MelangeError(Scan_failure, {
              MEL_EXN_ID: Scan_failure,
              _1: "no dot or exponent part found in float token"
            });
      }
      if (width$6 === 0 || end_of_input(ib)) {
        return width$6;
      }
      const c$3 = peek_char(ib);
      let exit$1 = 0;
      if (c$3 !== 80) {
        if (c$3 !== 112) {
          return width$6;
        }
        exit$1 = 2;
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        const width$8 = store_char(width$6, ib, c$3);
        if (width$8 === 0 || end_of_input(ib)) {
          throw new Caml_js_exceptions.MelangeError(Scan_failure, {
                MEL_EXN_ID: Scan_failure,
                _1: "not a valid float in hexadecimal notation"
              });
        }
        return scan_optionally_signed_decimal_int(width$8, ib);
      }
      
    }
    
  } else {
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token"
        });
  }
}

function scan_string(stp, width, ib) {
  let _width = width;
  while (true) {
    const width$1 = _width;
    if (width$1 === 0) {
      return width$1;
    }
    const c = peek_char(ib);
    if (ib.ic_eof) {
      return width$1;
    }
    if (stp !== undefined) {
      if (c === stp) {
        ib.ic_current_char_is_valid = false;
        return width$1;
      }
      _width = store_char(width$1, ib, c);
      continue;
    }
    if (c > 13 || c < 9) {
      if (c === 32) {
        return width$1;
      }
      _width = store_char(width$1, ib, c);
      continue;
    }
    if (!(c === 12 || c === 11)) {
      return width$1;
    }
    _width = store_char(width$1, ib, c);
    continue;
  };
}

function scan_char(width, ib) {
  return store_char(width, ib, checked_peek_char(ib));
}

function char_for_backslash(c) {
  if (c < 110) {
    if (c !== 98) {
      return c;
    } else {
      return /* '\\b' */8;
    }
  }
  if (c >= 117) {
    return c;
  }
  switch (c) {
    case 110 :
      return /* '\\n' */10;
    case 114 :
      return /* '\\r' */13;
    case 111 :
    case 112 :
    case 113 :
    case 115 :
      return c;
    case 116 :
      return /* '\\t' */9;
  }
}

function char_for_decimal_code(c0, c1, c2) {
  const c = (Math.imul(100, c0 - /* '0' */48 | 0) + Math.imul(10, c1 - /* '0' */48 | 0) | 0) + (c2 - /* '0' */48 | 0) | 0;
  if (!(c < 0 || c > 255)) {
    return Stdlib.char_of_int(c);
  }
  const s = Curry._3(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "bad character decimal encoding \\\\",
      _1: {
        TAG: /* Char */ 0,
        _0: {
          TAG: /* Char */ 0,
          _0: {
            TAG: /* Char */ 0,
            _0: /* End_of_format */ 0
          }
        }
      }
    },
    _1: "bad character decimal encoding \\\\%c%c%c"
  }), c0, c1, c2);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function hexadecimal_value_of_char(c) {
  if (c >= /* 'a' */97) {
    return c - 87 | 0;
  } else if (c >= /* 'A' */65) {
    return c - 55 | 0;
  } else {
    return c - /* '0' */48 | 0;
  }
}

function char_for_hexadecimal_code(c1, c2) {
  const c = (hexadecimal_value_of_char(c1) << 4) + hexadecimal_value_of_char(c2) | 0;
  if (!(c < 0 || c > 255)) {
    return Stdlib.char_of_int(c);
  }
  const s = Curry._2(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "bad character hexadecimal encoding \\\\",
      _1: {
        TAG: /* Char */ 0,
        _0: {
          TAG: /* Char */ 0,
          _0: /* End_of_format */ 0
        }
      }
    },
    _1: "bad character hexadecimal encoding \\\\%c%c"
  }), c1, c2);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function check_next_char(message, width, ib) {
  if (width === 0) {
    return bad_token_length(message);
  }
  const c = peek_char(ib);
  if (ib.ic_eof) {
    const s = Curry._1(Stdlib__Printf.sprintf({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "scanning of ",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: " failed: premature end of file occurred before end of token",
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "scanning of %s failed: premature end of file occurred before end of token"
    }), message);
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: s
        });
  } else {
    return c;
  }
}

function scan_backslash_char(width, ib) {
  const c = check_next_char("a Char", width, ib);
  if (c >= 40) {
    if (c >= 58) {
      switch (c) {
        case 92 :
        case 98 :
        case 110 :
        case 114 :
        case 116 :
          break;
        case 120 :
          const get_digit = function (param) {
            const c = next_char(ib);
            if (c > 70 || c < 48) {
              if (c > 102 || c < 97) {
                return bad_input_escape(c);
              } else {
                return c;
              }
            } else if (c > 64 || c < 58) {
              return c;
            } else {
              return bad_input_escape(c);
            }
          };
          const c1 = get_digit(undefined);
          const c2 = get_digit(undefined);
          return store_char(width - 2 | 0, ib, char_for_hexadecimal_code(c1, c2));
        default:
          return bad_input_escape(c);
      }
    } else {
      if (c < 48) {
        return bad_input_escape(c);
      }
      const get_digit$1 = function (param) {
        const c = next_char(ib);
        if (c > 57 || c < 48) {
          return bad_input_escape(c);
        } else {
          return c;
        }
      };
      const c1$1 = get_digit$1(undefined);
      const c2$1 = get_digit$1(undefined);
      return store_char(width - 2 | 0, ib, char_for_decimal_code(c, c1$1, c2$1));
    }
  } else if (c !== 34 && c < 39) {
    return bad_input_escape(c);
  }
  return store_char(width, ib, char_for_backslash(c));
}

function scan_caml_char(width, ib) {
  const find_stop = function (width) {
    const c = check_next_char("a Char", width, ib);
    if (c === 39) {
      return ignore_char(width, ib);
    }
    const s = character_mismatch_err(/* '\\'' */39, c);
    throw new Caml_js_exceptions.MelangeError(Scan_failure, {
          MEL_EXN_ID: Scan_failure,
          _1: s
        });
  };
  const c = checked_peek_char(ib);
  if (c === 39) {
    let width$1 = ignore_char(width, ib);
    const c$1 = check_next_char("a Char", width$1, ib);
    if (c$1 !== 92) {
      return find_stop(store_char(width$1, ib, c$1));
    } else {
      return find_stop(scan_backslash_char(ignore_char(width$1, ib), ib));
    }
  }
  const s = character_mismatch_err(/* '\\'' */39, c);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function scan_caml_string(width, ib) {
  const find_stop = function (_width) {
    while (true) {
      const width = _width;
      const c = check_next_char("a String", width, ib);
      if (c === 34) {
        return ignore_char(width, ib);
      }
      if (c === 92) {
        let width$1 = ignore_char(width, ib);
        const match = check_next_char("a String", width$1, ib);
        if (match !== 10) {
          if (match !== 13) {
            return find_stop(scan_backslash_char(width$1, ib));
          } else {
            let width$2 = ignore_char(width$1, ib);
            const match$1 = check_next_char("a String", width$2, ib);
            if (match$1 !== 10) {
              return find_stop(store_char(width$2, ib, /* '\\r' */13));
            } else {
              return skip_spaces(ignore_char(width$2, ib));
            }
          }
        } else {
          return skip_spaces(ignore_char(width$1, ib));
        }
      }
      _width = store_char(width, ib, c);
      continue;
    };
  };
  const skip_spaces = function (_width) {
    while (true) {
      const width = _width;
      const match = check_next_char("a String", width, ib);
      if (match !== 32) {
        return find_stop(width);
      }
      _width = ignore_char(width, ib);
      continue;
    };
  };
  const c = checked_peek_char(ib);
  if (c === 34) {
    return find_stop(ignore_char(width, ib));
  }
  const s = character_mismatch_err(/* '"' */34, c);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function scan_chars_in_char_set(char_set, scan_indic, width, ib) {
  const scan_chars = function (_i, stp) {
    while (true) {
      const i = _i;
      const c = peek_char(ib);
      if (!(i > 0 && !ib.ic_eof && CamlinternalFormat.is_in_char_set(char_set, c) && c !== stp)) {
        return;
      }
      store_char(Stdlib.max_int, ib, c);
      _i = i - 1 | 0;
      continue;
    };
  };
  if (scan_indic === undefined) {
    return scan_chars(width, -1);
  }
  scan_chars(width, scan_indic);
  if (ib.ic_eof) {
    return;
  }
  const ci = peek_char(ib);
  if (scan_indic === ci) {
    ib.ic_current_char_is_valid = false;
    return;
  }
  const s = character_mismatch_err(scan_indic, ci);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s
      });
}

function scanf_bad_input(ib, x) {
  let s;
  if (x.MEL_EXN_ID === Scan_failure || x.MEL_EXN_ID === Stdlib.Failure) {
    s = x._1;
  } else {
    throw new Caml_js_exceptions.MelangeError(x.MEL_EXN_ID, x);
  }
  const i = char_count(ib);
  const s$1 = Curry._2(Stdlib__Printf.sprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "scanf: bad input at char number ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_i */ 3,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* String_literal */ 11,
          _0: ": ",
          _1: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: /* End_of_format */ 0
          }
        }
      }
    },
    _1: "scanf: bad input at char number %i: %s"
  }), i, s);
  throw new Caml_js_exceptions.MelangeError(Scan_failure, {
        MEL_EXN_ID: Scan_failure,
        _1: s$1
      });
}

function get_counter(ib, counter) {
  switch (counter) {
    case /* Line_counter */ 0 :
      return ib.ic_line_count;
    case /* Char_counter */ 1 :
      return char_count(ib);
    case /* Token_counter */ 2 :
      return ib.ic_token_count;
  }
}

function stopper_of_formatting_lit(fmting) {
  if (Caml_obj.caml_equal(fmting, /* Escaped_percent */ 6)) {
    return [
      /* '%' */37,
      ""
    ];
  }
  const str = CamlinternalFormat.string_of_formatting_lit(fmting);
  const stp = Caml_string.get(str, 1);
  const sub_str = Stdlib__String.sub(str, 2, str.length - 2 | 0);
  return [
    stp,
    sub_str
  ];
}

function take_format_readers(k, _fmt) {
  while (true) {
    const fmt = _fmt;
    if (/* tag */ typeof fmt === "number" || typeof fmt === "string") {
      return Curry._1(k, /* Nil */ 0);
    }
    switch (fmt.TAG) {
      case /* Int */ 4 :
      case /* Int32 */ 5 :
      case /* Nativeint */ 6 :
      case /* Int64 */ 7 :
      case /* Float */ 8 :
        _fmt = fmt._3;
        continue;
      case /* Format_subst */ 14 :
        return take_fmtty_format_readers(k, CamlinternalFormatBasics.erase_rel(CamlinternalFormat.symm(fmt._1)), fmt._2);
      case /* Formatting_gen */ 18 :
        _fmt = CamlinternalFormatBasics.concat_fmt(fmt._0._0._0, fmt._1);
        continue;
      case /* Reader */ 19 :
        const fmt_rest = fmt._0;
        return function (reader) {
          const new_k = function (readers_rest) {
            return Curry._1(k, {
              TAG: /* Cons */ 0,
              _0: reader,
              _1: readers_rest
            });
          };
          return take_format_readers(new_k, fmt_rest);
        };
      case /* Char */ 0 :
      case /* Caml_char */ 1 :
      case /* Flush */ 10 :
      case /* Alpha */ 15 :
      case /* Theta */ 16 :
      case /* Scan_next_char */ 22 :
        _fmt = fmt._0;
        continue;
      case /* Ignored_param */ 23 :
        let ign = fmt._0;
        let fmt$1 = fmt._1;
        if (/* tag */ typeof ign === "number" || typeof ign === "string") {
          if (ign === /* Ignored_reader */ 2) {
            return function (reader) {
              const new_k = function (readers_rest) {
                return Curry._1(k, {
                  TAG: /* Cons */ 0,
                  _0: reader,
                  _1: readers_rest
                });
              };
              return take_format_readers(new_k, fmt$1);
            };
          } else {
            return take_format_readers(k, fmt$1);
          }
        } else if (ign.TAG === /* Ignored_format_subst */ 9) {
          return take_fmtty_format_readers(k, ign._1, fmt$1);
        } else {
          return take_format_readers(k, fmt$1);
        }
      case /* Format_arg */ 13 :
      case /* Scan_char_set */ 20 :
      case /* Custom */ 24 :
        _fmt = fmt._2;
        continue;
      default:
        _fmt = fmt._1;
        continue;
    }
  };
}

function take_fmtty_format_readers(k, _fmtty, fmt) {
  while (true) {
    const fmtty = _fmtty;
    if (/* tag */ typeof fmtty === "number" || typeof fmtty === "string") {
      return take_format_readers(k, fmt);
    }
    switch (fmtty.TAG) {
      case /* Format_arg_ty */ 8 :
        _fmtty = fmtty._1;
        continue;
      case /* Format_subst_ty */ 9 :
        const ty = CamlinternalFormat.trans(CamlinternalFormat.symm(fmtty._0), fmtty._1);
        _fmtty = CamlinternalFormatBasics.concat_fmtty(ty, fmtty._2);
        continue;
      case /* Reader_ty */ 13 :
        const fmt_rest = fmtty._0;
        return function (reader) {
          const new_k = function (readers_rest) {
            return Curry._1(k, {
              TAG: /* Cons */ 0,
              _0: reader,
              _1: readers_rest
            });
          };
          return take_fmtty_format_readers(new_k, fmt_rest, fmt);
        };
      case /* Ignored_reader_ty */ 14 :
        const fmt_rest$1 = fmtty._0;
        return function (reader) {
          const new_k = function (readers_rest) {
            return Curry._1(k, {
              TAG: /* Cons */ 0,
              _0: reader,
              _1: readers_rest
            });
          };
          return take_fmtty_format_readers(new_k, fmt_rest$1, fmt);
        };
      default:
        _fmtty = fmtty._0;
        continue;
    }
  };
}

function make_scanf(ib, _fmt, readers) {
  while (true) {
    const fmt = _fmt;
    if (/* tag */ typeof fmt === "number" || typeof fmt === "string") {
      return /* Nil */ 0;
    }
    switch (fmt.TAG) {
      case /* Char */ 0 :
        scan_char(0, ib);
        const c = Caml_string.get(token(ib), 0);
        return {
          TAG: /* Cons */ 0,
          _0: c,
          _1: make_scanf(ib, fmt._0, readers)
        };
      case /* Caml_char */ 1 :
        scan_caml_char(0, ib);
        const c$1 = Caml_string.get(token(ib), 0);
        return {
          TAG: /* Cons */ 0,
          _0: c$1,
          _1: make_scanf(ib, fmt._0, readers)
        };
      case /* String */ 2 :
        const pad = fmt._0;
        const match = fmt._1;
        if (!/* tag */ (typeof match === "number" || typeof match === "string")) {
          switch (match.TAG) {
            case /* Formatting_lit */ 17 :
              const match$1 = stopper_of_formatting_lit(match._0);
              const stp = match$1[0];
              const scan = function (width, param, ib) {
                return scan_string(stp, width, ib);
              };
              const str_rest_0 = match$1[1];
              const str_rest_1 = match._1;
              const str_rest = {
                TAG: /* String_literal */ 11,
                _0: str_rest_0,
                _1: str_rest_1
              };
              return pad_prec_scanf(ib, str_rest, readers, pad, /* No_precision */ 0, scan, token);
            case /* Formatting_gen */ 18 :
              const match$2 = match._0;
              if (match$2.TAG === /* Open_tag */ 0) {
                const scan$1 = function (width, param, ib) {
                  return scan_string(/* '{' */123, width, ib);
                };
                return pad_prec_scanf(ib, CamlinternalFormatBasics.concat_fmt(match$2._0._0, match._1), readers, pad, /* No_precision */ 0, scan$1, token);
              }
              const scan$2 = function (width, param, ib) {
                return scan_string(/* '[' */91, width, ib);
              };
              return pad_prec_scanf(ib, CamlinternalFormatBasics.concat_fmt(match$2._0._0, match._1), readers, pad, /* No_precision */ 0, scan$2, token);
          }
        }
        const scan$3 = function (width, param, ib) {
          return scan_string(undefined, width, ib);
        };
        return pad_prec_scanf(ib, fmt._1, readers, pad, /* No_precision */ 0, scan$3, token);
      case /* Caml_string */ 3 :
        const scan$4 = function (width, param, ib) {
          return scan_caml_string(width, ib);
        };
        return pad_prec_scanf(ib, fmt._1, readers, fmt._0, /* No_precision */ 0, scan$4, token);
      case /* Int */ 4 :
        const c$2 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
        const scan$5 = function (width, param, ib) {
          return scan_int_conversion(c$2, width, ib);
        };
        return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$5, (function (param) {
          return Caml_format.caml_int_of_string(token_int_literal(c$2, param));
        }));
      case /* Int32 */ 5 :
        const c$3 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
        const scan$6 = function (width, param, ib) {
          return scan_int_conversion(c$3, width, ib);
        };
        return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$6, (function (param) {
          return Caml_format.caml_int32_of_string(token_int_literal(c$3, param));
        }));
      case /* Nativeint */ 6 :
        const c$4 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
        const scan$7 = function (width, param, ib) {
          return scan_int_conversion(c$4, width, ib);
        };
        return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$7, (function (param) {
          return Caml_format.caml_nativeint_of_string(token_int_literal(c$4, param));
        }));
      case /* Int64 */ 7 :
        const c$5 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
        const scan$8 = function (width, param, ib) {
          return scan_int_conversion(c$5, width, ib);
        };
        return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$8, (function (param) {
          return Caml_format.caml_int64_of_string(token_int_literal(c$5, param));
        }));
      case /* Float */ 8 :
        let exit = 0;
        switch (fmt._0[1]) {
          case /* Float_h */ 6 :
          case /* Float_H */ 7 :
            exit = 2;
            break;
          case /* Float_F */ 5 :
          case /* Float_CF */ 8 :
            exit = 1;
            break;
          default:
            return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan_float, token_float);
        }
        switch (exit) {
          case 1 :
            return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan_caml_float, token_float);
          case 2 :
            return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan_hex_float, token_float);
        }
        break;
      case /* Bool */ 9 :
        const scan$9 = function (param, param$1, ib) {
          const c = checked_peek_char(ib);
          let m;
          if (c !== 102) {
            if (c !== 116) {
              const s = Curry._1(Stdlib__Printf.sprintf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "the character ",
                  _1: {
                    TAG: /* Caml_char */ 1,
                    _0: {
                      TAG: /* String_literal */ 11,
                      _0: " cannot start a boolean",
                      _1: /* End_of_format */ 0
                    }
                  }
                },
                _1: "the character %C cannot start a boolean"
              }), c);
              throw new Caml_js_exceptions.MelangeError(Scan_failure, {
                    MEL_EXN_ID: Scan_failure,
                    _1: s
                  });
            }
            m = 4;
          } else {
            m = 5;
          }
          return scan_string(undefined, m, ib);
        };
        return pad_prec_scanf(ib, fmt._1, readers, fmt._0, /* No_precision */ 0, scan$9, token_bool);
      case /* Flush */ 10 :
        if (end_of_input(ib)) {
          _fmt = fmt._0;
          continue;
        }
        throw new Caml_js_exceptions.MelangeError(Scan_failure, {
              MEL_EXN_ID: Scan_failure,
              _1: "end of input not found"
            });
      case /* String_literal */ 11 :
        Stdlib__String.iter((function (param) {
          return check_char(ib, param);
        }), fmt._0);
        _fmt = fmt._1;
        continue;
      case /* Char_literal */ 12 :
        check_char(ib, fmt._0);
        _fmt = fmt._1;
        continue;
      case /* Format_arg */ 13 :
        const pad_opt = fmt._0;
        scan_caml_string(pad_opt !== undefined ? pad_opt : Stdlib.max_int, ib);
        const s = token(ib);
        let fmt$1;
        try {
          fmt$1 = CamlinternalFormat.format_of_string_fmtty(s, fmt._1);
        }
        catch (raw_msg){
          const msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
          if (msg.MEL_EXN_ID === Stdlib.Failure) {
            throw new Caml_js_exceptions.MelangeError(Scan_failure, {
                  MEL_EXN_ID: Scan_failure,
                  _1: msg._1
                });
          }
          throw new Caml_js_exceptions.MelangeError(msg.MEL_EXN_ID, msg);
        }
        return {
          TAG: /* Cons */ 0,
          _0: fmt$1,
          _1: make_scanf(ib, fmt._2, readers)
        };
      case /* Format_subst */ 14 :
        const fmtty = fmt._1;
        const pad_opt$1 = fmt._0;
        scan_caml_string(pad_opt$1 !== undefined ? pad_opt$1 : Stdlib.max_int, ib);
        const s$1 = token(ib);
        let match$3;
        try {
          const fmt$2 = CamlinternalFormat.fmt_ebb_of_string(undefined, s$1);
          const fmt$p = CamlinternalFormat.fmt_ebb_of_string(undefined, s$1);
          match$3 = [
            CamlinternalFormat.type_format(fmt$2._0, CamlinternalFormatBasics.erase_rel(fmtty)),
            CamlinternalFormat.type_format(fmt$p._0, CamlinternalFormatBasics.erase_rel(CamlinternalFormat.symm(fmtty)))
          ];
        }
        catch (raw_msg$1){
          const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg$1);
          if (msg$1.MEL_EXN_ID === Stdlib.Failure) {
            throw new Caml_js_exceptions.MelangeError(Scan_failure, {
                  MEL_EXN_ID: Scan_failure,
                  _1: msg$1._1
                });
          }
          throw new Caml_js_exceptions.MelangeError(msg$1.MEL_EXN_ID, msg$1);
        }
        return {
          TAG: /* Cons */ 0,
          _0: {
            TAG: /* Format */ 0,
            _0: match$3[0],
            _1: s$1
          },
          _1: make_scanf(ib, CamlinternalFormatBasics.concat_fmt(match$3[1], fmt._2), readers)
        };
      case /* Alpha */ 15 :
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "scanf: bad conversion \\"%a\\""
            });
      case /* Theta */ 16 :
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "scanf: bad conversion \\"%t\\""
            });
      case /* Formatting_lit */ 17 :
        Stdlib__String.iter((function (param) {
          return check_char(ib, param);
        }), CamlinternalFormat.string_of_formatting_lit(fmt._0));
        _fmt = fmt._1;
        continue;
      case /* Formatting_gen */ 18 :
        const match$4 = fmt._0;
        if (match$4.TAG === /* Open_tag */ 0) {
          check_char(ib, /* '@' */64);
          check_char(ib, /* '{' */123);
          _fmt = CamlinternalFormatBasics.concat_fmt(match$4._0._0, fmt._1);
          continue;
        }
        check_char(ib, /* '@' */64);
        check_char(ib, /* '[' */91);
        _fmt = CamlinternalFormatBasics.concat_fmt(match$4._0._0, fmt._1);
        continue;
      case /* Reader */ 19 :
        if (/* tag */ typeof readers === "number" || typeof readers === "string") {
          throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "scanf: missing reader"
              });
        }
        const x = Curry._1(readers._0, ib);
        return {
          TAG: /* Cons */ 0,
          _0: x,
          _1: make_scanf(ib, fmt._0, readers._1)
        };
      case /* Scan_char_set */ 20 :
        const width_opt = fmt._0;
        const match$5 = fmt._2;
        if (!/* tag */ (typeof match$5 === "number" || typeof match$5 === "string") && match$5.TAG === /* Formatting_lit */ 17) {
          const match$6 = stopper_of_formatting_lit(match$5._0);
          const width = width_opt !== undefined ? width_opt : Stdlib.max_int;
          scan_chars_in_char_set(fmt._1, match$6[0], width, ib);
          const s$2 = token(ib);
          const str_rest_0$1 = match$6[1];
          const str_rest_1$1 = match$5._1;
          const str_rest$1 = {
            TAG: /* String_literal */ 11,
            _0: str_rest_0$1,
            _1: str_rest_1$1
          };
          return {
            TAG: /* Cons */ 0,
            _0: s$2,
            _1: make_scanf(ib, str_rest$1, readers)
          };
        }
        const width$1 = width_opt !== undefined ? width_opt : Stdlib.max_int;
        scan_chars_in_char_set(fmt._1, undefined, width$1, ib);
        const s$3 = token(ib);
        return {
          TAG: /* Cons */ 0,
          _0: s$3,
          _1: make_scanf(ib, fmt._2, readers)
        };
      case /* Scan_get_counter */ 21 :
        const count = get_counter(ib, fmt._0);
        return {
          TAG: /* Cons */ 0,
          _0: count,
          _1: make_scanf(ib, fmt._1, readers)
        };
      case /* Scan_next_char */ 22 :
        const c$6 = checked_peek_char(ib);
        return {
          TAG: /* Cons */ 0,
          _0: c$6,
          _1: make_scanf(ib, fmt._0, readers)
        };
      case /* Ignored_param */ 23 :
        const fmt$p$1 = CamlinternalFormat.param_format_of_ignored_format(fmt._0, fmt._1);
        const match$7 = make_scanf(ib, fmt$p$1._0, readers);
        if (!/* tag */ (typeof match$7 === "number" || typeof match$7 === "string")) {
          return match$7._1;
        }
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/stdlib/scanf.ml",
                1414,
                13
              ]
            });
      case /* Custom */ 24 :
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "scanf: bad conversion \\"%?\\" (custom converter)"
            });
    }
  };
}

function pad_prec_scanf(ib, fmt, readers, pad, prec, scan, token) {
  if (/* tag */ typeof pad === "number" || typeof pad === "string") {
    if (/* tag */ typeof prec === "number" || typeof prec === "string") {
      if (prec === /* No_precision */ 0) {
        Curry._3(scan, Stdlib.max_int, Stdlib.max_int, ib);
        const x = Curry._1(token, ib);
        return {
          TAG: /* Cons */ 0,
          _0: x,
          _1: make_scanf(ib, fmt, readers)
        };
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "scanf: bad conversion \\"%*\\""
          });
    } else {
      Curry._3(scan, Stdlib.max_int, prec._0, ib);
      const x$1 = Curry._1(token, ib);
      return {
        TAG: /* Cons */ 0,
        _0: x$1,
        _1: make_scanf(ib, fmt, readers)
      };
    }
  } else if (pad.TAG === /* Lit_padding */ 0) {
    switch (pad._0) {
      case /* Left */ 0 :
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "scanf: bad conversion \\"%-\\""
            });
      case /* Right */ 1 :
      case /* Zeros */ 2 :
        break;
    }
    const w = pad._1;
    if (/* tag */ typeof prec === "number" || typeof prec === "string") {
      if (prec === /* No_precision */ 0) {
        Curry._3(scan, w, Stdlib.max_int, ib);
        const x$2 = Curry._1(token, ib);
        return {
          TAG: /* Cons */ 0,
          _0: x$2,
          _1: make_scanf(ib, fmt, readers)
        };
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "scanf: bad conversion \\"%*\\""
          });
    } else {
      Curry._3(scan, w, prec._0, ib);
      const x$3 = Curry._1(token, ib);
      return {
        TAG: /* Cons */ 0,
        _0: x$3,
        _1: make_scanf(ib, fmt, readers)
      };
    }
  } else {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "scanf: bad conversion \\"%*\\""
        });
  }
}

function kscanf_gen(ib, ef, af, param) {
  const str = param._1;
  const fmt = param._0;
  const apply = function (_f, _args) {
    while (true) {
      const args = _args;
      const f = _f;
      if (/* tag */ typeof args === "number" || typeof args === "string") {
        return f;
      }
      _args = args._1;
      _f = Curry._1(f, args._0);
      continue;
    };
  };
  const k = function (readers, f) {
    Stdlib__Buffer.reset(ib.ic_token_buffer);
    let args;
    try {
      args = make_scanf(ib, fmt, readers);
    }
    catch (raw_exc){
      const exc = Caml_js_exceptions.internalToOCamlException(raw_exc);
      if (exc.MEL_EXN_ID === Scan_failure) {
        return Curry._2(ef, ib, exc);
      }
      if (exc.MEL_EXN_ID === Stdlib.Failure) {
        return Curry._2(ef, ib, exc);
      }
      if (exc.MEL_EXN_ID === Stdlib.End_of_file) {
        return Curry._2(ef, ib, exc);
      }
      if (exc.MEL_EXN_ID === Stdlib.Invalid_argument) {
        const s = exc._1 + (" in format \\"" + (Stdlib__String.escaped(str) + "\\""));
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: s
            });
      }
      throw new Caml_js_exceptions.MelangeError(exc.MEL_EXN_ID, exc);
    }
    return Curry._1(af, apply(f, args));
  };
  return take_format_readers(k, fmt);
}

function kscanf(ib, ef, fmt) {
  return kscanf_gen(ib, ef, (function (x) {
    return x;
  }), fmt);
}

function kscanf_opt(ib, fmt) {
  return kscanf_gen(ib, (function (param, param$1) {
    
  }), (function (x) {
    return Caml_option.some(x);
  }), fmt);
}

function bscanf(ib, fmt) {
  return kscanf(ib, scanf_bad_input, fmt);
}

const bscanf_opt = kscanf_opt;

function ksscanf(s, ef, fmt) {
  return kscanf(from_string(s), ef, fmt);
}

function sscanf(s, fmt) {
  return kscanf(from_string(s), scanf_bad_input, fmt);
}

function sscanf_opt(s, fmt) {
  return kscanf_opt(from_string(s), fmt);
}

function scanf(fmt) {
  return kscanf(stdin, scanf_bad_input, fmt);
}

function scanf_opt(fmt) {
  return kscanf_opt(stdin, fmt);
}

function bscanf_format(ib, format, f) {
  scan_caml_string(Stdlib.max_int, ib);
  const str = token(ib);
  let tmp;
  try {
    tmp = CamlinternalFormat.format_of_string_format(str, format);
  }
  catch (raw_msg){
    const msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.MEL_EXN_ID === Stdlib.Failure) {
      throw new Caml_js_exceptions.MelangeError(Scan_failure, {
            MEL_EXN_ID: Scan_failure,
            _1: msg._1
          });
    }
    throw new Caml_js_exceptions.MelangeError(msg.MEL_EXN_ID, msg);
  }
  return Curry._1(f, tmp);
}

function sscanf_format(s, format, f) {
  return bscanf_format(from_string(s), format, f);
}

function format_from_string(s, fmt) {
  return sscanf_format("\\"" + (Stdlib__String.escaped(s) + "\\""), fmt, (function (x) {
    return x;
  }));
}

function unescaped(s) {
  return Curry._1(sscanf("\\"" + (s + "\\""), {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* Caml_string */ 3,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* Flush */ 10,
        _0: /* End_of_format */ 0
      }
    },
    _1: "%S%!"
  }), (function (x) {
    return x;
  }));
}

const Scanning = {
  stdin: stdin,
  open_in: open_in,
  open_in_bin: open_in_bin,
  close_in: close_in,
  from_file: open_in,
  from_file_bin: open_in_bin,
  from_string: from_string,
  from_function: from_function,
  from_channel: from_channel,
  end_of_input: end_of_input,
  beginning_of_input: beginning_of_input,
  name_of_input: name_of_input
};

export {
  Scanning,
  Scan_failure,
  bscanf,
  bscanf_opt,
  sscanf,
  sscanf_opt,
  scanf,
  scanf_opt,
  kscanf,
  ksscanf,
  bscanf_format,
  sscanf_format,
  format_from_string,
  unescaped,
}
/* stdin Not a pure module */
`,am=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as CamlinternalLazy from "./camlinternalLazy.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Atomic from "./atomic.js";

function empty(param) {
  return /* Nil */ 0;
}

function $$return(x, param) {
  return {
    TAG: /* Cons */ 0,
    _0: x,
    _1: empty
  };
}

function cons(x, next, param) {
  return {
    TAG: /* Cons */ 0,
    _0: x,
    _1: next
  };
}

function append(seq1, seq2, param) {
  const match = Curry._1(seq1, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return Curry._1(seq2, undefined);
  }
  const next = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0,
    _1: (function (param) {
      return append(next, seq2, param);
    })
  };
}

function map(f, seq, param) {
  const match = Curry._1(seq, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const next = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._1(f, match._0),
    _1: (function (param) {
      return map(f, next, param);
    })
  };
}

function filter_map(f, _seq, _param) {
  while (true) {
    const seq = _seq;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return /* Nil */ 0;
    }
    const next = match._1;
    const y = Curry._1(f, match._0);
    if (y !== undefined) {
      return {
        TAG: /* Cons */ 0,
        _0: Caml_option.valFromOption(y),
        _1: (function (param) {
          return filter_map(f, next, param);
        })
      };
    }
    _param = undefined;
    _seq = next;
    continue;
  };
}

function filter(f, _seq, _param) {
  while (true) {
    const seq = _seq;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return /* Nil */ 0;
    }
    const next = match._1;
    const x = match._0;
    if (Curry._1(f, x)) {
      return {
        TAG: /* Cons */ 0,
        _0: x,
        _1: (function (param) {
          return filter(f, next, param);
        })
      };
    }
    _param = undefined;
    _seq = next;
    continue;
  };
}

function concat(seq, param) {
  const match = Curry._1(seq, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const next = match._1;
  return append(match._0, (function (param) {
    return concat(next, param);
  }), undefined);
}

function flat_map(f, seq, param) {
  const match = Curry._1(seq, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const next = match._1;
  return append(Curry._1(f, match._0), (function (param) {
    return flat_map(f, next, param);
  }), undefined);
}

function fold_left(f, _acc, _seq) {
  while (true) {
    const seq = _seq;
    const acc = _acc;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return acc;
    }
    const acc$1 = Curry._2(f, acc, match._0);
    _seq = match._1;
    _acc = acc$1;
    continue;
  };
}

function iter(f, _seq) {
  while (true) {
    const seq = _seq;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    Curry._1(f, match._0);
    _seq = match._1;
    continue;
  };
}

function unfold(f, u, param) {
  const match = Curry._1(f, u);
  if (match === undefined) {
    return /* Nil */ 0;
  }
  const u$p = match[1];
  return {
    TAG: /* Cons */ 0,
    _0: match[0],
    _1: (function (param) {
      return unfold(f, u$p, param);
    })
  };
}

function is_empty(xs) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return true;
  } else {
    return false;
  }
}

function uncons(xs) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return;
  } else {
    return [
      match._0,
      match._1
    ];
  }
}

function length(xs) {
  let _accu = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const accu = _accu;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return accu;
    }
    _xs = match._1;
    _accu = accu + 1 | 0;
    continue;
  };
}

function iteri(f, xs) {
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    Curry._2(f, i, match._0);
    _xs = match._1;
    _i = i + 1 | 0;
    continue;
  };
}

function fold_lefti(f, accu, xs) {
  let _accu = accu;
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const accu$1 = _accu;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return accu$1;
    }
    const accu$2 = Curry._3(f, accu$1, i, match._0);
    _xs = match._1;
    _i = i + 1 | 0;
    _accu = accu$2;
    continue;
  };
}

function for_all(p, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return true;
    }
    if (!Curry._1(p, match._0)) {
      return false;
    }
    _xs = match._1;
    continue;
  };
}

function exists(p, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return false;
    }
    if (Curry._1(p, match._0)) {
      return true;
    }
    _xs = match._1;
    continue;
  };
}

function find(p, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    const x = match._0;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _xs = match._1;
    continue;
  };
}

function find_index(p, xs) {
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    if (Curry._1(p, match._0)) {
      return i;
    }
    _xs = match._1;
    _i = i + 1 | 0;
    continue;
  };
}

function find_map(f, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    const result = Curry._1(f, match._0);
    if (result !== undefined) {
      return result;
    }
    _xs = match._1;
    continue;
  };
}

function find_mapi(f, xs) {
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    const result = Curry._2(f, i, match._0);
    if (result !== undefined) {
      return result;
    }
    _xs = match._1;
    _i = i + 1 | 0;
    continue;
  };
}

function iter2(f, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return;
    }
    Curry._2(f, match._0, match$1._0);
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function fold_left2(f, _accu, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const accu = _accu;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return accu;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return accu;
    }
    const accu$1 = Curry._3(f, accu, match._0, match$1._0);
    _ys = match$1._1;
    _xs = match._1;
    _accu = accu$1;
    continue;
  };
}

function for_all2(f, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return true;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return true;
    }
    if (!Curry._2(f, match._0, match$1._0)) {
      return false;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function exists2(f, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return false;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return false;
    }
    if (Curry._2(f, match._0, match$1._0)) {
      return true;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function equal(eq, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
        return true;
      } else {
        return false;
      }
    }
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return false;
    }
    if (!Curry._2(eq, match._0, match$1._0)) {
      return false;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function compare(cmp, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
        return 0;
      } else {
        return -1;
      }
    }
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return 1;
    }
    const c = Curry._2(cmp, match._0, match$1._0);
    if (c !== 0) {
      return c;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function init_aux(f, i, j, param) {
  if (i >= j) {
    return /* Nil */ 0;
  }
  const partial_arg = i + 1 | 0;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._1(f, i),
    _1: (function (param) {
      return init_aux(f, partial_arg, j, param);
    })
  };
}

function init(n, f) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Seq.init"
        });
  }
  return function (param) {
    return init_aux(f, 0, n, param);
  };
}

function repeat(x, param) {
  return {
    TAG: /* Cons */ 0,
    _0: x,
    _1: (function (param) {
      return repeat(x, param);
    })
  };
}

function forever(f, param) {
  return {
    TAG: /* Cons */ 0,
    _0: Curry._1(f, undefined),
    _1: (function (param) {
      return forever(f, param);
    })
  };
}

function cycle_nonempty(xs, param) {
  return append(xs, (function (param) {
    return cycle_nonempty(xs, param);
  }), undefined);
}

function cycle(xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xs$p = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0,
    _1: (function (param) {
      return append(xs$p, (function (param) {
        return cycle_nonempty(xs, param);
      }), param);
    })
  };
}

function iterate1(f, x, param) {
  const y = Curry._1(f, x);
  return {
    TAG: /* Cons */ 0,
    _0: y,
    _1: (function (param) {
      return iterate1(f, y, param);
    })
  };
}

function iterate(f, x) {
  return function (param) {
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return iterate1(f, x, param);
      })
    };
  };
}

function mapi_aux(f, i, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const partial_arg = i + 1 | 0;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._2(f, i, match._0),
    _1: (function (param) {
      return mapi_aux(f, partial_arg, xs$1, param);
    })
  };
}

function mapi(f, xs) {
  return function (param) {
    return mapi_aux(f, 0, xs, param);
  };
}

function tail_scan(f, s, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const s$1 = Curry._2(f, s, match._0);
  return {
    TAG: /* Cons */ 0,
    _0: s$1,
    _1: (function (param) {
      return tail_scan(f, s$1, xs$1, param);
    })
  };
}

function scan(f, s, xs) {
  return function (param) {
    return {
      TAG: /* Cons */ 0,
      _0: s,
      _1: (function (param) {
        return tail_scan(f, s, xs, param);
      })
    };
  };
}

function take_aux(n, xs) {
  if (n === 0) {
    return empty;
  } else {
    return function (param) {
      const match = Curry._1(xs, undefined);
      if (/* tag */ typeof match === "number" || typeof match === "string") {
        return /* Nil */ 0;
      } else {
        return {
          TAG: /* Cons */ 0,
          _0: match._0,
          _1: take_aux(n - 1 | 0, match._1)
        };
      }
    };
  }
}

function take(n, xs) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Seq.take"
        });
  }
  return take_aux(n, xs);
}

function drop(n, xs) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Seq.drop"
        });
  }
  if (n === 0) {
    return xs;
  } else {
    return function (param) {
      let _n = n;
      let _xs = xs;
      while (true) {
        const xs$1 = _xs;
        const n$1 = _n;
        const match = Curry._1(xs$1, undefined);
        if (/* tag */ typeof match === "number" || typeof match === "string") {
          return /* Nil */ 0;
        }
        const xs$2 = match._1;
        const n$2 = n$1 - 1 | 0;
        if (n$2 === 0) {
          return Curry._1(xs$2, undefined);
        }
        _xs = xs$2;
        _n = n$2;
        continue;
      };
    };
  }
}

function take_while(p, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const x = match._0;
  if (Curry._1(p, x)) {
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return take_while(p, xs$1, param);
      })
    };
  } else {
    return /* Nil */ 0;
  }
}

function drop_while(p, _xs, _param) {
  while (true) {
    const xs = _xs;
    const node = Curry._1(xs, undefined);
    if (/* tag */ typeof node === "number" || typeof node === "string") {
      return /* Nil */ 0;
    }
    if (!Curry._1(p, node._0)) {
      return node;
    }
    _param = undefined;
    _xs = node._1;
    continue;
  };
}

function group(eq, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const x = match._0;
  const partial_arg = Curry._1(eq, x);
  const partial_arg$1 = function (param) {
    return take_while(partial_arg, xs$1, param);
  };
  const partial_arg$2 = Curry._1(eq, x);
  const partial_arg$3 = function (param) {
    return drop_while(partial_arg$2, xs$1, param);
  };
  return {
    TAG: /* Cons */ 0,
    _0: (function (param) {
      return {
        TAG: /* Cons */ 0,
        _0: x,
        _1: partial_arg$1
      };
    }),
    _1: (function (param) {
      return group(eq, partial_arg$3, param);
    })
  };
}

const Forced_twice = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Seq.Forced_twice");

function failure(param) {
  throw new Caml_js_exceptions.MelangeError(Forced_twice, {
        MEL_EXN_ID: Forced_twice
      });
}

function memoize(xs) {
  const partial_arg = {
    LAZY_DONE: false,
    VAL: (function () {
      const match = Curry._1(xs, undefined);
      if (/* tag */ typeof match === "number" || typeof match === "string") {
        return /* Nil */ 0;
      } else {
        return {
          TAG: /* Cons */ 0,
          _0: match._0,
          _1: memoize(match._1)
        };
      }
    })
  };
  return function (param) {
    return CamlinternalLazy.force(partial_arg);
  };
}

function once(xs) {
  const f = function (param) {
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return /* Nil */ 0;
    } else {
      return {
        TAG: /* Cons */ 0,
        _0: match._0,
        _1: once(match._1)
      };
    }
  };
  const action = Stdlib__Atomic.make(f);
  return function (param) {
    const f = Stdlib__Atomic.exchange(action, failure);
    return Curry._1(f, undefined);
  };
}

function zip(xs, ys, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const match$1 = Curry._1(ys, undefined);
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    return /* Nil */ 0;
  }
  const ys$1 = match$1._1;
  return {
    TAG: /* Cons */ 0,
    _0: [
      match._0,
      match$1._0
    ],
    _1: (function (param) {
      return zip(xs$1, ys$1, param);
    })
  };
}

function map2(f, xs, ys, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const match$1 = Curry._1(ys, undefined);
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    return /* Nil */ 0;
  }
  const ys$1 = match$1._1;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._2(f, match._0, match$1._0),
    _1: (function (param) {
      return map2(f, xs$1, ys$1, param);
    })
  };
}

function interleave(xs, ys, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return Curry._1(ys, undefined);
  }
  const xs$1 = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0,
    _1: (function (param) {
      return interleave(ys, xs$1, param);
    })
  };
}

function sorted_merge1(cmp, x, xs, y, ys) {
  if (Curry._2(cmp, x, y) <= 0) {
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        const match = Curry._1(xs, undefined);
        if (/* tag */ typeof match === "number" || typeof match === "string") {
          return {
            TAG: /* Cons */ 0,
            _0: y,
            _1: ys
          };
        } else {
          return sorted_merge1(cmp, match._0, match._1, y, ys);
        }
      })
    };
  } else {
    return {
      TAG: /* Cons */ 0,
      _0: y,
      _1: (function (param) {
        const match = Curry._1(ys, undefined);
        if (/* tag */ typeof match === "number" || typeof match === "string") {
          return {
            TAG: /* Cons */ 0,
            _0: x,
            _1: xs
          };
        } else {
          return sorted_merge1(cmp, x, xs, match._0, match._1);
        }
      })
    };
  }
}

function sorted_merge(cmp, xs, ys, param) {
  const match = Curry._1(xs, undefined);
  const match$1 = Curry._1(ys, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return /* Nil */ 0;
    } else {
      return match$1;
    }
  } else if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    return match;
  } else {
    return sorted_merge1(cmp, match._0, match._1, match$1._0, match$1._1);
  }
}

function map_fst(xys, param) {
  const match = Curry._1(xys, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xys$1 = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0[0],
    _1: (function (param) {
      return map_fst(xys$1, param);
    })
  };
}

function map_snd(xys, param) {
  const match = Curry._1(xys, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return /* Nil */ 0;
  }
  const xys$1 = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0[1],
    _1: (function (param) {
      return map_snd(xys$1, param);
    })
  };
}

function unzip(xys) {
  return [
    (function (param) {
      return map_fst(xys, param);
    }),
    (function (param) {
      return map_snd(xys, param);
    })
  ];
}

function filter_map_find_left_map(f, _xs, _param) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return /* Nil */ 0;
    }
    const xs$1 = match._1;
    const y = Curry._1(f, match._0);
    if (y.TAG === /* Left */ 0) {
      return {
        TAG: /* Cons */ 0,
        _0: y._0,
        _1: (function (param) {
          return filter_map_find_left_map(f, xs$1, param);
        })
      };
    }
    _param = undefined;
    _xs = xs$1;
    continue;
  };
}

function filter_map_find_right_map(f, _xs, _param) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return /* Nil */ 0;
    }
    const xs$1 = match._1;
    const z = Curry._1(f, match._0);
    if (z.TAG !== /* Left */ 0) {
      return {
        TAG: /* Cons */ 0,
        _0: z._0,
        _1: (function (param) {
          return filter_map_find_right_map(f, xs$1, param);
        })
      };
    }
    _param = undefined;
    _xs = xs$1;
    continue;
  };
}

function partition_map(f, xs) {
  return [
    (function (param) {
      return filter_map_find_left_map(f, xs, param);
    }),
    (function (param) {
      return filter_map_find_right_map(f, xs, param);
    })
  ];
}

function partition(p, xs) {
  return [
    (function (param) {
      return filter(p, xs, param);
    }),
    (function (param) {
      return filter((function (x) {
        return !Curry._1(p, x);
      }), xs, param);
    })
  ];
}

function transpose(xss, param) {
  const match = unzip(function (param) {
    return filter_map(uncons, xss, param);
  });
  const tails = match[1];
  const heads = match[0];
  if (!is_empty(heads)) {
    return {
      TAG: /* Cons */ 0,
      _0: heads,
      _1: (function (param) {
        return transpose(tails, param);
      })
    };
  }
  if (!is_empty(tails)) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/seq.ml",
            616,
            4
          ]
        });
  }
  return /* Nil */ 0;
}

function diagonals(remainders, xss, param) {
  const match = Curry._1(xss, undefined);
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return transpose(remainders, undefined);
  }
  const xss$1 = match._1;
  const match$1 = Curry._1(match._0, undefined);
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    const match$2 = unzip(function (param) {
      return filter_map(uncons, remainders, param);
    });
    const tails = match$2[1];
    return {
      TAG: /* Cons */ 0,
      _0: match$2[0],
      _1: (function (param) {
        return diagonals(tails, xss$1, param);
      })
    };
  }
  const xs = match$1._1;
  const x = match$1._0;
  const match$3 = unzip(function (param) {
    return filter_map(uncons, remainders, param);
  });
  const tails$1 = match$3[1];
  const heads = match$3[0];
  return {
    TAG: /* Cons */ 0,
    _0: (function (param) {
      return {
        TAG: /* Cons */ 0,
        _0: x,
        _1: heads
      };
    }),
    _1: (function (param) {
      return diagonals((function (param) {
        return {
          TAG: /* Cons */ 0,
          _0: xs,
          _1: tails$1
        };
      }), xss$1, param);
    })
  };
}

function map_product(f, xs, ys) {
  return function (param) {
    return concat((function (param) {
      return diagonals(empty, (function (param) {
        return map((function (x) {
          return function (param) {
            return map((function (y) {
              return Curry._2(f, x, y);
            }), ys, param);
          };
        }), xs, param);
      }), param);
    }), param);
  };
}

function product(xs, ys) {
  return map_product((function (x, y) {
    return [
      x,
      y
    ];
  }), xs, ys);
}

function of_dispenser(it) {
  const c = function (param) {
    const x = Curry._1(it, undefined);
    if (x !== undefined) {
      return {
        TAG: /* Cons */ 0,
        _0: Caml_option.valFromOption(x),
        _1: c
      };
    } else {
      return /* Nil */ 0;
    }
  };
  return c;
}

function to_dispenser(xs) {
  const s = {
    contents: xs
  };
  return function (param) {
    const match = Curry._1(s.contents, undefined);
    if (/* tag */ typeof match === "number" || typeof match === "string") {
      return;
    }
    s.contents = match._1;
    return Caml_option.some(match._0);
  };
}

function ints(i, param) {
  const partial_arg = i + 1 | 0;
  return {
    TAG: /* Cons */ 0,
    _0: i,
    _1: (function (param) {
      return ints(partial_arg, param);
    })
  };
}

const concat_map = flat_map;

const split = unzip;

export {
  is_empty,
  uncons,
  length,
  iter,
  fold_left,
  iteri,
  fold_lefti,
  for_all,
  exists,
  find,
  find_index,
  find_map,
  find_mapi,
  iter2,
  fold_left2,
  for_all2,
  exists2,
  equal,
  compare,
  empty,
  $$return,
  cons,
  init,
  unfold,
  repeat,
  forever,
  cycle,
  iterate,
  map,
  mapi,
  filter,
  filter_map,
  scan,
  take,
  drop,
  take_while,
  drop_while,
  group,
  memoize,
  Forced_twice,
  once,
  transpose,
  append,
  concat,
  flat_map,
  concat_map,
  zip,
  map2,
  interleave,
  sorted_merge,
  product,
  map_product,
  unzip,
  split,
  partition_map,
  partition,
  of_dispenser,
  to_dispenser,
  ints,
}
/* No side effect */
`,im=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

function Make(funarg) {
  const height = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return 0;
    } else {
      return param.h;
    }
  };
  const create = function (l, v, r) {
    let hl;
    hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
    let hr;
    hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
    return {
      TAG: /* Node */ 0,
      l: l,
      v: v,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  };
  const bal = function (l, v, r) {
    let hl;
    hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
    let hr;
    hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
    if (hl > (hr + 2 | 0)) {
      if (/* tag */ typeof l === "number" || typeof l === "string") {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
      }
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height(ll) >= height(lr)) {
        return create(ll, lv, create(lr, v, r));
      }
      if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
        return create(create(ll, lv, lr.l), lr.v, create(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
    }
    if (hr <= (hl + 2 | 0)) {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: v,
        r: r,
        h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
      };
    }
    if (/* tag */ typeof r === "number" || typeof r === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
    }
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height(rr) >= height(rl)) {
      return create(create(l, v, rl), rv, rr);
    }
    if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
      return create(create(l, v, rl.l), rl.v, create(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Set.bal"
        });
  };
  const add = function (x, t) {
    if (/* tag */ typeof t === "number" || typeof t === "string") {
      return {
        TAG: /* Node */ 0,
        l: /* Empty */ 0,
        v: x,
        r: /* Empty */ 0,
        h: 1
      };
    }
    const r = t.r;
    const v = t.v;
    const l = t.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return t;
    }
    if (c < 0) {
      const ll = add(x, l);
      if (l === ll) {
        return t;
      } else {
        return bal(ll, v, r);
      }
    }
    const rr = add(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal(l, v, rr);
    }
  };
  const singleton = function (x) {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      r: /* Empty */ 0,
      h: 1
    };
  };
  const add_min_element = function (x, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return singleton(x);
    } else {
      return bal(add_min_element(x, param.l), param.v, param.r);
    }
  };
  const add_max_element = function (x, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return singleton(x);
    } else {
      return bal(param.l, param.v, add_max_element(x, param.r));
    }
  };
  const join = function (l, v, r) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      return add_min_element(v, r);
    }
    const lh = l.h;
    if (/* tag */ typeof r === "number" || typeof r === "string") {
      return add_max_element(v, l);
    }
    const rh = r.h;
    if (lh > (rh + 2 | 0)) {
      return bal(l.l, l.v, join(l.r, v, r));
    } else if (rh > (lh + 2 | 0)) {
      return bal(join(l, v, r.l), r.v, r.r);
    } else {
      return create(l, v, r);
    }
  };
  const min_elt = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const l = param.l;
      if (/* tag */ typeof l === "number" || typeof l === "string") {
        return param.v;
      }
      _param = l;
      continue;
    };
  };
  const min_elt_opt = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const l = param.l;
      if (/* tag */ typeof l === "number" || typeof l === "string") {
        return Caml_option.some(param.v);
      }
      _param = l;
      continue;
    };
  };
  const max_elt = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      let tmp = param.r;
      if (/* tag */ typeof tmp === "number" || typeof tmp === "string") {
        return param.v;
      }
      _param = param.r;
      continue;
    };
  };
  const max_elt_opt = function (_param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      let tmp = param.r;
      if (/* tag */ typeof tmp === "number" || typeof tmp === "string") {
        return Caml_option.some(param.v);
      }
      _param = param.r;
      continue;
    };
  };
  const remove_min_elt = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.remove_min_elt"
          });
    }
    const l = param.l;
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      return param.r;
    } else {
      return bal(remove_min_elt(l), param.v, param.r);
    }
  };
  const concat = function (t1, t2) {
    if (/* tag */ typeof t1 === "number" || typeof t1 === "string") {
      return t2;
    } else if (/* tag */ typeof t2 === "number" || typeof t2 === "string") {
      return t1;
    } else {
      return join(t1, min_elt(t2), remove_min_elt(t2));
    }
  };
  const split = function (x, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return [
        /* Empty */ 0,
        false,
        /* Empty */ 0
      ];
    }
    const r = param.r;
    const v = param.v;
    const l = param.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return [
        l,
        true,
        r
      ];
    }
    if (c < 0) {
      const match = split(x, l);
      return [
        match[0],
        match[1],
        join(match[2], v, r)
      ];
    }
    const match$1 = split(x, r);
    return [
      join(l, v, match$1[0]),
      match$1[1],
      match$1[2]
    ];
  };
  const is_empty = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return true;
    } else {
      return false;
    }
  };
  const mem = function (x, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      const c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return true;
      }
      _param = c < 0 ? param.l : param.r;
      continue;
    };
  };
  const remove = function (x, t) {
    if (/* tag */ typeof t === "number" || typeof t === "string") {
      return /* Empty */ 0;
    }
    const r = t.r;
    const v = t.v;
    const l = t.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      if (/* tag */ typeof l === "number" || typeof l === "string") {
        return r;
      } else if (/* tag */ typeof r === "number" || typeof r === "string") {
        return l;
      } else {
        return bal(l, min_elt(r), remove_min_elt(r));
      }
    }
    if (c < 0) {
      const ll = remove(x, l);
      if (l === ll) {
        return t;
      } else {
        return bal(ll, v, r);
      }
    }
    const rr = remove(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal(l, v, rr);
    }
  };
  const union = function (s1, s2) {
    if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
      return s2;
    }
    const h1 = s1.h;
    const v1 = s1.v;
    if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
      return s1;
    }
    const h2 = s2.h;
    const v2 = s2.v;
    if (h1 >= h2) {
      if (h2 === 1) {
        return add(v2, s1);
      }
      const match = split(v1, s2);
      return join(union(s1.l, match[0]), v1, union(s1.r, match[2]));
    }
    if (h1 === 1) {
      return add(v1, s2);
    }
    const match$1 = split(v2, s1);
    return join(union(match$1[0], s2.l), v2, union(match$1[2], s2.r));
  };
  const inter = function (s1, s2) {
    if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
      return /* Empty */ 0;
    }
    if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
      return /* Empty */ 0;
    }
    const r1 = s1.r;
    const v1 = s1.v;
    const l1 = s1.l;
    const match = split(v1, s2);
    const l2 = match[0];
    if (match[1]) {
      return join(inter(l1, l2), v1, inter(r1, match[2]));
    } else {
      return concat(inter(l1, l2), inter(r1, match[2]));
    }
  };
  const split_bis = function (x, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return {
        TAG: /* NotFound */ 0,
        _0: /* Empty */ 0,
        _1: (function (param) {
          return /* Empty */ 0;
        })
      };
    }
    const r = param.r;
    const v = param.v;
    const l = param.l;
    const c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return /* Found */ 0;
    }
    if (c < 0) {
      const match = split_bis(x, l);
      if (/* tag */ typeof match === "number" || typeof match === "string") {
        return /* Found */ 0;
      }
      const rl = match._1;
      return {
        TAG: /* NotFound */ 0,
        _0: match._0,
        _1: (function (param) {
          return join(Curry._1(rl, undefined), v, r);
        })
      };
    }
    const match$1 = split_bis(x, r);
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      return /* Found */ 0;
    } else {
      return {
        TAG: /* NotFound */ 0,
        _0: join(l, v, match$1._0),
        _1: match$1._1
      };
    }
  };
  const disjoint = function (_s1, _s2) {
    while (true) {
      const s2 = _s2;
      const s1 = _s1;
      if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
        return true;
      }
      if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
        return true;
      }
      if (s1 === s2) {
        return false;
      }
      const match = split_bis(s1.v, s2);
      if (/* tag */ typeof match === "number" || typeof match === "string") {
        return false;
      }
      if (!disjoint(s1.l, match._0)) {
        return false;
      }
      _s2 = Curry._1(match._1, undefined);
      _s1 = s1.r;
      continue;
    };
  };
  const diff = function (s1, s2) {
    if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
      return /* Empty */ 0;
    }
    if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
      return s1;
    }
    const r1 = s1.r;
    const v1 = s1.v;
    const l1 = s1.l;
    const match = split(v1, s2);
    const l2 = match[0];
    if (match[1]) {
      return concat(diff(l1, l2), diff(r1, match[2]));
    } else {
      return join(diff(l1, l2), v1, diff(r1, match[2]));
    }
  };
  const cons_enum = function (_s, _e) {
    while (true) {
      const e = _e;
      const s = _s;
      if (/* tag */ typeof s === "number" || typeof s === "string") {
        return e;
      }
      _e = {
        TAG: /* More */ 0,
        _0: s.v,
        _1: s.r,
        _2: e
      };
      _s = s.l;
      continue;
    };
  };
  const compare = function (s1, s2) {
    let _e1 = cons_enum(s1, /* End */ 0);
    let _e2 = cons_enum(s2, /* End */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (/* tag */ typeof e1 === "number" || typeof e1 === "string") {
        if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
          return 0;
        } else {
          return -1;
        }
      }
      if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
        return 1;
      }
      const c = Curry._2(funarg.compare, e1._0, e2._0);
      if (c !== 0) {
        return c;
      }
      _e2 = cons_enum(e2._1, e2._2);
      _e1 = cons_enum(e1._1, e1._2);
      continue;
    };
  };
  const equal = function (s1, s2) {
    return compare(s1, s2) === 0;
  };
  const subset = function (_s1, _s2) {
    while (true) {
      const s2 = _s2;
      const s1 = _s1;
      if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
        return true;
      }
      const r1 = s1.r;
      const v1 = s1.v;
      const l1 = s1.l;
      if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
        return false;
      }
      const r2 = s2.r;
      const l2 = s2.l;
      const c = Curry._2(funarg.compare, v1, s2.v);
      if (c === 0) {
        if (!subset(l1, l2)) {
          return false;
        }
        _s2 = r2;
        _s1 = r1;
        continue;
      }
      if (c < 0) {
        if (!subset({
            TAG: /* Node */ 0,
            l: l1,
            v: v1,
            r: /* Empty */ 0,
            h: 0
          }, l2)) {
          return false;
        }
        _s1 = r1;
        continue;
      }
      if (!subset({
          TAG: /* Node */ 0,
          l: /* Empty */ 0,
          v: v1,
          r: r1,
          h: 0
        }, r2)) {
        return false;
      }
      _s1 = l1;
      continue;
    };
  };
  const iter = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      iter(f, param.l);
      Curry._1(f, param.v);
      _param = param.r;
      continue;
    };
  };
  const fold = function (f, _s, _accu) {
    while (true) {
      const accu = _accu;
      const s = _s;
      if (/* tag */ typeof s === "number" || typeof s === "string") {
        return accu;
      }
      _accu = Curry._2(f, s.v, fold(f, s.l, accu));
      _s = s.r;
      continue;
    };
  };
  const for_all = function (p, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return true;
      }
      if (!Curry._1(p, param.v)) {
        return false;
      }
      if (!for_all(p, param.l)) {
        return false;
      }
      _param = param.r;
      continue;
    };
  };
  const exists = function (p, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return false;
      }
      if (Curry._1(p, param.v)) {
        return true;
      }
      if (exists(p, param.l)) {
        return true;
      }
      _param = param.r;
      continue;
    };
  };
  const filter = function (p, t) {
    if (/* tag */ typeof t === "number" || typeof t === "string") {
      return /* Empty */ 0;
    }
    const r = t.r;
    const v = t.v;
    const l = t.l;
    const l$p = filter(p, l);
    const pv = Curry._1(p, v);
    const r$p = filter(p, r);
    if (pv) {
      if (l === l$p && r === r$p) {
        return t;
      } else {
        return join(l$p, v, r$p);
      }
    } else {
      return concat(l$p, r$p);
    }
  };
  const partition = function (p, param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return [
        /* Empty */ 0,
        /* Empty */ 0
      ];
    }
    const v = param.v;
    const match = partition(p, param.l);
    const lf = match[1];
    const lt = match[0];
    const pv = Curry._1(p, v);
    const match$1 = partition(p, param.r);
    const rf = match$1[1];
    const rt = match$1[0];
    if (pv) {
      return [
        join(lt, v, rt),
        concat(lf, rf)
      ];
    } else {
      return [
        concat(lt, rt),
        join(lf, v, rf)
      ];
    }
  };
  const cardinal = function (param) {
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return 0;
    } else {
      return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
    }
  };
  const elements_aux = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return accu;
      }
      _param = param.l;
      _accu = {
        hd: param.v,
        tl: elements_aux(accu, param.r)
      };
      continue;
    };
  };
  const elements = function (s) {
    return elements_aux(/* [] */ 0, s);
  };
  const find = function (x, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const v = param.v;
      const c = Curry._2(funarg.compare, x, v);
      if (c === 0) {
        return v;
      }
      _param = c < 0 ? param.l : param.r;
      continue;
    };
  };
  const find_first = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _param$1 = param.l;
        while (true) {
          const param$1 = _param$1;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return v0;
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.r;
          continue;
        };
      }
      _param = param.r;
      continue;
    };
  };
  const find_first_opt = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _param$1 = param.l;
        while (true) {
          const param$1 = _param$1;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return Caml_option.some(v0);
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.r;
          continue;
        };
      }
      _param = param.r;
      continue;
    };
  };
  const find_last = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _param$1 = param.r;
        while (true) {
          const param$1 = _param$1;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return v0;
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.l;
          continue;
        };
      }
      _param = param.l;
      continue;
    };
  };
  const find_last_opt = function (f, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _param$1 = param.r;
        while (true) {
          const param$1 = _param$1;
          const v0 = _v0;
          if (/* tag */ typeof param$1 === "number" || typeof param$1 === "string") {
            return Caml_option.some(v0);
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _v0 = v$1;
            continue;
          }
          _param$1 = param$1.l;
          continue;
        };
      }
      _param = param.l;
      continue;
    };
  };
  const find_opt = function (x, _param) {
    while (true) {
      const param = _param;
      if (/* tag */ typeof param === "number" || typeof param === "string") {
        return;
      }
      const v = param.v;
      const c = Curry._2(funarg.compare, x, v);
      if (c === 0) {
        return Caml_option.some(v);
      }
      _param = c < 0 ? param.l : param.r;
      continue;
    };
  };
  const try_join = function (l, v, r) {
    if ((Caml_obj.caml_equal(l, /* Empty */ 0) || Curry._2(funarg.compare, max_elt(l), v) < 0) && (Caml_obj.caml_equal(r, /* Empty */ 0) || Curry._2(funarg.compare, v, min_elt(r)) < 0)) {
      return join(l, v, r);
    } else {
      return union(l, add(v, r));
    }
  };
  const map = function (f, t) {
    if (/* tag */ typeof t === "number" || typeof t === "string") {
      return /* Empty */ 0;
    }
    const r = t.r;
    const v = t.v;
    const l = t.l;
    const l$p = map(f, l);
    const v$p = Curry._1(f, v);
    const r$p = map(f, r);
    if (l === l$p && v === v$p && r === r$p) {
      return t;
    } else {
      return try_join(l$p, v$p, r$p);
    }
  };
  const filter_map = function (f, t) {
    if (/* tag */ typeof t === "number" || typeof t === "string") {
      return /* Empty */ 0;
    }
    const r = t.r;
    const v = t.v;
    const l = t.l;
    const l$p = filter_map(f, l);
    const v$p = Curry._1(f, v);
    const r$p = filter_map(f, r);
    if (v$p === undefined) {
      if (/* tag */ typeof l$p === "number" || typeof l$p === "string") {
        return r$p;
      } else if (/* tag */ typeof r$p === "number" || typeof r$p === "string") {
        return l$p;
      } else {
        return try_join(l$p, min_elt(r$p), remove_min_elt(r$p));
      }
    }
    const v$p$1 = Caml_option.valFromOption(v$p);
    if (l === l$p && v === v$p$1 && r === r$p) {
      return t;
    } else {
      return try_join(l$p, v$p$1, r$p);
    }
  };
  const of_list = function (l) {
    if (!l) {
      return /* Empty */ 0;
    }
    const match = l.tl;
    const x0 = l.hd;
    if (!match) {
      return singleton(x0);
    }
    const match$1 = match.tl;
    const x1 = match.hd;
    if (!match$1) {
      return add(x1, singleton(x0));
    }
    const match$2 = match$1.tl;
    const x2 = match$1.hd;
    if (!match$2) {
      return add(x2, add(x1, singleton(x0)));
    }
    const match$3 = match$2.tl;
    const x3 = match$2.hd;
    if (match$3) {
      if (match$3.tl) {
        let l$1 = Stdlib__List.sort_uniq(funarg.compare, l);
        const sub = function (n, l) {
          switch (n) {
            case 0 :
              return [
                /* Empty */ 0,
                l
              ];
            case 1 :
              if (l) {
                return [
                  {
                    TAG: /* Node */ 0,
                    l: /* Empty */ 0,
                    v: l.hd,
                    r: /* Empty */ 0,
                    h: 1
                  },
                  l.tl
                ];
              }
              break;
            case 2 :
              if (l) {
                const match = l.tl;
                if (match) {
                  return [
                    {
                      TAG: /* Node */ 0,
                      l: {
                        TAG: /* Node */ 0,
                        l: /* Empty */ 0,
                        v: l.hd,
                        r: /* Empty */ 0,
                        h: 1
                      },
                      v: match.hd,
                      r: /* Empty */ 0,
                      h: 2
                    },
                    match.tl
                  ];
                }
                
              }
              break;
            case 3 :
              if (l) {
                const match$1 = l.tl;
                if (match$1) {
                  const match$2 = match$1.tl;
                  if (match$2) {
                    return [
                      {
                        TAG: /* Node */ 0,
                        l: {
                          TAG: /* Node */ 0,
                          l: /* Empty */ 0,
                          v: l.hd,
                          r: /* Empty */ 0,
                          h: 1
                        },
                        v: match$1.hd,
                        r: {
                          TAG: /* Node */ 0,
                          l: /* Empty */ 0,
                          v: match$2.hd,
                          r: /* Empty */ 0,
                          h: 1
                        },
                        h: 2
                      },
                      match$2.tl
                    ];
                  }
                  
                }
                
              }
              break;
          }
          const nl = n / 2 | 0;
          const match$3 = sub(nl, l);
          const l$1 = match$3[1];
          if (l$1) {
            const match$4 = sub((n - nl | 0) - 1 | 0, l$1.tl);
            return [
              create(match$3[0], l$1.hd, match$4[0]),
              match$4[1]
            ];
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/stdlib/set.ml",
                  571,
                  18
                ]
              });
        };
        return sub(Stdlib__List.length(l$1), l$1)[0];
      } else {
        return add(match$3.hd, add(x3, add(x2, add(x1, singleton(x0)))));
      }
    } else {
      return add(x3, add(x2, add(x1, singleton(x0))));
    }
  };
  const add_seq = function (i, m) {
    return Stdlib__Seq.fold_left((function (s, x) {
      return add(x, s);
    }), m, i);
  };
  const of_seq = function (i) {
    return add_seq(i, /* Empty */ 0);
  };
  const seq_of_enum_ = function (c, param) {
    if (/* tag */ typeof c === "number" || typeof c === "string") {
      return /* Nil */ 0;
    }
    const partial_arg = cons_enum(c._1, c._2);
    return {
      TAG: /* Cons */ 0,
      _0: c._0,
      _1: (function (param) {
        return seq_of_enum_(partial_arg, param);
      })
    };
  };
  const to_seq = function (c) {
    const partial_arg = cons_enum(c, /* End */ 0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  const snoc_enum = function (_s, _e) {
    while (true) {
      const e = _e;
      const s = _s;
      if (/* tag */ typeof s === "number" || typeof s === "string") {
        return e;
      }
      _e = {
        TAG: /* More */ 0,
        _0: s.v,
        _1: s.l,
        _2: e
      };
      _s = s.r;
      continue;
    };
  };
  const rev_seq_of_enum_ = function (c, param) {
    if (/* tag */ typeof c === "number" || typeof c === "string") {
      return /* Nil */ 0;
    }
    const partial_arg = snoc_enum(c._1, c._2);
    return {
      TAG: /* Cons */ 0,
      _0: c._0,
      _1: (function (param) {
        return rev_seq_of_enum_(partial_arg, param);
      })
    };
  };
  const to_rev_seq = function (c) {
    const partial_arg = snoc_enum(c, /* End */ 0);
    return function (param) {
      return rev_seq_of_enum_(partial_arg, param);
    };
  };
  const to_seq_from = function (low, s) {
    const aux = function (low, _s, _c) {
      while (true) {
        const c = _c;
        const s = _s;
        if (/* tag */ typeof s === "number" || typeof s === "string") {
          return c;
        }
        const r = s.r;
        const v = s.v;
        const n = Curry._2(funarg.compare, v, low);
        if (n === 0) {
          return {
            TAG: /* More */ 0,
            _0: v,
            _1: r,
            _2: c
          };
        }
        if (n < 0) {
          _s = r;
          continue;
        }
        _c = {
          TAG: /* More */ 0,
          _0: v,
          _1: r,
          _2: c
        };
        _s = s.l;
        continue;
      };
    };
    const partial_arg = aux(low, s, /* End */ 0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  return {
    empty: /* Empty */ 0,
    add: add,
    singleton: singleton,
    remove: remove,
    union: union,
    inter: inter,
    disjoint: disjoint,
    diff: diff,
    cardinal: cardinal,
    elements: elements,
    min_elt: min_elt,
    min_elt_opt: min_elt_opt,
    max_elt: max_elt,
    max_elt_opt: max_elt_opt,
    choose: min_elt,
    choose_opt: min_elt_opt,
    find: find,
    find_opt: find_opt,
    find_first: find_first,
    find_first_opt: find_first_opt,
    find_last: find_last,
    find_last_opt: find_last_opt,
    iter: iter,
    fold: fold,
    map: map,
    filter: filter,
    filter_map: filter_map,
    partition: partition,
    split: split,
    is_empty: is_empty,
    mem: mem,
    equal: equal,
    compare: compare,
    subset: subset,
    for_all: for_all,
    exists: exists,
    to_list: elements,
    of_list: of_list,
    to_seq_from: to_seq_from,
    to_seq: to_seq,
    to_rev_seq: to_rev_seq,
    add_seq: add_seq,
    of_seq: of_seq
  };
}

export {
  Make,
}
/* No side effect */
`,sm=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

const Empty = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Stack.Empty");

function create(param) {
  return {
    c: /* [] */ 0,
    len: 0
  };
}

function clear(s) {
  s.c = /* [] */ 0;
  s.len = 0;
}

function copy(s) {
  return {
    c: s.c,
    len: s.len
  };
}

function push(x, s) {
  s.c = {
    hd: x,
    tl: s.c
  };
  s.len = s.len + 1 | 0;
}

function pop(s) {
  const match = s.c;
  if (match) {
    s.c = match.tl;
    s.len = s.len - 1 | 0;
    return match.hd;
  }
  throw new Caml_js_exceptions.MelangeError(Empty, {
        MEL_EXN_ID: Empty
      });
}

function pop_opt(s) {
  const match = s.c;
  if (match) {
    s.c = match.tl;
    s.len = s.len - 1 | 0;
    return Caml_option.some(match.hd);
  }
  
}

function drop(s) {
  const match = s.c;
  if (match) {
    s.c = match.tl;
    s.len = s.len - 1 | 0;
    return;
  }
  throw new Caml_js_exceptions.MelangeError(Empty, {
        MEL_EXN_ID: Empty
      });
}

function top(s) {
  const match = s.c;
  if (match) {
    return match.hd;
  }
  throw new Caml_js_exceptions.MelangeError(Empty, {
        MEL_EXN_ID: Empty
      });
}

function top_opt(s) {
  const match = s.c;
  if (match) {
    return Caml_option.some(match.hd);
  }
  
}

function is_empty(s) {
  return Caml_obj.caml_equal(s.c, /* [] */ 0);
}

function length(s) {
  return s.len;
}

function iter(f, s) {
  Stdlib__List.iter(f, s.c);
}

function fold(f, acc, s) {
  return Stdlib__List.fold_left(f, acc, s.c);
}

function to_seq(s) {
  return Stdlib__List.to_seq(s.c);
}

function add_seq(q, i) {
  Stdlib__Seq.iter((function (x) {
    push(x, q);
  }), i);
}

function of_seq(g) {
  const s = {
    c: /* [] */ 0,
    len: 0
  };
  add_seq(s, g);
  return s;
}

export {
  Empty,
  create,
  push,
  pop,
  pop_opt,
  drop,
  top,
  top_opt,
  clear,
  copy,
  is_empty,
  length,
  iter,
  fold,
  to_seq,
  add_seq,
  of_seq,
}
/* No side effect */
`,om=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,lm=`// Generated by Melange

import * as Stdlib from "./stdlib.js";

Stdlib.do_at_exit(undefined);
/*  Not a pure module */
`,cm=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Caml_sys from "melange.js/caml_sys.js";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.js";
import * as Curry from "melange.js/curry.js";

function failwith(s) {
  throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: s
      });
}

function invalid_arg(s) {
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: s
      });
}

const Exit = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Exit");

const Failure = "Failure";

const Sys_error = "Sys_error";

const End_of_file = "End_of_file";

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

const min_int = -2147483648;

function classify_float(x) {
  if (isFinite(x)) {
    if (Math.abs(x) >= 2.22507385850720138e-308) {
      return /* FP_normal */ 0;
    } else if (x !== 0) {
      return /* FP_subnormal */ 1;
    } else {
      return /* FP_zero */ 2;
    }
  } else if (isNaN(x)) {
    return /* FP_nan */ 4;
  } else {
    return /* FP_infinite */ 3;
  }
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "char_of_int"
        });
  }
  return n;
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" :
      return false;
    case "true" :
      return true;
    default:
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "bool_of_string"
          });
  }
}

function bool_of_string_opt(param) {
  switch (param) {
    case "false" :
      return false;
    case "true" :
      return true;
    default:
      return;
  }
}

function int_of_string_opt(s) {
  try {
    return Caml_format.caml_int_of_string(s);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Failure) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function valid_float_lexem(s) {
  const l = s.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i >= l) {
      return s + ".";
    }
    const match = Caml_string.get(s, i);
    if (match >= 48) {
      if (match >= 58) {
        return s;
      }
      _i = i + 1 | 0;
      continue;
    }
    if (match !== 45) {
      return s;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function string_of_float(f) {
  return valid_float_lexem(Caml_format.caml_format_float("%.12g", f));
}

function float_of_string_opt(s) {
  try {
    return Caml_format.caml_float_of_string(s);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Failure) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function $at_dps(_dst, _offset, _l1, l2) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const l1 = _l1;
    if (!l1) {
      dst[offset] = l2;
      return;
    }
    const match = l1.tl;
    const h1 = l1.hd;
    if (!match) {
      dst[offset] = {
        hd: h1,
        tl: l2
      };
      return;
    }
    const match$1 = match.tl;
    const h2 = match.hd;
    if (!match$1) {
      dst[offset] = {
        hd: h1,
        tl: {
          hd: h2,
          tl: l2
        }
      };
      return;
    }
    const block = {
      hd: match$1.hd,
      tl: 24029
    };
    dst[offset] = {
      hd: h1,
      tl: {
        hd: h2,
        tl: block
      }
    };
    _l1 = match$1.tl;
    _offset = "tl";
    _dst = block;
    continue;
  };
}

function $at(l1, l2) {
  if (!l1) {
    return l2;
  }
  const match = l1.tl;
  const h1 = l1.hd;
  if (!match) {
    return {
      hd: h1,
      tl: l2
    };
  }
  const match$1 = match.tl;
  const h2 = match.hd;
  if (!match$1) {
    return {
      hd: h1,
      tl: {
        hd: h2,
        tl: l2
      }
    };
  }
  const block = {
    hd: match$1.hd,
    tl: 24029
  };
  return {
    hd: h1,
    tl: {
      hd: h2,
      tl: ($at_dps(block, "tl", match$1.tl, l2), block)
    }
  };
}

const stdin = Caml_io.stdin;

const stdout = Caml_io.stdout;

const stderr = Caml_io.stderr;

function open_out_gen(mode, perm, name) {
  const c = Caml_external_polyfill.resolve("caml_ml_open_descriptor_out")(Caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  Caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_out(name) {
  return open_out_gen({
    hd: /* Open_wronly */ 1,
    tl: {
      hd: /* Open_creat */ 3,
      tl: {
        hd: /* Open_trunc */ 4,
        tl: {
          hd: /* Open_text */ 7,
          tl: /* [] */ 0
        }
      }
    }
  }, 438, name);
}

function open_out_bin(name) {
  return open_out_gen({
    hd: /* Open_wronly */ 1,
    tl: {
      hd: /* Open_creat */ 3,
      tl: {
        hd: /* Open_trunc */ 4,
        tl: {
          hd: /* Open_binary */ 6,
          tl: /* [] */ 0
        }
      }
    }
  }, 438, name);
}

function flush_all(param) {
  let _param = Caml_io.caml_ml_out_channels_list(undefined);
  while (true) {
    const param$1 = _param;
    if (!param$1) {
      return;
    }
    try {
      Caml_io.caml_ml_flush(param$1.hd);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID !== Sys_error) {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
      
    }
    _param = param$1.tl;
    continue;
  };
}

function output_bytes(oc, s) {
  Caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, 0, s.length);
}

function output_string(oc, s) {
  Caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "output"
        });
  }
  Caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, ofs, len);
}

function output_substring(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "output_substring"
        });
  }
  Caml_io.caml_ml_output(oc, s, ofs, len);
}

function output_value(chan, v) {
  Caml_external_polyfill.resolve("caml_output_value")(chan, v, /* [] */ 0);
}

function close_out(oc) {
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function close_out_noerr(oc) {
  try {
    Caml_io.caml_ml_flush(oc);
  }
  catch (exn){
    
  }
  try {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
  }
  catch (exn$1){
    return;
  }
}

function open_in_gen(mode, perm, name) {
  const c = Caml_external_polyfill.resolve("caml_ml_open_descriptor_in")(Caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  Caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_in(name) {
  return open_in_gen({
    hd: /* Open_rdonly */ 0,
    tl: {
      hd: /* Open_text */ 7,
      tl: /* [] */ 0
    }
  }, 0, name);
}

function open_in_bin(name) {
  return open_in_gen({
    hd: /* Open_rdonly */ 0,
    tl: {
      hd: /* Open_binary */ 6,
      tl: /* [] */ 0
    }
  }, 0, name);
}

function input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "input"
        });
  }
  return Caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
}

function unsafe_really_input(ic, s, _ofs, _len) {
  while (true) {
    const len = _len;
    const ofs = _ofs;
    if (len <= 0) {
      return;
    }
    const r = Caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
    if (r === 0) {
      throw new Caml_js_exceptions.MelangeError(End_of_file, {
            MEL_EXN_ID: End_of_file
          });
    }
    _len = len - r | 0;
    _ofs = ofs + r | 0;
    continue;
  };
}

function really_input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "really_input"
        });
  }
  unsafe_really_input(ic, s, ofs, len);
}

function really_input_string(ic, len) {
  const s = Caml_bytes.caml_create_bytes(len);
  really_input(ic, s, 0, len);
  return Caml_bytes.bytes_to_string(s);
}

function input_line(chan) {
  const build_result = function (buf, _pos, _param) {
    while (true) {
      const param = _param;
      const pos = _pos;
      if (!param) {
        return buf;
      }
      const hd = param.hd;
      const len = hd.length;
      Caml_bytes.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
      _param = param.tl;
      _pos = pos - len | 0;
      continue;
    };
  };
  const scan = function (_accu, _len) {
    while (true) {
      const len = _len;
      const accu = _accu;
      const n = Caml_external_polyfill.resolve("caml_ml_input_scan_line")(chan);
      if (n === 0) {
        if (accu) {
          return build_result(Caml_bytes.caml_create_bytes(len), len, accu);
        }
        throw new Caml_js_exceptions.MelangeError(End_of_file, {
              MEL_EXN_ID: End_of_file
            });
      }
      if (n > 0) {
        const res = Caml_bytes.caml_create_bytes(n - 1 | 0);
        Caml_external_polyfill.resolve("caml_ml_input")(chan, res, 0, n - 1 | 0);
        Caml_external_polyfill.resolve("caml_ml_input_char")(chan);
        if (!accu) {
          return res;
        }
        const len$1 = (len + n | 0) - 1 | 0;
        return build_result(Caml_bytes.caml_create_bytes(len$1), len$1, {
          hd: res,
          tl: accu
        });
      }
      const beg = Caml_bytes.caml_create_bytes(-n | 0);
      Caml_external_polyfill.resolve("caml_ml_input")(chan, beg, 0, -n | 0);
      _len = len - n | 0;
      _accu = {
        hd: beg,
        tl: accu
      };
      continue;
    };
  };
  return Caml_bytes.bytes_to_string(scan(/* [] */ 0, 0));
}

function close_in_noerr(ic) {
  try {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  }
  catch (exn){
    return;
  }
}

function print_char(c) {
  Caml_io.caml_ml_output_char(stdout, c);
}

function print_string(s) {
  output_string(stdout, s);
}

function print_bytes(s) {
  output_bytes(stdout, s);
}

function print_int(i) {
  output_string(stdout, String(i));
}

function print_float(f) {
  output_string(stdout, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function print_newline(param) {
  Caml_io.caml_ml_output_char(stdout, /* '\\n' */10);
  Caml_io.caml_ml_flush(stdout);
}

function prerr_char(c) {
  Caml_io.caml_ml_output_char(stderr, c);
}

function prerr_string(s) {
  output_string(stderr, s);
}

function prerr_bytes(s) {
  output_bytes(stderr, s);
}

function prerr_int(i) {
  output_string(stderr, String(i));
}

function prerr_float(f) {
  output_string(stderr, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function prerr_newline(param) {
  Caml_io.caml_ml_output_char(stderr, /* '\\n' */10);
  Caml_io.caml_ml_flush(stderr);
}

function read_line(param) {
  Caml_io.caml_ml_flush(stdout);
  return input_line(stdin);
}

function read_int(param) {
  return Caml_format.caml_int_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_int_opt(param) {
  return int_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float(param) {
  return Caml_format.caml_float_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float_opt(param) {
  return float_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function string_of_format(param) {
  return param._1;
}

function $caret$caret(param, param$1) {
  return {
    TAG: /* Format */ 0,
    _0: CamlinternalFormatBasics.concat_fmt(param._0, param$1._0),
    _1: param._1 + ("%," + param$1._1)
  };
}

const exit_function = {
  contents: flush_all
};

function at_exit(f) {
  const f_yet_to_run = {
    contents: true
  };
  const old_exit = exit_function.contents;
  const new_exit = function (param) {
    if (!f_yet_to_run.contents) {
      f_yet_to_run.contents = false;
      Curry._1(f, undefined);
    }
    Curry._1(old_exit, undefined);
  };
  exit_function.contents = new_exit;
}

const do_domain_local_at_exit = {
  contents: (function (param) {
    
  })
};

function do_at_exit(param) {
  Curry._1(do_domain_local_at_exit.contents, undefined);
  Curry._1(exit_function.contents, undefined);
}

function exit(retcode) {
  do_at_exit(undefined);
  return Caml_sys.caml_sys_exit(retcode);
}

const Match_failure = "Match_failure";

const Assert_failure = "Assert_failure";

const Invalid_argument = "Invalid_argument";

const Not_found = "Not_found";

const Out_of_memory = "Out_of_memory";

const Stack_overflow = "Stack_overflow";

const Division_by_zero = "Division_by_zero";

const Sys_blocked_io = "Sys_blocked_io";

const Undefined_recursive_module = "Undefined_recursive_module";

const max_int = 2147483647;

const infinity = Infinity;

const neg_infinity = -Infinity;

const max_float = 1.79769313486231571e+308;

const min_float = 2.22507385850720138e-308;

const epsilon_float = 2.22044604925031308e-16;

const flush = Caml_io.caml_ml_flush;

const output_char = Caml_io.caml_ml_output_char;

const output_byte = Caml_io.caml_ml_output_char;

function output_binary_int(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_output_int")(prim0, prim1);
}

function seek_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_out")(prim0, prim1);
}

function pos_out(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_out")(prim);
}

function out_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function set_binary_mode_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim0, prim1);
}

function input_char(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_byte(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_binary_int(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_int")(prim);
}

function input_value(prim) {
  return Caml_external_polyfill.resolve("caml_input_value")(prim);
}

function seek_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_in")(prim0, prim1);
}

function pos_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_in")(prim);
}

function in_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function close_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_close_channel")(prim);
}

function set_binary_mode_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim0, prim1);
}

function LargeFile_seek_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_out_64")(prim0, prim1);
}

function LargeFile_pos_out(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_out_64")(prim);
}

function LargeFile_out_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

function LargeFile_seek_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_in_64")(prim0, prim1);
}

function LargeFile_pos_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_in_64")(prim);
}

function LargeFile_in_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

const LargeFile = {
  seek_out: LargeFile_seek_out,
  pos_out: LargeFile_pos_out,
  out_channel_length: LargeFile_out_channel_length,
  seek_in: LargeFile_seek_in,
  pos_in: LargeFile_pos_in,
  in_channel_length: LargeFile_in_channel_length
};

export {
  invalid_arg,
  failwith,
  Exit,
  Match_failure,
  Assert_failure,
  Invalid_argument,
  Failure,
  Not_found,
  Out_of_memory,
  Stack_overflow,
  Sys_error,
  End_of_file,
  Division_by_zero,
  Sys_blocked_io,
  Undefined_recursive_module,
  abs,
  max_int,
  min_int,
  lnot,
  infinity,
  neg_infinity,
  max_float,
  min_float,
  epsilon_float,
  classify_float,
  char_of_int,
  string_of_bool,
  bool_of_string_opt,
  bool_of_string,
  int_of_string_opt,
  string_of_float,
  float_of_string_opt,
  $at,
  stdin,
  stdout,
  stderr,
  print_char,
  print_string,
  print_bytes,
  print_int,
  print_float,
  print_newline,
  prerr_char,
  prerr_string,
  prerr_bytes,
  prerr_int,
  prerr_float,
  prerr_newline,
  read_line,
  read_int_opt,
  read_int,
  read_float_opt,
  read_float,
  open_out,
  open_out_bin,
  open_out_gen,
  flush,
  flush_all,
  output_char,
  output_string,
  output_bytes,
  output,
  output_substring,
  output_byte,
  output_binary_int,
  output_value,
  seek_out,
  pos_out,
  out_channel_length,
  close_out,
  close_out_noerr,
  set_binary_mode_out,
  open_in,
  open_in_bin,
  open_in_gen,
  input_char,
  input_line,
  input,
  really_input,
  really_input_string,
  input_byte,
  input_binary_int,
  input_value,
  seek_in,
  pos_in,
  in_channel_length,
  close_in,
  close_in_noerr,
  set_binary_mode_in,
  LargeFile,
  string_of_format,
  $caret$caret,
  exit,
  at_exit,
  valid_float_lexem,
  unsafe_really_input,
  do_at_exit,
  do_domain_local_at_exit,
}
/* No side effect */
`,_m=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";

function make(n, c) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, c));
}

function init(n, f) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.init(n, f));
}

function sub(s, ofs, len) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.sub(Caml_bytes.bytes_of_string(s), ofs, len));
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.concat"
      });
}

function sum_lengths(_acc, seplen, _param) {
  while (true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return acc;
    }
    const hd = param.hd;
    if (!param.tl) {
      return hd.length + acc | 0;
    }
    _param = param.tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue;
  };
}

function unsafe_blits(dst, _pos, sep, seplen, _param) {
  while (true) {
    const param = _param;
    const pos = _pos;
    if (!param) {
      return dst;
    }
    const hd = param.hd;
    if (param.tl) {
      Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
      Caml_bytes.caml_blit_string(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = param.tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue;
    }
    Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
    return dst;
  };
}

function concat(sep, l) {
  if (!l) {
    return "";
  }
  const seplen = sep.length;
  return Caml_bytes.bytes_to_string(unsafe_blits(Caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l)), 0, sep, seplen, l));
}

function cat(prim0, prim1) {
  return prim0 + prim1;
}

function iter(f, s) {
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    Curry._1(f, s.charCodeAt(i));
  }
}

function iteri(f, s) {
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    Curry._2(f, i, s.charCodeAt(i));
  }
}

function map(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.map(f, Caml_bytes.bytes_of_string(s)));
}

function mapi(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.mapi(f, Caml_bytes.bytes_of_string(s)));
}

function fold_right(f, x, a) {
  return Stdlib__Bytes.fold_right(f, Caml_bytes.bytes_of_string(x), a);
}

function fold_left(f, a, x) {
  return Stdlib__Bytes.fold_left(f, a, Caml_bytes.bytes_of_string(x));
}

function exists(f, s) {
  return Stdlib__Bytes.exists(f, Caml_bytes.bytes_of_string(s));
}

function for_all(f, s) {
  return Stdlib__Bytes.for_all(f, Caml_bytes.bytes_of_string(s));
}

function is_space(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}

function trim(s) {
  if (s === "" || !(is_space(s.charCodeAt(0)) || is_space(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return Caml_bytes.bytes_to_string(Stdlib__Bytes.trim(Caml_bytes.bytes_of_string(s)));
  }
}

function escaped(s) {
  const b = Caml_bytes.bytes_of_string(s);
  const b$p = Stdlib__Bytes.unsafe_escape(b);
  if (b === b$p) {
    return s;
  } else {
    return Caml_bytes.bytes_to_string(b$p);
  }
}

function index_rec(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      return;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from / Bytes.index_from"
        });
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from_opt / Bytes.index_from_opt"
        });
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  };
}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from / Bytes.rindex_from"
        });
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      return;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  };
}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from_opt / Bytes.rindex_from_opt"
        });
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.contains_from / Bytes.contains_from"
        });
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rcontains_from / Bytes.rcontains_from"
        });
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function uppercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uppercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function lowercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function capitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.capitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function uncapitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uncapitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function starts_with(prefix, s) {
  const len_s = s.length;
  const len_pre = prefix.length;
  if (len_s >= len_pre) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_pre) {
        return true;
      }
      if (s.charCodeAt(i) !== prefix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function ends_with(suffix, s) {
  const len_s = s.length;
  const len_suf = suffix.length;
  const diff = len_s - len_suf | 0;
  if (diff >= 0) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_suf) {
        return true;
      }
      if (s.charCodeAt(diff + i | 0) !== suffix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function hash(x) {
  return Caml_external_polyfill.resolve("caml_string_hash")(0, x);
}

function split_on_char(sep, s) {
  let r = /* [] */ 0;
  let j = s.length;
  for (let i = s.length - 1 | 0; i >= 0; --i) {
    if (s.charCodeAt(i) === sep) {
      r = {
        hd: sub(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
    
  }
  return {
    hd: sub(s, 0, j),
    tl: r
  };
}

const compare = Caml.caml_string_compare;

function to_seq(s) {
  return Stdlib__Bytes.to_seq(Caml_bytes.bytes_of_string(s));
}

function to_seqi(s) {
  return Stdlib__Bytes.to_seqi(Caml_bytes.bytes_of_string(s));
}

function of_seq(g) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.of_seq(g));
}

function get_utf_8_uchar(s, i) {
  return Stdlib__Bytes.get_utf_8_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_8(s) {
  return Stdlib__Bytes.is_valid_utf_8(Caml_bytes.bytes_of_string(s));
}

function get_utf_16be_uchar(s, i) {
  return Stdlib__Bytes.get_utf_16be_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_16be(s) {
  return Stdlib__Bytes.is_valid_utf_16be(Caml_bytes.bytes_of_string(s));
}

function get_utf_16le_uchar(s, i) {
  return Stdlib__Bytes.get_utf_16le_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_16le(s) {
  return Stdlib__Bytes.is_valid_utf_16le(Caml_bytes.bytes_of_string(s));
}

function get_int8(s, i) {
  return Stdlib__Bytes.get_int8(Caml_bytes.bytes_of_string(s), i);
}

function get_uint16_le(s, i) {
  return Stdlib__Bytes.get_uint16_le(Caml_bytes.bytes_of_string(s), i);
}

function get_uint16_be(s, i) {
  return Stdlib__Bytes.get_uint16_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_ne(s, i) {
  return Stdlib__Bytes.get_int16_ne(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_le(s, i) {
  return Stdlib__Bytes.get_int16_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_be(s, i) {
  return Stdlib__Bytes.get_int16_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int32_le(s, i) {
  return Stdlib__Bytes.get_int32_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int32_be(s, i) {
  return Stdlib__Bytes.get_int32_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int64_le(s, i) {
  return Stdlib__Bytes.get_int64_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int64_be(s, i) {
  return Stdlib__Bytes.get_int64_be(Caml_bytes.bytes_of_string(s), i);
}

const empty = "";

const of_bytes = Stdlib__Bytes.to_string;

const to_bytes = Stdlib__Bytes.of_string;

const blit = Stdlib__Bytes.blit_string;

function equal(prim0, prim1) {
  return prim0 === prim1;
}

const get_uint8 = Caml_string.get;

const get_uint16_ne = Caml_bytes.get16;

const get_int32_ne = Caml_bytes.get32;

function seeded_hash(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_string_hash")(prim0, prim1);
}

const get_int64_ne = Caml_bytes.get64;

export {
  make,
  init,
  empty,
  of_bytes,
  to_bytes,
  blit,
  concat,
  cat,
  equal,
  compare,
  starts_with,
  ends_with,
  contains_from,
  rcontains_from,
  contains,
  sub,
  split_on_char,
  map,
  mapi,
  fold_left,
  fold_right,
  for_all,
  exists,
  trim,
  escaped,
  uppercase_ascii,
  lowercase_ascii,
  capitalize_ascii,
  uncapitalize_ascii,
  iter,
  iteri,
  index_from,
  index_from_opt,
  rindex_from,
  rindex_from_opt,
  index,
  index_opt,
  rindex,
  rindex_opt,
  to_seq,
  to_seqi,
  of_seq,
  get_utf_8_uchar,
  is_valid_utf_8,
  get_utf_16be_uchar,
  is_valid_utf_16be,
  get_utf_16le_uchar,
  is_valid_utf_16le,
  get_uint8,
  get_int8,
  get_uint16_ne,
  get_uint16_be,
  get_uint16_le,
  get_int16_ne,
  get_int16_be,
  get_int16_le,
  get_int32_ne,
  hash,
  seeded_hash,
  get_int32_be,
  get_int32_le,
  get_int64_ne,
  get_int64_be,
  get_int64_le,
}
/* No side effect */
`,um=`// Generated by Melange

import * as Stdlib__String from "./string.js";

const make = Stdlib__String.make;

const init = Stdlib__String.init;

const empty = Stdlib__String.empty;

const of_bytes = Stdlib__String.of_bytes;

const to_bytes = Stdlib__String.to_bytes;

const blit = Stdlib__String.blit;

const concat = Stdlib__String.concat;

const cat = Stdlib__String.cat;

const equal = Stdlib__String.equal;

const compare = Stdlib__String.compare;

const starts_with = Stdlib__String.starts_with;

const ends_with = Stdlib__String.ends_with;

const contains_from = Stdlib__String.contains_from;

const rcontains_from = Stdlib__String.rcontains_from;

const contains = Stdlib__String.contains;

const sub = Stdlib__String.sub;

const split_on_char = Stdlib__String.split_on_char;

const map = Stdlib__String.map;

const mapi = Stdlib__String.mapi;

const fold_left = Stdlib__String.fold_left;

const fold_right = Stdlib__String.fold_right;

const for_all = Stdlib__String.for_all;

const exists = Stdlib__String.exists;

const trim = Stdlib__String.trim;

const escaped = Stdlib__String.escaped;

const uppercase_ascii = Stdlib__String.uppercase_ascii;

const lowercase_ascii = Stdlib__String.lowercase_ascii;

const capitalize_ascii = Stdlib__String.capitalize_ascii;

const uncapitalize_ascii = Stdlib__String.uncapitalize_ascii;

const iter = Stdlib__String.iter;

const iteri = Stdlib__String.iteri;

const index_from = Stdlib__String.index_from;

const index_from_opt = Stdlib__String.index_from_opt;

const rindex_from = Stdlib__String.rindex_from;

const rindex_from_opt = Stdlib__String.rindex_from_opt;

const index = Stdlib__String.index;

const index_opt = Stdlib__String.index_opt;

const rindex = Stdlib__String.rindex;

const rindex_opt = Stdlib__String.rindex_opt;

const to_seq = Stdlib__String.to_seq;

const to_seqi = Stdlib__String.to_seqi;

const of_seq = Stdlib__String.of_seq;

const get_utf_8_uchar = Stdlib__String.get_utf_8_uchar;

const is_valid_utf_8 = Stdlib__String.is_valid_utf_8;

const get_utf_16be_uchar = Stdlib__String.get_utf_16be_uchar;

const is_valid_utf_16be = Stdlib__String.is_valid_utf_16be;

const get_utf_16le_uchar = Stdlib__String.get_utf_16le_uchar;

const is_valid_utf_16le = Stdlib__String.is_valid_utf_16le;

const get_uint8 = Stdlib__String.get_uint8;

const get_int8 = Stdlib__String.get_int8;

const get_uint16_ne = Stdlib__String.get_uint16_ne;

const get_uint16_be = Stdlib__String.get_uint16_be;

const get_uint16_le = Stdlib__String.get_uint16_le;

const get_int16_ne = Stdlib__String.get_int16_ne;

const get_int16_be = Stdlib__String.get_int16_be;

const get_int16_le = Stdlib__String.get_int16_le;

const get_int32_ne = Stdlib__String.get_int32_ne;

const hash = Stdlib__String.hash;

const seeded_hash = Stdlib__String.seeded_hash;

const get_int32_be = Stdlib__String.get_int32_be;

const get_int32_le = Stdlib__String.get_int32_le;

const get_int64_ne = Stdlib__String.get_int64_ne;

const get_int64_be = Stdlib__String.get_int64_be;

const get_int64_le = Stdlib__String.get_int64_le;

export {
  make,
  init,
  empty,
  of_bytes,
  to_bytes,
  blit,
  concat,
  cat,
  equal,
  compare,
  starts_with,
  ends_with,
  contains_from,
  rcontains_from,
  contains,
  sub,
  split_on_char,
  map,
  mapi,
  fold_left,
  fold_right,
  for_all,
  exists,
  trim,
  escaped,
  uppercase_ascii,
  lowercase_ascii,
  capitalize_ascii,
  uncapitalize_ascii,
  iter,
  iteri,
  index_from,
  index_from_opt,
  rindex_from,
  rindex_from_opt,
  index,
  index_opt,
  rindex,
  rindex_opt,
  to_seq,
  to_seqi,
  of_seq,
  get_utf_8_uchar,
  is_valid_utf_8,
  get_utf_16be_uchar,
  is_valid_utf_16be,
  get_utf_16le_uchar,
  is_valid_utf_16le,
  get_uint8,
  get_int8,
  get_uint16_ne,
  get_uint16_be,
  get_uint16_le,
  get_int16_ne,
  get_int16_be,
  get_int16_le,
  get_int32_ne,
  hash,
  seeded_hash,
  get_int32_be,
  get_int32_le,
  get_int64_ne,
  get_int64_be,
  get_int64_le,
}
/* No side effect */
`,fm=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_sys from "melange.js/caml_sys.js";

const executable_name = Caml_sys.caml_sys_executable_name(undefined);

const os_type = Caml_sys.os_type(undefined);

const backend_type = {
  TAG: /* Other */ 0,
  _0: "Melange"
};

const big_endian = false;

const unix = Caml_sys.os_type(undefined) === "Unix";

const win32 = Caml_sys.os_type(undefined) === "Win32";

function getenv_opt(s) {
  const x = typeof process === "undefined" ? undefined : process;
  if (x !== undefined) {
    return x.env[s];
  }
  
}

const interactive = {
  contents: false
};

function set_signal(sig_num, sig_beh) {
  
}

const Break = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Sys.Break");

function catch_break(on) {
  
}

function Make(Immediate, Non_immediate) {
  const repr = /* Non_immediate */ 1;
  return {
    repr: repr
  };
}

const Immediate64 = {
  Make: Make
};

const cygwin = false;

const word_size = 32;

const int_size = 32;

const max_string_length = 2147483647;

const max_array_length = 2147483647;

const max_floatarray_length = 2147483647;

const sigabrt = -1;

const sigalrm = -2;

const sigfpe = -3;

const sighup = -4;

const sigill = -5;

const sigint = -6;

const sigkill = -7;

const sigpipe = -8;

const sigquit = -9;

const sigsegv = -10;

const sigterm = -11;

const sigusr1 = -12;

const sigusr2 = -13;

const sigchld = -14;

const sigcont = -15;

const sigstop = -16;

const sigtstp = -17;

const sigttin = -18;

const sigttou = -19;

const sigvtalrm = -20;

const sigprof = -21;

const sigbus = -22;

const sigpoll = -23;

const sigsys = -24;

const sigtrap = -25;

const sigurg = -26;

const sigxcpu = -27;

const sigxfsz = -28;

const ocaml_version = "4.14.0+mel";

const development_version = false;

const ocaml_release = {
  major: 4,
  minor: 14,
  patchlevel: 0,
  extra: [
    /* Plus */ 0,
    "mel"
  ]
};

function enable_runtime_warnings(prim) {
  return Caml_external_polyfill.resolve("caml_ml_enable_runtime_warnings")(prim);
}

function runtime_warnings_enabled(prim) {
  return Caml_external_polyfill.resolve("caml_ml_runtime_warnings_enabled")(prim);
}

export {
  executable_name,
  getenv_opt,
  interactive,
  os_type,
  backend_type,
  unix,
  win32,
  cygwin,
  word_size,
  int_size,
  big_endian,
  max_string_length,
  max_array_length,
  max_floatarray_length,
  set_signal,
  sigabrt,
  sigalrm,
  sigfpe,
  sighup,
  sigill,
  sigint,
  sigkill,
  sigpipe,
  sigquit,
  sigsegv,
  sigterm,
  sigusr1,
  sigusr2,
  sigchld,
  sigcont,
  sigstop,
  sigtstp,
  sigttin,
  sigttou,
  sigvtalrm,
  sigprof,
  sigbus,
  sigpoll,
  sigsys,
  sigtrap,
  sigurg,
  sigxcpu,
  sigxfsz,
  Break,
  catch_break,
  ocaml_version,
  development_version,
  ocaml_release,
  enable_runtime_warnings,
  runtime_warnings_enabled,
  Immediate64,
}
/* No side effect */
`,mm=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Stdlib__Obj from "./obj.js";

function make(param) {
  const Id = /* @__PURE__ */ Caml_exceptions.create("Id");
  return {
    Id: Id
  };
}

function uid(A) {
  return Stdlib__Obj.Extension_constructor.id(Stdlib__Obj.Extension_constructor.of_val({
    MEL_EXN_ID: A.Id
  }));
}

function provably_equal(A, B) {
  if (A.Id === B.Id) {
    return /* Equal */ 0;
  }
  
}

const Id = {
  make: make,
  uid: uid,
  provably_equal: provably_equal
};

export {
  Id,
}
/* No side effect */
`,dm=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";

function err_not_sv(i) {
  return Caml_format.caml_format_int("%X", i) + " is not a Unicode scalar value";
}

function err_not_latin1(u) {
  return "U+" + (Caml_format.caml_format_int("%04X", u) + " is not a latin1 character");
}

function succ(u) {
  if (u === 55295) {
    return 57344;
  }
  if (u === 1114111) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "U+10FFFF has no successor"
        });
  }
  return u + 1 | 0;
}

function pred(u) {
  if (u === 57344) {
    return 55295;
  }
  if (u === 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "U+0000 has no predecessor"
        });
  }
  return u - 1 | 0;
}

function is_valid(i) {
  if (0 <= i && i <= 55295) {
    return true;
  } else if (57344 <= i) {
    return i <= 1114111;
  } else {
    return false;
  }
}

function of_int(i) {
  if (is_valid(i)) {
    return i;
  }
  const s = err_not_sv(i);
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: s
      });
}

function is_char(u) {
  return u < 256;
}

function of_char(c) {
  return c;
}

function to_char(u) {
  if (u <= 255) {
    return u;
  }
  const s = err_not_latin1(u);
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: s
      });
}

function unsafe_to_char(prim) {
  return prim;
}

function equal(prim0, prim1) {
  return prim0 === prim1;
}

const compare = Caml.caml_int_compare;

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function utf_decode_is_valid(d) {
  return (d >>> 27) === 1;
}

function utf_decode_length(d) {
  return (d >>> 24) & 7;
}

function utf_decode_uchar(d) {
  return d & 16777215;
}

function utf_decode(n, u) {
  return ((8 | n) << 24) | u;
}

function utf_decode_invalid(n) {
  return (n << 24) | 65533;
}

function utf_8_byte_length(u) {
  if (u < 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/uchar.ml",
            84,
            18
          ]
        });
  }
  if (u <= 127) {
    return 1;
  }
  if (u <= 2047) {
    return 2;
  }
  if (u <= 65535) {
    return 3;
  }
  if (u <= 1114111) {
    return 4;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/uchar.ml",
          89,
          7
        ]
      });
}

function utf_16_byte_length(u) {
  if (u < 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/uchar.ml",
            92,
            18
          ]
        });
  }
  if (u <= 65535) {
    return 2;
  }
  if (u <= 1114111) {
    return 4;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/uchar.ml",
          95,
          7
        ]
      });
}

const min = 0;

const max = 1114111;

const bom = 65279;

const rep = 65533;

function unsafe_of_int(prim) {
  return prim;
}

function to_int(prim) {
  return prim;
}

export {
  min,
  max,
  bom,
  rep,
  succ,
  pred,
  is_valid,
  of_int,
  unsafe_of_int,
  to_int,
  is_char,
  of_char,
  to_char,
  unsafe_to_char,
  equal,
  compare,
  seeded_hash,
  hash,
  utf_decode_is_valid,
  utf_decode_uchar,
  utf_decode_length,
  utf_decode,
  utf_decode_invalid,
  utf_8_byte_length,
  utf_16_byte_length,
}
/* No side effect */
`,pm=`// Generated by Melange


function equal(param, param$1) {
  return true;
}

function compare(param, param$1) {
  return 0;
}

function to_string(param) {
  return "()";
}

export {
  equal,
  compare,
  to_string,
}
/* No side effect */
`,hm=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Obj from "./obj.js";
import * as Stdlib__Sys from "./sys.js";

function create(l) {
  if (!(0 <= l && l <= Stdlib__Obj.Ephemeron.max_ephe_length)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Weak.create"
        });
  }
  return Caml_external_polyfill.resolve("caml_weak_create")(l);
}

function length(x) {
  return (x.length | 0) - 2 | 0;
}

function raise_if_invalid_offset(e, o, msg) {
  if (0 <= o && o < length(e)) {
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: msg
      });
}

function set(e, o, x) {
  raise_if_invalid_offset(e, o, "Weak.set");
  if (x !== undefined) {
    return Caml_external_polyfill.resolve("caml_ephe_set_key")(e, o, Caml_option.valFromOption(x));
  } else {
    return Caml_external_polyfill.resolve("caml_ephe_unset_key")(e, o);
  }
}

function get(e, o) {
  raise_if_invalid_offset(e, o, "Weak.get");
  return Caml_external_polyfill.resolve("caml_weak_get")(e, o);
}

function get_copy(e, o) {
  raise_if_invalid_offset(e, o, "Weak.get_copy");
  return Caml_external_polyfill.resolve("caml_weak_get_copy")(e, o);
}

function check(e, o) {
  raise_if_invalid_offset(e, o, "Weak.check");
  return Caml_external_polyfill.resolve("caml_weak_check")(e, o);
}

function blit(e1, o1, e2, o2, l) {
  if (l < 0 || o1 < 0 || o1 > (length(e1) - l | 0) || o2 < 0 || o2 > (length(e2) - l | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Weak.blit"
        });
  }
  if (l !== 0) {
    return Caml_external_polyfill.resolve("caml_weak_blit")(e1, o1, e2, o2, l);
  }
  
}

function fill(ar, ofs, len, x) {
  if (ofs < 0 || len < 0 || ofs > (length(ar) - len | 0)) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
          MEL_EXN_ID: Stdlib.Invalid_argument,
          _1: "Weak.fill"
        });
  }
  for (let i = ofs, i_finish = ofs + len | 0; i < i_finish; ++i) {
    set(ar, i, x);
  }
}

function Make(H) {
  const emptybucket = create(0);
  const get_index = function (t, h) {
    return (h & Stdlib.max_int) % t.table.length;
  };
  const create$1 = function (sz) {
    const sz$1 = sz < 7 ? 7 : sz;
    const sz$2 = sz$1 > Stdlib__Sys.max_array_length ? Stdlib__Sys.max_array_length : sz$1;
    return {
      table: Caml_array.make(sz$2, emptybucket),
      hashes: Caml_array.make(sz$2, []),
      limit: 7,
      oversize: 0,
      rover: 0
    };
  };
  const clear = function (t) {
    for (let i = 0, i_finish = t.table.length; i < i_finish; ++i) {
      Caml_array.set(t.table, i, emptybucket);
      Caml_array.set(t.hashes, i, []);
    }
    t.limit = 7;
    t.oversize = 0;
  };
  const fold = function (f, t, init) {
    return Stdlib__Array.fold_right((function (param, param$1) {
      let _i = 0;
      let _accu = param$1;
      while (true) {
        const accu = _accu;
        const i = _i;
        if (i >= length(param)) {
          return accu;
        }
        const v = get(param, i);
        if (v !== undefined) {
          _accu = Curry._2(f, Caml_option.valFromOption(v), accu);
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      };
    }), t.table, init);
  };
  const iter = function (f, t) {
    Stdlib__Array.iter((function (param) {
      let _i = 0;
      while (true) {
        const i = _i;
        if (i >= length(param)) {
          return;
        }
        const v = get(param, i);
        if (v !== undefined) {
          Curry._1(f, Caml_option.valFromOption(v));
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      };
    }), t.table);
  };
  const iter_weak = function (f, t) {
    Stdlib__Array.iteri((function (param, param$1) {
      let _i = 0;
      while (true) {
        const i = _i;
        if (i >= length(param$1)) {
          return;
        }
        if (check(param$1, i)) {
          Curry._3(f, param$1, Caml_array.get(t.hashes, param), i);
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      };
    }), t.table);
  };
  const count_bucket = function (_i, b, _accu) {
    while (true) {
      const accu = _accu;
      const i = _i;
      if (i >= length(b)) {
        return accu;
      }
      _accu = accu + (
        check(b, i) ? 1 : 0
      ) | 0;
      _i = i + 1 | 0;
      continue;
    };
  };
  const count = function (t) {
    return Stdlib__Array.fold_right((function (param, param$1) {
      return count_bucket(0, param, param$1);
    }), t.table, 0);
  };
  const next_sz = function (n) {
    return Stdlib__Int.min((Math.imul(3, n) / 2 | 0) + 3 | 0, Stdlib__Sys.max_array_length);
  };
  const prev_sz = function (n) {
    return (((n - 3 | 0) << 1) + 2 | 0) / 3 | 0;
  };
  const test_shrink_bucket = function (t) {
    const bucket = Caml_array.get(t.table, t.rover);
    const hbucket = Caml_array.get(t.hashes, t.rover);
    const len = length(bucket);
    const prev_len = prev_sz(len);
    const live = count_bucket(0, bucket, 0);
    if (live <= prev_len) {
      const loop = function (_i, _j) {
        while (true) {
          const j = _j;
          const i = _i;
          if (j < prev_len) {
            return;
          }
          if (check(bucket, i)) {
            _i = i + 1 | 0;
            continue;
          }
          if (check(bucket, j)) {
            blit(bucket, j, bucket, i, 1);
            Caml_array.set(hbucket, i, Caml_array.get(hbucket, j));
            _j = j - 1 | 0;
            _i = i + 1 | 0;
            continue;
          }
          _j = j - 1 | 0;
          continue;
        };
      };
      loop(0, length(bucket) - 1 | 0);
      if (prev_len === 0) {
        Caml_array.set(t.table, t.rover, emptybucket);
        Caml_array.set(t.hashes, t.rover, []);
      } else {
        const newbucket = create(prev_len);
        blit(bucket, 0, newbucket, 0, prev_len);
        Caml_array.set(t.table, t.rover, newbucket);
        Caml_array.set(t.hashes, t.rover, Stdlib__Array.sub(hbucket, 0, prev_len));
      }
      if (len > t.limit && prev_len <= t.limit) {
        t.oversize = t.oversize - 1 | 0;
      }
      
    }
    t.rover = (t.rover + 1 | 0) % t.table.length;
  };
  const add_aux = function (t, setter, d, h, index) {
    const bucket = Caml_array.get(t.table, index);
    const hashes = Caml_array.get(t.hashes, index);
    const sz = length(bucket);
    let _i = 0;
    while (true) {
      const i = _i;
      if (i >= sz) {
        const newsz = Stdlib__Int.min((Math.imul(3, sz) / 2 | 0) + 3 | 0, Stdlib__Sys.max_array_length - 2 | 0);
        if (newsz <= sz) {
          throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "Weak.Make: hash bucket cannot grow more"
              });
        }
        const newbucket = create(newsz);
        const newhashes = Caml_array.make(newsz, 0);
        blit(bucket, 0, newbucket, 0, sz);
        Stdlib__Array.blit(hashes, 0, newhashes, 0, sz);
        Curry._3(setter, newbucket, sz, d);
        Caml_array.set(newhashes, sz, h);
        Caml_array.set(t.table, index, newbucket);
        Caml_array.set(t.hashes, index, newhashes);
        if (sz <= t.limit && newsz > t.limit) {
          t.oversize = t.oversize + 1 | 0;
          for (let _i$1 = 0; _i$1 <= 2; ++_i$1) {
            test_shrink_bucket(t);
          }
        }
        if (t.oversize > (t.table.length >> 1)) {
          const oldlen = t.table.length;
          const newlen = next_sz(oldlen);
          if (newlen > oldlen) {
            const newt = create$1(newlen);
            const add_weak = function (ob, oh, oi) {
              const setter = function (nb, ni, param) {
                blit(ob, oi, nb, ni, 1);
              };
              const h = Caml_array.get(oh, oi);
              add_aux(newt, setter, undefined, h, get_index(newt, h));
            };
            iter_weak(add_weak, t);
            t.table = newt.table;
            t.hashes = newt.hashes;
            t.limit = newt.limit;
            t.oversize = newt.oversize;
            t.rover = t.rover % newt.table.length;
            return;
          }
          t.limit = Stdlib.max_int;
          t.oversize = 0;
          return;
        } else {
          return;
        }
      }
      if (check(bucket, i)) {
        _i = i + 1 | 0;
        continue;
      }
      Curry._3(setter, bucket, i, d);
      return Caml_array.set(hashes, i, h);
    };
  };
  const add = function (t, d) {
    const h = Curry._1(H.hash, d);
    add_aux(t, set, Caml_option.some(d), h, get_index(t, h));
  };
  const find_aux = function (t, d, found, notfound) {
    const h = Curry._1(H.hash, d);
    const index = get_index(t, h);
    const bucket = Caml_array.get(t.table, index);
    const hashes = Caml_array.get(t.hashes, index);
    const sz = length(bucket);
    let _i = 0;
    while (true) {
      const i = _i;
      if (i >= sz) {
        return Curry._2(notfound, h, index);
      }
      if (h === Caml_array.get(hashes, i)) {
        const opt = get(bucket, i);
        if (opt !== undefined) {
          const v = Caml_option.valFromOption(opt);
          if (Curry._2(H.equal, v, d)) {
            return Curry._4(found, bucket, i, opt, v);
          }
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const find_opt = function (t, d) {
    return find_aux(t, d, (function (_b, _i, o, _v) {
      return o;
    }), (function (_h, _i) {
      
    }));
  };
  const merge = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, v) {
      return v;
    }), (function (h, i) {
      add_aux(t, set, Caml_option.some(d), h, i);
      return d;
    }));
  };
  const find = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, v) {
      return v;
    }), (function (_h, _i) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }));
  };
  const remove = function (t, d) {
    find_aux(t, d, (function (b, i, _o, _v) {
      set(b, i, undefined);
    }), (function (_h, _i) {
      
    }));
  };
  const mem = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, _v) {
      return true;
    }), (function (_h, _i) {
      return false;
    }));
  };
  const find_all = function (t, d) {
    const h = Curry._1(H.hash, d);
    const index = get_index(t, h);
    const bucket = Caml_array.get(t.table, index);
    const hashes = Caml_array.get(t.hashes, index);
    const sz = length(bucket);
    let _i = 0;
    let _accu = /* [] */ 0;
    while (true) {
      const accu = _accu;
      const i = _i;
      if (i >= sz) {
        return accu;
      }
      if (h === Caml_array.get(hashes, i)) {
        const v = get(bucket, i);
        if (v !== undefined) {
          const v$1 = Caml_option.valFromOption(v);
          if (Curry._2(H.equal, v$1, d)) {
            _accu = {
              hd: v$1,
              tl: accu
            };
            _i = i + 1 | 0;
            continue;
          }
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const stats = function (t) {
    const len = t.table.length;
    const lens = Stdlib__Array.map(length, t.table);
    Stdlib__Array.sort(Caml.caml_int_compare, lens);
    const totlen = Stdlib__Array.fold_left((function (prim0, prim1) {
      return prim0 + prim1 | 0;
    }), 0, lens);
    return [
      len,
      count(t),
      totlen,
      Caml_array.get(lens, 0),
      Caml_array.get(lens, len / 2 | 0),
      Caml_array.get(lens, len - 1 | 0)
    ];
  };
  return {
    create: create$1,
    clear: clear,
    merge: merge,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    mem: mem,
    iter: iter,
    fold: fold,
    count: count,
    stats: stats
  };
}

export {
  create,
  length,
  set,
  get,
  get_copy,
  check,
  fill,
  blit,
  Make,
}
/* No side effect */
`;function Sn(t){for(var n=arguments.length,e=Array(n>1?n-1:0),r=1;r<n;r++)e[r-1]=arguments[r];throw Error("[Immer] minified error nr: "+t+(e.length?" "+e.map(function(a){return"'"+a+"'"}).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function jt(t){return!!t&&!!t[tn]}function nt(t){return!!t&&(function(n){if(!n||typeof n!="object")return!1;var e=Object.getPrototypeOf(n);if(e===null)return!0;var r=Object.hasOwnProperty.call(e,"constructor")&&e.constructor;return r===Object||typeof r=="function"&&Function.toString.call(r)===Em}(t)||Array.isArray(t)||!!t[xe]||!!t.constructor[xe]||ir(t)||sr(t))}function Mt(t,n,e){e===void 0&&(e=!1),yt(t)===0?(e?Object.keys:wa)(t).forEach(function(r){e&&typeof r=="symbol"||n(r,t[r],t)}):t.forEach(function(r,a){return n(a,r,t)})}function yt(t){var n=t[tn];return n?n.i>3?n.i-4:n.i:Array.isArray(t)?1:ir(t)?2:sr(t)?3:0}function ge(t,n){return yt(t)===2?t.has(n):Object.prototype.hasOwnProperty.call(t,n)}function ar(t,n){return yt(t)===2?t.get(n):t[n]}function ps(t,n,e){var r=yt(t);r===2?t.set(n,e):r===3?(t.delete(n),t.add(e)):t[n]=e}function gm(t,n){return t===n?t!==0||1/t==1/n:t!=t&&n!=n}function ir(t){return km&&t instanceof Map}function sr(t){return Cm&&t instanceof Set}function Cn(t){return t.o||t.t}function ga(t){if(Array.isArray(t))return Array.prototype.slice.call(t);var n=Am(t);delete n[tn];for(var e=wa(n),r=0;r<e.length;r++){var a=e[r],i=n[a];i.writable===!1&&(i.writable=!0,i.configurable=!0),(i.get||i.set)&&(n[a]={configurable:!0,writable:!0,enumerable:i.enumerable,value:t[a]})}return Object.create(Object.getPrototypeOf(t),n)}function ya(t,n){return n===void 0&&(n=!1),ba(t)||jt(t)||!nt(t)||(yt(t)>1&&(t.set=t.add=t.clear=t.delete=ym),Object.freeze(t),n&&Mt(t,function(e,r){return ya(r,!0)},!0)),t}function ym(){Sn(2)}function ba(t){return t==null||typeof t!="object"||Object.isFrozen(t)}function tt(t){var n=Sa[t];return n||Sn(18,t),n}function hs(t,n){Sa[t]||(Sa[t]=n)}function or(){return be}function xa(t,n){n&&(tt("Patches"),t.u=[],t.s=[],t.v=n)}function lr(t){va(t),t.p.forEach(bm),t.p=null}function va(t){t===be&&(be=t.l)}function gs(t){return be={p:[],l:be,h:t,m:!0,_:0}}function bm(t){var n=t[tn];n.i===0||n.i===1?n.j():n.O=!0}function $a(t,n){n._=n.p.length;var e=n.p[0],r=t!==void 0&&t!==e;return n.h.g||tt("ES5").S(n,t,r),r?(e[tn].P&&(lr(n),Sn(4)),nt(t)&&(t=cr(n,t),n.l||_r(n,t)),n.u&&tt("Patches").M(e[tn].t,t,n.u,n.s)):t=cr(n,e,[]),lr(n),n.u&&n.v(n.u,n.s),t!==Aa?t:void 0}function cr(t,n,e){if(ba(n))return n;var r=n[tn];if(!r)return Mt(n,function(i,s){return ys(t,r,n,i,s,e)},!0),n;if(r.A!==t)return n;if(!r.P)return _r(t,r.t,!0),r.t;if(!r.I){r.I=!0,r.A._--;var a=r.i===4||r.i===5?r.o=ga(r.k):r.o;Mt(r.i===3?new Set(a):a,function(i,s){return ys(t,r,a,i,s,e)}),_r(t,a,!1),e&&t.u&&tt("Patches").R(r,e,t.u,t.s)}return r.o}function ys(t,n,e,r,a,i){if(jt(a)){var s=cr(t,a,i&&n&&n.i!==3&&!ge(n.D,r)?i.concat(r):void 0);if(ps(e,r,s),!jt(s))return;t.m=!1}if(nt(a)&&!ba(a)){if(!t.h.F&&t._<1)return;cr(t,a),n&&n.A.l||_r(t,a)}}function _r(t,n,e){e===void 0&&(e=!1),t.h.F&&t.m&&ya(n,e)}function ka(t,n){var e=t[tn];return(e?Cn(e):t)[n]}function bs(t,n){if(n in t)for(var e=Object.getPrototypeOf(t);e;){var r=Object.getOwnPropertyDescriptor(e,n);if(r)return r;e=Object.getPrototypeOf(e)}}function ut(t){t.P||(t.P=!0,t.l&&ut(t.l))}function Ca(t){t.o||(t.o=ga(t.t))}function ye(t,n,e){var r=ir(n)?tt("MapSet").N(n,e):sr(n)?tt("MapSet").T(n,e):t.g?function(a,i){var s=Array.isArray(a),o={i:s?1:0,A:i?i.A:or(),P:!1,I:!1,D:{},l:i,t:a,k:null,o:null,j:null,C:!1},l=o,c=Ba;s&&(l=[o],c=ve);var u=Proxy.revocable(l,c),f=u.revoke,m=u.proxy;return o.k=m,o.j=f,m}(n,e):tt("ES5").J(n,e);return(e?e.A:or()).p.push(r),r}function xm(t){return jt(t)||Sn(22,t),function n(e){if(!nt(e))return e;var r,a=e[tn],i=yt(e);if(a){if(!a.P&&(a.i<4||!tt("ES5").K(a)))return a.t;a.I=!0,r=xs(e,i),a.I=!1}else r=xs(e,i);return Mt(r,function(s,o){a&&ar(a.t,s)===o||ps(r,s,n(o))}),i===3?new Set(r):r}(t)}function xs(t,n){switch(n){case 2:return new Map(t);case 3:return Array.from(t)}return ga(t)}function vm(){function t(r){if(!nt(r))return r;if(Array.isArray(r))return r.map(t);if(ir(r))return new Map(Array.from(r.entries()).map(function(s){return[s[0],t(s[1])]}));if(sr(r))return new Set(Array.from(r).map(t));var a=Object.create(Object.getPrototypeOf(r));for(var i in r)a[i]=t(r[i]);return ge(r,xe)&&(a[xe]=r[xe]),a}function n(r){return jt(r)?t(r):r}var e="add";hs("Patches",{$:function(r,a){return a.forEach(function(i){for(var s=i.path,o=i.op,l=r,c=0;c<s.length-1;c++){var u=yt(l),f=""+s[c];u!==0&&u!==1||f!=="__proto__"&&f!=="constructor"||Sn(24),typeof l=="function"&&f==="prototype"&&Sn(24),typeof(l=ar(l,f))!="object"&&Sn(15,s.join("/"))}var m=yt(l),h=t(i.value),b=s[s.length-1];switch(o){case"replace":switch(m){case 2:return l.set(b,h);case 3:Sn(16);default:return l[b]=h}case e:switch(m){case 1:return b==="-"?l.push(h):l.splice(b,0,h);case 2:return l.set(b,h);case 3:return l.add(h);default:return l[b]=h}case"remove":switch(m){case 1:return l.splice(b,1);case 2:return l.delete(b);case 3:return l.delete(i.value);default:return delete l[b]}default:Sn(17,o)}}),r},R:function(r,a,i,s){switch(r.i){case 0:case 4:case 2:return function(o,l,c,u){var f=o.t,m=o.o;Mt(o.D,function(h,b){var p=ar(f,h),g=ar(m,h),x=b?ge(f,h)?"replace":e:"remove";if(p!==g||x!=="replace"){var k=l.concat(h);c.push(x==="remove"?{op:x,path:k}:{op:x,path:k,value:g}),u.push(x===e?{op:"remove",path:k}:x==="remove"?{op:e,path:k,value:n(p)}:{op:"replace",path:k,value:n(p)})}})}(r,a,i,s);case 5:case 1:return function(o,l,c,u){var f=o.t,m=o.D,h=o.o;if(h.length<f.length){var b=[h,f];f=b[0],h=b[1];var p=[u,c];c=p[0],u=p[1]}for(var g=0;g<f.length;g++)if(m[g]&&h[g]!==f[g]){var x=l.concat([g]);c.push({op:"replace",path:x,value:n(h[g])}),u.push({op:"replace",path:x,value:n(f[g])})}for(var k=f.length;k<h.length;k++){var y=l.concat([k]);c.push({op:e,path:y,value:n(h[k])})}f.length<h.length&&u.push({op:"replace",path:l.concat(["length"]),value:f.length})}(r,a,i,s);case 3:return function(o,l,c,u){var f=o.t,m=o.o,h=0;f.forEach(function(b){if(!m.has(b)){var p=l.concat([h]);c.push({op:"remove",path:p,value:b}),u.unshift({op:e,path:p,value:b})}h++}),h=0,m.forEach(function(b){if(!f.has(b)){var p=l.concat([h]);c.push({op:e,path:p,value:b}),u.unshift({op:"remove",path:p,value:b})}h++})}(r,a,i,s)}},M:function(r,a,i,s){i.push({op:"replace",path:[],value:a===Aa?void 0:a}),s.push({op:"replace",path:[],value:r})}})}function $m(){function t(o,l){function c(){this.constructor=o}a(o,l),o.prototype=(c.prototype=l.prototype,new c)}function n(o){o.o||(o.D=new Map,o.o=new Map(o.t))}function e(o){o.o||(o.o=new Set,o.t.forEach(function(l){if(nt(l)){var c=ye(o.A.h,l,o);o.p.set(l,c),o.o.add(c)}else o.o.add(l)}))}function r(o){o.O&&Sn(3,JSON.stringify(Cn(o)))}var a=function(o,l){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(c,u){c.__proto__=u}||function(c,u){for(var f in u)u.hasOwnProperty(f)&&(c[f]=u[f])})(o,l)},i=function(){function o(c,u){return this[tn]={i:2,l:u,A:u?u.A:or(),P:!1,I:!1,o:void 0,D:void 0,t:c,k:this,C:!1,O:!1},this}t(o,Map);var l=o.prototype;return Object.defineProperty(l,"size",{get:function(){return Cn(this[tn]).size}}),l.has=function(c){return Cn(this[tn]).has(c)},l.set=function(c,u){var f=this[tn];return r(f),Cn(f).has(c)&&Cn(f).get(c)===u||(n(f),ut(f),f.D.set(c,!0),f.o.set(c,u),f.D.set(c,!0)),this},l.delete=function(c){if(!this.has(c))return!1;var u=this[tn];return r(u),n(u),ut(u),u.t.has(c)?u.D.set(c,!1):u.D.delete(c),u.o.delete(c),!0},l.clear=function(){var c=this[tn];r(c),Cn(c).size&&(n(c),ut(c),c.D=new Map,Mt(c.t,function(u){c.D.set(u,!1)}),c.o.clear())},l.forEach=function(c,u){var f=this;Cn(this[tn]).forEach(function(m,h){c.call(u,f.get(h),h,f)})},l.get=function(c){var u=this[tn];r(u);var f=Cn(u).get(c);if(u.I||!nt(f)||f!==u.t.get(c))return f;var m=ye(u.A.h,f,u);return n(u),u.o.set(c,m),m},l.keys=function(){return Cn(this[tn]).keys()},l.values=function(){var c,u=this,f=this.keys();return(c={})[ur]=function(){return u.values()},c.next=function(){var m=f.next();return m.done?m:{done:!1,value:u.get(m.value)}},c},l.entries=function(){var c,u=this,f=this.keys();return(c={})[ur]=function(){return u.entries()},c.next=function(){var m=f.next();if(m.done)return m;var h=u.get(m.value);return{done:!1,value:[m.value,h]}},c},l[ur]=function(){return this.entries()},o}(),s=function(){function o(c,u){return this[tn]={i:3,l:u,A:u?u.A:or(),P:!1,I:!1,o:void 0,t:c,k:this,p:new Map,O:!1,C:!1},this}t(o,Set);var l=o.prototype;return Object.defineProperty(l,"size",{get:function(){return Cn(this[tn]).size}}),l.has=function(c){var u=this[tn];return r(u),u.o?!!u.o.has(c)||!(!u.p.has(c)||!u.o.has(u.p.get(c))):u.t.has(c)},l.add=function(c){var u=this[tn];return r(u),this.has(c)||(e(u),ut(u),u.o.add(c)),this},l.delete=function(c){if(!this.has(c))return!1;var u=this[tn];return r(u),e(u),ut(u),u.o.delete(c)||!!u.p.has(c)&&u.o.delete(u.p.get(c))},l.clear=function(){var c=this[tn];r(c),Cn(c).size&&(e(c),ut(c),c.o.clear())},l.values=function(){var c=this[tn];return r(c),e(c),c.o.values()},l.entries=function(){var c=this[tn];return r(c),e(c),c.o.entries()},l.keys=function(){return this.values()},l[ur]=function(){return this.values()},l.forEach=function(c,u){for(var f=this.values(),m=f.next();!m.done;)c.call(u,m.value,m.value,this),m=f.next()},o}();hs("MapSet",{N:function(o,l){return new i(o,l)},T:function(o,l){return new s(o,l)}})}var vs,be,Ea=typeof Symbol<"u"&&typeof Symbol("x")=="symbol",km=typeof Map<"u",Cm=typeof Set<"u",$s=typeof Proxy<"u"&&Proxy.revocable!==void 0&&typeof Reflect<"u",Aa=Ea?Symbol.for("immer-nothing"):((vs={})["immer-nothing"]=!0,vs),xe=Ea?Symbol.for("immer-draftable"):"__$immer_draftable",tn=Ea?Symbol.for("immer-state"):"__$immer_state",ur=typeof Symbol<"u"&&Symbol.iterator||"@@iterator",Em=""+Object.prototype.constructor,wa=typeof Reflect<"u"&&Reflect.ownKeys?Reflect.ownKeys:Object.getOwnPropertySymbols!==void 0?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Object.getOwnPropertyNames,Am=Object.getOwnPropertyDescriptors||function(t){var n={};return wa(t).forEach(function(e){n[e]=Object.getOwnPropertyDescriptor(t,e)}),n},Sa={},Ba={get:function(t,n){if(n===tn)return t;var e=Cn(t);if(!ge(e,n))return function(a,i,s){var o,l=bs(i,s);return l?"value"in l?l.value:(o=l.get)===null||o===void 0?void 0:o.call(a.k):void 0}(t,e,n);var r=e[n];return t.I||!nt(r)?r:r===ka(t.t,n)?(Ca(t),t.o[n]=ye(t.A.h,r,t)):r},has:function(t,n){return n in Cn(t)},ownKeys:function(t){return Reflect.ownKeys(Cn(t))},set:function(t,n,e){var r=bs(Cn(t),n);if(r!=null&&r.set)return r.set.call(t.k,e),!0;if(!t.P){var a=ka(Cn(t),n),i=a==null?void 0:a[tn];if(i&&i.t===e)return t.o[n]=e,t.D[n]=!1,!0;if(gm(e,a)&&(e!==void 0||ge(t.t,n)))return!0;Ca(t),ut(t)}return t.o[n]===e&&typeof e!="number"&&(e!==void 0||n in t.o)||(t.o[n]=e,t.D[n]=!0,!0)},deleteProperty:function(t,n){return ka(t.t,n)!==void 0||n in t.t?(t.D[n]=!1,Ca(t),ut(t)):delete t.D[n],t.o&&delete t.o[n],!0},getOwnPropertyDescriptor:function(t,n){var e=Cn(t),r=Reflect.getOwnPropertyDescriptor(e,n);return r&&{writable:!0,configurable:t.i!==1||n!=="length",enumerable:r.enumerable,value:e[n]}},defineProperty:function(){Sn(11)},getPrototypeOf:function(t){return Object.getPrototypeOf(t.t)},setPrototypeOf:function(){Sn(12)}},ve={};Mt(Ba,function(t,n){ve[t]=function(){return arguments[0]=arguments[0][0],n.apply(this,arguments)}}),ve.deleteProperty=function(t,n){return ve.set.call(this,t,n,void 0)},ve.set=function(t,n,e){return Ba.set.call(this,t[0],n,e,t[0])};var wm=function(){function t(e){var r=this;this.g=$s,this.F=!0,this.produce=function(a,i,s){if(typeof a=="function"&&typeof i!="function"){var o=i;i=a;var l=r;return function(p){var g=this;p===void 0&&(p=o);for(var x=arguments.length,k=Array(x>1?x-1:0),y=1;y<x;y++)k[y-1]=arguments[y];return l.produce(p,function(v){var $;return($=i).call.apply($,[g,v].concat(k))})}}var c;if(typeof i!="function"&&Sn(6),s!==void 0&&typeof s!="function"&&Sn(7),nt(a)){var u=gs(r),f=ye(r,a,void 0),m=!0;try{c=i(f),m=!1}finally{m?lr(u):va(u)}return typeof Promise<"u"&&c instanceof Promise?c.then(function(p){return xa(u,s),$a(p,u)},function(p){throw lr(u),p}):(xa(u,s),$a(c,u))}if(!a||typeof a!="object"){if((c=i(a))===void 0&&(c=a),c===Aa&&(c=void 0),r.F&&ya(c,!0),s){var h=[],b=[];tt("Patches").M(a,c,h,b),s(h,b)}return c}Sn(21,a)},this.produceWithPatches=function(a,i){if(typeof a=="function")return function(c){for(var u=arguments.length,f=Array(u>1?u-1:0),m=1;m<u;m++)f[m-1]=arguments[m];return r.produceWithPatches(c,function(h){return a.apply(void 0,[h].concat(f))})};var s,o,l=r.produce(a,i,function(c,u){s=c,o=u});return typeof Promise<"u"&&l instanceof Promise?l.then(function(c){return[c,s,o]}):[l,s,o]},typeof(e==null?void 0:e.useProxies)=="boolean"&&this.setUseProxies(e.useProxies),typeof(e==null?void 0:e.autoFreeze)=="boolean"&&this.setAutoFreeze(e.autoFreeze)}var n=t.prototype;return n.createDraft=function(e){nt(e)||Sn(8),jt(e)&&(e=xm(e));var r=gs(this),a=ye(this,e,void 0);return a[tn].C=!0,va(r),a},n.finishDraft=function(e,r){var a=e&&e[tn],i=a.A;return xa(i,r),$a(void 0,i)},n.setAutoFreeze=function(e){this.F=e},n.setUseProxies=function(e){e&&!$s&&Sn(20),this.g=e},n.applyPatches=function(e,r){var a;for(a=r.length-1;a>=0;a--){var i=r[a];if(i.path.length===0&&i.op==="replace"){e=i.value;break}}a>-1&&(r=r.slice(a+1));var s=tt("Patches").$;return jt(e)?s(e,r):this.produce(e,function(o){return s(o,r)})},t}(),On=new wm,Sm=On.produce;On.produceWithPatches.bind(On),On.setAutoFreeze.bind(On),On.setUseProxies.bind(On),On.applyPatches.bind(On),On.createDraft.bind(On),On.finishDraft.bind(On),vm(),$m();function Bm(t,n,e=()=>({})){const r=new Map;function a(o,l){postMessage({__uwrType:"patch",id:o,patches:l})}function i(){let o,l=null;return new WritableStream({async write(c,u){switch(c.__uwrType){case"init":{const{id:f,initialState:m}=c;l=m,o=e(l),a(f,[])}break;case"dispatch":{const{id:f,action:m}=c;l=await Sm(l,async h=>{await n(h,m,o)},h=>a(f,h))}break;case"destroy":{const{name:f}=c;r.delete(f),u.error()}break}}})}function s(o){if(typeof o.data!="object"||!("__uwrType"in o.data))return;const l=o.data;if(l.__uwrType==="init"){const{name:m}=l,[h,b]=JSON.parse(m);if(b!==t||r.has(m))return;const p=i();r.set(m,p)}const{name:c}=l,u=r.get(c);if(!u)return;const f=u.getWriter();f.write(l),f.releaseLock()}addEventListener("message",s)}/*
    @license
  	Rollup.js v3.25.1
  	Mon, 12 Jun 2023 04:38:12 GMT - commit b1341bf9cd719670a670905e0308418b37621d70

  	https://github.com/rollup/rollup

  	Released under the MIT License.
  */var Ia="3.25.1";function ks(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var Cs={exports:{}};(function(t){const n=",".charCodeAt(0),e=";".charCodeAt(0),r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=new Uint8Array(64),i=new Uint8Array(128);for(let p=0;p<r.length;p++){const g=r.charCodeAt(p);a[p]=g,i[g]=p}const s=typeof TextDecoder<"u"?new TextDecoder:typeof Buffer<"u"?{decode:p=>Buffer.from(p.buffer,p.byteOffset,p.byteLength).toString()}:{decode(p){let g="";for(let x=0;x<p.length;x++)g+=String.fromCharCode(p[x]);return g}};function o(p){const g=new Int32Array(5),x=[];let k=0;do{const y=l(p,k),v=[];let $=!0,w=0;g[0]=0;for(let S=k;S<y;S++){let I;S=c(p,S,g,0);const C=g[0];C<w&&($=!1),w=C,u(p,S,y)?(S=c(p,S,g,1),S=c(p,S,g,2),S=c(p,S,g,3),u(p,S,y)?(S=c(p,S,g,4),I=[C,g[1],g[2],g[3],g[4]]):I=[C,g[1],g[2],g[3]]):I=[C],v.push(I)}$||f(v),x.push(v),k=y+1}while(k<=p.length);return x}function l(p,g){const x=p.indexOf(";",g);return x===-1?p.length:x}function c(p,g,x,k){let y=0,v=0,$=0;do{const S=p.charCodeAt(g++);$=i[S],y|=(31&$)<<v,v+=5}while(32&$);const w=1&y;return y>>>=1,w&&(y=-2147483648|-y),x[k]+=y,g}function u(p,g,x){return!(g>=x)&&p.charCodeAt(g)!==n}function f(p){p.sort(m)}function m(p,g){return p[0]-g[0]}function h(p){const g=new Int32Array(5),x=16384,k=x-36,y=new Uint8Array(x),v=y.subarray(0,k);let $=0,w="";for(let S=0;S<p.length;S++){const I=p[S];if(S>0&&($===x&&(w+=s.decode(y),$=0),y[$++]=e),I.length!==0){g[0]=0;for(let C=0;C<I.length;C++){const B=I[C];$>k&&(w+=s.decode(v),y.copyWithin(0,k,$),$-=k),C>0&&(y[$++]=n),$=b(y,$,g,B,0),B.length!==1&&($=b(y,$,g,B,1),$=b(y,$,g,B,2),$=b(y,$,g,B,3),B.length!==4&&($=b(y,$,g,B,4)))}}}return w+s.decode(y.subarray(0,$))}function b(p,g,x,k,y){const v=k[y];let $=v-x[y];x[y]=v,$=$<0?-$<<1|1:$<<1;do{let w=31&$;$>>>=5,$>0&&(w|=32),p[g++]=a[w]}while($>0);return g}t.decode=o,t.encode=h,Object.defineProperty(t,"__esModule",{value:!0})})(Cs.exports);var Es=Cs.exports;class fr{constructor(n){this.bits=n instanceof fr?n.bits.slice():[]}add(n){this.bits[n>>5]|=1<<(31&n)}has(n){return!!(this.bits[n>>5]&1<<(31&n))}}let As=class ds{constructor(n,e,r){this.start=n,this.end=e,this.original=r,this.intro="",this.outro="",this.content=r,this.storeName=!1,this.edited=!1,this.previous=null,this.next=null}appendLeft(n){this.outro+=n}appendRight(n){this.intro=this.intro+n}clone(){const n=new ds(this.start,this.end,this.original);return n.intro=this.intro,n.outro=this.outro,n.content=this.content,n.storeName=this.storeName,n.edited=this.edited,n}contains(n){return this.start<n&&n<this.end}eachNext(n){let e=this;for(;e;)n(e),e=e.next}eachPrevious(n){let e=this;for(;e;)n(e),e=e.previous}edit(n,e,r){return this.content=n,r||(this.intro="",this.outro=""),this.storeName=e,this.edited=!0,this}prependLeft(n){this.outro=n+this.outro}prependRight(n){this.intro=n+this.intro}split(n){const e=n-this.start,r=this.original.slice(0,e),a=this.original.slice(e);this.original=r;const i=new ds(n,this.end,a);return i.outro=this.outro,this.outro="",this.end=n,this.edited?(i.edit("",!1),this.content=""):this.content=r,i.next=this.next,i.next&&(i.next.previous=i),i.previous=this,this.next=i,i}toString(){return this.intro+this.content+this.outro}trimEnd(n){if(this.outro=this.outro.replace(n,""),this.outro.length)return!0;const e=this.content.replace(n,"");return e.length?(e!==this.content&&this.split(this.start+e.length).edit("",void 0,!0),!0):(this.edit("",void 0,!0),this.intro=this.intro.replace(n,""),!!this.intro.length||void 0)}trimStart(n){if(this.intro=this.intro.replace(n,""),this.intro.length)return!0;const e=this.content.replace(n,"");return e.length?(e!==this.content&&(this.split(this.end-e.length),this.edit("",void 0,!0)),!0):(this.edit("",void 0,!0),this.outro=this.outro.replace(n,""),!!this.outro.length||void 0)}};function Im(){return typeof window<"u"&&typeof window.btoa=="function"?t=>window.btoa(unescape(encodeURIComponent(t))):typeof Buffer=="function"?t=>Buffer.from(t,"utf-8").toString("base64"):()=>{throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.")}}const jm=Im();class mr{constructor(n){this.version=3,this.file=n.file,this.sources=n.sources,this.sourcesContent=n.sourcesContent,this.names=n.names,this.mappings=Es.encode(n.mappings),n.x_google_ignoreList!==void 0&&(this.x_google_ignoreList=n.x_google_ignoreList)}toString(){return JSON.stringify(this)}toUrl(){return"data:application/json;charset=utf-8;base64,"+jm(this.toString())}}function ws(t,n){const e=t.split(/[/\\]/),r=n.split(/[/\\]/);for(e.pop();e[0]===r[0];)e.shift(),r.shift();if(e.length){let a=e.length;for(;a--;)e[a]=".."}return e.concat(r).join("/")}const Mm=Object.prototype.toString;function Ss(t){return Mm.call(t)==="[object Object]"}function ja(t){const n=t.split(`
`),e=[];for(let r=0,a=0;r<n.length;r++)e.push(a),a+=n[r].length+1;return function(r){let a=0,i=e.length;for(;a<i;){const o=a+i>>1;r<e[o]?i=o:a=o+1}const s=a-1;return{line:s,column:r-e[s]}}}class Bs{constructor(n){this.hires=n,this.generatedCodeLine=0,this.generatedCodeColumn=0,this.raw=[],this.rawSegments=this.raw[this.generatedCodeLine]=[],this.pending=null}addEdit(n,e,r,a){if(e.length){const i=[this.generatedCodeColumn,n,r.line,r.column];a>=0&&i.push(a),this.rawSegments.push(i)}else this.pending&&this.rawSegments.push(this.pending);this.advance(e),this.pending=null}addUneditedChunk(n,e,r,a,i){let s=e.start,o=!0;for(;s<e.end;)(this.hires||o||i.has(s))&&this.rawSegments.push([this.generatedCodeColumn,n,a.line,a.column]),r[s]===`
`?(a.line+=1,a.column=0,this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,o=!0):(a.column+=1,this.generatedCodeColumn+=1,o=!1),s+=1;this.pending=null}advance(n){if(!n)return;const e=n.split(`
`);if(e.length>1){for(let r=0;r<e.length-1;r++)this.generatedCodeLine++,this.raw[this.generatedCodeLine]=this.rawSegments=[];this.generatedCodeColumn=0}this.generatedCodeColumn+=e[e.length-1].length}}const $e=`
`,Zt={insertLeft:!1,insertRight:!1,storeName:!1};class Lt{constructor(n,e={}){const r=new As(0,n.length,n);Object.defineProperties(this,{original:{writable:!0,value:n},outro:{writable:!0,value:""},intro:{writable:!0,value:""},firstChunk:{writable:!0,value:r},lastChunk:{writable:!0,value:r},lastSearchedChunk:{writable:!0,value:r},byStart:{writable:!0,value:{}},byEnd:{writable:!0,value:{}},filename:{writable:!0,value:e.filename},indentExclusionRanges:{writable:!0,value:e.indentExclusionRanges},sourcemapLocations:{writable:!0,value:new fr},storedNames:{writable:!0,value:{}},indentStr:{writable:!0,value:void 0},ignoreList:{writable:!0,value:e.ignoreList}}),this.byStart[0]=r,this.byEnd[n.length]=r}addSourcemapLocation(n){this.sourcemapLocations.add(n)}append(n){if(typeof n!="string")throw new TypeError("outro content must be a string");return this.outro+=n,this}appendLeft(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byEnd[n];return r?r.appendLeft(e):this.intro+=e,this}appendRight(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byStart[n];return r?r.appendRight(e):this.outro+=e,this}clone(){const n=new Lt(this.original,{filename:this.filename});let e=this.firstChunk,r=n.firstChunk=n.lastSearchedChunk=e.clone();for(;e;){n.byStart[r.start]=r,n.byEnd[r.end]=r;const a=e.next,i=a&&a.clone();i&&(r.next=i,i.previous=r,r=i),e=a}return n.lastChunk=r,this.indentExclusionRanges&&(n.indentExclusionRanges=this.indentExclusionRanges.slice()),n.sourcemapLocations=new fr(this.sourcemapLocations),n.intro=this.intro,n.outro=this.outro,n}generateDecodedMap(n){n=n||{};const e=Object.keys(this.storedNames),r=new Bs(n.hires),a=ja(this.original);return this.intro&&r.advance(this.intro),this.firstChunk.eachNext(i=>{const s=a(i.start);i.intro.length&&r.advance(i.intro),i.edited?r.addEdit(0,i.content,s,i.storeName?e.indexOf(i.original):-1):r.addUneditedChunk(0,i,this.original,s,this.sourcemapLocations),i.outro.length&&r.advance(i.outro)}),{file:n.file?n.file.split(/[/\\]/).pop():void 0,sources:[n.source?ws(n.file||"",n.source):n.file||""],sourcesContent:n.includeContent?[this.original]:void 0,names:e,mappings:r.raw,x_google_ignoreList:this.ignoreList?[0]:void 0}}generateMap(n){return new mr(this.generateDecodedMap(n))}_ensureindentStr(){this.indentStr===void 0&&(this.indentStr=function(n){const e=n.split(`
`),r=e.filter(s=>/^\t+/.test(s)),a=e.filter(s=>/^ {2,}/.test(s));if(r.length===0&&a.length===0)return null;if(r.length>=a.length)return"	";const i=a.reduce((s,o)=>{const l=/^ +/.exec(o)[0].length;return Math.min(l,s)},1/0);return new Array(i+1).join(" ")}(this.original))}_getRawIndentString(){return this._ensureindentStr(),this.indentStr}getIndentString(){return this._ensureindentStr(),this.indentStr===null?"	":this.indentStr}indent(n,e){const r=/^[^\r\n]/gm;if(Ss(n)&&(e=n,n=void 0),n===void 0&&(this._ensureindentStr(),n=this.indentStr||"	"),n==="")return this;const a={};(e=e||{}).exclude&&(typeof e.exclude[0]=="number"?[e.exclude]:e.exclude).forEach(c=>{for(let u=c[0];u<c[1];u+=1)a[u]=!0});let i=e.indentStart!==!1;const s=c=>i?`${n}${c}`:(i=!0,c);this.intro=this.intro.replace(r,s);let o=0,l=this.firstChunk;for(;l;){const c=l.end;if(l.edited)a[o]||(l.content=l.content.replace(r,s),l.content.length&&(i=l.content[l.content.length-1]===`
`));else for(o=l.start;o<c;){if(!a[o]){const u=this.original[o];u===`
`?i=!0:u!=="\r"&&i&&(i=!1,o===l.start||(this._splitChunk(l,o),l=l.next),l.prependRight(n))}o+=1}o=l.end,l=l.next}return this.outro=this.outro.replace(r,s),this}insert(){throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)")}insertLeft(n,e){return Zt.insertLeft||(console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"),Zt.insertLeft=!0),this.appendLeft(n,e)}insertRight(n,e){return Zt.insertRight||(console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"),Zt.insertRight=!0),this.prependRight(n,e)}move(n,e,r){if(r>=n&&r<=e)throw new Error("Cannot move a selection inside itself");this._split(n),this._split(e),this._split(r);const a=this.byStart[n],i=this.byEnd[e],s=a.previous,o=i.next,l=this.byStart[r];if(!l&&i===this.lastChunk)return this;const c=l?l.previous:this.lastChunk;return s&&(s.next=o),o&&(o.previous=s),c&&(c.next=a),l&&(l.previous=i),a.previous||(this.firstChunk=i.next),i.next||(this.lastChunk=a.previous,this.lastChunk.next=null),a.previous=c,i.next=l||null,c||(this.firstChunk=a),l||(this.lastChunk=i),this}overwrite(n,e,r,a){return a=a||{},this.update(n,e,r,{...a,overwrite:!a.contentOnly})}update(n,e,r,a){if(typeof r!="string")throw new TypeError("replacement content must be a string");for(;n<0;)n+=this.original.length;for(;e<0;)e+=this.original.length;if(e>this.original.length)throw new Error("end is out of bounds");if(n===e)throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");this._split(n),this._split(e),a===!0&&(Zt.storeName||(console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"),Zt.storeName=!0),a={storeName:!0});const i=a!==void 0&&a.storeName,s=a!==void 0&&a.overwrite;if(i){const c=this.original.slice(n,e);Object.defineProperty(this.storedNames,c,{writable:!0,value:!0,enumerable:!0})}const o=this.byStart[n],l=this.byEnd[e];if(o){let c=o;for(;c!==l;){if(c.next!==this.byStart[c.end])throw new Error("Cannot overwrite across a split point");c=c.next,c.edit("",!1)}o.edit(r,i,!s)}else{const c=new As(n,e,"").edit(r,i);l.next=c,c.previous=l}return this}prepend(n){if(typeof n!="string")throw new TypeError("outro content must be a string");return this.intro=n+this.intro,this}prependLeft(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byEnd[n];return r?r.prependLeft(e):this.intro=e+this.intro,this}prependRight(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byStart[n];return r?r.prependRight(e):this.outro=e+this.outro,this}remove(n,e){for(;n<0;)n+=this.original.length;for(;e<0;)e+=this.original.length;if(n===e)return this;if(n<0||e>this.original.length)throw new Error("Character is out of bounds");if(n>e)throw new Error("end must be greater than start");this._split(n),this._split(e);let r=this.byStart[n];for(;r;)r.intro="",r.outro="",r.edit(""),r=e>r.end?this.byStart[r.end]:null;return this}lastChar(){if(this.outro.length)return this.outro[this.outro.length-1];let n=this.lastChunk;do{if(n.outro.length)return n.outro[n.outro.length-1];if(n.content.length)return n.content[n.content.length-1];if(n.intro.length)return n.intro[n.intro.length-1]}while(n=n.previous);return this.intro.length?this.intro[this.intro.length-1]:""}lastLine(){let n=this.outro.lastIndexOf($e);if(n!==-1)return this.outro.substr(n+1);let e=this.outro,r=this.lastChunk;do{if(r.outro.length>0){if(n=r.outro.lastIndexOf($e),n!==-1)return r.outro.substr(n+1)+e;e=r.outro+e}if(r.content.length>0){if(n=r.content.lastIndexOf($e),n!==-1)return r.content.substr(n+1)+e;e=r.content+e}if(r.intro.length>0){if(n=r.intro.lastIndexOf($e),n!==-1)return r.intro.substr(n+1)+e;e=r.intro+e}}while(r=r.previous);return n=this.intro.lastIndexOf($e),n!==-1?this.intro.substr(n+1)+e:this.intro+e}slice(n=0,e=this.original.length){for(;n<0;)n+=this.original.length;for(;e<0;)e+=this.original.length;let r="",a=this.firstChunk;for(;a&&(a.start>n||a.end<=n);){if(a.start<e&&a.end>=e)return r;a=a.next}if(a&&a.edited&&a.start!==n)throw new Error(`Cannot use replaced character ${n} as slice start anchor.`);const i=a;for(;a;){!a.intro||i===a&&a.start!==n||(r+=a.intro);const s=a.start<e&&a.end>=e;if(s&&a.edited&&a.end!==e)throw new Error(`Cannot use replaced character ${e} as slice end anchor.`);const o=i===a?n-a.start:0,l=s?a.content.length+e-a.end:a.content.length;if(r+=a.content.slice(o,l),!a.outro||s&&a.end!==e||(r+=a.outro),s)break;a=a.next}return r}snip(n,e){const r=this.clone();return r.remove(0,n),r.remove(e,r.original.length),r}_split(n){if(this.byStart[n]||this.byEnd[n])return;let e=this.lastSearchedChunk;const r=n>e.end;for(;e;){if(e.contains(n))return this._splitChunk(e,n);e=r?this.byStart[e.end]:this.byEnd[e.start]}}_splitChunk(n,e){if(n.edited&&n.content.length){const a=ja(this.original)(e);throw new Error(`Cannot split a chunk that has already been edited (${a.line}:${a.column} – "${n.original}")`)}const r=n.split(e);return this.byEnd[e]=n,this.byStart[e]=r,this.byEnd[r.end]=r,n===this.lastChunk&&(this.lastChunk=r),this.lastSearchedChunk=n,!0}toString(){let n=this.intro,e=this.firstChunk;for(;e;)n+=e.toString(),e=e.next;return n+this.outro}isEmpty(){let n=this.firstChunk;do if(n.intro.length&&n.intro.trim()||n.content.length&&n.content.trim()||n.outro.length&&n.outro.trim())return!1;while(n=n.next);return!0}length(){let n=this.firstChunk,e=0;do e+=n.intro.length+n.content.length+n.outro.length;while(n=n.next);return e}trimLines(){return this.trim("[\\r\\n]")}trim(n){return this.trimStart(n).trimEnd(n)}trimEndAborted(n){const e=new RegExp((n||"\\s")+"+$");if(this.outro=this.outro.replace(e,""),this.outro.length)return!0;let r=this.lastChunk;do{const a=r.end,i=r.trimEnd(e);if(r.end!==a&&(this.lastChunk===r&&(this.lastChunk=r.next),this.byEnd[r.end]=r,this.byStart[r.next.start]=r.next,this.byEnd[r.next.end]=r.next),i)return!0;r=r.previous}while(r);return!1}trimEnd(n){return this.trimEndAborted(n),this}trimStartAborted(n){const e=new RegExp("^"+(n||"\\s")+"+");if(this.intro=this.intro.replace(e,""),this.intro.length)return!0;let r=this.firstChunk;do{const a=r.end,i=r.trimStart(e);if(r.end!==a&&(r===this.lastChunk&&(this.lastChunk=r.next),this.byEnd[r.end]=r,this.byStart[r.next.start]=r.next,this.byEnd[r.next.end]=r.next),i)return!0;r=r.next}while(r);return!1}trimStart(n){return this.trimStartAborted(n),this}hasChanged(){return this.original!==this.toString()}_replaceRegexp(n,e){function r(a,i){return typeof e=="string"?e.replace(/\$(\$|&|\d+)/g,(s,o)=>o==="$"?"$":o==="&"?a[0]:+o<a.length?a[+o]:`$${o}`):e(...a,a.index,i,a.groups)}if(n.global)(function(a,i){let s;const o=[];for(;s=a.exec(i);)o.push(s);return o})(n,this.original).forEach(a=>{a.index!=null&&this.overwrite(a.index,a.index+a[0].length,r(a,this.original))});else{const a=this.original.match(n);a&&a.index!=null&&this.overwrite(a.index,a.index+a[0].length,r(a,this.original))}return this}_replaceString(n,e){const{original:r}=this,a=r.indexOf(n);return a!==-1&&this.overwrite(a,a+n.length,e),this}replace(n,e){return typeof n=="string"?this._replaceString(n,e):this._replaceRegexp(n,e)}_replaceAllString(n,e){const{original:r}=this,a=n.length;for(let i=r.indexOf(n);i!==-1;i=r.indexOf(n,i+a))this.overwrite(i,i+a,e);return this}replaceAll(n,e){if(typeof n=="string")return this._replaceAllString(n,e);if(!n.global)throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");return this._replaceRegexp(n,e)}}const Is=Object.prototype.hasOwnProperty,Lm=/^(?:\/|(?:[A-Za-z]:)?[/\\|])/,Tm=/^\.?\.\//,Nm=/\\/g,Qt=/[/\\]/,Dm=/\.[^.]+$/;function bt(t){return Lm.test(t)}function Ma(t){return Tm.test(t)}function ke(t){return t.replace(Nm,"/")}function ft(t){return t.split(Qt).pop()||""}function Tt(t){const n=/[/\\][^/\\]*$/.exec(t);return n?t.slice(0,-n[0].length)||"/":"."}function xt(t){const n=Dm.exec(ft(t));return n?n[0]:""}function ne(t,n){const e=t.split(Qt).filter(Boolean),r=n.split(Qt).filter(Boolean);for(e[0]==="."&&e.shift(),r[0]==="."&&r.shift();e[0]&&r[0]&&e[0]===r[0];)e.shift(),r.shift();for(;r[0]===".."&&e.length>0;)r.shift(),e.pop();for(;e.pop();)r.unshift("..");return r.join("/")}function Hn(...t){const n=t.shift();if(!n)return"/";let e=n.split(Qt);for(const r of t)if(bt(r))e=r.split(Qt);else{const a=r.split(Qt);for(;a[0]==="."||a[0]==="..";)a.shift()===".."&&e.pop();e.push(...a)}return e.join("/")}const Om=/[\n\r'\\\u2028\u2029]/,zm=/([\n\r'\u2028\u2029])/g,Gm=/\\/g;function dr(t){return Om.test(t)?t.replace(Gm,"\\\\").replace(zm,"\\$1"):t}function La(t){const n=ft(t);return n.slice(0,Math.max(0,n.length-xt(t).length))}function W(t){return bt(t)?ne(Hn(),t):t}function pr(t){return t[0]==="/"||t[0]==="."&&(t[1]==="/"||t[1]===".")||bt(t)}const Fm=/^(\.\.\/)*\.\.$/;function js(t,n,e,r){let a=ke(ne(Tt(t),n));if(e&&a.endsWith(".js")&&(a=a.slice(0,-3)),r){if(a==="")return"../"+ft(n);if(Fm.test(a))return[...a.split("/"),"..",ft(n)].join("/")}return a?a.startsWith("..")?a:"./"+a:"."}class te{constructor(n,e,r){this.options=e,this.inputBase=r,this.defaultVariableName="",this.namespaceVariableName="",this.variableName="",this.fileName=null,this.importAssertions=null,this.id=n.id,this.moduleInfo=n.info,this.renormalizeRenderPath=n.renormalizeRenderPath,this.suggestedVariableName=n.suggestedVariableName}getFileName(){if(this.fileName)return this.fileName;const{paths:n}=this.options;return this.fileName=(typeof n=="function"?n(this.id):n[this.id])||(this.renormalizeRenderPath?ke(ne(this.inputBase,this.id)):this.id)}getImportAssertions(n){return this.importAssertions||(this.importAssertions=function(e,{getObject:r}){if(!e)return null;const a=Object.entries(e).map(([i,s])=>[i,`'${s}'`]);return a.length>0?r(a,{lineBreakIndent:null}):null}(this.options.format==="es"&&this.options.externalImportAssertions&&this.moduleInfo.assertions,n))}getImportPath(n){return dr(this.renormalizeRenderPath?js(n,this.getFileName(),this.options.format==="amd",!1):this.getFileName())}}function zn(t,n,e){const r=t.get(n);if(r!==void 0)return r;const a=e();return t.set(n,a),a}function Nt(){return new Set}function Ms(){return[]}const on=Symbol("Unknown Key"),hr=Symbol("Unknown Non-Accessor Key"),Ce=Symbol("Unknown Integer"),Ta=Symbol("Symbol.toStringTag"),q=[],nn=[on],Pm=[hr],Na=[Ce],ee=Symbol("Entities");class re{constructor(){this.entityPaths=Object.create(null,{[ee]:{value:new Set}})}trackEntityAtPathAndGetIfTracked(n,e){const r=this.getEntities(n);return!!r.has(e)||(r.add(e),!1)}withTrackedEntityAtPath(n,e,r,a){const i=this.getEntities(n);if(i.has(e))return a;i.add(e);const s=r();return i.delete(e),s}getEntities(n){let e=this.entityPaths;for(const r of n)e=e[r]=e[r]||Object.create(null,{[ee]:{value:new Set}});return e[ee]}}const vn=new re;class Ls{constructor(){this.entityPaths=Object.create(null,{[ee]:{value:new Map}})}trackEntityAtPathAndGetIfTracked(n,e,r){let a=this.entityPaths;for(const s of n)a=a[s]=a[s]||Object.create(null,{[ee]:{value:new Map}});const i=zn(a[ee],e,Nt);return!!i.has(r)||(i.add(r),!1)}}const mn=Symbol("Unknown Value"),Ts=Symbol("Unknown Truthy Value");class Rn{constructor(){this.included=!1}deoptimizeArgumentsOnInteractionAtPath(n,e,r){vt(n)}deoptimizePath(n){}getLiteralValueAtPath(n,e,r){return mn}getReturnExpressionWhenCalledAtPath(n,e,r,a){return gn}hasEffectsOnInteractionAtPath(n,e,r){return!0}include(n,e,r){this.included=!0}includeCallArguments(n,e){for(const r of e)r.include(n,!1)}shouldBeIncluded(n){return!0}}const X=new class extends Rn{},gn=[X,!1],vt=t=>{for(const n of t.args)n==null||n.deoptimizePath(nn)},Da={args:[null],type:0},Oa={args:[null,X],type:1},gr={args:[null],type:2,withNew:!1};class Dt extends Rn{constructor(n){super(),this.name=n,this.alwaysRendered=!1,this.forbiddenNames=null,this.initReached=!1,this.isId=!1,this.isReassigned=!1,this.kind=null,this.renderBaseName=null,this.renderName=null}addReference(n){}forbidName(n){(this.forbiddenNames||(this.forbiddenNames=new Set)).add(n)}getBaseVariableName(){return this.renderBaseName||this.renderName||this.name}getName(n,e){if(e!=null&&e(this))return this.name;const r=this.renderName||this.name;return this.renderBaseName?`${this.renderBaseName}${n(r)}`:r}hasEffectsOnInteractionAtPath(n,{type:e},r){return e!==0||n.length>0}include(){this.included=!0}markCalledFromTryStatement(){}setRenderNames(n,e){this.renderBaseName=n,this.renderName=e}}class yr extends Dt{constructor(n,e){super(e),this.referenced=!1,this.module=n,this.isNamespace=e==="*"}addReference(n){this.referenced=!0,this.name!=="default"&&this.name!=="*"||this.module.suggestName(n.name)}hasEffectsOnInteractionAtPath(n,{type:e}){return e!==0||n.length>(this.isNamespace?1:0)}include(){this.included||(this.included=!0,this.module.used=!0)}}const Bn=Object.freeze(Object.create(null)),Gn=Object.freeze({}),yn=Object.freeze([]),Ns=Object.freeze(new class extends Set{add(){throw new Error("Cannot add to empty set")}});var br=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","enum","eval","export","extends","false","finally","for","function","if","implements","import","in","instanceof","interface","let","NaN","new","null","package","private","protected","public","return","static","super","switch","this","throw","true","try","typeof","undefined","var","void","while","with","yield"]);const Ds=/[^\w$]/g,Os=t=>(n=>/\d/.test(n[0]))(t)||br.has(t)||t==="arguments";function za(t){return t=t.replace(/-(\w)/g,(n,e)=>e.toUpperCase()).replace(Ds,"_"),Os(t)&&(t=`_${t}`),t||"_"}const V="warn",Ot="info",Ee="debug",zt={[Ee]:0,[Ot]:1,silent:3,[V]:2};function Ga(t,n,e){if(typeof e=="number")throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");return function(r,a){a===void 0&&(a={});var i=a.offsetLine||0,s=a.offsetColumn||0,o=r.split(`
`),l=0,c=o.map(function(h,b){var p=l+h.length+1,g={start:l,end:p,line:b};return l=p,g}),u=0;function f(h,b){return h.start<=b&&b<h.end}function m(h,b){return{line:i+h.line,column:s+b-h.start,character:b}}return function(h,b){typeof h=="string"&&(h=r.indexOf(h,b||0));for(var p=c[u],g=h>=p.end?1:-1;p;){if(f(p,h))return m(p,h);p=c[u+=g]}}}(t,e)(n,e&&e.startIndex)}function Fa(t){return t.replace(/^\t+/,n=>n.split("	").join("  "))}const Um=120,Rm=10,Pa="...";function zs(t,n,e){let r=t.split(`
`);if(n>r.length)return"";const a=Math.max(Fa(r[n-1].slice(0,e)).length+Rm+Pa.length,Um),i=Math.max(0,n-3);let s=Math.min(n+2,r.length);for(r=r.slice(i,s);!/\S/.test(r[r.length-1]);)r.pop(),s-=1;const o=String(s).length;return r.map((l,c)=>{const u=i+c+1===n;let f=String(c+i+1);for(;f.length<o;)f=` ${f}`;let m=Fa(l);if(m.length>a&&(m=`${m.slice(0,a-Pa.length)}${Pa}`),u){const h=function(b){let p="";for(;b--;)p+=" ";return p}(o+2+Fa(l.slice(0,e)).length)+"^";return`${f}: ${m}
${h}`}return`${f}: ${m}`}).join(`
`)}function mt(t,n){const e=t.length<=1,r=t.map(i=>`"${i}"`);let a=e?r[0]:`${r.slice(0,-1).join(", ")} and ${r.slice(-1)[0]}`;return n&&(a+=` ${e?n[0]:n[1]}`),a}function En(t){return`https://rollupjs.org/${t}`}const Vm="troubleshooting/#error-name-is-not-exported-by-module",qm="troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect",Gs="configuration-options/#output-amd-id",Ae="configuration-options/#output-dir",Ua="configuration-options/#output-exports",Xm="configuration-options/#output-extend",Fs="configuration-options/#output-format",Wm="configuration-options/#output-experimentaldeepdynamicchunkoptimization",Km="configuration-options/#output-globals",Ra="configuration-options/#output-inlinedynamicimports",Va="configuration-options/#output-interop",qa="configuration-options/#output-manualchunks",Ps="configuration-options/#output-name",Hm="configuration-options/#output-sourcemapfile",Us="plugin-development/#this-getmoduleinfo";function L(t){throw t instanceof Error||(t=Object.assign(new Error(t.message),t),Object.defineProperty(t,"name",{value:"RollupError"})),t}function xr(t,n,e,r){if(typeof n=="object"){const{line:a,column:i}=n;t.loc={column:i,file:r,line:a}}else{t.pos=n;const{line:a,column:i}=Ga(e,n,{offsetLine:1});t.loc={column:i,file:r,line:a}}if(t.frame===void 0){const{line:a,column:i}=t.loc;t.frame=zs(e,a,i)}}const Ym="ADDON_ERROR",Jm="ALREADY_CLOSED",Zm="ANONYMOUS_PLUGIN_CACHE",Qm="ASSET_NOT_FINALISED",nd="CANNOT_EMIT_FROM_OPTIONS_HOOK",td="CHUNK_NOT_GENERATED",ed="CIRCULAR_REEXPORT",rd="DEPRECATED_FEATURE",ad="DUPLICATE_PLUGIN_NAME",id="FILE_NAME_CONFLICT",sd="ILLEGAL_IDENTIFIER_AS_NAME",od="INVALID_CHUNK",Rs="INVALID_EXPORT_OPTION",ld="INVALID_LOG_POSITION",cd="INVALID_OPTION",Vs="INVALID_PLUGIN_HOOK",qs="INVALID_ROLLUP_PHASE",_d="INVALID_SETASSETSOURCE",ud="MISSING_EXPORT",fd="MISSING_GLOBAL_NAME",Xa="MISSING_IMPLICIT_DEPENDANT",Xs="MISSING_NAME_OPTION_FOR_IIFE_EXPORT",md="MISSING_NODE_BUILTINS",dd="MISSING_OPTION",pd="MIXED_EXPORTS",hd="NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE",gd="OPTIMIZE_CHUNK_STATUS",yd="PLUGIN_ERROR",Ws="SOURCEMAP_BROKEN",Ks="UNEXPECTED_NAMED_IMPORT",bd="UNKNOWN_OPTION",Hs="UNRESOLVED_ENTRY",Ys="UNRESOLVED_IMPORT",xd="VALIDATION_ERROR";function Js(){return{code:Jm,message:'Bundle is already closed, no more calls to "generate" or "write" are allowed.'}}function Zs(t){return{code:"CANNOT_CALL_NAMESPACE",message:`Cannot call a namespace ("${t}").`}}function vd({fileName:t,code:n},e){const r={code:"CHUNK_INVALID",message:`Chunk "${t}" is not valid JavaScript: ${e.message}.`};return xr(r,e.loc,n,t),r}function $d(t){return{code:"CIRCULAR_DEPENDENCY",ids:t,message:`Circular dependency: ${t.map(W).join(" -> ")}`}}function kd(t,n,{line:e,column:r}){return{code:"FIRST_SIDE_EFFECT",message:`First side effect in ${W(n)} is at (${e}:${r})
${zs(t,e,r)}`}}function Qs(t,n){return{code:"ILLEGAL_REASSIGNMENT",message:`Illegal reassignment of import "${t}" in "${W(n)}".`}}function vr(t,n,e,r){return{code:"INCONSISTENT_IMPORT_ASSERTIONS",message:`Module "${W(r)}" tried to import "${W(e)}" with ${no(n)} assertions, but it was already imported elsewhere with ${no(t)} assertions. Please ensure that import assertions for the same module are always consistent.`}}const no=t=>{const n=Object.entries(t);return n.length===0?"no":n.map(([e,r])=>`"${e}": "${r}"`).join(", ")};function to(t,n,e){return{code:Rs,message:`"${t}" was specified for "output.exports", but entry module "${W(e)}" has the following exports: ${mt(n)}`,url:En(Ua)}}function bn(t,n,e,r){return{code:cd,message:`Invalid value ${r===void 0?"":`${JSON.stringify(r)} `}for option "${t}" - ${e}.`,url:En(n)}}function $r(t,n,e){const r=xt(e)===".json";return{binding:t,code:ud,exporter:e,id:n,message:`"${t}" is not exported by "${W(e)}", imported by "${W(n)}".${r?" (Note that you need @rollup/plugin-json to import JSON files)":""}`,url:En(Vm)}}function Cd(t){const n=[...t.implicitlyLoadedBefore].map(e=>W(e.id)).sort();return{code:Xa,message:`Module "${W(t.id)}" that should be implicitly loaded before ${mt(n)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`}}function eo(t,n,e){return{code:gd,message:`${e}, there are
${t} chunks, of which
${n} are below minChunkSize.`}}function we(t,n,{hook:e,id:r}={}){return!t.code||t.code.startsWith("PLUGIN_")||t.pluginCode||(t.pluginCode=t.code),t.code=yd,t.plugin=n,e&&(t.hook=e),r&&(t.id=r),t}function Ed(t){return{code:Ws,message:`Multiple conflicting contents for sourcemap source ${t}`}}function ro(t,n,e){const r=e?"reexport":"import";return{code:Ks,exporter:t,message:`The named export "${n}" was ${r}ed from the external module "${W(t)}" even though its interop type is "defaultOnly". Either remove or change this ${r} or change the value of the "output.interop" option.`,url:En(Va)}}function Ad(t){return{code:Ks,exporter:t,message:`There was a namespace "*" reexport from the external module "${W(t)}" even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,url:En(Va)}}function Tn(t){return{code:xd,message:t}}function Gt(t,n,e,r,a){Se(t,n,e,r.onLog,r.strictDeprecations,a)}function Se(t,n,e,r,a,i){if(e||a){const s=function(o,l,c){return{code:rd,message:o,url:En(l),...c?{plugin:c}:{}}}(t,n,i);if(a)return L(s);r(V,s)}}class fn{constructor(n,e,r,a,i,s){this.options=n,this.id=e,this.renormalizeRenderPath=i,this.dynamicImporters=[],this.execIndex=1/0,this.exportedVariables=new Map,this.importers=[],this.reexported=!1,this.used=!1,this.declarations=new Map,this.mostCommonSuggestion=0,this.nameSuggestions=new Map,this.suggestedVariableName=za(e.split(/[/\\]/).pop());const{importers:o,dynamicImporters:l}=this,c=this.info={assertions:s,ast:null,code:null,dynamicallyImportedIdResolutions:yn,dynamicallyImportedIds:yn,get dynamicImporters(){return l.sort()},exportedBindings:null,exports:null,hasDefaultExport:null,get hasModuleSideEffects(){return Gt("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.",Us,!0,n),c.moduleSideEffects},id:e,implicitlyLoadedAfterOneOf:yn,implicitlyLoadedBefore:yn,importedIdResolutions:yn,importedIds:yn,get importers(){return o.sort()},isEntry:!1,isExternal:!0,isIncluded:null,meta:a,moduleSideEffects:r,syntheticNamedExports:!1};Object.defineProperty(this.info,"hasModuleSideEffects",{enumerable:!1})}getVariableForExportName(n){const e=this.declarations.get(n);if(e)return[e];const r=new yr(this,n);return this.declarations.set(n,r),this.exportedVariables.set(r,n),[r]}suggestName(n){const e=(this.nameSuggestions.get(n)??0)+1;this.nameSuggestions.set(n,e),e>this.mostCommonSuggestion&&(this.mostCommonSuggestion=e,this.suggestedVariableName=n)}warnUnusedImports(){const n=[...this.declarations].filter(([o,l])=>o!=="*"&&!l.included&&!this.reexported&&!l.referenced).map(([o])=>o);if(n.length===0)return;const e=new Set;for(const o of n)for(const l of this.declarations.get(o).module.importers)e.add(l);const r=[...e];var a,i,s;this.options.onLog(V,{code:"UNUSED_EXTERNAL_IMPORT",exporter:a=this.id,ids:s=r,message:`${mt(i=n,["is","are"])} imported from external module "${a}" but never used in ${mt(s.map(o=>W(o)))}.`,names:i})}}const ae={ArrayPattern(t,n){for(const e of n.elements)e&&ae[e.type](t,e)},AssignmentPattern(t,n){ae[n.left.type](t,n.left)},Identifier(t,n){t.push(n.name)},MemberExpression(){},ObjectPattern(t,n){for(const e of n.properties)e.type==="RestElement"?ae.RestElement(t,e):ae[e.value.type](t,e.value)},RestElement(t,n){ae[n.argument.type](t,n.argument)}},wd=function(t){const n=[];return ae[t.type](n,t),n};function Wa(){return{brokenFlow:!1,hasBreak:!1,hasContinue:!1,includedCallArguments:new Set,includedLabels:new Set}}function kr(){return{accessed:new re,assigned:new re,brokenFlow:!1,called:new Ls,hasBreak:!1,hasContinue:!1,ignore:{breaks:!1,continues:!1,labels:new Set,returnYield:!1,this:!1},includedLabels:new Set,instantiated:new Ls,replacedVariableInits:new Map}}function Be(t,n=null){return Object.create(n,t)}new Set("break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" ")).add("");const ie=new class extends Rn{getLiteralValueAtPath(){}},Ft={value:{hasEffectsWhenCalled:null,returns:X}},Ka=new class extends Rn{getReturnExpressionWhenCalledAtPath(t){return t.length===1?Me(Ya,t[0]):gn}hasEffectsOnInteractionAtPath(t,n,e){return n.type===0?t.length>1:n.type!==2||t.length!==1||je(Ya,t[0],n,e)}},$t={value:{hasEffectsWhenCalled:null,returns:Ka}},se=new class extends Rn{getReturnExpressionWhenCalledAtPath(t){return t.length===1?Me(Ja,t[0]):gn}hasEffectsOnInteractionAtPath(t,n,e){return n.type===0?t.length>1:n.type!==2||t.length!==1||je(Ja,t[0],n,e)}},oe={value:{hasEffectsWhenCalled:null,returns:se}},Ha=new class extends Rn{getReturnExpressionWhenCalledAtPath(t){return t.length===1?Me(Ie,t[0]):gn}hasEffectsOnInteractionAtPath(t,n,e){return n.type===0?t.length>1:n.type!==2||t.length!==1||je(Ie,t[0],n,e)}},H={value:{hasEffectsWhenCalled:null,returns:Ha}},ao={value:{hasEffectsWhenCalled({args:t},n){const e=t[2];return t.length<3||typeof e.getLiteralValueAtPath(q,vn,{deoptimizeCache(){}})=="symbol"&&e.hasEffectsOnInteractionAtPath(q,gr,n)},returns:Ha}},Cr=Be({hasOwnProperty:$t,isPrototypeOf:$t,propertyIsEnumerable:$t,toLocaleString:H,toString:H,valueOf:Ft}),Ya=Be({valueOf:$t},Cr),Ja=Be({toExponential:H,toFixed:H,toLocaleString:H,toPrecision:H,valueOf:oe},Cr),Sd=Be({exec:Ft,test:$t},Cr),Ie=Be({anchor:H,at:Ft,big:H,blink:H,bold:H,charAt:H,charCodeAt:oe,codePointAt:Ft,concat:H,endsWith:$t,fixed:H,fontcolor:H,fontsize:H,includes:$t,indexOf:oe,italics:H,lastIndexOf:oe,link:H,localeCompare:oe,match:Ft,matchAll:Ft,normalize:H,padEnd:H,padStart:H,repeat:H,replace:ao,replaceAll:ao,search:oe,slice:H,small:H,split:Ft,startsWith:$t,strike:H,sub:H,substr:H,substring:H,sup:H,toLocaleLowerCase:H,toLocaleUpperCase:H,toLowerCase:H,toString:H,toUpperCase:H,trim:H,trimEnd:H,trimLeft:H,trimRight:H,trimStart:H,valueOf:H},Cr);function je(t,n,e,r){var a,i;return typeof n!="string"||!t[n]||((i=(a=t[n]).hasEffectsWhenCalled)==null?void 0:i.call(a,e,r))||!1}function Me(t,n){return typeof n=="string"&&t[n]?[t[n].returns,!1]:gn}function Za(t,n,e){e(t,n)}function Pt(t,n,e){}var M={};M.Program=M.BlockStatement=M.StaticBlock=function(t,n,e){for(var r=0,a=t.body;r<a.length;r+=1)e(a[r],n,"Statement")},M.Statement=Za,M.EmptyStatement=Pt,M.ExpressionStatement=M.ParenthesizedExpression=M.ChainExpression=function(t,n,e){return e(t.expression,n,"Expression")},M.IfStatement=function(t,n,e){e(t.test,n,"Expression"),e(t.consequent,n,"Statement"),t.alternate&&e(t.alternate,n,"Statement")},M.LabeledStatement=function(t,n,e){return e(t.body,n,"Statement")},M.BreakStatement=M.ContinueStatement=Pt,M.WithStatement=function(t,n,e){e(t.object,n,"Expression"),e(t.body,n,"Statement")},M.SwitchStatement=function(t,n,e){e(t.discriminant,n,"Expression");for(var r=0,a=t.cases;r<a.length;r+=1){var i=a[r];i.test&&e(i.test,n,"Expression");for(var s=0,o=i.consequent;s<o.length;s+=1)e(o[s],n,"Statement")}},M.SwitchCase=function(t,n,e){t.test&&e(t.test,n,"Expression");for(var r=0,a=t.consequent;r<a.length;r+=1)e(a[r],n,"Statement")},M.ReturnStatement=M.YieldExpression=M.AwaitExpression=function(t,n,e){t.argument&&e(t.argument,n,"Expression")},M.ThrowStatement=M.SpreadElement=function(t,n,e){return e(t.argument,n,"Expression")},M.TryStatement=function(t,n,e){e(t.block,n,"Statement"),t.handler&&e(t.handler,n),t.finalizer&&e(t.finalizer,n,"Statement")},M.CatchClause=function(t,n,e){t.param&&e(t.param,n,"Pattern"),e(t.body,n,"Statement")},M.WhileStatement=M.DoWhileStatement=function(t,n,e){e(t.test,n,"Expression"),e(t.body,n,"Statement")},M.ForStatement=function(t,n,e){t.init&&e(t.init,n,"ForInit"),t.test&&e(t.test,n,"Expression"),t.update&&e(t.update,n,"Expression"),e(t.body,n,"Statement")},M.ForInStatement=M.ForOfStatement=function(t,n,e){e(t.left,n,"ForInit"),e(t.right,n,"Expression"),e(t.body,n,"Statement")},M.ForInit=function(t,n,e){t.type==="VariableDeclaration"?e(t,n):e(t,n,"Expression")},M.DebuggerStatement=Pt,M.FunctionDeclaration=function(t,n,e){return e(t,n,"Function")},M.VariableDeclaration=function(t,n,e){for(var r=0,a=t.declarations;r<a.length;r+=1)e(a[r],n)},M.VariableDeclarator=function(t,n,e){e(t.id,n,"Pattern"),t.init&&e(t.init,n,"Expression")},M.Function=function(t,n,e){t.id&&e(t.id,n,"Pattern");for(var r=0,a=t.params;r<a.length;r+=1)e(a[r],n,"Pattern");e(t.body,n,t.expression?"Expression":"Statement")},M.Pattern=function(t,n,e){t.type==="Identifier"?e(t,n,"VariablePattern"):t.type==="MemberExpression"?e(t,n,"MemberPattern"):e(t,n)},M.VariablePattern=Pt,M.MemberPattern=Za,M.RestElement=function(t,n,e){return e(t.argument,n,"Pattern")},M.ArrayPattern=function(t,n,e){for(var r=0,a=t.elements;r<a.length;r+=1){var i=a[r];i&&e(i,n,"Pattern")}},M.ObjectPattern=function(t,n,e){for(var r=0,a=t.properties;r<a.length;r+=1){var i=a[r];i.type==="Property"?(i.computed&&e(i.key,n,"Expression"),e(i.value,n,"Pattern")):i.type==="RestElement"&&e(i.argument,n,"Pattern")}},M.Expression=Za,M.ThisExpression=M.Super=M.MetaProperty=Pt,M.ArrayExpression=function(t,n,e){for(var r=0,a=t.elements;r<a.length;r+=1){var i=a[r];i&&e(i,n,"Expression")}},M.ObjectExpression=function(t,n,e){for(var r=0,a=t.properties;r<a.length;r+=1)e(a[r],n)},M.FunctionExpression=M.ArrowFunctionExpression=M.FunctionDeclaration,M.SequenceExpression=function(t,n,e){for(var r=0,a=t.expressions;r<a.length;r+=1)e(a[r],n,"Expression")},M.TemplateLiteral=function(t,n,e){for(var r=0,a=t.quasis;r<a.length;r+=1)e(a[r],n);for(var i=0,s=t.expressions;i<s.length;i+=1)e(s[i],n,"Expression")},M.TemplateElement=Pt,M.UnaryExpression=M.UpdateExpression=function(t,n,e){e(t.argument,n,"Expression")},M.BinaryExpression=M.LogicalExpression=function(t,n,e){e(t.left,n,"Expression"),e(t.right,n,"Expression")},M.AssignmentExpression=M.AssignmentPattern=function(t,n,e){e(t.left,n,"Pattern"),e(t.right,n,"Expression")},M.ConditionalExpression=function(t,n,e){e(t.test,n,"Expression"),e(t.consequent,n,"Expression"),e(t.alternate,n,"Expression")},M.NewExpression=M.CallExpression=function(t,n,e){if(e(t.callee,n,"Expression"),t.arguments)for(var r=0,a=t.arguments;r<a.length;r+=1)e(a[r],n,"Expression")},M.MemberExpression=function(t,n,e){e(t.object,n,"Expression"),t.computed&&e(t.property,n,"Expression")},M.ExportNamedDeclaration=M.ExportDefaultDeclaration=function(t,n,e){t.declaration&&e(t.declaration,n,t.type==="ExportNamedDeclaration"||t.declaration.id?"Statement":"Expression"),t.source&&e(t.source,n,"Expression")},M.ExportAllDeclaration=function(t,n,e){t.exported&&e(t.exported,n),e(t.source,n,"Expression")},M.ImportDeclaration=function(t,n,e){for(var r=0,a=t.specifiers;r<a.length;r+=1)e(a[r],n);e(t.source,n,"Expression")},M.ImportExpression=function(t,n,e){e(t.source,n,"Expression")},M.ImportSpecifier=M.ImportDefaultSpecifier=M.ImportNamespaceSpecifier=M.Identifier=M.PrivateIdentifier=M.Literal=Pt,M.TaggedTemplateExpression=function(t,n,e){e(t.tag,n,"Expression"),e(t.quasi,n,"Expression")},M.ClassDeclaration=M.ClassExpression=function(t,n,e){return e(t,n,"Class")},M.Class=function(t,n,e){t.id&&e(t.id,n,"Pattern"),t.superClass&&e(t.superClass,n,"Expression"),e(t.body,n)},M.ClassBody=function(t,n,e){for(var r=0,a=t.body;r<a.length;r+=1)e(a[r],n)},M.MethodDefinition=M.PropertyDefinition=M.Property=function(t,n,e){t.computed&&e(t.key,n,"Expression"),t.value&&e(t.value,n,"Expression")};const Qa="ArrowFunctionExpression",Bd="BinaryExpression",io="BlockStatement",so="CallExpression",Id="ChainExpression",jd="ConditionalExpression",Md="ExportDefaultDeclaration",Ld="ExportNamedDeclaration",Vn="ExpressionStatement",Td="FunctionDeclaration",oo="Identifier",Nd="LogicalExpression",Dd="NewExpression",Er="Program",Od="SequenceExpression",zd="VariableDeclarator",Gd="VariableDeclaration";let ni="sourceMa";ni+="ppingURL";const Fd=new RegExp(`^#[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+${ni}=.+`),lo="_rollupAnnotations",co="_rollupRemoved";function _o(t,n,e=t.type){const{annotations:r,code:a}=n;let i=r[n.annotationIndex];for(;i&&t.start>=i.end;)Ud(t,i,a),i=r[++n.annotationIndex];if(i&&i.end<=t.end)for(M[e](t,n,_o);(i=r[n.annotationIndex])&&i.end<=t.end;)++n.annotationIndex,wr(t,i,!1)}const Pd=/[^\s(]/g,ti=/\S/g;function Ud(t,n,e){const r=[];let a;if(Ar(e.slice(n.end,t.start),Pd)){const i=t.start;for(;;){switch(r.push(t),t.type){case Vn:case Id:t=t.expression;continue;case Od:if(Ar(e.slice(i,t.start),ti)){t=t.expressions[0];continue}a=!0;break;case jd:if(Ar(e.slice(i,t.start),ti)){t=t.test;continue}a=!0;break;case Nd:case Bd:if(Ar(e.slice(i,t.start),ti)){t=t.left;continue}a=!0;break;case Ld:case Md:t=t.declaration;continue;case Gd:{const s=t;if(s.kind==="const"){t=s.declarations[0].init;continue}a=!0;break}case zd:t=t.init;continue;case Td:case Qa:case so:case Dd:break;default:a=!0}break}}else a=!0;if(a)wr(t,n,!1);else for(const i of r)wr(i,n,!0)}function Ar(t,n){let e;for(;(e=n.exec(t))!==null;){if(e[0]==="/"){const r=t.charCodeAt(n.lastIndex);if(r===42){n.lastIndex=t.indexOf("*/",n.lastIndex+1)+2;continue}if(r===47){n.lastIndex=t.indexOf(`
`,n.lastIndex+1)+1;continue}}return n.lastIndex=0,!1}return!0}const Rd=[["pure",/[#@]__PURE__/],["noSideEffects",/[#@]__NO_SIDE_EFFECTS__/]];function wr(t,n,e){const r=e?lo:co,a=t[r];a?a.push(n):t[r]=[n]}const ei={ImportExpression:["arguments"],Literal:[],Program:["body"]},uo="variables";class O extends Rn{constructor(n,e,r,a=!1){super(),this.deoptimized=!1,this.esTreeNode=a?n:null,this.keys=ei[n.type]||function(i){return ei[i.type]=Object.keys(i).filter(s=>typeof i[s]=="object"&&s.charCodeAt(0)!==95),ei[i.type]}(n),this.parent=e,this.context=e.context,this.createScope(r),this.parseNode(n),this.initialise(),this.context.magicString.addSourcemapLocation(this.start),this.context.magicString.addSourcemapLocation(this.end)}addExportedVariables(n,e){}bind(){for(const n of this.keys){const e=this[n];if(Array.isArray(e))for(const r of e)r==null||r.bind();else e&&e.bind()}}createScope(n){this.scope=n}hasEffects(n){this.deoptimized||this.applyDeoptimizations();for(const e of this.keys){const r=this[e];if(r!==null){if(Array.isArray(r)){for(const a of r)if(a!=null&&a.hasEffects(n))return!0}else if(r.hasEffects(n))return!0}}return!1}hasEffectsAsAssignmentTarget(n,e){return this.hasEffects(n)||this.hasEffectsOnInteractionAtPath(q,this.assignmentInteraction,n)}include(n,e,r){this.deoptimized||this.applyDeoptimizations(),this.included=!0;for(const a of this.keys){const i=this[a];if(i!==null)if(Array.isArray(i))for(const s of i)s==null||s.include(n,e);else i.include(n,e)}}includeAsAssignmentTarget(n,e,r){this.include(n,e)}initialise(){}insertSemicolon(n){n.original[this.end-1]!==";"&&n.appendLeft(this.end,";")}parseNode(n,e){for(const[r,a]of Object.entries(n))if(!this.hasOwnProperty(r))if(r.charCodeAt(0)===95){if(r===lo){const i=a;this.annotations=i,this.context.options.treeshake.annotations&&(this.annotationNoSideEffects=i.some(s=>s.annotationType==="noSideEffects"),this.annotationPure=i.some(s=>s.annotationType==="pure"))}else if(r===co)for(const{start:i,end:s}of a)this.context.magicString.remove(i,s)}else if(typeof a!="object"||a===null)this[r]=a;else if(Array.isArray(a)){this[r]=[];for(const i of a)this[r].push(i===null?null:new(this.context.getNodeConstructor(i.type))(i,this,this.scope,e==null?void 0:e.includes(r)))}else this[r]=new(this.context.getNodeConstructor(a.type))(a,this,this.scope,e==null?void 0:e.includes(r))}render(n,e){for(const r of this.keys){const a=this[r];if(a!==null)if(Array.isArray(a))for(const i of a)i==null||i.render(n,e);else a.render(n,e)}}setAssignedValue(n){this.assignmentInteraction={args:[null,n],type:1}}shouldBeIncluded(n){return this.included||!n.brokenFlow&&this.hasEffects(kr())}applyDeoptimizations(){this.deoptimized=!0;for(const n of this.keys){const e=this[n];if(e!==null)if(Array.isArray(e))for(const r of e)r==null||r.deoptimizePath(nn);else e.deoptimizePath(nn)}this.context.requestTreeshakingPass()}}class Le extends O{deoptimizeArgumentsOnInteractionAtPath(n,e,r){e.length>0&&this.argument.deoptimizeArgumentsOnInteractionAtPath(n,[on,...e],r)}hasEffects(n){this.deoptimized||this.applyDeoptimizations();const{propertyReadSideEffects:e}=this.context.options.treeshake;return this.argument.hasEffects(n)||e&&(e==="always"||this.argument.hasEffectsOnInteractionAtPath(nn,Da,n))}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath([on,on]),this.context.requestTreeshakingPass()}}class Mn extends Rn{constructor(n){super(),this.description=n}deoptimizeArgumentsOnInteractionAtPath({args:n,type:e},r){var a;e===2&&r.length===0&&this.description.mutatesSelfAsArray&&((a=n[0])==null||a.deoptimizePath(Na))}getReturnExpressionWhenCalledAtPath(n,{args:e}){return n.length>0?gn:[this.description.returnsPrimitive||(this.description.returns==="self"?e[0]||X:this.description.returns()),!1]}hasEffectsOnInteractionAtPath(n,e,r){var i,s;const{type:a}=e;if(n.length>(a===0?1:0))return!0;if(a===2){const{args:o}=e;if(this.description.mutatesSelfAsArray===!0&&((i=o[0])!=null&&i.hasEffectsOnInteractionAtPath(Na,Oa,r)))return!0;if(this.description.callsArgs){for(const l of this.description.callsArgs)if((s=o[l+1])!=null&&s.hasEffectsOnInteractionAtPath(q,gr,r))return!0}}return!1}}const Sr=[new Mn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:Ka})],Te=[new Mn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:Ha})],fo=[new Mn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:se})],mo=[new Mn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:X})],Ne=/^\d+$/;class Fn extends Rn{constructor(n,e,r=!1){if(super(),this.prototypeExpression=e,this.immutable=r,this.additionalExpressionsToBeDeoptimized=new Set,this.allProperties=[],this.deoptimizedPaths=Object.create(null),this.expressionsToBeDeoptimizedByKey=Object.create(null),this.gettersByKey=Object.create(null),this.hasLostTrack=!1,this.hasUnknownDeoptimizedInteger=!1,this.hasUnknownDeoptimizedProperty=!1,this.propertiesAndGettersByKey=Object.create(null),this.propertiesAndSettersByKey=Object.create(null),this.settersByKey=Object.create(null),this.unknownIntegerProps=[],this.unmatchableGetters=[],this.unmatchablePropertiesAndGetters=[],this.unmatchableSetters=[],Array.isArray(n))this.buildPropertyMaps(n);else{this.propertiesAndGettersByKey=this.propertiesAndSettersByKey=n;for(const a of Object.values(n))this.allProperties.push(...a)}}deoptimizeAllProperties(n){var r;const e=this.hasLostTrack||this.hasUnknownDeoptimizedProperty;if(n?this.hasUnknownDeoptimizedProperty=!0:this.hasLostTrack=!0,!e){for(const a of[...Object.values(this.propertiesAndGettersByKey),...Object.values(this.settersByKey)])for(const i of a)i.deoptimizePath(nn);(r=this.prototypeExpression)==null||r.deoptimizePath([on,on]),this.deoptimizeCachedEntities()}}deoptimizeArgumentsOnInteractionAtPath(n,e,r){var f;const[a,...i]=e,{args:s,type:o}=n;if(this.hasLostTrack||(o===2||e.length>1)&&(this.hasUnknownDeoptimizedProperty||typeof a=="string"&&this.deoptimizedPaths[a]))return void vt(n);const[l,c,u]=o===2||e.length>1?[this.propertiesAndGettersByKey,this.propertiesAndGettersByKey,this.unmatchablePropertiesAndGetters]:o===0?[this.propertiesAndGettersByKey,this.gettersByKey,this.unmatchableGetters]:[this.propertiesAndSettersByKey,this.settersByKey,this.unmatchableSetters];if(typeof a=="string"){if(l[a]){const m=c[a];if(m)for(const h of m)h.deoptimizeArgumentsOnInteractionAtPath(n,i,r);if(!this.immutable)for(const h of s)h&&this.additionalExpressionsToBeDeoptimized.add(h);return}for(const m of u)m.deoptimizeArgumentsOnInteractionAtPath(n,i,r);if(Ne.test(a))for(const m of this.unknownIntegerProps)m.deoptimizeArgumentsOnInteractionAtPath(n,i,r)}else{for(const m of[...Object.values(c),u])for(const h of m)h.deoptimizeArgumentsOnInteractionAtPath(n,i,r);for(const m of this.unknownIntegerProps)m.deoptimizeArgumentsOnInteractionAtPath(n,i,r)}if(!this.immutable)for(const m of s)m&&this.additionalExpressionsToBeDeoptimized.add(m);(f=this.prototypeExpression)==null||f.deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizeIntegerProperties(){if(!(this.hasLostTrack||this.hasUnknownDeoptimizedProperty||this.hasUnknownDeoptimizedInteger)){this.hasUnknownDeoptimizedInteger=!0;for(const[n,e]of Object.entries(this.propertiesAndGettersByKey))if(Ne.test(n))for(const r of e)r.deoptimizePath(nn);this.deoptimizeCachedIntegerEntities()}}deoptimizePath(n){var a;if(this.hasLostTrack||this.immutable)return;const e=n[0];if(n.length===1){if(typeof e!="string")return e===Ce?this.deoptimizeIntegerProperties():this.deoptimizeAllProperties(e===hr);if(!this.deoptimizedPaths[e]){this.deoptimizedPaths[e]=!0;const i=this.expressionsToBeDeoptimizedByKey[e];if(i)for(const s of i)s.deoptimizeCache()}}const r=n.length===1?nn:n.slice(1);for(const i of typeof e=="string"?[...this.propertiesAndGettersByKey[e]||this.unmatchablePropertiesAndGetters,...this.settersByKey[e]||this.unmatchableSetters]:this.allProperties)i.deoptimizePath(r);(a=this.prototypeExpression)==null||a.deoptimizePath(n.length===1?[...n,on]:n)}getLiteralValueAtPath(n,e,r){if(n.length===0)return Ts;const a=n[0],i=this.getMemberExpressionAndTrackDeopt(a,r);return i?i.getLiteralValueAtPath(n.slice(1),e,r):this.prototypeExpression?this.prototypeExpression.getLiteralValueAtPath(n,e,r):n.length!==1?mn:void 0}getReturnExpressionWhenCalledAtPath(n,e,r,a){if(n.length===0)return gn;const[i,...s]=n,o=this.getMemberExpressionAndTrackDeopt(i,a);return o?o.getReturnExpressionWhenCalledAtPath(s,e,r,a):this.prototypeExpression?this.prototypeExpression.getReturnExpressionWhenCalledAtPath(n,e,r,a):gn}hasEffectsOnInteractionAtPath(n,e,r){const[a,...i]=n;if(i.length>0||e.type===2){const c=this.getMemberExpression(a);return c?c.hasEffectsOnInteractionAtPath(i,e,r):!this.prototypeExpression||this.prototypeExpression.hasEffectsOnInteractionAtPath(n,e,r)}if(a===hr)return!1;if(this.hasLostTrack)return!0;const[s,o,l]=e.type===0?[this.propertiesAndGettersByKey,this.gettersByKey,this.unmatchableGetters]:[this.propertiesAndSettersByKey,this.settersByKey,this.unmatchableSetters];if(typeof a=="string"){if(s[a]){const c=o[a];if(c){for(const u of c)if(u.hasEffectsOnInteractionAtPath(i,e,r))return!0}return!1}for(const c of l)if(c.hasEffectsOnInteractionAtPath(i,e,r))return!0}else for(const c of[...Object.values(o),l])for(const u of c)if(u.hasEffectsOnInteractionAtPath(i,e,r))return!0;return!!this.prototypeExpression&&this.prototypeExpression.hasEffectsOnInteractionAtPath(n,e,r)}buildPropertyMaps(n){const{allProperties:e,propertiesAndGettersByKey:r,propertiesAndSettersByKey:a,settersByKey:i,gettersByKey:s,unknownIntegerProps:o,unmatchablePropertiesAndGetters:l,unmatchableGetters:c,unmatchableSetters:u}=this,f=[];for(let m=n.length-1;m>=0;m--){const{key:h,kind:b,property:p}=n[m];if(e.push(p),typeof h=="string")b==="set"?a[h]||(a[h]=[p,...f],i[h]=[p,...u]):b==="get"?r[h]||(r[h]=[p,...l],s[h]=[p,...c]):(a[h]||(a[h]=[p,...f]),r[h]||(r[h]=[p,...l]));else{if(h===Ce){o.push(p);continue}b==="set"&&u.push(p),b==="get"&&c.push(p),b!=="get"&&f.push(p),b!=="set"&&l.push(p)}}}deoptimizeCachedEntities(){for(const n of Object.values(this.expressionsToBeDeoptimizedByKey))for(const e of n)e.deoptimizeCache();for(const n of this.additionalExpressionsToBeDeoptimized)n.deoptimizePath(nn)}deoptimizeCachedIntegerEntities(){for(const[n,e]of Object.entries(this.expressionsToBeDeoptimizedByKey))if(Ne.test(n))for(const r of e)r.deoptimizeCache();for(const n of this.additionalExpressionsToBeDeoptimized)n.deoptimizePath(Na)}getMemberExpression(n){if(this.hasLostTrack||this.hasUnknownDeoptimizedProperty||typeof n!="string"||this.hasUnknownDeoptimizedInteger&&Ne.test(n)||this.deoptimizedPaths[n])return X;const e=this.propertiesAndGettersByKey[n];return(e==null?void 0:e.length)===1?e[0]:e||this.unmatchablePropertiesAndGetters.length>0||this.unknownIntegerProps.length>0&&Ne.test(n)?X:null}getMemberExpressionAndTrackDeopt(n,e){if(typeof n!="string")return X;const r=this.getMemberExpression(n);return r!==X&&!this.immutable&&(this.expressionsToBeDeoptimizedByKey[n]=this.expressionsToBeDeoptimizedByKey[n]||[]).push(e),r}}const po=t=>typeof t=="string"&&/^\d+$/.test(t),Vd=new class extends Rn{deoptimizeArgumentsOnInteractionAtPath(t,n){t.type!==2||n.length!==1||po(n[0])||vt(t)}getLiteralValueAtPath(t){return t.length===1&&po(t[0])?void 0:mn}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>1||n===2}},kt=new Fn({__proto__:null,hasOwnProperty:Sr,isPrototypeOf:Sr,propertyIsEnumerable:Sr,toLocaleString:Te,toString:Te,valueOf:mo},Vd,!0),ri=[{key:Ce,kind:"init",property:X},{key:"length",kind:"init",property:se}],ho=[new Mn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:Ka})],go=[new Mn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:se})],qd=[new Mn({callsArgs:null,mutatesSelfAsArray:!0,returns:()=>new Fn(ri,Ir),returnsPrimitive:null})],Br=[new Mn({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:()=>new Fn(ri,Ir),returnsPrimitive:null})],ai=[new Mn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:()=>new Fn(ri,Ir),returnsPrimitive:null})],yo=[new Mn({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:se})],bo=[new Mn({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:X})],xo=[new Mn({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:X})],De=[new Mn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:X})],ii=[new Mn({callsArgs:null,mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],Xd=[new Mn({callsArgs:[0],mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],Ir=new Fn({__proto__:null,at:xo,concat:Br,copyWithin:ii,entries:Br,every:ho,fill:ii,filter:ai,find:De,findIndex:go,findLast:De,findLastIndex:go,flat:Br,flatMap:ai,forEach:De,includes:Sr,indexOf:fo,join:Te,keys:mo,lastIndexOf:fo,map:ai,pop:bo,push:yo,reduce:De,reduceRight:De,reverse:ii,shift:bo,slice:Br,some:ho,sort:Xd,splice:qd,toLocaleString:Te,toString:Te,unshift:yo,values:xo},kt,!0);class vo extends O{constructor(){super(...arguments),this.objectEntity=null}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizePath(n){this.getObjectEntity().deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getObjectEntity().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(n,e,r,a)}hasEffectsOnInteractionAtPath(n,e,r){return this.getObjectEntity().hasEffectsOnInteractionAtPath(n,e,r)}applyDeoptimizations(){this.deoptimized=!0;let n=!1;for(let e=0;e<this.elements.length;e++){const r=this.elements[e];r&&(n||r instanceof Le)&&(n=!0,r.deoptimizePath(nn))}this.context.requestTreeshakingPass()}getObjectEntity(){if(this.objectEntity!==null)return this.objectEntity;const n=[{key:"length",kind:"init",property:se}];let e=!1;for(let r=0;r<this.elements.length;r++){const a=this.elements[r];e||a instanceof Le?a&&(e=!0,n.unshift({key:Ce,kind:"init",property:a})):a?n.push({key:String(r),kind:"init",property:a}):n.push({key:String(r),kind:"init",property:ie})}return this.objectEntity=new Fn(n,Ir)}}class $o extends O{addExportedVariables(n,e){for(const r of this.elements)r==null||r.addExportedVariables(n,e)}declare(n){const e=[];for(const r of this.elements)r!==null&&e.push(...r.declare(n,X));return e}deoptimizePath(){for(const n of this.elements)n==null||n.deoptimizePath(q)}hasEffectsOnInteractionAtPath(n,e,r){for(const a of this.elements)if(a!=null&&a.hasEffectsOnInteractionAtPath(q,e,r))return!0;return!1}markDeclarationReached(){for(const n of this.elements)n==null||n.markDeclarationReached()}}class dt extends Dt{constructor(n,e,r,a){super(n),this.init=r,this.calledFromTryStatement=!1,this.additionalInitializers=null,this.expressionsToBeDeoptimized=[],this.declarations=e?[e]:[],this.deoptimizationTracker=a.deoptimizationTracker,this.module=a.module}addDeclaration(n,e){this.declarations.push(n),this.markInitializersForDeoptimization().push(e)}consolidateInitializers(){if(this.additionalInitializers){for(const n of this.additionalInitializers)n.deoptimizePath(nn);this.additionalInitializers=null}}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.isReassigned?vt(n):r.withTrackedEntityAtPath(e,this.init,()=>this.init.deoptimizeArgumentsOnInteractionAtPath(n,e,r),void 0)}deoptimizePath(n){if(!this.isReassigned&&!this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(n,this))if(n.length===0){if(!this.isReassigned){this.isReassigned=!0;const e=this.expressionsToBeDeoptimized;this.expressionsToBeDeoptimized=yn;for(const r of e)r.deoptimizeCache();this.init.deoptimizePath(nn)}}else this.init.deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.isReassigned?mn:e.withTrackedEntityAtPath(n,this.init,()=>(this.expressionsToBeDeoptimized.push(r),this.init.getLiteralValueAtPath(n,e,r)),mn)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.isReassigned?gn:r.withTrackedEntityAtPath(n,this.init,()=>(this.expressionsToBeDeoptimized.push(a),this.init.getReturnExpressionWhenCalledAtPath(n,e,r,a)),gn)}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return!!this.isReassigned||!r.accessed.trackEntityAtPathAndGetIfTracked(n,this)&&this.init.hasEffectsOnInteractionAtPath(n,e,r);case 1:return!!this.included||n.length!==0&&(!!this.isReassigned||!r.assigned.trackEntityAtPathAndGetIfTracked(n,this)&&this.init.hasEffectsOnInteractionAtPath(n,e,r));case 2:return!!this.isReassigned||!(e.withNew?r.instantiated:r.called).trackEntityAtPathAndGetIfTracked(n,e.args,this)&&this.init.hasEffectsOnInteractionAtPath(n,e,r)}}include(){if(!this.included){this.included=!0;for(const n of this.declarations){n.included||n.include(Wa(),!1);let e=n.parent;for(;!e.included&&(e.included=!0,e.type!==Er);)e=e.parent}}}includeCallArguments(n,e){if(this.isReassigned||n.includedCallArguments.has(this.init))for(const r of e)r.include(n,!1);else n.includedCallArguments.add(this.init),this.init.includeCallArguments(n,e),n.includedCallArguments.delete(this.init)}markCalledFromTryStatement(){this.calledFromTryStatement=!0}markInitializersForDeoptimization(){return this.additionalInitializers===null&&(this.additionalInitializers=[this.init],this.init=X,this.isReassigned=!0),this.additionalInitializers}mergeDeclarations(n){const{declarations:e}=this;for(const a of n.declarations)e.push(a);const r=this.markInitializersForDeoptimization();if(r.push(n.init),n.additionalInitializers)for(const a of n.additionalInitializers)r.push(a)}}const ko=yn,Wd=new Set([on]),Kd=new re,Hd=new Set([X]);class Co extends dt{constructor(n,e,r){super(n,e,X,r),this.deoptimizationInteractions=[],this.deoptimizations=new re,this.deoptimizedFields=new Set,this.entitiesToBeDeoptimized=new Set}addEntityToBeDeoptimized(n){if(n===X){if(!this.entitiesToBeDeoptimized.has(X)){this.entitiesToBeDeoptimized.add(X);for(const{interaction:e}of this.deoptimizationInteractions)vt(e);this.deoptimizationInteractions=ko}}else if(this.deoptimizedFields.has(on))n.deoptimizePath(nn);else if(!this.entitiesToBeDeoptimized.has(n)){this.entitiesToBeDeoptimized.add(n);for(const e of this.deoptimizedFields)n.deoptimizePath([e]);for(const{interaction:e,path:r}of this.deoptimizationInteractions)n.deoptimizeArgumentsOnInteractionAtPath(e,r,vn)}}deoptimizeArgumentsOnInteractionAtPath(n,e){if(e.length>=2||this.entitiesToBeDeoptimized.has(X)||this.deoptimizationInteractions.length>=20||e.length===1&&(this.deoptimizedFields.has(on)||n.type===2&&this.deoptimizedFields.has(e[0])))vt(n);else if(!this.deoptimizations.trackEntityAtPathAndGetIfTracked(e,n.args)){for(const r of this.entitiesToBeDeoptimized)r.deoptimizeArgumentsOnInteractionAtPath(n,e,vn);this.entitiesToBeDeoptimized.has(X)||this.deoptimizationInteractions.push({interaction:n,path:e})}}deoptimizePath(n){if(n.length===0||this.deoptimizedFields.has(on))return;const e=n[0];if(!this.deoptimizedFields.has(e)){this.deoptimizedFields.add(e);for(const r of this.entitiesToBeDeoptimized)r.deoptimizePath(n);e===on&&(this.deoptimizationInteractions=ko,this.deoptimizations=Kd,this.deoptimizedFields=Wd,this.entitiesToBeDeoptimized=Hd)}}getReturnExpressionWhenCalledAtPath(n){return n.length===0?this.deoptimizePath(nn):this.deoptimizedFields.has(n[0])||this.deoptimizePath([n[0]]),gn}}const Yd="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$",Eo=64;function jr(t){let n="";do{const e=t%Eo;t=t/Eo|0,n=Yd[e]+n}while(t!==0);return n}function et(t,n,e){let r=t,a=1;for(;n.has(r)||br.has(r)||e!=null&&e.has(r);)r=`${t}$${jr(a++)}`;return n.add(r),r}let Ao=class{constructor(){this.children=[],this.variables=new Map}addDeclaration(t,n,e,r){const a=t.name;let i=this.variables.get(a);return i?i.addDeclaration(t,e):(i=new dt(t.name,t,e||ie,n),this.variables.set(a,i)),i}contains(t){return this.variables.has(t)}findVariable(t){throw new Error("Internal Error: findVariable needs to be implemented by a subclass")}};class Yn extends Ao{constructor(n){super(),this.accessedOutsideVariables=new Map,this.parent=n,n.children.push(this)}addAccessedDynamicImport(n){(this.accessedDynamicImports||(this.accessedDynamicImports=new Set)).add(n),this.parent instanceof Yn&&this.parent.addAccessedDynamicImport(n)}addAccessedGlobals(n,e){const r=e.get(this)||new Set;for(const a of n)r.add(a);e.set(this,r),this.parent instanceof Yn&&this.parent.addAccessedGlobals(n,e)}addNamespaceMemberAccess(n,e){this.accessedOutsideVariables.set(n,e),this.parent.addNamespaceMemberAccess(n,e)}addReturnExpression(n){this.parent instanceof Yn&&this.parent.addReturnExpression(n)}addUsedOutsideNames(n,e,r,a){for(const s of this.accessedOutsideVariables.values())s.included&&(n.add(s.getBaseVariableName()),e==="system"&&r.has(s)&&n.add("exports"));const i=a.get(this);if(i)for(const s of i)n.add(s)}contains(n){return this.variables.has(n)||this.parent.contains(n)}deconflict(n,e,r){const a=new Set;if(this.addUsedOutsideNames(a,n,e,r),this.accessedDynamicImports)for(const i of this.accessedDynamicImports)i.inlineNamespace&&a.add(i.inlineNamespace.getBaseVariableName());for(const[i,s]of this.variables)(s.included||s.alwaysRendered)&&s.setRenderNames(null,et(i,a,s.forbiddenNames));for(const i of this.children)i.deconflict(n,e,r)}findLexicalBoundary(){return this.parent.findLexicalBoundary()}findVariable(n){const e=this.variables.get(n)||this.accessedOutsideVariables.get(n);if(e)return e;const r=this.parent.findVariable(n);return this.accessedOutsideVariables.set(n,r),r}}class wo extends Yn{constructor(n,e){super(n),this.parameters=[],this.hasRest=!1,this.context=e,this.hoistedBodyVarScope=new Yn(this)}addParameterDeclaration(n){const{name:e}=n,r=new Co(e,n,this.context),a=this.hoistedBodyVarScope.variables.get(e);return a&&(this.hoistedBodyVarScope.variables.set(e,r),r.mergeDeclarations(a)),this.variables.set(e,r),r}addParameterVariables(n,e){this.parameters=n;for(const r of n)for(const a of r)a.alwaysRendered=!0;this.hasRest=e}includeCallArguments(n,e){let r=!1,a=!1;const i=this.hasRest&&this.parameters[this.parameters.length-1];for(const s of e)if(s instanceof Le){for(const o of e)o.include(n,!1);break}for(let s=e.length-1;s>=0;s--){const o=this.parameters[s]||i,l=e[s];if(o)if(r=!1,o.length===0)a=!0;else for(const c of o)c.included&&(a=!0),c.calledFromTryStatement&&(r=!0);!a&&l.shouldBeIncluded(n)&&(a=!0),a&&l.include(n,r)}}}class So extends wo{constructor(){super(...arguments),this.returnExpression=null,this.returnExpressions=[]}addReturnExpression(n){this.returnExpressions.push(n)}getReturnExpression(){return this.returnExpression===null&&this.updateReturnExpression(),this.returnExpression}updateReturnExpression(){if(this.returnExpressions.length===1)this.returnExpression=this.returnExpressions[0];else{this.returnExpression=X;for(const n of this.returnExpressions)n.deoptimizePath(nn)}}}function Bo(t,n){if(t.type==="MemberExpression")return!t.computed&&Bo(t.object,t);if(t.type==="Identifier"){if(!n)return!0;switch(n.type){case"MemberExpression":return n.computed||t===n.object;case"MethodDefinition":return n.computed;case"PropertyDefinition":case"Property":return n.computed||t===n.value;case"ExportSpecifier":case"ImportSpecifier":return t===n.local;case"LabeledStatement":case"BreakStatement":case"ContinueStatement":return!1;default:return!0}}return!1}const si=Symbol("PureFunction"),rt=()=>{},pn=Symbol("Value Properties"),Mr=()=>Ts,Io=()=>!0,at={deoptimizeArgumentsOnCall:rt,getLiteralValue:Mr,hasEffectsWhenCalled:()=>!1},Ct={deoptimizeArgumentsOnCall:rt,getLiteralValue:Mr,hasEffectsWhenCalled:Io},A={__proto__:null,[pn]:Ct},T={__proto__:null,[pn]:at},oi={__proto__:null,[pn]:{deoptimizeArgumentsOnCall({args:[,t]}){t==null||t.deoptimizePath(nn)},getLiteralValue:Mr,hasEffectsWhenCalled:({args:t},n)=>t.length<=1||t[1].hasEffectsOnInteractionAtPath(Pm,Oa,n)}},_={__proto__:null,[pn]:Ct,prototype:A},Jn={__proto__:null,[pn]:at,prototype:A},Lr={__proto__:null,[pn]:{deoptimizeArgumentsOnCall:rt,getLiteralValue:Mr,hasEffectsWhenCalled:({args:t})=>t.length>1&&!(t[1]instanceof vo)},prototype:A},pt={__proto__:null,[pn]:at,from:A,of:T,prototype:A},le={__proto__:null,[pn]:at,supportedLocalesOf:Jn},li={global:A,globalThis:A,self:A,window:A,__proto__:null,[pn]:Ct,Array:{__proto__:null,[pn]:Ct,from:A,isArray:T,of:T,prototype:A},ArrayBuffer:{__proto__:null,[pn]:at,isView:T,prototype:A},Atomics:A,BigInt:_,BigInt64Array:_,BigUint64Array:_,Boolean:Jn,constructor:_,DataView:Jn,Date:{__proto__:null,[pn]:at,now:T,parse:T,prototype:A,UTC:T},decodeURI:T,decodeURIComponent:T,encodeURI:T,encodeURIComponent:T,Error:Jn,escape:T,eval:A,EvalError:Jn,Float32Array:pt,Float64Array:pt,Function:_,hasOwnProperty:A,Infinity:A,Int16Array:pt,Int32Array:pt,Int8Array:pt,isFinite:T,isNaN:T,isPrototypeOf:A,JSON:A,Map:Lr,Math:{__proto__:null,[pn]:Ct,abs:T,acos:T,acosh:T,asin:T,asinh:T,atan:T,atan2:T,atanh:T,cbrt:T,ceil:T,clz32:T,cos:T,cosh:T,exp:T,expm1:T,floor:T,fround:T,hypot:T,imul:T,log:T,log10:T,log1p:T,log2:T,max:T,min:T,pow:T,random:T,round:T,sign:T,sin:T,sinh:T,sqrt:T,tan:T,tanh:T,trunc:T},NaN:A,Number:{__proto__:null,[pn]:at,isFinite:T,isInteger:T,isNaN:T,isSafeInteger:T,parseFloat:T,parseInt:T,prototype:A},Object:{__proto__:null,[pn]:at,create:T,defineProperty:oi,defineProperties:oi,freeze:oi,getOwnPropertyDescriptor:T,getOwnPropertyDescriptors:T,getOwnPropertyNames:T,getOwnPropertySymbols:T,getPrototypeOf:T,hasOwn:T,is:T,isExtensible:T,isFrozen:T,isSealed:T,keys:T,fromEntries:A,entries:T,prototype:A},parseFloat:T,parseInt:T,Promise:{__proto__:null,[pn]:Ct,all:A,allSettled:A,any:A,prototype:A,race:A,reject:A,resolve:A},propertyIsEnumerable:A,Proxy:A,RangeError:Jn,ReferenceError:Jn,Reflect:A,RegExp:Jn,Set:Lr,SharedArrayBuffer:_,String:{__proto__:null,[pn]:at,fromCharCode:T,fromCodePoint:T,prototype:A,raw:T},Symbol:{__proto__:null,[pn]:at,for:T,keyFor:T,prototype:A,toStringTag:{__proto__:null,[pn]:{deoptimizeArgumentsOnCall:rt,getLiteralValue:()=>Ta,hasEffectsWhenCalled:Io}}},SyntaxError:Jn,toLocaleString:A,toString:A,TypeError:Jn,Uint16Array:pt,Uint32Array:pt,Uint8Array:pt,Uint8ClampedArray:pt,unescape:T,URIError:Jn,valueOf:A,WeakMap:Lr,WeakSet:Lr,clearInterval:_,clearTimeout:_,console:{__proto__:null,[pn]:Ct,assert:_,clear:_,count:_,countReset:_,debug:_,dir:_,dirxml:_,error:_,exception:_,group:_,groupCollapsed:_,groupEnd:_,info:_,log:_,table:_,time:_,timeEnd:_,timeLog:_,trace:_,warn:_},Intl:{__proto__:null,[pn]:Ct,Collator:le,DateTimeFormat:le,ListFormat:le,NumberFormat:le,PluralRules:le,RelativeTimeFormat:le},setInterval:_,setTimeout:_,TextDecoder:_,TextEncoder:_,URL:_,URLSearchParams:_,AbortController:_,AbortSignal:_,addEventListener:A,alert:A,AnalyserNode:_,Animation:_,AnimationEvent:_,applicationCache:A,ApplicationCache:_,ApplicationCacheErrorEvent:_,atob:A,Attr:_,Audio:_,AudioBuffer:_,AudioBufferSourceNode:_,AudioContext:_,AudioDestinationNode:_,AudioListener:_,AudioNode:_,AudioParam:_,AudioProcessingEvent:_,AudioScheduledSourceNode:_,AudioWorkletNode:_,BarProp:_,BaseAudioContext:_,BatteryManager:_,BeforeUnloadEvent:_,BiquadFilterNode:_,Blob:_,BlobEvent:_,blur:A,BroadcastChannel:_,btoa:A,ByteLengthQueuingStrategy:_,Cache:_,caches:A,CacheStorage:_,cancelAnimationFrame:A,cancelIdleCallback:A,CanvasCaptureMediaStreamTrack:_,CanvasGradient:_,CanvasPattern:_,CanvasRenderingContext2D:_,ChannelMergerNode:_,ChannelSplitterNode:_,CharacterData:_,clientInformation:A,ClipboardEvent:_,close:A,closed:A,CloseEvent:_,Comment:_,CompositionEvent:_,confirm:A,ConstantSourceNode:_,ConvolverNode:_,CountQueuingStrategy:_,createImageBitmap:A,Credential:_,CredentialsContainer:_,crypto:A,Crypto:_,CryptoKey:_,CSS:_,CSSConditionRule:_,CSSFontFaceRule:_,CSSGroupingRule:_,CSSImportRule:_,CSSKeyframeRule:_,CSSKeyframesRule:_,CSSMediaRule:_,CSSNamespaceRule:_,CSSPageRule:_,CSSRule:_,CSSRuleList:_,CSSStyleDeclaration:_,CSSStyleRule:_,CSSStyleSheet:_,CSSSupportsRule:_,CustomElementRegistry:_,customElements:A,CustomEvent:_,DataTransfer:_,DataTransferItem:_,DataTransferItemList:_,defaultstatus:A,defaultStatus:A,DelayNode:_,DeviceMotionEvent:_,DeviceOrientationEvent:_,devicePixelRatio:A,dispatchEvent:A,document:A,Document:_,DocumentFragment:_,DocumentType:_,DOMError:_,DOMException:_,DOMImplementation:_,DOMMatrix:_,DOMMatrixReadOnly:_,DOMParser:_,DOMPoint:_,DOMPointReadOnly:_,DOMQuad:_,DOMRect:_,DOMRectReadOnly:_,DOMStringList:_,DOMStringMap:_,DOMTokenList:_,DragEvent:_,DynamicsCompressorNode:_,Element:_,ErrorEvent:_,Event:_,EventSource:_,EventTarget:_,external:A,fetch:A,File:_,FileList:_,FileReader:_,find:A,focus:A,FocusEvent:_,FontFace:_,FontFaceSetLoadEvent:_,FormData:_,frames:A,GainNode:_,Gamepad:_,GamepadButton:_,GamepadEvent:_,getComputedStyle:A,getSelection:A,HashChangeEvent:_,Headers:_,history:A,History:_,HTMLAllCollection:_,HTMLAnchorElement:_,HTMLAreaElement:_,HTMLAudioElement:_,HTMLBaseElement:_,HTMLBodyElement:_,HTMLBRElement:_,HTMLButtonElement:_,HTMLCanvasElement:_,HTMLCollection:_,HTMLContentElement:_,HTMLDataElement:_,HTMLDataListElement:_,HTMLDetailsElement:_,HTMLDialogElement:_,HTMLDirectoryElement:_,HTMLDivElement:_,HTMLDListElement:_,HTMLDocument:_,HTMLElement:_,HTMLEmbedElement:_,HTMLFieldSetElement:_,HTMLFontElement:_,HTMLFormControlsCollection:_,HTMLFormElement:_,HTMLFrameElement:_,HTMLFrameSetElement:_,HTMLHeadElement:_,HTMLHeadingElement:_,HTMLHRElement:_,HTMLHtmlElement:_,HTMLIFrameElement:_,HTMLImageElement:_,HTMLInputElement:_,HTMLLabelElement:_,HTMLLegendElement:_,HTMLLIElement:_,HTMLLinkElement:_,HTMLMapElement:_,HTMLMarqueeElement:_,HTMLMediaElement:_,HTMLMenuElement:_,HTMLMetaElement:_,HTMLMeterElement:_,HTMLModElement:_,HTMLObjectElement:_,HTMLOListElement:_,HTMLOptGroupElement:_,HTMLOptionElement:_,HTMLOptionsCollection:_,HTMLOutputElement:_,HTMLParagraphElement:_,HTMLParamElement:_,HTMLPictureElement:_,HTMLPreElement:_,HTMLProgressElement:_,HTMLQuoteElement:_,HTMLScriptElement:_,HTMLSelectElement:_,HTMLShadowElement:_,HTMLSlotElement:_,HTMLSourceElement:_,HTMLSpanElement:_,HTMLStyleElement:_,HTMLTableCaptionElement:_,HTMLTableCellElement:_,HTMLTableColElement:_,HTMLTableElement:_,HTMLTableRowElement:_,HTMLTableSectionElement:_,HTMLTemplateElement:_,HTMLTextAreaElement:_,HTMLTimeElement:_,HTMLTitleElement:_,HTMLTrackElement:_,HTMLUListElement:_,HTMLUnknownElement:_,HTMLVideoElement:_,IDBCursor:_,IDBCursorWithValue:_,IDBDatabase:_,IDBFactory:_,IDBIndex:_,IDBKeyRange:_,IDBObjectStore:_,IDBOpenDBRequest:_,IDBRequest:_,IDBTransaction:_,IDBVersionChangeEvent:_,IdleDeadline:_,IIRFilterNode:_,Image:_,ImageBitmap:_,ImageBitmapRenderingContext:_,ImageCapture:_,ImageData:_,indexedDB:A,innerHeight:A,innerWidth:A,InputEvent:_,IntersectionObserver:_,IntersectionObserverEntry:_,isSecureContext:A,KeyboardEvent:_,KeyframeEffect:_,length:A,localStorage:A,location:A,Location:_,locationbar:A,matchMedia:A,MediaDeviceInfo:_,MediaDevices:_,MediaElementAudioSourceNode:_,MediaEncryptedEvent:_,MediaError:_,MediaKeyMessageEvent:_,MediaKeySession:_,MediaKeyStatusMap:_,MediaKeySystemAccess:_,MediaList:_,MediaQueryList:_,MediaQueryListEvent:_,MediaRecorder:_,MediaSettingsRange:_,MediaSource:_,MediaStream:_,MediaStreamAudioDestinationNode:_,MediaStreamAudioSourceNode:_,MediaStreamEvent:_,MediaStreamTrack:_,MediaStreamTrackEvent:_,menubar:A,MessageChannel:_,MessageEvent:_,MessagePort:_,MIDIAccess:_,MIDIConnectionEvent:_,MIDIInput:_,MIDIInputMap:_,MIDIMessageEvent:_,MIDIOutput:_,MIDIOutputMap:_,MIDIPort:_,MimeType:_,MimeTypeArray:_,MouseEvent:_,moveBy:A,moveTo:A,MutationEvent:_,MutationObserver:_,MutationRecord:_,name:A,NamedNodeMap:_,NavigationPreloadManager:_,navigator:A,Navigator:_,NetworkInformation:_,Node:_,NodeFilter:A,NodeIterator:_,NodeList:_,Notification:_,OfflineAudioCompletionEvent:_,OfflineAudioContext:_,offscreenBuffering:A,OffscreenCanvas:_,open:A,openDatabase:A,Option:_,origin:A,OscillatorNode:_,outerHeight:A,outerWidth:A,PageTransitionEvent:_,pageXOffset:A,pageYOffset:A,PannerNode:_,parent:A,Path2D:_,PaymentAddress:_,PaymentRequest:_,PaymentRequestUpdateEvent:_,PaymentResponse:_,performance:A,Performance:_,PerformanceEntry:_,PerformanceLongTaskTiming:_,PerformanceMark:_,PerformanceMeasure:_,PerformanceNavigation:_,PerformanceNavigationTiming:_,PerformanceObserver:_,PerformanceObserverEntryList:_,PerformancePaintTiming:_,PerformanceResourceTiming:_,PerformanceTiming:_,PeriodicWave:_,Permissions:_,PermissionStatus:_,personalbar:A,PhotoCapabilities:_,Plugin:_,PluginArray:_,PointerEvent:_,PopStateEvent:_,postMessage:A,Presentation:_,PresentationAvailability:_,PresentationConnection:_,PresentationConnectionAvailableEvent:_,PresentationConnectionCloseEvent:_,PresentationConnectionList:_,PresentationReceiver:_,PresentationRequest:_,print:A,ProcessingInstruction:_,ProgressEvent:_,PromiseRejectionEvent:_,prompt:A,PushManager:_,PushSubscription:_,PushSubscriptionOptions:_,queueMicrotask:A,RadioNodeList:_,Range:_,ReadableStream:_,RemotePlayback:_,removeEventListener:A,Request:_,requestAnimationFrame:A,requestIdleCallback:A,resizeBy:A,ResizeObserver:_,ResizeObserverEntry:_,resizeTo:A,Response:_,RTCCertificate:_,RTCDataChannel:_,RTCDataChannelEvent:_,RTCDtlsTransport:_,RTCIceCandidate:_,RTCIceTransport:_,RTCPeerConnection:_,RTCPeerConnectionIceEvent:_,RTCRtpReceiver:_,RTCRtpSender:_,RTCSctpTransport:_,RTCSessionDescription:_,RTCStatsReport:_,RTCTrackEvent:_,screen:A,Screen:_,screenLeft:A,ScreenOrientation:_,screenTop:A,screenX:A,screenY:A,ScriptProcessorNode:_,scroll:A,scrollbars:A,scrollBy:A,scrollTo:A,scrollX:A,scrollY:A,SecurityPolicyViolationEvent:_,Selection:_,ServiceWorker:_,ServiceWorkerContainer:_,ServiceWorkerRegistration:_,sessionStorage:A,ShadowRoot:_,SharedWorker:_,SourceBuffer:_,SourceBufferList:_,speechSynthesis:A,SpeechSynthesisEvent:_,SpeechSynthesisUtterance:_,StaticRange:_,status:A,statusbar:A,StereoPannerNode:_,stop:A,Storage:_,StorageEvent:_,StorageManager:_,styleMedia:A,StyleSheet:_,StyleSheetList:_,SubtleCrypto:_,SVGAElement:_,SVGAngle:_,SVGAnimatedAngle:_,SVGAnimatedBoolean:_,SVGAnimatedEnumeration:_,SVGAnimatedInteger:_,SVGAnimatedLength:_,SVGAnimatedLengthList:_,SVGAnimatedNumber:_,SVGAnimatedNumberList:_,SVGAnimatedPreserveAspectRatio:_,SVGAnimatedRect:_,SVGAnimatedString:_,SVGAnimatedTransformList:_,SVGAnimateElement:_,SVGAnimateMotionElement:_,SVGAnimateTransformElement:_,SVGAnimationElement:_,SVGCircleElement:_,SVGClipPathElement:_,SVGComponentTransferFunctionElement:_,SVGDefsElement:_,SVGDescElement:_,SVGDiscardElement:_,SVGElement:_,SVGEllipseElement:_,SVGFEBlendElement:_,SVGFEColorMatrixElement:_,SVGFEComponentTransferElement:_,SVGFECompositeElement:_,SVGFEConvolveMatrixElement:_,SVGFEDiffuseLightingElement:_,SVGFEDisplacementMapElement:_,SVGFEDistantLightElement:_,SVGFEDropShadowElement:_,SVGFEFloodElement:_,SVGFEFuncAElement:_,SVGFEFuncBElement:_,SVGFEFuncGElement:_,SVGFEFuncRElement:_,SVGFEGaussianBlurElement:_,SVGFEImageElement:_,SVGFEMergeElement:_,SVGFEMergeNodeElement:_,SVGFEMorphologyElement:_,SVGFEOffsetElement:_,SVGFEPointLightElement:_,SVGFESpecularLightingElement:_,SVGFESpotLightElement:_,SVGFETileElement:_,SVGFETurbulenceElement:_,SVGFilterElement:_,SVGForeignObjectElement:_,SVGGElement:_,SVGGeometryElement:_,SVGGradientElement:_,SVGGraphicsElement:_,SVGImageElement:_,SVGLength:_,SVGLengthList:_,SVGLinearGradientElement:_,SVGLineElement:_,SVGMarkerElement:_,SVGMaskElement:_,SVGMatrix:_,SVGMetadataElement:_,SVGMPathElement:_,SVGNumber:_,SVGNumberList:_,SVGPathElement:_,SVGPatternElement:_,SVGPoint:_,SVGPointList:_,SVGPolygonElement:_,SVGPolylineElement:_,SVGPreserveAspectRatio:_,SVGRadialGradientElement:_,SVGRect:_,SVGRectElement:_,SVGScriptElement:_,SVGSetElement:_,SVGStopElement:_,SVGStringList:_,SVGStyleElement:_,SVGSVGElement:_,SVGSwitchElement:_,SVGSymbolElement:_,SVGTextContentElement:_,SVGTextElement:_,SVGTextPathElement:_,SVGTextPositioningElement:_,SVGTitleElement:_,SVGTransform:_,SVGTransformList:_,SVGTSpanElement:_,SVGUnitTypes:_,SVGUseElement:_,SVGViewElement:_,TaskAttributionTiming:_,Text:_,TextEvent:_,TextMetrics:_,TextTrack:_,TextTrackCue:_,TextTrackCueList:_,TextTrackList:_,TimeRanges:_,toolbar:A,top:A,Touch:_,TouchEvent:_,TouchList:_,TrackEvent:_,TransitionEvent:_,TreeWalker:_,UIEvent:_,ValidityState:_,visualViewport:A,VisualViewport:_,VTTCue:_,WaveShaperNode:_,WebAssembly:A,WebGL2RenderingContext:_,WebGLActiveInfo:_,WebGLBuffer:_,WebGLContextEvent:_,WebGLFramebuffer:_,WebGLProgram:_,WebGLQuery:_,WebGLRenderbuffer:_,WebGLRenderingContext:_,WebGLSampler:_,WebGLShader:_,WebGLShaderPrecisionFormat:_,WebGLSync:_,WebGLTexture:_,WebGLTransformFeedback:_,WebGLUniformLocation:_,WebGLVertexArrayObject:_,WebSocket:_,WheelEvent:_,Window:_,Worker:_,WritableStream:_,XMLDocument:_,XMLHttpRequest:_,XMLHttpRequestEventTarget:_,XMLHttpRequestUpload:_,XMLSerializer:_,XPathEvaluator:_,XPathExpression:_,XPathResult:_,XSLTProcessor:_};for(const t of["window","global","self","globalThis"])li[t]=li;function ce(t){let n=li;for(const e of t)if(typeof e!="string"||(n=n[e],!n))return null;return n[pn]}class ci extends Dt{constructor(){super(...arguments),this.isReassigned=!0}deoptimizeArgumentsOnInteractionAtPath(n,e,r){switch(n.type){case 0:case 1:return void(ce([this.name,...e].slice(0,-1))||super.deoptimizeArgumentsOnInteractionAtPath(n,e,r));case 2:{const a=ce([this.name,...e]);return void(a?a.deoptimizeArgumentsOnCall(n):super.deoptimizeArgumentsOnInteractionAtPath(n,e,r))}}}getLiteralValueAtPath(n,e,r){const a=ce([this.name,...n]);return a?a.getLiteralValue():mn}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return n.length===0?this.name!=="undefined"&&!ce([this.name]):!ce([this.name,...n].slice(0,-1));case 1:return!0;case 2:{const a=ce([this.name,...n]);return!a||a.hasEffectsWhenCalled(e,r)}}}}const Jd={__proto__:null,class:!0,const:!0,let:!0,var:!0};class _n extends O{constructor(){super(...arguments),this.variable=null,this.isTDZAccess=null}addExportedVariables(n,e){e.has(this.variable)&&n.push(this.variable)}bind(){!this.variable&&Bo(this,this.parent)&&(this.variable=this.scope.findVariable(this.name),this.variable.addReference(this))}declare(n,e){let r;const{treeshake:a}=this.context.options;switch(n){case"var":r=this.scope.addDeclaration(this,this.context,e,!0),a&&a.correctVarValueBeforeDeclaration&&r.markInitializersForDeoptimization();break;case"function":case"let":case"const":case"class":r=this.scope.addDeclaration(this,this.context,e,!1);break;case"parameter":r=this.scope.addParameterDeclaration(this);break;default:throw new Error(`Internal Error: Unexpected identifier kind ${n}.`)}return r.kind=n,[this.variable=r]}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.variable.deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizePath(n){var e;n.length!==0||this.scope.contains(this.name)||this.disallowImportReassignment(),(e=this.variable)==null||e.deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getVariableRespectingTDZ().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){const[i,s]=this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(n,e,r,a);return[i,s||this.isPureFunction(n)]}hasEffects(n){return this.deoptimized||this.applyDeoptimizations(),!(!this.isPossibleTDZ()||this.variable.kind==="var")||this.context.options.treeshake.unknownGlobalSideEffects&&this.variable instanceof ci&&!this.isPureFunction(q)&&this.variable.hasEffectsOnInteractionAtPath(q,Da,n)}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return this.variable!==null&&!this.isPureFunction(n)&&this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(n,e,r);case 1:return(n.length>0?this.getVariableRespectingTDZ():this.variable).hasEffectsOnInteractionAtPath(n,e,r);case 2:return!this.isPureFunction(n)&&this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(n,e,r)}}include(){this.deoptimized||this.applyDeoptimizations(),this.included||(this.included=!0,this.variable!==null&&this.context.includeVariableInModule(this.variable))}includeCallArguments(n,e){this.variable.includeCallArguments(n,e)}isPossibleTDZ(){if(this.isTDZAccess!==null)return this.isTDZAccess;if(!(this.variable instanceof dt&&this.variable.kind&&this.variable.kind in Jd&&this.variable.module===this.context.module))return this.isTDZAccess=!1;let n;return this.variable.declarations&&this.variable.declarations.length===1&&(n=this.variable.declarations[0])&&this.start<n.start&&jo(this)===jo(n)?this.isTDZAccess=!0:this.variable.initReached?this.isTDZAccess=!1:this.isTDZAccess=!0}markDeclarationReached(){this.variable.initReached=!0}render(n,{snippets:{getPropertyAccess:e},useOriginalName:r},{renderedParentType:a,isCalleeOfRenderedParent:i,isShorthandProperty:s}=Bn){if(this.variable){const o=this.variable.getName(e,r);o!==this.name&&(n.overwrite(this.start,this.end,o,{contentOnly:!0,storeName:!0}),s&&n.prependRight(this.start,`${this.name}: `)),o==="eval"&&a===so&&i&&n.appendRight(this.start,"0, ")}}applyDeoptimizations(){this.deoptimized=!0,this.variable instanceof dt&&(this.variable.consolidateInitializers(),this.context.requestTreeshakingPass())}disallowImportReassignment(){return this.context.error(Qs(this.name,this.context.module.id),this.start)}getVariableRespectingTDZ(){return this.isPossibleTDZ()?X:this.variable}isPureFunction(n){let e=this.context.manualPureFunctions[this.name];for(const r of n){if(!e)return!1;if(e[si])return!0;e=e[r]}return e==null?void 0:e[si]}}function jo(t){for(;t&&!/^Program|Function/.test(t.type);)t=t.parent;return t}function _i(t,n,e,r){if(n.remove(e,r),t.annotations)for(const a of t.annotations){if(!(a.start<e))return;n.remove(a.start,a.end)}}function Mo(t,n){if(t.annotations||t.parent.type!==Vn||(t=t.parent),t.annotations)for(const e of t.annotations)n.remove(e.start,e.end)}const Ut={isNoStatement:!0};function kn(t,n,e=0){let r,a;for(r=t.indexOf(n,e);;){if((e=t.indexOf("/",e))===-1||e>=r)return r;a=t.charCodeAt(++e),++e,(e=a===47?t.indexOf(`
`,e)+1:t.indexOf("*/",e)+2)>r&&(r=t.indexOf(n,e))}}const Lo=/\S/g;function Et(t,n){return Lo.lastIndex=n,Lo.exec(t).index}function Oe(t){let n,e,r=0;for(n=t.indexOf(`
`,r);;){if(r=t.indexOf("/",r),r===-1||r>n)return[n,n+1];if(e=t.charCodeAt(r+1),e===47)return[r,n+1];r=t.indexOf("*/",r+3)+2,r>n&&(n=t.indexOf(`
`,r))}}function ze(t,n,e,r,a){let i,s,o,l,c=t[0],u=!c.included||c.needsBoundaries;u&&(l=e+Oe(n.original.slice(e,c.start))[1]);for(let f=1;f<=t.length;f++)i=c,s=l,o=u,c=t[f],u=c!==void 0&&(!c.included||c.needsBoundaries),o||u?(l=i.end+Oe(n.original.slice(i.end,c===void 0?r:c.start))[1],i.included?o?i.render(n,a,{end:l,start:s}):i.render(n,a):_i(i,n,s,l)):i.render(n,a)}function To(t,n,e,r){const a=[];let i,s,o,l,c=e-1;for(const u of t){for(i!==void 0&&(c=i.end+kn(n.original.slice(i.end,u.start),",")),s=o=c+1+Oe(n.original.slice(c+1,u.start))[1];l=n.original.charCodeAt(s),l===32||l===9||l===10||l===13;)s++;i!==void 0&&a.push({contentEnd:o,end:s,node:i,separator:c,start:e}),i=u,e=s}return a.push({contentEnd:r,end:r,node:i,separator:null,start:e}),a}function Tr(t,n,e){for(;;){const[r,a]=Oe(t.original.slice(n,e));if(r===-1)break;t.remove(n+r,n+=a)}}class Rt extends Yn{addDeclaration(n,e,r,a){if(a){const i=this.parent.addDeclaration(n,e,r,a);return i.markInitializersForDeoptimization(),i}return super.addDeclaration(n,e,r,!1)}}class Vt extends O{initialise(){var n,e;this.directive&&this.directive!=="use strict"&&this.parent.type===Er&&this.context.log(V,(n=this.directive,{code:"MODULE_LEVEL_DIRECTIVE",id:e=this.context.module.id,message:`Module level directives cause errors when bundled, "${n}" in "${W(e)}" was ignored.`}),this.start)}render(n,e){super.render(n,e),this.included&&this.insertSemicolon(n)}shouldBeIncluded(n){return this.directive&&this.directive!=="use strict"?this.parent.type!==Er:super.shouldBeIncluded(n)}applyDeoptimizations(){}}class Nr extends O{constructor(){super(...arguments),this.directlyIncluded=!1}addImplicitReturnExpressionToScope(){const n=this.body[this.body.length-1];n&&n.type==="ReturnStatement"||this.scope.addReturnExpression(X)}createScope(n){this.scope=this.parent.preventChildBlockScope?n:new Rt(n)}hasEffects(n){if(this.deoptimizeBody)return!0;for(const e of this.body){if(n.brokenFlow)break;if(e.hasEffects(n))return!0}return!1}include(n,e){if(!this.deoptimizeBody||!this.directlyIncluded){this.included=!0,this.directlyIncluded=!0,this.deoptimizeBody&&(e=!0);for(const r of this.body)(e||r.shouldBeIncluded(n))&&r.include(n,e)}}initialise(){const n=this.body[0];this.deoptimizeBody=n instanceof Vt&&n.directive==="use asm"}render(n,e){this.body.length>0?ze(this.body,n,this.start+1,this.end-1,e):super.render(n,e)}}class ui extends O{constructor(){super(...arguments),this.declarationInit=null}addExportedVariables(n,e){this.argument.addExportedVariables(n,e)}declare(n,e){return this.declarationInit=e,this.argument.declare(n,X)}deoptimizePath(n){n.length===0&&this.argument.deoptimizePath(q)}hasEffectsOnInteractionAtPath(n,e,r){return n.length>0||this.argument.hasEffectsOnInteractionAtPath(q,e,r)}markDeclarationReached(){this.argument.markDeclarationReached()}applyDeoptimizations(){this.deoptimized=!0,this.declarationInit!==null&&(this.declarationInit.deoptimizePath([on,on]),this.context.requestTreeshakingPass())}}class fi extends O{constructor(){super(...arguments),this.objectEntity=null,this.deoptimizedReturn=!1}deoptimizeArgumentsOnInteractionAtPath(n,e,r){if(n.type===2){const{parameters:a}=this.scope,{args:i}=n;let s=!1;for(let o=0;o<i.length-1;o++){const l=this.params[o],c=i[o+1];s||l instanceof ui?(s=!0,c.deoptimizePath(nn)):l instanceof _n?(a[o][0].addEntityToBeDeoptimized(c),this.addArgumentToBeDeoptimized(c)):l?c.deoptimizePath(nn):this.addArgumentToBeDeoptimized(c)}}else this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizePath(n){this.getObjectEntity().deoptimizePath(n),n.length===1&&n[0]===on&&this.scope.getReturnExpression().deoptimizePath(nn)}getLiteralValueAtPath(n,e,r){return this.getObjectEntity().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return n.length>0?this.getObjectEntity().getReturnExpressionWhenCalledAtPath(n,e,r,a):this.async?(this.deoptimizedReturn||(this.deoptimizedReturn=!0,this.scope.getReturnExpression().deoptimizePath(nn),this.context.requestTreeshakingPass()),gn):[this.scope.getReturnExpression(),!1]}hasEffectsOnInteractionAtPath(n,e,r){if(n.length>0||e.type!==2)return this.getObjectEntity().hasEffectsOnInteractionAtPath(n,e,r);if(this.annotationNoSideEffects)return!1;if(this.async){const{propertyReadSideEffects:a}=this.context.options.treeshake,i=this.scope.getReturnExpression();if(i.hasEffectsOnInteractionAtPath(["then"],gr,r)||a&&(a==="always"||i.hasEffectsOnInteractionAtPath(["then"],Da,r)))return!0}for(const a of this.params)if(a.hasEffects(r))return!0;return!1}include(n,e){this.deoptimized||this.applyDeoptimizations(),this.included=!0;const{brokenFlow:r}=n;n.brokenFlow=!1,this.body.include(n,e),n.brokenFlow=r}includeCallArguments(n,e){this.scope.includeCallArguments(n,e)}initialise(){this.scope.addParameterVariables(this.params.map(n=>n.declare("parameter",X)),this.params[this.params.length-1]instanceof ui),this.body instanceof Nr?this.body.addImplicitReturnExpressionToScope():this.scope.addReturnExpression(this.body)}parseNode(n){n.body.type===io&&(this.body=new Nr(n.body,this,this.scope.hoistedBodyVarScope)),super.parseNode(n)}addArgumentToBeDeoptimized(n){}applyDeoptimizations(){}}fi.prototype.preventChildBlockScope=!0;class mi extends fi{constructor(){super(...arguments),this.objectEntity=null}createScope(n){this.scope=new So(n,this.context)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!1}hasEffectsOnInteractionAtPath(n,e,r){if(super.hasEffectsOnInteractionAtPath(n,e,r))return!0;if(this.annotationNoSideEffects)return!1;if(e.type===2){const{ignore:a,brokenFlow:i}=r;if(r.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0,this:!1},this.body.hasEffects(r))return!0;r.ignore=a,r.brokenFlow=i}return!1}include(n,e){super.include(n,e);for(const r of this.params)r instanceof _n||r.include(n,e)}getObjectEntity(){return this.objectEntity!==null?this.objectEntity:this.objectEntity=new Fn([],kt)}}function qt(t,{exportNamesByVariable:n,snippets:{_:e,getObject:r,getPropertyAccess:a}},i=""){if(t.length===1&&n.get(t[0]).length===1){const s=t[0];return`exports('${n.get(s)}',${e}${s.getName(a)}${i})`}{const s=[];for(const o of t)for(const l of n.get(o))s.push([l,o.getName(a)+i]);return`exports(${r(s,{lineBreakIndent:null})})`}}function di(t,n,e,r,{exportNamesByVariable:a,snippets:{_:i}}){r.prependRight(n,`exports('${a.get(t)}',${i}`),r.appendLeft(e,")")}function No(t,n,e,r,a,i){const{_:s,getPropertyAccess:o}=i.snippets;a.appendLeft(e,`,${s}${qt([t],i)},${s}${t.getName(o)}`),r&&(a.prependRight(n,"("),a.appendLeft(e,")"))}class Ge extends O{addExportedVariables(n,e){for(const r of this.properties)r.type==="Property"?r.value.addExportedVariables(n,e):r.argument.addExportedVariables(n,e)}declare(n,e){const r=[];for(const a of this.properties)r.push(...a.declare(n,e));return r}deoptimizePath(n){if(n.length===0)for(const e of this.properties)e.deoptimizePath(n)}hasEffectsOnInteractionAtPath(n,e,r){for(const a of this.properties)if(a.hasEffectsOnInteractionAtPath(q,e,r))return!0;return!1}markDeclarationReached(){for(const n of this.properties)n.markDeclarationReached()}}class Zd extends dt{constructor(n){super("arguments",null,X,n),this.deoptimizedArguments=[]}addArgumentToBeDeoptimized(n){this.included?n.deoptimizePath(nn):this.deoptimizedArguments.push(n)}hasEffectsOnInteractionAtPath(n,{type:e}){return e!==0||n.length>1}include(){super.include();for(const n of this.deoptimizedArguments)n.deoptimizePath(nn);this.deoptimizedArguments.length=0}}class Do extends Co{constructor(n){super("this",null,n)}hasEffectsOnInteractionAtPath(n,e,r){return(r.replacedVariableInits.get(this)||X).hasEffectsOnInteractionAtPath(n,e,r)}}class Qd extends So{constructor(n,e){super(n,e),this.variables.set("arguments",this.argumentsVariable=new Zd(e)),this.variables.set("this",this.thisVariable=new Do(e))}findLexicalBoundary(){return this}includeCallArguments(n,e){if(super.includeCallArguments(n,e),this.argumentsVariable.included)for(const r of e)r.included||r.include(n,!1)}}class pi extends fi{constructor(){super(...arguments),this.objectEntity=null}createScope(n){this.scope=new Qd(n,this.context),this.constructedEntity=new Fn(Object.create(null),kt),this.scope.thisVariable.addEntityToBeDeoptimized(this.constructedEntity)}deoptimizeArgumentsOnInteractionAtPath(n,e,r){super.deoptimizeArgumentsOnInteractionAtPath(n,e,r),n.type===2&&e.length===0&&n.args[0]&&this.scope.thisVariable.addEntityToBeDeoptimized(n.args[0])}hasEffects(n){var e;return this.deoptimized||this.applyDeoptimizations(),!this.annotationNoSideEffects&&!!((e=this.id)!=null&&e.hasEffects(n))}hasEffectsOnInteractionAtPath(n,e,r){if(super.hasEffectsOnInteractionAtPath(n,e,r))return!0;if(this.annotationNoSideEffects)return!1;if(e.type===2){const a=r.replacedVariableInits.get(this.scope.thisVariable);r.replacedVariableInits.set(this.scope.thisVariable,e.withNew?this.constructedEntity:X);const{brokenFlow:i,ignore:s,replacedVariableInits:o}=r;if(r.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0,this:e.withNew},this.body.hasEffects(r))return!0;r.brokenFlow=i,a?o.set(this.scope.thisVariable,a):o.delete(this.scope.thisVariable),r.ignore=s}return!1}include(n,e){var a;super.include(n,e),(a=this.id)==null||a.include();const r=this.scope.argumentsVariable.included;for(const i of this.params)i instanceof _n&&!r||i.include(n,e)}initialise(){var n;super.initialise(),(n=this.id)==null||n.declare("function",this)}addArgumentToBeDeoptimized(n){this.scope.argumentsVariable.addArgumentToBeDeoptimized(n)}getObjectEntity(){return this.objectEntity!==null?this.objectEntity:this.objectEntity=new Fn([{key:"prototype",kind:"init",property:new Fn([],kt)}],kt)}}class Oo extends O{hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(n,e){if(this.deoptimized||this.applyDeoptimizations(),!this.included){this.included=!0;n:if(!this.context.usesTopLevelAwait){let r=this.parent;do if(r instanceof pi||r instanceof mi)break n;while(r=r.parent);this.context.usesTopLevelAwait=!0}}this.argument.include(n,e)}}const np={"!=":(t,n)=>t!=n,"!==":(t,n)=>t!==n,"%":(t,n)=>t%n,"&":(t,n)=>t&n,"*":(t,n)=>t*n,"**":(t,n)=>t**n,"+":(t,n)=>t+n,"-":(t,n)=>t-n,"/":(t,n)=>t/n,"<":(t,n)=>t<n,"<<":(t,n)=>t<<n,"<=":(t,n)=>t<=n,"==":(t,n)=>t==n,"===":(t,n)=>t===n,">":(t,n)=>t>n,">=":(t,n)=>t>=n,">>":(t,n)=>t>>n,">>>":(t,n)=>t>>>n,"^":(t,n)=>t^n,"|":(t,n)=>t|n};function zo(t,n,e){if(e.arguments.length>0)if(e.arguments[e.arguments.length-1].included)for(const r of e.arguments)r.render(t,n);else{let r=e.arguments.length-2;for(;r>=0&&!e.arguments[r].included;)r--;if(r>=0){for(let a=0;a<=r;a++)e.arguments[a].render(t,n);t.remove(kn(t.original,",",e.arguments[r].end),e.end-1)}else t.remove(kn(t.original,"(",e.callee.end)+1,e.end-1)}}class Xt extends O{deoptimizeArgumentsOnInteractionAtPath(){}getLiteralValueAtPath(n){return n.length>0||this.value===null&&this.context.code.charCodeAt(this.start)!==110||typeof this.value=="bigint"||this.context.code.charCodeAt(this.start)===47?mn:this.value}getReturnExpressionWhenCalledAtPath(n){return n.length!==1?gn:Me(this.members,n[0])}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return n.length>(this.value===null?0:1);case 1:return!0;case 2:return!!(this.included&&this.value instanceof RegExp&&(this.value.global||this.value.sticky))||n.length!==1||je(this.members,n[0],e,r)}}initialise(){this.members=function(n){if(n instanceof RegExp)return Sd;switch(typeof n){case"boolean":return Ya;case"number":return Ja;case"string":return Ie}return Object.create(null)}(this.value)}parseNode(n){this.value=n.value,this.regex=n.regex,super.parseNode(n)}render(n){typeof this.value=="string"&&n.indentExclusionRanges.push([this.start+1,this.end-1])}}function tp(t){return t.computed?function(n){return n instanceof Xt?String(n.value):null}(t.property):t.property.name}function Go(t){const n=t.propertyKey,e=t.object;if(typeof n=="string"){if(e instanceof _n)return[{key:e.name,pos:e.start},{key:n,pos:t.property.start}];if(e instanceof At){const r=Go(e);return r&&[...r,{key:n,pos:t.property.start}]}}return null}class At extends O{constructor(){super(...arguments),this.variable=null,this.assignmentDeoptimized=!1,this.bound=!1,this.expressionsToBeDeoptimized=[],this.isUndefined=!1}bind(){this.bound=!0;const n=Go(this),e=n&&this.scope.findVariable(n[0].key);if(e!=null&&e.isNamespace){const r=Fo(e,n.slice(1),this.context);r?r==="undefined"?this.isUndefined=!0:(this.variable=r,this.scope.addNamespaceMemberAccess(function(a){let i=a[0].key;for(let s=1;s<a.length;s++)i+="."+a[s].key;return i}(n),r)):super.bind()}else super.bind()}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.variable?this.variable.deoptimizeArgumentsOnInteractionAtPath(n,e,r):this.isUndefined||(e.length<7?this.object.deoptimizeArgumentsOnInteractionAtPath(n,[this.getPropertyKey(),...e],r):vt(n))}deoptimizeCache(){const{expressionsToBeDeoptimized:n,object:e}=this;this.expressionsToBeDeoptimized=yn,this.propertyKey=on,e.deoptimizePath(nn);for(const r of n)r.deoptimizeCache()}deoptimizePath(n){if(n.length===0&&this.disallowNamespaceReassignment(),this.variable)this.variable.deoptimizePath(n);else if(!this.isUndefined&&n.length<7){const e=this.getPropertyKey();this.object.deoptimizePath([e===on?hr:e,...n])}}getLiteralValueAtPath(n,e,r){return this.variable?this.variable.getLiteralValueAtPath(n,e,r):this.isUndefined?void 0:this.propertyKey!==on&&n.length<7?(this.expressionsToBeDeoptimized.push(r),this.object.getLiteralValueAtPath([this.getPropertyKey(),...n],e,r)):mn}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.variable?this.variable.getReturnExpressionWhenCalledAtPath(n,e,r,a):this.isUndefined?[ie,!1]:this.propertyKey!==on&&n.length<7?(this.expressionsToBeDeoptimized.push(a),this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(),...n],e,r,a)):gn}hasEffects(n){return this.deoptimized||this.applyDeoptimizations(),this.property.hasEffects(n)||this.object.hasEffects(n)||this.hasAccessEffect(n)}hasEffectsAsAssignmentTarget(n,e){return e&&!this.deoptimized&&this.applyDeoptimizations(),this.assignmentDeoptimized||this.applyAssignmentDeoptimization(),this.property.hasEffects(n)||this.object.hasEffects(n)||e&&this.hasAccessEffect(n)||this.hasEffectsOnInteractionAtPath(q,this.assignmentInteraction,n)}hasEffectsOnInteractionAtPath(n,e,r){return this.variable?this.variable.hasEffectsOnInteractionAtPath(n,e,r):!!this.isUndefined||!(n.length<7)||this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey(),...n],e,r)}include(n,e){this.deoptimized||this.applyDeoptimizations(),this.includeProperties(n,e)}includeAsAssignmentTarget(n,e,r){this.assignmentDeoptimized||this.applyAssignmentDeoptimization(),r?this.include(n,e):this.includeProperties(n,e)}includeCallArguments(n,e){this.variable?this.variable.includeCallArguments(n,e):super.includeCallArguments(n,e)}initialise(){this.propertyKey=tp(this),this.accessInteraction={args:[this.object],type:0}}isSkippedAsOptional(n){var e,r;return!this.variable&&!this.isUndefined&&(((r=(e=this.object).isSkippedAsOptional)==null?void 0:r.call(e,n))||this.optional&&this.object.getLiteralValueAtPath(q,vn,n)==null)}render(n,e,{renderedParentType:r,isCalleeOfRenderedParent:a,renderedSurroundingElement:i}=Bn){if(this.variable||this.isUndefined){const{snippets:{getPropertyAccess:s}}=e;let o=this.variable?this.variable.getName(s):"undefined";r&&a&&(o="0, "+o),n.overwrite(this.start,this.end,o,{contentOnly:!0,storeName:!0})}else r&&a&&n.appendRight(this.start,"0, "),this.object.render(n,e,{renderedSurroundingElement:i}),this.property.render(n,e)}setAssignedValue(n){this.assignmentInteraction={args:[this.object,n],type:1}}applyDeoptimizations(){this.deoptimized=!0;const{propertyReadSideEffects:n}=this.context.options.treeshake;if(this.bound&&n&&!this.variable&&!this.isUndefined){const e=this.getPropertyKey();this.object.deoptimizeArgumentsOnInteractionAtPath(this.accessInteraction,[e],vn),this.context.requestTreeshakingPass()}}applyAssignmentDeoptimization(){this.assignmentDeoptimized=!0;const{propertyReadSideEffects:n}=this.context.options.treeshake;this.bound&&n&&!this.variable&&!this.isUndefined&&(this.object.deoptimizeArgumentsOnInteractionAtPath(this.assignmentInteraction,[this.getPropertyKey()],vn),this.context.requestTreeshakingPass())}disallowNamespaceReassignment(){this.object instanceof _n&&this.scope.findVariable(this.object.name).isNamespace&&(this.variable&&this.context.includeVariableInModule(this.variable),this.context.log(V,Qs(this.object.name,this.context.module.id),this.start))}getPropertyKey(){if(this.propertyKey===null){this.propertyKey=on;const n=this.property.getLiteralValueAtPath(q,vn,this);return this.propertyKey=n===Ta?n:typeof n=="symbol"?on:String(n)}return this.propertyKey}hasAccessEffect(n){const{propertyReadSideEffects:e}=this.context.options.treeshake;return!(this.variable||this.isUndefined)&&e&&(e==="always"||this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey()],this.accessInteraction,n))}includeProperties(n,e){this.included||(this.included=!0,this.variable&&this.context.includeVariableInModule(this.variable)),this.object.include(n,e),this.property.include(n,e)}}function Fo(t,n,e){if(n.length===0)return t;if(!t.isNamespace||t instanceof yr)return null;const r=n[0].key,a=t.context.traceExport(r);if(!a){if(n.length===1){const i=t.context.fileName;return e.log(V,$r(r,e.module.id,i),n[0].pos),"undefined"}return null}return Fo(a,n.slice(1),e)}class Po extends O{constructor(){super(...arguments),this.returnExpression=null,this.deoptimizableDependentExpressions=[],this.expressionsToBeDeoptimized=new Set}deoptimizeArgumentsOnInteractionAtPath(n,e,r){const{args:a}=n,[i,s]=this.getReturnExpression(r);if(s)return;const o=a.filter(l=>!!l&&l!==X);if(o.length!==0)if(i===X)for(const l of o)l.deoptimizePath(nn);else r.withTrackedEntityAtPath(e,i,()=>{for(const l of o)this.expressionsToBeDeoptimized.add(l);i.deoptimizeArgumentsOnInteractionAtPath(n,e,r)},null)}deoptimizeCache(){var n;if(((n=this.returnExpression)==null?void 0:n[0])!==X){this.returnExpression=gn;const{deoptimizableDependentExpressions:e,expressionsToBeDeoptimized:r}=this;this.expressionsToBeDeoptimized=Ns,this.deoptimizableDependentExpressions=yn;for(const a of e)a.deoptimizeCache();for(const a of r)a.deoptimizePath(nn)}}deoptimizePath(n){if(n.length===0||this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(n,this))return;const[e]=this.getReturnExpression();e!==X&&e.deoptimizePath(n)}getLiteralValueAtPath(n,e,r){const[a]=this.getReturnExpression(e);return a===X?mn:e.withTrackedEntityAtPath(n,a,()=>(this.deoptimizableDependentExpressions.push(r),a.getLiteralValueAtPath(n,e,r)),mn)}getReturnExpressionWhenCalledAtPath(n,e,r,a){const i=this.getReturnExpression(r);return i[0]===X?i:r.withTrackedEntityAtPath(n,i,()=>{this.deoptimizableDependentExpressions.push(a);const[s,o]=i[0].getReturnExpressionWhenCalledAtPath(n,e,r,a);return[s,o||i[1]]},gn)}hasEffectsOnInteractionAtPath(n,e,r){const{type:a}=e;if(a===2){const{args:o,withNew:l}=e;if((l?r.instantiated:r.called).trackEntityAtPathAndGetIfTracked(n,o,this))return!1}else if((a===1?r.assigned:r.accessed).trackEntityAtPathAndGetIfTracked(n,this))return!1;const[i,s]=this.getReturnExpression();return(a===1||!s)&&i.hasEffectsOnInteractionAtPath(n,e,r)}}class Uo extends Po{bind(){super.bind(),this.callee instanceof _n&&(this.scope.findVariable(this.callee.name).isNamespace&&this.context.log(V,Zs(this.callee.name),this.start),this.callee.name==="eval"&&this.context.log(V,{code:"EVAL",id:n=this.context.module.id,message:`Use of eval in "${W(n)}" is strongly discouraged as it poses security risks and may cause issues with minification.`,url:En("troubleshooting/#avoiding-eval")},this.start));var n;this.interaction={args:[this.callee instanceof At&&!this.callee.variable?this.callee.object:null,...this.arguments],type:2,withNew:!1}}hasEffects(n){try{for(const e of this.arguments)if(e.hasEffects(n))return!0;return!this.annotationPure&&(this.callee.hasEffects(n)||this.callee.hasEffectsOnInteractionAtPath(q,this.interaction,n))}finally{this.deoptimized||this.applyDeoptimizations()}}include(n,e){this.deoptimized||this.applyDeoptimizations(),e?(super.include(n,e),e===uo&&this.callee instanceof _n&&this.callee.variable&&this.callee.variable.markCalledFromTryStatement()):(this.included=!0,this.callee.include(n,!1)),this.callee.includeCallArguments(n,this.arguments)}isSkippedAsOptional(n){var e,r;return((r=(e=this.callee).isSkippedAsOptional)==null?void 0:r.call(e,n))||this.optional&&this.callee.getLiteralValueAtPath(q,vn,n)==null}render(n,e,{renderedSurroundingElement:r}=Bn){this.callee.render(n,e,{isCalleeOfRenderedParent:!0,renderedSurroundingElement:r}),zo(n,e,this)}applyDeoptimizations(){this.deoptimized=!0,this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction,q,vn),this.context.requestTreeshakingPass()}getReturnExpression(n=vn){return this.returnExpression===null?(this.returnExpression=gn,this.returnExpression=this.callee.getReturnExpressionWhenCalledAtPath(q,this.interaction,n,this)):this.returnExpression}}class ep extends wo{addDeclaration(n,e,r,a){const i=this.variables.get(n.name);return i?(this.parent.addDeclaration(n,e,ie,a),i.addDeclaration(n,r),i):this.parent.addDeclaration(n,e,r,a)}}class rp extends Yn{constructor(n,e,r){super(n),this.variables.set("this",this.thisVariable=new dt("this",null,e,r)),this.instanceScope=new Yn(this),this.instanceScope.variables.set("this",new Do(r))}findLexicalBoundary(){return this}}class Ro extends O{constructor(){super(...arguments),this.accessedValue=null}deoptimizeArgumentsOnInteractionAtPath(n,e,r){return n.type===0&&this.kind==="get"&&e.length===0||n.type===1&&this.kind==="set"&&e.length===0?this.value.deoptimizeArgumentsOnInteractionAtPath({args:n.args,type:2,withNew:!1},q,r):void this.getAccessedValue()[0].deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizeCache(){}deoptimizePath(n){this.getAccessedValue()[0].deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getAccessedValue()[0].getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(n,e,r,a)}hasEffects(n){return this.key.hasEffects(n)}hasEffectsOnInteractionAtPath(n,e,r){return this.kind==="get"&&e.type===0&&n.length===0||this.kind==="set"&&e.type===1?this.value.hasEffectsOnInteractionAtPath(q,{args:e.args,type:2,withNew:!1},r):this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(n,e,r)}applyDeoptimizations(){}getAccessedValue(){return this.accessedValue===null?this.kind==="get"?(this.accessedValue=gn,this.accessedValue=this.value.getReturnExpressionWhenCalledAtPath(q,gr,vn,this)):this.accessedValue=[this.value,!1]:this.accessedValue}}class hi extends Ro{applyDeoptimizations(){}}class ap extends Rn{constructor(n,e){super(),this.object=n,this.key=e}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.object.deoptimizeArgumentsOnInteractionAtPath(n,[this.key,...e],r)}deoptimizePath(n){this.object.deoptimizePath([this.key,...n])}getLiteralValueAtPath(n,e,r){return this.object.getLiteralValueAtPath([this.key,...n],e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.object.getReturnExpressionWhenCalledAtPath([this.key,...n],e,r,a)}hasEffectsOnInteractionAtPath(n,e,r){return this.object.hasEffectsOnInteractionAtPath([this.key,...n],e,r)}}class Vo extends O{constructor(){super(...arguments),this.objectEntity=null}createScope(n){this.scope=new Yn(n)}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(n){this.getObjectEntity().deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getObjectEntity().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(n,e,r,a)}hasEffects(n){var r,a;this.deoptimized||this.applyDeoptimizations();const e=((r=this.superClass)==null?void 0:r.hasEffects(n))||this.body.hasEffects(n);return(a=this.id)==null||a.markDeclarationReached(),e||super.hasEffects(n)}hasEffectsOnInteractionAtPath(n,e,r){var a;return e.type===2&&n.length===0?!e.withNew||(this.classConstructor===null?(a=this.superClass)==null?void 0:a.hasEffectsOnInteractionAtPath(n,e,r):this.classConstructor.hasEffectsOnInteractionAtPath(n,e,r))||!1:this.getObjectEntity().hasEffectsOnInteractionAtPath(n,e,r)}include(n,e){var r;this.deoptimized||this.applyDeoptimizations(),this.included=!0,(r=this.superClass)==null||r.include(n,e),this.body.include(n,e),this.id&&(this.id.markDeclarationReached(),this.id.include())}initialise(){var n;(n=this.id)==null||n.declare("class",this);for(const e of this.body.body)if(e instanceof hi&&e.kind==="constructor")return void(this.classConstructor=e);this.classConstructor=null}applyDeoptimizations(){this.deoptimized=!0;for(const n of this.body.body)n.static||n instanceof hi&&n.kind==="constructor"||n.deoptimizePath(nn);this.context.requestTreeshakingPass()}getObjectEntity(){if(this.objectEntity!==null)return this.objectEntity;const n=[],e=[];for(const r of this.body.body){const a=r.static?n:e,i=r.kind;if(a===e&&!i)continue;const s=i==="set"||i==="get"?i:"init";let o;if(r.computed){const l=r.key.getLiteralValueAtPath(q,vn,this);if(typeof l=="symbol"){a.push({key:on,kind:s,property:r});continue}o=String(l)}else o=r.key instanceof _n?r.key.name:String(r.key.value);a.push({key:o,kind:s,property:r})}return n.unshift({key:"prototype",kind:"init",property:new Fn(e,this.superClass?new ap(this.superClass,"prototype"):kt)}),this.objectEntity=new Fn(n,this.superClass||kt)}}class Dr extends Vo{initialise(){super.initialise(),this.id!==null&&(this.id.variable.isId=!0)}parseNode(n){n.id!==null&&(this.id=new _n(n.id,this,this.scope.parent)),super.parseNode(n)}render(n,e){var o;const{exportNamesByVariable:r,format:a,snippets:{_:i,getPropertyAccess:s}}=e;if(this.id){const{variable:l,name:c}=this.id;a==="system"&&r.has(l)&&n.appendLeft(this.end,`${i}${qt([l],e)};`);const u=l.getName(s);if(u!==c)return(o=this.superClass)==null||o.render(n,e),this.body.render(n,{...e,useOriginalName:f=>f===l}),n.prependRight(this.start,`let ${u}${i}=${i}`),void n.prependLeft(this.end,";")}super.render(n,e)}applyDeoptimizations(){super.applyDeoptimizations();const{id:n,scope:e}=this;if(n){const{name:r,variable:a}=n;for(const i of e.accessedOutsideVariables.values())i!==a&&i.forbidName(r)}}}class gi extends Vo{render(n,e,{renderedSurroundingElement:r}=Bn){super.render(n,e),r===Vn&&(n.appendRight(this.start,"("),n.prependLeft(this.end,")"))}}class Or extends Rn{constructor(n){super(),this.expressions=n,this.included=!1}deoptimizePath(n){for(const e of this.expressions)e.deoptimizePath(n)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return[new Or(this.expressions.map(i=>i.getReturnExpressionWhenCalledAtPath(n,e,r,a)[0])),!1]}hasEffectsOnInteractionAtPath(n,e,r){for(const a of this.expressions)if(a.hasEffectsOnInteractionAtPath(n,e,r))return!0;return!1}}function zr(t,n){const{brokenFlow:e,hasBreak:r,hasContinue:a,ignore:i}=t,{breaks:s,continues:o}=i;return i.breaks=!0,i.continues=!0,t.hasBreak=!1,t.hasContinue=!1,!!n.hasEffects(t)||(i.breaks=s,i.continues=o,t.hasBreak=r,t.hasContinue=a,t.brokenFlow=e,!1)}function Fe(t,n,e){const{brokenFlow:r,hasBreak:a,hasContinue:i}=t;t.hasBreak=!1,t.hasContinue=!1,n.include(t,e,{asSingleStatement:!0}),t.hasBreak=a,t.hasContinue=i,t.brokenFlow=r}class yi extends O{hasEffects(){return!1}initialise(){this.context.addExport(this)}render(n,e,r){n.remove(r.start,r.end)}applyDeoptimizations(){}}yi.prototype.needsBoundaries=!0;class Pe extends pi{initialise(){super.initialise(),this.id!==null&&(this.id.variable.isId=!0)}parseNode(n){n.id!==null&&(this.id=new _n(n.id,this,this.scope.parent)),super.parseNode(n)}}class Gr extends O{include(n,e){super.include(n,e),e&&this.context.includeVariableInModule(this.variable)}initialise(){const n=this.declaration;this.declarationName=n.id&&n.id.name||this.declaration.name,this.variable=this.scope.addExportDefaultDeclaration(this.declarationName||this.context.getModuleName(),this,this.context),this.context.addExport(this)}render(n,e,r){const{start:a,end:i}=r,s=function(o,l){return Et(o,kn(o,"default",l)+7)}(n.original,this.start);if(this.declaration instanceof Pe)this.renderNamedDeclaration(n,s,this.declaration.id===null?function(o,l){const c=kn(o,"function",l)+8;o=o.slice(c,kn(o,"(",c));const u=kn(o,"*");return u===-1?c:c+u+1}(n.original,s):null,e);else if(this.declaration instanceof Dr)this.renderNamedDeclaration(n,s,this.declaration.id===null?kn(n.original,"class",a)+5:null,e);else{if(this.variable.getOriginalVariable()!==this.variable)return void _i(this,n,a,i);if(!this.variable.included)return n.remove(this.start,s),this.declaration.render(n,e,{renderedSurroundingElement:Vn}),void(n.original[this.end-1]!==";"&&n.appendLeft(this.end,";"));this.renderVariableDeclaration(n,s,e)}this.declaration.render(n,e)}applyDeoptimizations(){}renderNamedDeclaration(n,e,r,a){const{exportNamesByVariable:i,format:s,snippets:{getPropertyAccess:o}}=a,l=this.variable.getName(o);n.remove(this.start,e),r!==null&&n.appendLeft(r,` ${l}`),s==="system"&&this.declaration instanceof Dr&&i.has(this.variable)&&n.appendLeft(this.end,` ${qt([this.variable],a)};`)}renderVariableDeclaration(n,e,{format:r,exportNamesByVariable:a,snippets:{cnst:i,getPropertyAccess:s}}){const o=n.original.charCodeAt(this.end-1)===59,l=r==="system"&&a.get(this.variable);l?(n.overwrite(this.start,e,`${i} ${this.variable.getName(s)} = exports('${l[0]}', `),n.appendRight(o?this.end-1:this.end,")"+(o?"":";"))):(n.overwrite(this.start,e,`${i} ${this.variable.getName(s)} = `),o||n.appendLeft(this.end,";"))}}Gr.prototype.needsBoundaries=!0;class qo extends O{bind(){var n;(n=this.declaration)==null||n.bind()}hasEffects(n){var e;return!!((e=this.declaration)!=null&&e.hasEffects(n))}initialise(){this.context.addExport(this)}render(n,e,r){const{start:a,end:i}=r;this.declaration===null?n.remove(a,i):(n.remove(this.start,this.declaration.start),this.declaration.render(n,e,{end:i,start:a}))}applyDeoptimizations(){}}qo.prototype.needsBoundaries=!0;class Xo extends pi{render(n,e,{renderedSurroundingElement:r}=Bn){super.render(n,e),r===Vn&&(n.appendRight(this.start,"("),n.prependLeft(this.end,")"))}}class Wo extends Rt{constructor(){super(...arguments),this.hoistedDeclarations=[]}addDeclaration(n,e,r,a){return this.hoistedDeclarations.push(n),super.addDeclaration(n,e,r,a)}}const Ko=Symbol("unset");class bi extends O{constructor(){super(...arguments),this.testValue=Ko}deoptimizeCache(){this.testValue=mn}hasEffects(n){var r;if(this.test.hasEffects(n))return!0;const e=this.getTestValue();if(typeof e=="symbol"){const{brokenFlow:a}=n;if(this.consequent.hasEffects(n))return!0;const i=n.brokenFlow;return n.brokenFlow=a,this.alternate===null?!1:!!this.alternate.hasEffects(n)||(n.brokenFlow=n.brokenFlow&&i,!1)}return e?this.consequent.hasEffects(n):!!((r=this.alternate)!=null&&r.hasEffects(n))}include(n,e){if(this.included=!0,e)this.includeRecursively(e,n);else{const r=this.getTestValue();typeof r=="symbol"?this.includeUnknownTest(n):this.includeKnownTest(n,r)}}parseNode(n){this.consequentScope=new Wo(this.scope),this.consequent=new(this.context.getNodeConstructor(n.consequent.type))(n.consequent,this,this.consequentScope),n.alternate&&(this.alternateScope=new Wo(this.scope),this.alternate=new(this.context.getNodeConstructor(n.alternate.type))(n.alternate,this,this.alternateScope)),super.parseNode(n)}render(n,e){const{snippets:{getPropertyAccess:r}}=e,a=this.getTestValue(),i=[],s=this.test.included,o=!this.context.options.treeshake;s?this.test.render(n,e):n.remove(this.start,this.consequent.start),this.consequent.included&&(o||typeof a=="symbol"||a)?this.consequent.render(n,e):(n.overwrite(this.consequent.start,this.consequent.end,s?";":""),i.push(...this.consequentScope.hoistedDeclarations)),this.alternate&&(!this.alternate.included||!o&&typeof a!="symbol"&&a?(s&&this.shouldKeepAlternateBranch()?n.overwrite(this.alternate.start,this.end,";"):n.remove(this.consequent.end,this.end),i.push(...this.alternateScope.hoistedDeclarations)):(s?n.original.charCodeAt(this.alternate.start-1)===101&&n.prependLeft(this.alternate.start," "):n.remove(this.consequent.end,this.alternate.start),this.alternate.render(n,e))),this.renderHoistedDeclarations(i,n,r)}applyDeoptimizations(){}getTestValue(){return this.testValue===Ko?this.testValue=this.test.getLiteralValueAtPath(q,vn,this):this.testValue}includeKnownTest(n,e){var r;this.test.shouldBeIncluded(n)&&this.test.include(n,!1),e&&this.consequent.shouldBeIncluded(n)&&this.consequent.include(n,!1,{asSingleStatement:!0}),!e&&((r=this.alternate)!=null&&r.shouldBeIncluded(n))&&this.alternate.include(n,!1,{asSingleStatement:!0})}includeRecursively(n,e){var r;this.test.include(e,n),this.consequent.include(e,n),(r=this.alternate)==null||r.include(e,n)}includeUnknownTest(n){var a;this.test.include(n,!1);const{brokenFlow:e}=n;let r=!1;this.consequent.shouldBeIncluded(n)&&(this.consequent.include(n,!1,{asSingleStatement:!0}),r=n.brokenFlow,n.brokenFlow=e),(a=this.alternate)!=null&&a.shouldBeIncluded(n)&&(this.alternate.include(n,!1,{asSingleStatement:!0}),n.brokenFlow=n.brokenFlow&&r)}renderHoistedDeclarations(n,e,r){const a=[...new Set(n.map(i=>{const s=i.variable;return s.included?s.getName(r):""}))].filter(Boolean).join(", ");if(a){const i=this.parent.type,s=i!==Er&&i!==io;e.prependRight(this.start,`${s?"{ ":""}var ${a}; `),s&&e.appendLeft(this.end," }")}}shouldKeepAlternateBranch(){let n=this.parent;do{if(n instanceof bi&&n.alternate)return!0;if(n instanceof Nr)return!1;n=n.parent}while(n);return!1}}class Ho extends O{bind(){}hasEffects(){return!1}initialise(){this.context.addImport(this)}render(n,e,r){n.remove(r.start,r.end)}applyDeoptimizations(){}}Ho.prototype.needsBoundaries=!0;class Yo extends O{applyDeoptimizations(){}}const xi="_interopDefault",vi="_interopDefaultCompat",Fr="_interopNamespace",Pr="_interopNamespaceCompat",Wt="_interopNamespaceDefault",Ue="_interopNamespaceDefaultOnly",Ur="_mergeNamespaces",Rr={auto:xi,compat:vi,default:null,defaultOnly:null,esModule:null},Vr=(t,n)=>t==="esModule"||n&&(t==="auto"||t==="compat"),Re={auto:Fr,compat:Pr,default:Wt,defaultOnly:Ue,esModule:null},ip=(t,n)=>t!=="esModule"&&Vr(t,n),$i=(t,n,e,r,a,i,s)=>{const o=new Set(t);for(const l of Ai)n.has(l)&&o.add(l);return Ai.map(l=>o.has(l)?Jo[l](e,r,a,i,s,o):"").join("")},Jo={[vi](t,n,e){const{_:r,getDirectReturnFunction:a,n:i}=n,[s,o]=a(["e"],{functionReturn:!0,lineBreakIndent:null,name:vi});return`${s}${ki(n)}${r}?${r}${e?Zo(n):Qo(n)}${o}${i}${i}`},[xi](t,n,e){const{_:r,getDirectReturnFunction:a,n:i}=n,[s,o]=a(["e"],{functionReturn:!0,lineBreakIndent:null,name:xi});return`${s}e${r}&&${r}e.__esModule${r}?${r}${e?Zo(n):Qo(n)}${o}${i}${i}`},[Pr](t,n,e,r,a,i){const{_:s,getDirectReturnFunction:o,n:l}=n;if(i.has(Wt)){const[c,u]=o(["e"],{functionReturn:!0,lineBreakIndent:null,name:Pr});return`${c}${ki(n)}${s}?${s}e${s}:${s}${Wt}(e)${u}${l}${l}`}return`function ${Pr}(e)${s}{${l}${t}if${s}(${ki(n)})${s}return e;${l}`+Ci(t,t,n,e,r,a)+`}${l}${l}`},[Ue](t,n,e,r,a){const{getDirectReturnFunction:i,getObject:s,n:o}=n,[l,c]=i(["e"],{functionReturn:!0,lineBreakIndent:null,name:Ue});return`${l}${Ei(r,el(a,s([["__proto__","null"],["default","e"]],{lineBreakIndent:null}),n))}${c}${o}${o}`},[Wt](t,n,e,r,a){const{_:i,n:s}=n;return`function ${Wt}(e)${i}{${s}`+Ci(t,t,n,e,r,a)+`}${s}${s}`},[Fr](t,n,e,r,a,i){const{_:s,getDirectReturnFunction:o,n:l}=n;if(i.has(Wt)){const[c,u]=o(["e"],{functionReturn:!0,lineBreakIndent:null,name:Fr});return`${c}e${s}&&${s}e.__esModule${s}?${s}e${s}:${s}${Wt}(e)${u}${l}${l}`}return`function ${Fr}(e)${s}{${l}${t}if${s}(e${s}&&${s}e.__esModule)${s}return e;${l}`+Ci(t,t,n,e,r,a)+`}${l}${l}`},[Ur](t,n,e,r,a){const{_:i,cnst:s,n:o}=n,l=s==="var"&&e;return`function ${Ur}(n, m)${i}{${o}${t}${op(`{${o}${t}${t}${t}if${i}(k${i}!==${i}'default'${i}&&${i}!(k in n))${i}{${o}`+(e?l?nl:cp:tl)(t,t+t+t+t,n)+`${t}${t}${t}}${o}${t}${t}}`,l,t,n)}${o}${t}return ${Ei(r,el(a,"n",n))};${o}}${o}${o}`}},Zo=({_:t,getObject:n})=>`e${t}:${t}${n([["default","e"]],{lineBreakIndent:null})}`,Qo=({_:t,getPropertyAccess:n})=>`e${n("default")}${t}:${t}e`,ki=({_:t})=>`e${t}&&${t}typeof e${t}===${t}'object'${t}&&${t}'default'${t}in e`,Ci=(t,n,e,r,a,i)=>{const{_:s,cnst:o,getObject:l,getPropertyAccess:c,n:u,s:f}=e,m=`{${u}`+(r?lp:tl)(t,n+t+t,e)+`${n}${t}}`;return`${n}${o} n${s}=${s}Object.create(null${i?`,${s}{${s}[Symbol.toStringTag]:${s}${Ve(l)}${s}}`:""});${u}${n}if${s}(e)${s}{${u}${n}${t}${sp(m,!r,e)}${u}${n}}${u}${n}n${c("default")}${s}=${s}e;${u}${n}return ${Ei(a,"n")}${f}${u}`},sp=(t,n,{_:e,cnst:r,getFunctionIntro:a,s:i})=>r!=="var"||n?`for${e}(${r} k in e)${e}${t}`:`Object.keys(e).forEach(${a(["k"],{isAsync:!1,name:null})}${t})${i}`,op=(t,n,e,{_:r,cnst:a,getDirectReturnFunction:i,getFunctionIntro:s,n:o})=>{if(n){const[l,c]=i(["e"],{functionReturn:!1,lineBreakIndent:{base:e,t:e},name:null});return`m.forEach(${l}e${r}&&${r}typeof e${r}!==${r}'string'${r}&&${r}!Array.isArray(e)${r}&&${r}Object.keys(e).forEach(${s(["k"],{isAsync:!1,name:null})}${t})${c});`}return`for${r}(var i${r}=${r}0;${r}i${r}<${r}m.length;${r}i++)${r}{${o}${e}${e}${a} e${r}=${r}m[i];${o}${e}${e}if${r}(typeof e${r}!==${r}'string'${r}&&${r}!Array.isArray(e))${r}{${r}for${r}(${a} k in e)${r}${t}${r}}${o}${e}}`},lp=(t,n,e)=>{const{_:r,n:a}=e;return`${n}if${r}(k${r}!==${r}'default')${r}{${a}`+nl(t,n+t,e)+`${n}}${a}`},nl=(t,n,{_:e,cnst:r,getDirectReturnFunction:a,n:i})=>{const[s,o]=a([],{functionReturn:!0,lineBreakIndent:null,name:null});return`${n}${r} d${e}=${e}Object.getOwnPropertyDescriptor(e,${e}k);${i}${n}Object.defineProperty(n,${e}k,${e}d.get${e}?${e}d${e}:${e}{${i}${n}${t}enumerable:${e}true,${i}${n}${t}get:${e}${s}e[k]${o}${i}${n}});${i}`},cp=(t,n,{_:e,cnst:r,getDirectReturnFunction:a,n:i})=>{const[s,o]=a([],{functionReturn:!0,lineBreakIndent:null,name:null});return`${n}${r} d${e}=${e}Object.getOwnPropertyDescriptor(e,${e}k);${i}${n}if${e}(d)${e}{${i}${n}${t}Object.defineProperty(n,${e}k,${e}d.get${e}?${e}d${e}:${e}{${i}${n}${t}${t}enumerable:${e}true,${i}${n}${t}${t}get:${e}${s}e[k]${o}${i}${n}${t}});${i}${n}}${i}`},tl=(t,n,{_:e,n:r})=>`${n}n[k]${e}=${e}e[k];${r}`,Ei=(t,n)=>t?`Object.freeze(${n})`:n,el=(t,n,{_:e,getObject:r})=>t?`Object.defineProperty(${n},${e}Symbol.toStringTag,${e}${Ve(r)})`:n,Ai=Object.keys(Jo);function Ve(t){return t([["value","'Module'"]],{lineBreakIndent:null})}function rl(t,n){return t.renderBaseName!==null&&n.has(t)&&t.isReassigned}class al extends O{declareDeclarator(n){this.id.declare(n,this.init||ie)}deoptimizePath(n){this.id.deoptimizePath(n)}hasEffects(n){var r;this.deoptimized||this.applyDeoptimizations();const e=(r=this.init)==null?void 0:r.hasEffects(n);return this.id.markDeclarationReached(),e||this.id.hasEffects(n)}include(n,e){const{deoptimized:r,id:a,init:i}=this;r||this.applyDeoptimizations(),this.included=!0,i==null||i.include(n,e),a.markDeclarationReached(),(e||a.shouldBeIncluded(n))&&a.include(n,e)}render(n,e){const{exportNamesByVariable:r,snippets:{_:a,getPropertyAccess:i}}=e,{end:s,id:o,init:l,start:c}=this,u=o.included;if(u)o.render(n,e);else{const f=kn(n.original,"=",o.end);n.remove(c,Et(n.original,f+1))}l?(o instanceof _n&&l instanceof gi&&!l.id&&o.variable.getName(i)!==o.name&&n.appendLeft(l.start+5,` ${o.name}`),l.render(n,e,u?Bn:{renderedSurroundingElement:Vn})):o instanceof _n&&rl(o.variable,r)&&n.appendLeft(s,`${a}=${a}void 0`)}applyDeoptimizations(){this.deoptimized=!0;const{id:n,init:e}=this;if(e&&n instanceof _n&&e instanceof gi&&!e.id){const{name:r,variable:a}=n;for(const i of e.scope.accessedOutsideVariables.values())i!==a&&i.forbidName(r)}}}function il(t,n,e){return n==="external"?Re[e(t instanceof fn?t.id:null)]:n==="default"?Ue:null}const _p={amd:["require"],cjs:["require"],system:["module"]};function sl(t){const n=[];for(const e of t.properties){if(e.type==="RestElement"||e.computed||e.key.type!=="Identifier")return;n.push(e.key.name)}return n}class ol extends O{applyDeoptimizations(){}}const wi="ROLLUP_FILE_URL_",Si="import",up={amd:["document","module","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module"],umd:["document","require","URL"]},fp={amd:["document","require","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module","URL"],umd:["document","require","URL"]},qe=(t,n="URL")=>`new ${n}(${t}).href`,Bi=(t,n=!1)=>qe(`'${dr(t)}', ${n?"typeof document === 'undefined' ? location.href : ":""}document.currentScript && document.currentScript.src || document.baseURI`),qr=t=>(n,{chunkId:e})=>{const r=t(e);return n===null?`({ url: ${r} })`:n==="url"?r:"undefined"},Ii=t=>`require('u' + 'rl').pathToFileURL(${t}).href`,ll=t=>Ii(`__dirname + '/${t}'`),ji=(t,n=!1)=>`${n?"typeof document === 'undefined' ? location.href : ":""}(document.currentScript && document.currentScript.src || new URL('${dr(t)}', document.baseURI).href)`,mp={amd:t=>(t[0]!=="."&&(t="./"+t),qe(`require.toUrl('${t}'), document.baseURI`)),cjs:t=>`(typeof document === 'undefined' ? ${ll(t)} : ${Bi(t)})`,es:t=>qe(`'${t}', import.meta.url`),iife:t=>Bi(t),system:t=>qe(`'${t}', module.meta.url`),umd:t=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${ll(t)} : ${Bi(t,!0)})`},Mi={amd:qr(()=>qe("module.uri, document.baseURI")),cjs:qr(t=>`(typeof document === 'undefined' ? ${Ii("__filename")} : ${ji(t)})`),iife:qr(t=>ji(t)),system:(t,{snippets:{getPropertyAccess:n}})=>t===null?"module.meta":`module.meta${n(t)}`,umd:qr(t=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${Ii("__filename")} : ${ji(t,!0)})`)};class cl extends O{constructor(){super(...arguments),this.hasCachedEffect=null,this.hasLoggedEffect=!1}hasCachedEffects(){return!!this.included&&(this.hasCachedEffect===null?this.hasCachedEffect=this.hasEffects(kr()):this.hasCachedEffect)}hasEffects(n){for(const e of this.body)if(e.hasEffects(n)){if(this.context.options.experimentalLogSideEffects&&!this.hasLoggedEffect){this.hasLoggedEffect=!0;const{code:r,log:a,module:i}=this.context;a(Ot,kd(r,i.id,Ga(r,e.start,{offsetLine:1})),e.start)}return this.hasCachedEffect=!0}return!1}include(n,e){this.included=!0;for(const r of this.body)(e||r.shouldBeIncluded(n))&&r.include(n,e)}render(n,e){let r=this.start;if(n.original.startsWith("#!")&&(r=Math.min(n.original.indexOf(`
`)+1,this.end),n.remove(0,r)),this.body.length>0){for(;n.original[r]==="/"&&/[*/]/.test(n.original[r+1]);){const a=Oe(n.original.slice(r,this.body[0].start));if(a[0]===-1)break;r+=a[1]}ze(this.body,n,r,this.end,e)}else super.render(n,e)}applyDeoptimizations(){}}class _l extends O{hasEffects(n){var e;if((e=this.test)!=null&&e.hasEffects(n))return!0;for(const r of this.consequent){if(n.brokenFlow)break;if(r.hasEffects(n))return!0}return!1}include(n,e){var r;this.included=!0,(r=this.test)==null||r.include(n,e);for(const a of this.consequent)(e||a.shouldBeIncluded(n))&&a.include(n,e)}render(n,e,r){if(this.consequent.length>0){this.test&&this.test.render(n,e);const a=this.test?this.test.end:kn(n.original,"default",this.start)+7,i=kn(n.original,":",a)+1;ze(this.consequent,n,i,r.end,e)}else super.render(n,e)}}_l.prototype.needsBoundaries=!0;class ul extends O{deoptimizeArgumentsOnInteractionAtPath(){}getLiteralValueAtPath(n){return n.length>0||this.quasis.length!==1?mn:this.quasis[0].value.cooked}getReturnExpressionWhenCalledAtPath(n){return n.length!==1?gn:Me(Ie,n[0])}hasEffectsOnInteractionAtPath(n,e,r){return e.type===0?n.length>1:e.type!==2||n.length!==1||je(Ie,n[0],e,r)}render(n,e){n.indentExclusionRanges.push([this.start,this.end]),super.render(n,e)}}class fl extends Dt{constructor(){super("undefined")}getLiteralValueAtPath(){}}class it extends dt{constructor(n,e,r){super(n,e,e.declaration,r),this.hasId=!1,this.originalId=null,this.originalVariable=null;const a=e.declaration;(a instanceof Pe||a instanceof Dr)&&a.id?(this.hasId=!0,this.originalId=a.id):a instanceof _n&&(this.originalId=a)}addReference(n){this.hasId||(this.name=n.name)}forbidName(n){const e=this.getOriginalVariable();e===this?super.forbidName(n):e.forbidName(n)}getAssignedVariableName(){return this.originalId&&this.originalId.name||null}getBaseVariableName(){const n=this.getOriginalVariable();return n===this?super.getBaseVariableName():n.getBaseVariableName()}getDirectOriginalVariable(){return!this.originalId||!this.hasId&&(this.originalId.isPossibleTDZ()||this.originalId.variable.isReassigned||this.originalId.variable instanceof fl||"syntheticNamespace"in this.originalId.variable)?null:this.originalId.variable}getName(n){const e=this.getOriginalVariable();return e===this?super.getName(n):e.getName(n)}getOriginalVariable(){if(this.originalVariable)return this.originalVariable;let n,e=this;const r=new Set;do r.add(e),n=e,e=n.getDirectOriginalVariable();while(e instanceof it&&!r.has(e));return this.originalVariable=e||n}}class ml extends Yn{constructor(n,e){super(n),this.context=e,this.variables.set("this",new dt("this",null,ie,e))}addExportDefaultDeclaration(n,e,r){const a=new it(n,e,r);return this.variables.set("default",a),a}addNamespaceMemberAccess(){}deconflict(n,e,r){for(const a of this.children)a.deconflict(n,e,r)}findLexicalBoundary(){return this}findVariable(n){const e=this.variables.get(n)||this.accessedOutsideVariables.get(n);if(e)return e;const r=this.context.traceVariable(n)||this.parent.findVariable(n);return r instanceof ci&&this.accessedOutsideVariables.set(n,r),r}}const dp={"!":t=>!t,"+":t=>+t,"-":t=>-t,delete:()=>mn,typeof:t=>typeof t,void:()=>{},"~":t=>~t};class dl extends O{deoptimizePath(){for(const n of this.declarations)n.deoptimizePath(q)}hasEffectsOnInteractionAtPath(){return!1}include(n,e,{asSingleStatement:r}=Bn){this.included=!0;for(const a of this.declarations){(e||a.shouldBeIncluded(n))&&a.include(n,e);const{id:i,init:s}=a;r&&i.include(n,e),s&&i.included&&!s.included&&(i instanceof Ge||i instanceof $o)&&s.include(n,e)}}initialise(){for(const n of this.declarations)n.declareDeclarator(this.kind)}render(n,e,r=Bn){if(function(a,i){for(const s of a){if(!s.id.included)return!1;if(s.id.type===oo){if(i.has(s.id.variable))return!1}else{const o=[];if(s.id.addExportedVariables(o,i),o.length>0)return!1}}return!0}(this.declarations,e.exportNamesByVariable)){for(const a of this.declarations)a.render(n,e);r.isNoStatement||n.original.charCodeAt(this.end-1)===59||n.appendLeft(this.end,";")}else this.renderReplacedDeclarations(n,e)}applyDeoptimizations(){}renderDeclarationEnd(n,e,r,a,i,s,o){n.original.charCodeAt(this.end-1)===59&&n.remove(this.end-1,this.end),e+=";",r===null?n.appendLeft(i,e):(n.original.charCodeAt(a-1)!==10||n.original.charCodeAt(this.end)!==10&&n.original.charCodeAt(this.end)!==13||(a--,n.original.charCodeAt(a)===13&&a--),a===r+1?n.overwrite(r,i,e):(n.overwrite(r,r+1,e),n.remove(a,i))),s.length>0&&n.appendLeft(i,` ${qt(s,o)};`)}renderReplacedDeclarations(n,e){const r=To(this.declarations,n,this.start+this.kind.length,this.end-(n.original.charCodeAt(this.end-1)===59?1:0));let a,i;i=Et(n.original,this.start+this.kind.length);let s=i-1;n.remove(this.start,s);let o,l=!1,c=!1,u="";const f=[],m=function(h,b,p){var x;let g=null;if(b.format==="system"){for(const{node:k}of h)k.id instanceof _n&&k.init&&p.length===0&&((x=b.exportNamesByVariable.get(k.id.variable))==null?void 0:x.length)===1?(g=k.id.variable,p.push(g)):k.id.addExportedVariables(p,b.exportNamesByVariable);p.length>1?g=null:g&&(p.length=0)}return g}(r,e,f);for(const{node:h,start:b,separator:p,contentEnd:g,end:x}of r)if(h.included){if(h.render(n,e),o="",!h.id.included||h.id instanceof _n&&rl(h.id.variable,e.exportNamesByVariable))c&&(u+=";"),l=!1;else{if(m&&m===h.id.variable){const k=kn(n.original,"=",h.id.end);di(m,Et(n.original,k+1),p===null?g:p,n,e)}l?u+=",":(c&&(u+=";"),o+=`${this.kind} `,l=!0)}i===s+1?n.overwrite(s,i,u+o):(n.overwrite(s,s+1,u),n.appendLeft(i,o)),a=g,i=x,c=!0,s=p,u=""}else n.remove(b,x);this.renderDeclarationEnd(n,u,s,a,i,f,e)}}const pl={ArrayExpression:vo,ArrayPattern:$o,ArrowFunctionExpression:mi,AssignmentExpression:class extends O{hasEffects(t){const{deoptimized:n,left:e,operator:r,right:a}=this;return n||this.applyDeoptimizations(),a.hasEffects(t)||e.hasEffectsAsAssignmentTarget(t,r!=="=")}hasEffectsOnInteractionAtPath(t,n,e){return this.right.hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){const{deoptimized:e,left:r,right:a,operator:i}=this;e||this.applyDeoptimizations(),this.included=!0,(n||i!=="="||r.included||r.hasEffectsAsAssignmentTarget(kr(),!1))&&r.includeAsAssignmentTarget(t,n,i!=="="),a.include(t,n)}initialise(){this.left.setAssignedValue(this.right)}render(t,n,{preventASI:e,renderedParentType:r,renderedSurroundingElement:a}=Bn){const{left:i,right:s,start:o,end:l,parent:c}=this;if(i.included)i.render(t,n),s.render(t,n);else{const u=Et(t.original,kn(t.original,"=",i.end)+1);t.remove(o,u),e&&Tr(t,u,s.start),s.render(t,n,{renderedParentType:r||c.type,renderedSurroundingElement:a||c.type})}if(n.format==="system")if(i instanceof _n){const u=i.variable,f=n.exportNamesByVariable.get(u);if(f)return void(f.length===1?di(u,o,l,t,n):No(u,o,l,c.type!==Vn,t,n))}else{const u=[];if(i.addExportedVariables(u,n.exportNamesByVariable),u.length>0)return void function(f,m,h,b,p,g){const{_:x,getDirectReturnIifeLeft:k}=g.snippets;p.prependRight(m,k(["v"],`${qt(f,g)},${x}v`,{needsArrowReturnParens:!0,needsWrappedFunction:b})),p.appendLeft(h,")")}(u,o,l,a===Vn,t,n)}i.included&&i instanceof Ge&&(a===Vn||a===Qa)&&(t.appendRight(o,"("),t.prependLeft(l,")"))}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(q),this.right.deoptimizePath(nn),this.context.requestTreeshakingPass()}},AssignmentPattern:class extends O{addExportedVariables(t,n){this.left.addExportedVariables(t,n)}declare(t,n){return this.left.declare(t,n)}deoptimizePath(t){t.length===0&&this.left.deoptimizePath(t)}hasEffectsOnInteractionAtPath(t,n,e){return t.length>0||this.left.hasEffectsOnInteractionAtPath(q,n,e)}markDeclarationReached(){this.left.markDeclarationReached()}render(t,n,{isShorthandProperty:e}=Bn){this.left.render(t,n,{isShorthandProperty:e}),this.right.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(q),this.right.deoptimizePath(nn),this.context.requestTreeshakingPass()}},AwaitExpression:Oo,BinaryExpression:class extends O{deoptimizeCache(){}getLiteralValueAtPath(t,n,e){if(t.length>0)return mn;const r=this.left.getLiteralValueAtPath(q,n,e);if(typeof r=="symbol")return mn;const a=this.right.getLiteralValueAtPath(q,n,e);if(typeof a=="symbol")return mn;const i=np[this.operator];return i?i(r,a):mn}hasEffects(t){return this.operator==="+"&&this.parent instanceof Vt&&this.left.getLiteralValueAtPath(q,vn,this)===""||super.hasEffects(t)}hasEffectsOnInteractionAtPath(t,{type:n}){return n!==0||t.length>1}render(t,n,{renderedSurroundingElement:e}=Bn){this.left.render(t,n,{renderedSurroundingElement:e}),this.right.render(t,n)}},BlockStatement:Nr,BreakStatement:class extends O{hasEffects(t){if(this.label){if(!t.ignore.labels.has(this.label.name))return!0;t.includedLabels.add(this.label.name)}else{if(!t.ignore.breaks)return!0;t.hasBreak=!0}return t.brokenFlow=!0,!1}include(t){this.included=!0,this.label?(this.label.include(),t.includedLabels.add(this.label.name)):t.hasBreak=!0,t.brokenFlow=!0}},CallExpression:Uo,CatchClause:class extends O{createScope(t){this.scope=new ep(t,this.context)}parseNode(t){const{param:n}=t;n&&(this.param=new(this.context.getNodeConstructor(n.type))(n,this,this.scope),this.param.declare("parameter",X)),super.parseNode(t)}},ChainExpression:class extends O{deoptimizeCache(){}getLiteralValueAtPath(t,n,e){if(!this.expression.isSkippedAsOptional(e))return this.expression.getLiteralValueAtPath(t,n,e)}hasEffects(t){return!this.expression.isSkippedAsOptional(this)&&this.expression.hasEffects(t)}},ClassBody:class extends O{createScope(t){this.scope=new rp(t,this.parent,this.context)}include(t,n){this.included=!0,this.context.includeVariableInModule(this.scope.thisVariable);for(const e of this.body)e.include(t,n)}parseNode(t){const n=this.body=[];for(const e of t.body)n.push(new(this.context.getNodeConstructor(e.type))(e,this,e.static?this.scope:this.scope.instanceScope));super.parseNode(t)}applyDeoptimizations(){}},ClassDeclaration:Dr,ClassExpression:gi,ConditionalExpression:class extends O{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.consequent.deoptimizeArgumentsOnInteractionAtPath(t,n,e),this.alternate.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizeCache(){if(this.usedBranch!==null){const t=this.usedBranch===this.consequent?this.alternate:this.consequent;this.usedBranch=null,t.deoptimizePath(nn);const{expressionsToBeDeoptimized:n}=this;this.expressionsToBeDeoptimized=yn;for(const e of n)e.deoptimizeCache()}}deoptimizePath(t){const n=this.getUsedBranch();n?n.deoptimizePath(t):(this.consequent.deoptimizePath(t),this.alternate.deoptimizePath(t))}getLiteralValueAtPath(t,n,e){const r=this.getUsedBranch();return r?(this.expressionsToBeDeoptimized.push(e),r.getLiteralValueAtPath(t,n,e)):mn}getReturnExpressionWhenCalledAtPath(t,n,e,r){const a=this.getUsedBranch();return a?(this.expressionsToBeDeoptimized.push(r),a.getReturnExpressionWhenCalledAtPath(t,n,e,r)):[new Or([this.consequent.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0],this.alternate.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0]]),!1]}hasEffects(t){if(this.test.hasEffects(t))return!0;const n=this.getUsedBranch();return n?n.hasEffects(t):this.consequent.hasEffects(t)||this.alternate.hasEffects(t)}hasEffectsOnInteractionAtPath(t,n,e){const r=this.getUsedBranch();return r?r.hasEffectsOnInteractionAtPath(t,n,e):this.consequent.hasEffectsOnInteractionAtPath(t,n,e)||this.alternate.hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){this.included=!0;const e=this.getUsedBranch();n||this.test.shouldBeIncluded(t)||e===null?(this.test.include(t,n),this.consequent.include(t,n),this.alternate.include(t,n)):e.include(t,n)}includeCallArguments(t,n){const e=this.getUsedBranch();e?e.includeCallArguments(t,n):(this.consequent.includeCallArguments(t,n),this.alternate.includeCallArguments(t,n))}render(t,n,{isCalleeOfRenderedParent:e,preventASI:r,renderedParentType:a,renderedSurroundingElement:i}=Bn){const s=this.getUsedBranch();if(this.test.included)this.test.render(t,n,{renderedSurroundingElement:i}),this.consequent.render(t,n),this.alternate.render(t,n);else{const o=kn(t.original,":",this.consequent.end),l=Et(t.original,(this.consequent.included?kn(t.original,"?",this.test.end):o)+1);r&&Tr(t,l,s.start),t.remove(this.start,l),this.consequent.included&&t.remove(o,this.end),Mo(this,t),s.render(t,n,{isCalleeOfRenderedParent:e,preventASI:!0,renderedParentType:a||this.parent.type,renderedSurroundingElement:i||this.parent.type})}}getUsedBranch(){if(this.isBranchResolutionAnalysed)return this.usedBranch;this.isBranchResolutionAnalysed=!0;const t=this.test.getLiteralValueAtPath(q,vn,this);return typeof t=="symbol"?null:this.usedBranch=t?this.consequent:this.alternate}},ContinueStatement:class extends O{hasEffects(t){if(this.label){if(!t.ignore.labels.has(this.label.name))return!0;t.includedLabels.add(this.label.name)}else{if(!t.ignore.continues)return!0;t.hasContinue=!0}return t.brokenFlow=!0,!1}include(t){this.included=!0,this.label?(this.label.include(),t.includedLabels.add(this.label.name)):t.hasContinue=!0,t.brokenFlow=!0}},DoWhileStatement:class extends O{hasEffects(t){return!!this.test.hasEffects(t)||zr(t,this.body)}include(t,n){this.included=!0,this.test.include(t,n),Fe(t,this.body,n)}},EmptyStatement:class extends O{hasEffects(){return!1}},ExportAllDeclaration:yi,ExportDefaultDeclaration:Gr,ExportNamedDeclaration:qo,ExportSpecifier:class extends O{applyDeoptimizations(){}},ExpressionStatement:Vt,ForInStatement:class extends O{createScope(t){this.scope=new Rt(t)}hasEffects(t){const{body:n,deoptimized:e,left:r,right:a}=this;return e||this.applyDeoptimizations(),!(!r.hasEffectsAsAssignmentTarget(t,!1)&&!a.hasEffects(t))||zr(t,n)}include(t,n){const{body:e,deoptimized:r,left:a,right:i}=this;r||this.applyDeoptimizations(),this.included=!0,a.includeAsAssignmentTarget(t,n||!0,!1),i.include(t,n),Fe(t,e,n)}initialise(){this.left.setAssignedValue(X)}render(t,n){this.left.render(t,n,Ut),this.right.render(t,n,Ut),t.original.charCodeAt(this.right.start-1)===110&&t.prependLeft(this.right.start," "),this.body.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(q),this.context.requestTreeshakingPass()}},ForOfStatement:class extends O{createScope(t){this.scope=new Rt(t)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(t,n){const{body:e,deoptimized:r,left:a,right:i}=this;r||this.applyDeoptimizations(),this.included=!0,a.includeAsAssignmentTarget(t,n||!0,!1),i.include(t,n),Fe(t,e,n)}initialise(){this.left.setAssignedValue(X)}render(t,n){this.left.render(t,n,Ut),this.right.render(t,n,Ut),t.original.charCodeAt(this.right.start-1)===102&&t.prependLeft(this.right.start," "),this.body.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(q),this.right.deoptimizePath(nn),this.context.requestTreeshakingPass()}},ForStatement:class extends O{createScope(t){this.scope=new Rt(t)}hasEffects(t){var n,e,r;return!!((n=this.init)!=null&&n.hasEffects(t)||(e=this.test)!=null&&e.hasEffects(t)||(r=this.update)!=null&&r.hasEffects(t))||zr(t,this.body)}include(t,n){var e,r,a;this.included=!0,(e=this.init)==null||e.include(t,n,{asSingleStatement:!0}),(r=this.test)==null||r.include(t,n),(a=this.update)==null||a.include(t,n),Fe(t,this.body,n)}render(t,n){var e,r,a;(e=this.init)==null||e.render(t,n,Ut),(r=this.test)==null||r.render(t,n,Ut),(a=this.update)==null||a.render(t,n,Ut),this.body.render(t,n)}},FunctionDeclaration:Pe,FunctionExpression:Xo,Identifier:_n,IfStatement:bi,ImportAttribute:class extends O{},ImportDeclaration:Ho,ImportDefaultSpecifier:Yo,ImportExpression:class extends O{constructor(){super(...arguments),this.inlineNamespace=null,this.assertions=null,this.mechanism=null,this.namespaceExportName=void 0,this.resolution=null,this.resolutionString=null}bind(){this.source.bind()}getDeterministicImportedNames(){const t=this.parent;if(t instanceof Vt)return yn;if(t instanceof Oo){const n=t.parent;if(n instanceof Vt)return yn;if(n instanceof al){const e=n.id;return e instanceof Ge?sl(e):void 0}if(n instanceof At){const e=n.property;if(!n.computed&&e instanceof _n)return[e.name]}}else if(t instanceof At){const n=t.parent,e=t.property;if(!(n instanceof Uo&&e instanceof _n))return;const r=e.name;if(n.parent instanceof Vt&&["catch","finally"].includes(r))return yn;if(r!=="then")return;if(n.arguments.length===0)return yn;const a=n.arguments[0];if(n.arguments.length!==1||!(a instanceof mi||a instanceof Xo))return;if(a.params.length===0)return yn;const i=a.params[0];return a.params.length===1&&i instanceof Ge?sl(i):void 0}}hasEffects(){return!0}include(t,n){this.included||(this.included=!0,this.context.includeDynamicImport(this),this.scope.addAccessedDynamicImport(this)),this.source.include(t,n)}initialise(){this.context.addDynamicImport(this)}parseNode(t){super.parseNode(t,["source"])}render(t,n){const{snippets:{_:e,getDirectReturnFunction:r,getObject:a,getPropertyAccess:i}}=n;if(this.inlineNamespace){const[s,o]=r([],{functionReturn:!0,lineBreakIndent:null,name:null});t.overwrite(this.start,this.end,`Promise.resolve().then(${s}${this.inlineNamespace.getName(i)}${o})`)}else{if(this.mechanism&&(t.overwrite(this.start,kn(t.original,"(",this.start+6)+1,this.mechanism.left),t.overwrite(this.end-1,this.end,this.mechanism.right)),this.resolutionString){if(t.overwrite(this.source.start,this.source.end,this.resolutionString),this.namespaceExportName){const[s,o]=r(["n"],{functionReturn:!0,lineBreakIndent:null,name:null});t.prependLeft(this.end,`.then(${s}n.${this.namespaceExportName}${o})`)}}else this.source.render(t,n);this.assertions!==!0&&(this.arguments&&t.overwrite(this.source.end,this.end-1,"",{contentOnly:!0}),this.assertions&&t.appendLeft(this.end-1,`,${e}${a([["assert",this.assertions]],{lineBreakIndent:null})}`))}}setExternalResolution(t,n,e,r,a,i,s,o,l){const{format:c}=e;this.inlineNamespace=null,this.resolution=n,this.resolutionString=s,this.namespaceExportName=o,this.assertions=l;const u=[..._p[c]||[]];let f;({helper:f,mechanism:this.mechanism}=this.getDynamicImportMechanismAndHelper(n,t,e,r,a)),f&&u.push(f),u.length>0&&this.scope.addAccessedGlobals(u,i)}setInternalResolution(t){this.inlineNamespace=t}applyDeoptimizations(){}getDynamicImportMechanismAndHelper(t,n,{compact:e,dynamicImportFunction:r,dynamicImportInCjs:a,format:i,generatedCode:{arrowFunctions:s},interop:o},{_:l,getDirectReturnFunction:c,getDirectReturnIifeLeft:u},f){const m=f.hookFirstSync("renderDynamicImport",[{customResolution:typeof this.resolution=="string"?this.resolution:null,format:i,moduleId:this.context.module.id,targetModuleId:this.resolution&&typeof this.resolution!="string"?this.resolution.id:null}]);if(m)return{helper:null,mechanism:m};const h=!this.resolution||typeof this.resolution=="string";switch(i){case"cjs":{if(a&&(!t||typeof t=="string"||t instanceof fn))return{helper:null,mechanism:null};const b=il(t,n,o);let p="require(",g=")";b&&(p=`/*#__PURE__*/${b}(${p}`,g+=")");const[x,k]=c([],{functionReturn:!0,lineBreakIndent:null,name:null});return p=`Promise.resolve().then(${x}${p}`,g+=`${k})`,!s&&h&&(p=u(["t"],`${p}t${g}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),g=")"),{helper:b,mechanism:{left:p,right:g}}}case"amd":{const b=e?"c":"resolve",p=e?"e":"reject",g=il(t,n,o),[x,k]=c(["m"],{functionReturn:!1,lineBreakIndent:null,name:null}),y=g?`${x}${b}(/*#__PURE__*/${g}(m))${k}`:b,[v,$]=c([b,p],{functionReturn:!1,lineBreakIndent:null,name:null});let w=`new Promise(${v}require([`,S=`],${l}${y},${l}${p})${$})`;return!s&&h&&(w=u(["t"],`${w}t${S}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),S=")"),{helper:g,mechanism:{left:w,right:S}}}case"system":return{helper:null,mechanism:{left:"module.import(",right:")"}};case"es":if(r)return{helper:null,mechanism:{left:`${r}(`,right:")"}}}return{helper:null,mechanism:null}}},ImportNamespaceSpecifier:ol,ImportSpecifier:class extends O{applyDeoptimizations(){}},LabeledStatement:class extends O{hasEffects(t){const n=t.brokenFlow;return t.ignore.labels.add(this.label.name),!!this.body.hasEffects(t)||(t.ignore.labels.delete(this.label.name),t.includedLabels.has(this.label.name)&&(t.includedLabels.delete(this.label.name),t.brokenFlow=n),!1)}include(t,n){this.included=!0;const e=t.brokenFlow;this.body.include(t,n),(n||t.includedLabels.has(this.label.name))&&(this.label.include(),t.includedLabels.delete(this.label.name),t.brokenFlow=e)}render(t,n){this.label.included?this.label.render(t,n):t.remove(this.start,Et(t.original,kn(t.original,":",this.label.end)+1)),this.body.render(t,n)}},Literal:Xt,LogicalExpression:class extends O{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.left.deoptimizeArgumentsOnInteractionAtPath(t,n,e),this.right.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizeCache(){if(this.usedBranch){const t=this.usedBranch===this.left?this.right:this.left;this.usedBranch=null,t.deoptimizePath(nn);const{context:n,expressionsToBeDeoptimized:e}=this;this.expressionsToBeDeoptimized=yn;for(const r of e)r.deoptimizeCache();n.requestTreeshakingPass()}}deoptimizePath(t){const n=this.getUsedBranch();n?n.deoptimizePath(t):(this.left.deoptimizePath(t),this.right.deoptimizePath(t))}getLiteralValueAtPath(t,n,e){const r=this.getUsedBranch();return r?(this.expressionsToBeDeoptimized.push(e),r.getLiteralValueAtPath(t,n,e)):mn}getReturnExpressionWhenCalledAtPath(t,n,e,r){const a=this.getUsedBranch();return a?(this.expressionsToBeDeoptimized.push(r),a.getReturnExpressionWhenCalledAtPath(t,n,e,r)):[new Or([this.left.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0],this.right.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0]]),!1]}hasEffects(t){return!!this.left.hasEffects(t)||this.getUsedBranch()!==this.left&&this.right.hasEffects(t)}hasEffectsOnInteractionAtPath(t,n,e){const r=this.getUsedBranch();return r?r.hasEffectsOnInteractionAtPath(t,n,e):this.left.hasEffectsOnInteractionAtPath(t,n,e)||this.right.hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){this.included=!0;const e=this.getUsedBranch();n||e===this.right&&this.left.shouldBeIncluded(t)||!e?(this.left.include(t,n),this.right.include(t,n)):e.include(t,n)}render(t,n,{isCalleeOfRenderedParent:e,preventASI:r,renderedParentType:a,renderedSurroundingElement:i}=Bn){if(this.left.included&&this.right.included)this.left.render(t,n,{preventASI:r,renderedSurroundingElement:i}),this.right.render(t,n);else{const s=kn(t.original,this.operator,this.left.end);if(this.right.included){const o=Et(t.original,s+2);t.remove(this.start,o),r&&Tr(t,o,this.right.start)}else t.remove(s,this.end);Mo(this,t),this.getUsedBranch().render(t,n,{isCalleeOfRenderedParent:e,preventASI:r,renderedParentType:a||this.parent.type,renderedSurroundingElement:i||this.parent.type})}}getUsedBranch(){if(!this.isBranchResolutionAnalysed){this.isBranchResolutionAnalysed=!0;const t=this.left.getLiteralValueAtPath(q,vn,this);if(typeof t=="symbol")return null;this.usedBranch=this.operator==="||"&&t||this.operator==="&&"&&!t||this.operator==="??"&&t!=null?this.left:this.right}return this.usedBranch}},MemberExpression:At,MetaProperty:class extends O{constructor(){super(...arguments),this.metaProperty=null,this.preliminaryChunkId=null,this.referenceId=null}getReferencedFileName(t){const{meta:{name:n},metaProperty:e}=this;return n===Si&&(e!=null&&e.startsWith(wi))?t.getFileName(e.slice(16)):null}hasEffects(){return!1}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>1||n!==0}include(){if(!this.included&&(this.included=!0,this.meta.name===Si)){this.context.addImportMeta(this);const t=this.parent,n=this.metaProperty=t instanceof At&&typeof t.propertyKey=="string"?t.propertyKey:null;n!=null&&n.startsWith(wi)&&(this.referenceId=n.slice(16))}}render(t,{format:n,pluginDriver:e,snippets:r}){var b;const{context:{module:{id:a}},meta:{name:i},metaProperty:s,parent:o,preliminaryChunkId:l,referenceId:c,start:u,end:f}=this;if(i!==Si)return;const m=l;if(c){const p=e.getFileName(c),g=ke(ne(Tt(m),p)),x=e.hookFirstSync("resolveFileUrl",[{chunkId:m,fileName:p,format:n,moduleId:a,referenceId:c,relativePath:g}])||mp[n](g);return void t.overwrite(o.start,o.end,x,{contentOnly:!0})}const h=e.hookFirstSync("resolveImportMeta",[s,{chunkId:m,format:n,moduleId:a}])||((b=Mi[n])==null?void 0:b.call(Mi,s,{chunkId:m,snippets:r}));typeof h=="string"&&(o instanceof At?t.overwrite(o.start,o.end,h,{contentOnly:!0}):t.overwrite(u,f,h,{contentOnly:!0}))}setResolution(t,n,e){var a;this.preliminaryChunkId=e;const r=((a=this.metaProperty)!=null&&a.startsWith(wi)?fp:up)[t];r.length>0&&this.scope.addAccessedGlobals(r,n)}},MethodDefinition:hi,NewExpression:class extends O{hasEffects(t){try{for(const n of this.arguments)if(n.hasEffects(t))return!0;return!this.annotationPure&&(this.callee.hasEffects(t)||this.callee.hasEffectsOnInteractionAtPath(q,this.interaction,t))}finally{this.deoptimized||this.applyDeoptimizations()}}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>0||n!==0}include(t,n){this.deoptimized||this.applyDeoptimizations(),n?super.include(t,n):(this.included=!0,this.callee.include(t,!1)),this.callee.includeCallArguments(t,this.arguments)}initialise(){this.interaction={args:[null,...this.arguments],type:2,withNew:!0}}render(t,n){this.callee.render(t,n),zo(t,n,this)}applyDeoptimizations(){this.deoptimized=!0,this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction,q,vn),this.context.requestTreeshakingPass()}},ObjectExpression:class extends O{constructor(){super(...arguments),this.objectEntity=null}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(t){this.getObjectEntity().deoptimizePath(t)}getLiteralValueAtPath(t,n,e){return this.getObjectEntity().getLiteralValueAtPath(t,n,e)}getReturnExpressionWhenCalledAtPath(t,n,e,r){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(t,n,e,r)}hasEffectsOnInteractionAtPath(t,n,e){return this.getObjectEntity().hasEffectsOnInteractionAtPath(t,n,e)}render(t,n,{renderedSurroundingElement:e}=Bn){super.render(t,n),e!==Vn&&e!==Qa||(t.appendRight(this.start,"("),t.prependLeft(this.end,")"))}applyDeoptimizations(){}getObjectEntity(){if(this.objectEntity!==null)return this.objectEntity;let t=kt;const n=[];for(const e of this.properties){if(e instanceof Le){n.push({key:on,kind:"init",property:e});continue}let r;if(e.computed){const a=e.key.getLiteralValueAtPath(q,vn,this);if(typeof a=="symbol"){n.push({key:on,kind:e.kind,property:e});continue}r=String(a)}else if(r=e.key instanceof _n?e.key.name:String(e.key.value),r==="__proto__"&&e.kind==="init"){t=e.value instanceof Xt&&e.value.value===null?null:e.value;continue}n.push({key:r,kind:e.kind,property:e})}return this.objectEntity=new Fn(n,t)}},ObjectPattern:Ge,PrivateIdentifier:class extends O{},Program:cl,Property:class extends Ro{constructor(){super(...arguments),this.declarationInit=null}declare(t,n){return this.declarationInit=n,this.value.declare(t,X)}hasEffects(t){this.deoptimized||this.applyDeoptimizations();const n=this.context.options.treeshake.propertyReadSideEffects;return this.parent.type==="ObjectPattern"&&n==="always"||this.key.hasEffects(t)||this.value.hasEffects(t)}markDeclarationReached(){this.value.markDeclarationReached()}render(t,n){this.shorthand||this.key.render(t,n),this.value.render(t,n,{isShorthandProperty:this.shorthand})}applyDeoptimizations(){this.deoptimized=!0,this.declarationInit!==null&&(this.declarationInit.deoptimizePath([on,on]),this.context.requestTreeshakingPass())}},PropertyDefinition:class extends O{deoptimizeArgumentsOnInteractionAtPath(t,n,e){var r;(r=this.value)==null||r.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){var n;(n=this.value)==null||n.deoptimizePath(t)}getLiteralValueAtPath(t,n,e){return this.value?this.value.getLiteralValueAtPath(t,n,e):mn}getReturnExpressionWhenCalledAtPath(t,n,e,r){return this.value?this.value.getReturnExpressionWhenCalledAtPath(t,n,e,r):gn}hasEffects(t){var n;return this.key.hasEffects(t)||this.static&&!!((n=this.value)!=null&&n.hasEffects(t))}hasEffectsOnInteractionAtPath(t,n,e){return!this.value||this.value.hasEffectsOnInteractionAtPath(t,n,e)}applyDeoptimizations(){}},RestElement:ui,ReturnStatement:class extends O{hasEffects(t){var n;return!(t.ignore.returnYield&&!((n=this.argument)!=null&&n.hasEffects(t)))||(t.brokenFlow=!0,!1)}include(t,n){var e;this.included=!0,(e=this.argument)==null||e.include(t,n),t.brokenFlow=!0}initialise(){this.scope.addReturnExpression(this.argument||X)}render(t,n){this.argument&&(this.argument.render(t,n,{preventASI:!0}),this.argument.start===this.start+6&&t.prependLeft(this.start+6," "))}},SequenceExpression:class extends O{deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.expressions[this.expressions.length-1].deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){this.expressions[this.expressions.length-1].deoptimizePath(t)}getLiteralValueAtPath(t,n,e){return this.expressions[this.expressions.length-1].getLiteralValueAtPath(t,n,e)}hasEffects(t){for(const n of this.expressions)if(n.hasEffects(t))return!0;return!1}hasEffectsOnInteractionAtPath(t,n,e){return this.expressions[this.expressions.length-1].hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){this.included=!0;const e=this.expressions[this.expressions.length-1];for(const r of this.expressions)(n||r===e&&!(this.parent instanceof Vt)||r.shouldBeIncluded(t))&&r.include(t,n)}render(t,n,{renderedParentType:e,isCalleeOfRenderedParent:r,preventASI:a}=Bn){let i=0,s=null;const o=this.expressions[this.expressions.length-1];for(const{node:l,separator:c,start:u,end:f}of To(this.expressions,t,this.start,this.end))if(l.included)if(i++,s=c,i===1&&a&&Tr(t,u,l.start),i===1){const m=e||this.parent.type;l.render(t,n,{isCalleeOfRenderedParent:r&&l===o,renderedParentType:m,renderedSurroundingElement:m})}else l.render(t,n);else _i(l,t,u,f);s&&t.remove(s,this.end)}},SpreadElement:Le,StaticBlock:class extends O{createScope(t){this.scope=new Rt(t)}hasEffects(t){for(const n of this.body)if(n.hasEffects(t))return!0;return!1}include(t,n){this.included=!0;for(const e of this.body)(n||e.shouldBeIncluded(t))&&e.include(t,n)}render(t,n){if(this.body.length>0){const e=kn(t.original.slice(this.start,this.end),"{")+1;ze(this.body,t,this.start+e,this.end-1,n)}else super.render(t,n)}},Super:class extends O{bind(){this.variable=this.scope.findVariable("this")}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.variable.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){this.variable.deoptimizePath(t)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}},SwitchCase:_l,SwitchStatement:class extends O{createScope(t){this.parentScope=t,this.scope=new Rt(t)}hasEffects(t){if(this.discriminant.hasEffects(t))return!0;const{brokenFlow:n,hasBreak:e,ignore:r}=t,{breaks:a}=r;r.breaks=!0,t.hasBreak=!1;let i=!0;for(const s of this.cases){if(s.hasEffects(t))return!0;i&&(i=t.brokenFlow&&!t.hasBreak),t.hasBreak=!1,t.brokenFlow=n}return this.defaultCase!==null&&(t.brokenFlow=i),r.breaks=a,t.hasBreak=e,!1}include(t,n){this.included=!0,this.discriminant.include(t,n);const{brokenFlow:e,hasBreak:r}=t;t.hasBreak=!1;let a=!0,i=n||this.defaultCase!==null&&this.defaultCase<this.cases.length-1;for(let s=this.cases.length-1;s>=0;s--){const o=this.cases[s];if(o.included&&(i=!0),!i){const l=kr();l.ignore.breaks=!0,i=o.hasEffects(l)}i?(o.include(t,n),a&&(a=t.brokenFlow&&!t.hasBreak),t.hasBreak=!1,t.brokenFlow=e):a=e}i&&this.defaultCase!==null&&(t.brokenFlow=a),t.hasBreak=r}initialise(){for(let t=0;t<this.cases.length;t++)if(this.cases[t].test===null)return void(this.defaultCase=t);this.defaultCase=null}parseNode(t){this.discriminant=new(this.context.getNodeConstructor(t.discriminant.type))(t.discriminant,this,this.parentScope),super.parseNode(t)}render(t,n){this.discriminant.render(t,n),this.cases.length>0&&ze(this.cases,t,this.cases[0].start,this.end-1,n)}},TaggedTemplateExpression:class extends Po{bind(){if(super.bind(),this.tag.type===oo){const t=this.tag.name;this.scope.findVariable(t).isNamespace&&this.context.log(V,Zs(t),this.start)}}hasEffects(t){try{for(const n of this.quasi.expressions)if(n.hasEffects(t))return!0;return this.tag.hasEffects(t)||this.tag.hasEffectsOnInteractionAtPath(q,this.interaction,t)}finally{this.deoptimized||this.applyDeoptimizations()}}include(t,n){this.deoptimized||this.applyDeoptimizations(),n?super.include(t,n):(this.included=!0,this.tag.include(t,n),this.quasi.include(t,n)),this.tag.includeCallArguments(t,this.args);const[e]=this.getReturnExpression();e.included||e.include(t,!1)}initialise(){this.args=[X,...this.quasi.expressions],this.interaction={args:[this.tag instanceof At&&!this.tag.variable?this.tag.object:null,...this.args],type:2,withNew:!1}}render(t,n){this.tag.render(t,n,{isCalleeOfRenderedParent:!0}),this.quasi.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.tag.deoptimizeArgumentsOnInteractionAtPath(this.interaction,q,vn),this.context.requestTreeshakingPass()}getReturnExpression(t=vn){return this.returnExpression===null?(this.returnExpression=gn,this.returnExpression=this.tag.getReturnExpressionWhenCalledAtPath(q,this.interaction,t,this)):this.returnExpression}},TemplateElement:class extends O{bind(){}hasEffects(){return!1}include(){this.included=!0}parseNode(t){this.value=t.value,super.parseNode(t)}render(){}},TemplateLiteral:ul,ThisExpression:class extends O{bind(){this.variable=this.scope.findVariable("this")}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.variable.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){this.variable.deoptimizePath(t)}hasEffectsOnInteractionAtPath(t,n,e){return t.length===0?n.type!==0:this.variable.hasEffectsOnInteractionAtPath(t,n,e)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}initialise(){this.alias=this.scope.findLexicalBoundary()instanceof ml?this.context.moduleContext:null,this.alias==="undefined"&&this.context.log(V,{code:"THIS_IS_UNDEFINED",message:"The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten",url:En("troubleshooting/#error-this-is-undefined")},this.start)}render(t){this.alias!==null&&t.overwrite(this.start,this.end,this.alias,{contentOnly:!1,storeName:!0})}},ThrowStatement:class extends O{hasEffects(){return!0}include(t,n){this.included=!0,this.argument.include(t,n),t.brokenFlow=!0}render(t,n){this.argument.render(t,n,{preventASI:!0}),this.argument.start===this.start+5&&t.prependLeft(this.start+5," ")}},TryStatement:class extends O{constructor(){super(...arguments),this.directlyIncluded=!1,this.includedLabelsAfterBlock=null}hasEffects(t){var n;return(this.context.options.treeshake.tryCatchDeoptimization?this.block.body.length>0:this.block.hasEffects(t))||!!((n=this.finalizer)!=null&&n.hasEffects(t))}include(t,n){var i,s;const e=(i=this.context.options.treeshake)==null?void 0:i.tryCatchDeoptimization,{brokenFlow:r,includedLabels:a}=t;if(this.directlyIncluded&&e){if(this.includedLabelsAfterBlock)for(const o of this.includedLabelsAfterBlock)a.add(o)}else this.included=!0,this.directlyIncluded=!0,this.block.include(t,e?uo:n),a.size>0&&(this.includedLabelsAfterBlock=[...a]),t.brokenFlow=r;this.handler!==null&&(this.handler.include(t,n),t.brokenFlow=r),(s=this.finalizer)==null||s.include(t,n)}},UnaryExpression:class extends O{getLiteralValueAtPath(t,n,e){if(t.length>0)return mn;const r=this.argument.getLiteralValueAtPath(q,n,e);return typeof r=="symbol"?mn:dp[this.operator](r)}hasEffects(t){return this.deoptimized||this.applyDeoptimizations(),!(this.operator==="typeof"&&this.argument instanceof _n)&&(this.argument.hasEffects(t)||this.operator==="delete"&&this.argument.hasEffectsOnInteractionAtPath(q,Oa,t))}hasEffectsOnInteractionAtPath(t,{type:n}){return n!==0||t.length>(this.operator==="void"?0:1)}applyDeoptimizations(){this.deoptimized=!0,this.operator==="delete"&&(this.argument.deoptimizePath(q),this.context.requestTreeshakingPass())}},UnknownNode:class extends O{hasEffects(){return!0}include(t){super.include(t,!0)}},UpdateExpression:class extends O{hasEffects(t){return this.deoptimized||this.applyDeoptimizations(),this.argument.hasEffectsAsAssignmentTarget(t,!0)}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>1||n!==0}include(t,n){this.deoptimized||this.applyDeoptimizations(),this.included=!0,this.argument.includeAsAssignmentTarget(t,n,!0)}initialise(){this.argument.setAssignedValue(X)}render(t,n){const{exportNamesByVariable:e,format:r,snippets:{_:a}}=n;if(this.argument.render(t,n),r==="system"){const i=this.argument.variable,s=e.get(i);if(s)if(this.prefix)s.length===1?di(i,this.start,this.end,t,n):No(i,this.start,this.end,this.parent.type!==Vn,t,n);else{const o=this.operator[0];(function(l,c,u,f,m,h,b){const{_:p}=h.snippets;m.prependRight(c,`${qt([l],h,b)},${p}`),f&&(m.prependRight(c,"("),m.appendLeft(u,")"))})(i,this.start,this.end,this.parent.type!==Vn,t,n,`${a}${o}${a}1`)}}}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath(q),this.argument instanceof _n&&(this.scope.findVariable(this.argument.name).isReassigned=!0),this.context.requestTreeshakingPass()}},VariableDeclaration:dl,VariableDeclarator:al,WhileStatement:class extends O{hasEffects(t){return!!this.test.hasEffects(t)||zr(t,this.body)}include(t,n){this.included=!0,this.test.include(t,n),Fe(t,this.body,n)}},YieldExpression:class extends O{hasEffects(t){var n;return this.deoptimized||this.applyDeoptimizations(),!(t.ignore.returnYield&&!((n=this.argument)!=null&&n.hasEffects(t)))}render(t,n){this.argument&&(this.argument.render(t,n,{preventASI:!0}),this.argument.start===this.start+5&&t.prependLeft(this.start+5," "))}}},_e="_missingExportShim";class pp extends Dt{constructor(n){super(_e),this.module=n}include(){super.include(),this.module.needsExportShim=!0}}class Xe extends Dt{constructor(n){super(n.getModuleName()),this.memberVariables=null,this.mergedNamespaces=[],this.referencedEarly=!1,this.references=[],this.context=n,this.module=n.module}addReference(n){this.references.push(n),this.name=n.name}deoptimizeArgumentsOnInteractionAtPath(n,e,r){var a;if(e.length>1||e.length===1&&n.type===2){const i=e[0];typeof i=="string"?(a=this.getMemberVariables()[i])==null||a.deoptimizeArgumentsOnInteractionAtPath(n,e.slice(1),r):vt(n)}}deoptimizePath(n){var e;if(n.length>1){const r=n[0];typeof r=="string"&&((e=this.getMemberVariables()[r])==null||e.deoptimizePath(n.slice(1)))}}getLiteralValueAtPath(n){return n[0]===Ta?"Module":mn}getMemberVariables(){if(this.memberVariables)return this.memberVariables;const n=Object.create(null),e=[...this.context.getExports(),...this.context.getReexports()].sort();for(const r of e)if(r[0]!=="*"&&r!==this.module.info.syntheticNamedExports){const a=this.context.traceExport(r);a&&(n[r]=a)}return this.memberVariables=n}hasEffectsOnInteractionAtPath(n,e,r){const{type:a}=e;if(n.length===0)return!0;if(n.length===1&&a!==2)return a===1;const i=n[0];if(typeof i!="string")return!0;const s=this.getMemberVariables()[i];return!s||s.hasEffectsOnInteractionAtPath(n.slice(1),e,r)}include(){this.included=!0,this.context.includeAllExports()}prepare(n){this.mergedNamespaces.length>0&&this.module.scope.addAccessedGlobals([Ur],n)}renderBlock(n){const{exportNamesByVariable:e,format:r,freeze:a,indent:i,namespaceToStringTag:s,snippets:{_:o,cnst:l,getObject:c,getPropertyAccess:u,n:f,s:m}}=n,h=this.getMemberVariables(),b=Object.entries(h).filter(([g,x])=>x.included).map(([g,x])=>this.referencedEarly||x.isReassigned||x===this?[null,`get ${g}${o}()${o}{${o}return ${x.getName(u)}${m}${o}}`]:[g,x.getName(u)]);b.unshift([null,`__proto__:${o}null`]);let p=c(b,{lineBreakIndent:{base:"",t:i}});if(this.mergedNamespaces.length>0){const g=this.mergedNamespaces.map(x=>x.getName(u));p=`/*#__PURE__*/${Ur}(${p},${o}[${g.join(`,${o}`)}])`}else s&&(p=`/*#__PURE__*/Object.defineProperty(${p},${o}Symbol.toStringTag,${o}${Ve(c)})`),a&&(p=`/*#__PURE__*/Object.freeze(${p})`);return p=`${l} ${this.getName(u)}${o}=${o}${p};`,r==="system"&&e.has(this)&&(p+=`${f}${qt([this],n)};`),p}renderFirst(){return this.referencedEarly}setMergedNamespaces(n){this.mergedNamespaces=n;const e=this.context.getModuleExecIndex();for(const r of this.references)if(r.context.getModuleExecIndex()<=e){this.referencedEarly=!0;break}}}Xe.prototype.isNamespace=!0;class Nn extends Dt{constructor(n,e,r){super(e),this.baseVariable=null,this.context=n,this.module=n.module,this.syntheticNamespace=r}getBaseVariable(){if(this.baseVariable)return this.baseVariable;let n=this.syntheticNamespace;for(;n instanceof it||n instanceof Nn;){if(n instanceof it){const e=n.getOriginalVariable();if(e===n)break;n=e}n instanceof Nn&&(n=n.syntheticNamespace)}return this.baseVariable=n}getBaseVariableName(){return this.syntheticNamespace.getBaseVariableName()}getName(n){return`${this.syntheticNamespace.getName(n)}${n(this.name)}`}include(){this.included=!0,this.context.includeVariableInModule(this.syntheticNamespace)}setRenderNames(n,e){super.setRenderNames(n,e)}}var wt;function Li(t){return t.id}(function(t){t[t.LOAD_AND_PARSE=0]="LOAD_AND_PARSE",t[t.ANALYSE=1]="ANALYSE",t[t.GENERATE=2]="GENERATE"})(wt||(wt={}));const Ti=t=>{const n=t.key;return n&&(n.name||n.value)};function Xr(t,n){const e=Object.keys(t);return e.length!==Object.keys(n).length||e.some(r=>t[r]!==n[r])}var hl="performance"in(typeof globalThis>"u"?typeof window>"u"?{}:window:globalThis)?performance:{now:()=>0},gl={memoryUsage:()=>({heapUsed:0})};let We=new Map;function yl(t,n){switch(n){case 1:return`# ${t}`;case 2:return`## ${t}`;case 3:return t;default:return`${"  ".repeat(n-4)}- ${t}`}}function hp(t,n=3){t=yl(t,n);const e=gl.memoryUsage().heapUsed,r=hl.now(),a=We.get(t);a===void 0?We.set(t,{memory:0,startMemory:e,startTime:r,time:0,totalMemory:0}):(a.startMemory=e,a.startTime=r)}function gp(t,n=3){t=yl(t,n);const e=We.get(t);if(e!==void 0){const r=gl.memoryUsage().heapUsed;e.memory+=r-e.startMemory,e.time+=hl.now()-e.startTime,e.totalMemory=Math.max(e.totalMemory,r)}}function yp(){const t={};for(const[n,{memory:e,time:r,totalMemory:a}]of We)t[n]=[r,e,a];return t}let $n=rt,xn=rt;const bp=["augmentChunkHash","buildEnd","buildStart","generateBundle","load","moduleParsed","options","outputOptions","renderChunk","renderDynamicImport","renderStart","resolveDynamicImport","resolveFileUrl","resolveId","resolveImportMeta","shouldTransformCachedModule","transform","writeBundle"];function xp(t,n){for(const e of bp)if(e in t){let r=`plugin ${n}`;t.name&&(r+=` (${t.name})`),r+=` - ${e}`;const a=function(...s){$n(r,4);const o=i.apply(this,s);return xn(r,4),o};let i;typeof t[e].handler=="function"?(i=t[e].handler,t[e].handler=a):(i=t[e],t[e]=a)}return t}function Ke(t){t.isExecuted=!0;const n=[t],e=new Set;for(const r of n)for(const a of[...r.dependencies,...r.implicitlyLoadedBefore])a instanceof fn||a.isExecuted||!a.info.moduleSideEffects&&!r.implicitlyLoadedBefore.has(a)||e.has(a.id)||(a.isExecuted=!0,e.add(a.id),n.push(a))}const bl={identifier:null,localName:_e};function Ni(t,n,e,r,a=new Map){const i=a.get(n);if(i){if(i.has(t))return r?[null]:L((s=n,o=t.id,{code:ed,exporter:o,message:`"${s}" cannot be exported from "${W(o)}" as it is a reexport that references itself.`}));i.add(t)}else a.set(n,new Set([t]));var s,o;return t.getVariableForExportName(n,{importerForSideEffects:e,isExportAllSearch:r,searchedNamesAndModules:a})}function xl(t,n){const e=zn(n.sideEffectDependenciesByVariable,t,Nt);let r=t;const a=new Set([r]);for(;;){const i=r.module;if(r=r instanceof it?r.getDirectOriginalVariable():r instanceof Nn?r.syntheticNamespace:null,!r||a.has(r))break;a.add(r),e.add(i);const s=i.sideEffectDependenciesByVariable.get(r);if(s)for(const o of s)e.add(o)}return e}class hn{constructor(n,e,r,a,i,s,o,l){this.graph=n,this.id=e,this.options=r,this.alternativeReexportModules=new Map,this.chunkFileNames=new Set,this.chunkNames=[],this.cycles=new Set,this.dependencies=new Set,this.dynamicDependencies=new Set,this.dynamicImporters=[],this.dynamicImports=[],this.execIndex=1/0,this.implicitlyLoadedAfter=new Set,this.implicitlyLoadedBefore=new Set,this.importDescriptions=new Map,this.importMetas=[],this.importedFromNotTreeshaken=!1,this.importers=[],this.includedDynamicImporters=[],this.includedImports=new Set,this.isExecuted=!1,this.isUserDefinedEntryPoint=!1,this.needsExportShim=!1,this.sideEffectDependenciesByVariable=new Map,this.sourcesWithAssertions=new Map,this.allExportNames=null,this.ast=null,this.exportAllModules=[],this.exportAllSources=new Set,this.exportNamesByVariable=null,this.exportShimVariable=new pp(this),this.exports=new Map,this.namespaceReexportsByName=new Map,this.reexportDescriptions=new Map,this.relevantDependencies=null,this.syntheticExports=new Map,this.syntheticNamespace=null,this.transformDependencies=[],this.transitiveReexports=null,this.excludeFromSourcemap=/\0/.test(e),this.context=r.moduleContext(e),this.preserveSignature=this.options.preserveEntrySignatures;const c=this,{dynamicImports:u,dynamicImporters:f,exportAllSources:m,exports:h,implicitlyLoadedAfter:b,implicitlyLoadedBefore:p,importers:g,reexportDescriptions:x,sourcesWithAssertions:k}=this;this.info={assertions:l,ast:null,code:null,get dynamicallyImportedIdResolutions(){return u.map(({argument:y})=>typeof y=="string"&&c.resolvedIds[y]).filter(Boolean)},get dynamicallyImportedIds(){return u.map(({id:y})=>y).filter(y=>y!=null)},get dynamicImporters(){return f.sort()},get exportedBindings(){const y={".":[...h.keys()]};for(const[v,{source:$}]of x)(y[$]??(y[$]=[])).push(v);for(const v of m)(y[v]??(y[v]=[])).push("*");return y},get exports(){return[...h.keys(),...x.keys(),...[...m].map(()=>"*")]},get hasDefaultExport(){return c.ast?c.exports.has("default")||x.has("default"):null},get hasModuleSideEffects(){return Gt("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.",Us,!0,r),this.moduleSideEffects},id:e,get implicitlyLoadedAfterOneOf(){return Array.from(b,Li).sort()},get implicitlyLoadedBefore(){return Array.from(p,Li).sort()},get importedIdResolutions(){return Array.from(k.keys(),y=>c.resolvedIds[y]).filter(Boolean)},get importedIds(){return Array.from(k.keys(),y=>{var v;return(v=c.resolvedIds[y])==null?void 0:v.id}).filter(Boolean)},get importers(){return g.sort()},isEntry:a,isExternal:!1,get isIncluded(){return n.phase!==wt.GENERATE?null:c.isIncluded()},meta:{...o},moduleSideEffects:i,syntheticNamedExports:s},Object.defineProperty(this.info,"hasModuleSideEffects",{enumerable:!1})}basename(){const n=ft(this.id),e=xt(this.id);return za(e?n.slice(0,-e.length):n)}bindReferences(){this.ast.bind()}error(n,e){return this.addLocationToLogProps(n,e),L(n)}estimateSize(){let n=0;for(const e of this.ast.body)e.included&&(n+=e.end-e.start);return n}getAllExportNames(){if(this.allExportNames)return this.allExportNames;this.allExportNames=new Set([...this.exports.keys(),...this.reexportDescriptions.keys()]);for(const n of this.exportAllModules)if(n instanceof fn)this.allExportNames.add(`*${n.id}`);else for(const e of n.getAllExportNames())e!=="default"&&this.allExportNames.add(e);return typeof this.info.syntheticNamedExports=="string"&&this.allExportNames.delete(this.info.syntheticNamedExports),this.allExportNames}getDependenciesToBeIncluded(){if(this.relevantDependencies)return this.relevantDependencies;this.relevantDependencies=new Set;const n=new Set,e=new Set,r=new Set(this.includedImports);if(this.info.isEntry||this.includedDynamicImporters.length>0||this.namespace.included||this.implicitlyLoadedAfter.size>0)for(const a of[...this.getReexports(),...this.getExports()]){const[i]=this.getVariableForExportName(a);i&&r.add(i)}for(let a of r){const i=this.sideEffectDependenciesByVariable.get(a);if(i)for(const s of i)e.add(s);a instanceof Nn?a=a.getBaseVariable():a instanceof it&&(a=a.getOriginalVariable()),n.add(a.module)}if(this.options.treeshake&&this.info.moduleSideEffects!=="no-treeshake")this.addRelevantSideEffectDependencies(this.relevantDependencies,n,e);else for(const a of this.dependencies)this.relevantDependencies.add(a);for(const a of n)this.relevantDependencies.add(a);return this.relevantDependencies}getExportNamesByVariable(){if(this.exportNamesByVariable)return this.exportNamesByVariable;const n=new Map;for(const e of this.getAllExportNames()){let[r]=this.getVariableForExportName(e);if(r instanceof it&&(r=r.getOriginalVariable()),!r||!(r.included||r instanceof yr))continue;const a=n.get(r);a?a.push(e):n.set(r,[e])}return this.exportNamesByVariable=n}getExports(){return[...this.exports.keys()]}getReexports(){if(this.transitiveReexports)return this.transitiveReexports;this.transitiveReexports=[];const n=new Set(this.reexportDescriptions.keys());for(const e of this.exportAllModules)if(e instanceof fn)n.add(`*${e.id}`);else for(const r of[...e.getReexports(),...e.getExports()])r!=="default"&&n.add(r);return this.transitiveReexports=[...n]}getRenderedExports(){const n=[],e=[];for(const r of this.exports.keys()){const[a]=this.getVariableForExportName(r);(a&&a.included?n:e).push(r)}return{removedExports:e,renderedExports:n}}getSyntheticNamespace(){return this.syntheticNamespace===null&&(this.syntheticNamespace=void 0,[this.syntheticNamespace]=this.getVariableForExportName(typeof this.info.syntheticNamedExports=="string"?this.info.syntheticNamedExports:"default",{onlyExplicit:!0})),this.syntheticNamespace?this.syntheticNamespace:L((n=this.id,e=this.info.syntheticNamedExports,{code:"SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT",exporter:n,message:`Module "${W(n)}" that is marked with \`syntheticNamedExports: ${JSON.stringify(e)}\` needs ${typeof e=="string"&&e!=="default"?`an explicit export named "${e}"`:"a default export"} that does not reexport an unresolved named export of the same module.`}));var n,e}getVariableForExportName(n,{importerForSideEffects:e,isExportAllSearch:r,onlyExplicit:a,searchedNamesAndModules:i}=Gn){if(n[0]==="*")return n.length===1?[this.namespace]:this.graph.modulesById.get(n.slice(1)).getVariableForExportName("*");const s=this.reexportDescriptions.get(n);if(s){const[l]=Ni(s.module,s.localName,e,!1,i);return l?(e&&(vl(l,e,this),this.info.moduleSideEffects&&zn(e.sideEffectDependenciesByVariable,l,Nt).add(this)),[l]):this.error($r(s.localName,this.id,s.module.id),s.start)}const o=this.exports.get(n);if(o){if(o===bl)return[this.exportShimVariable];const l=o.localName,c=this.traceVariable(l,{importerForSideEffects:e,searchedNamesAndModules:i});return e&&(vl(c,e,this),zn(e.sideEffectDependenciesByVariable,c,Nt).add(this)),[c]}if(a)return[null];if(n!=="default"){const l=this.namespaceReexportsByName.get(n)??this.getVariableFromNamespaceReexports(n,e,i);if(this.namespaceReexportsByName.set(n,l),l[0])return l}return this.info.syntheticNamedExports?[zn(this.syntheticExports,n,()=>new Nn(this.astContext,n,this.getSyntheticNamespace()))]:!r&&this.options.shimMissingExports?(this.shimMissingExport(n),[this.exportShimVariable]):[null]}hasEffects(){return this.info.moduleSideEffects==="no-treeshake"||this.ast.hasCachedEffects()}include(){const n=Wa();this.ast.shouldBeIncluded(n)&&this.ast.include(n,!1)}includeAllExports(n){this.isExecuted||(Ke(this),this.graph.needsTreeshakingPass=!0);for(const e of this.exports.keys())if(n||e!==this.info.syntheticNamedExports){const r=this.getVariableForExportName(e)[0];r.deoptimizePath(nn),r.included||this.includeVariable(r)}for(const e of this.getReexports()){const[r]=this.getVariableForExportName(e);r&&(r.deoptimizePath(nn),r.included||this.includeVariable(r),r instanceof yr&&(r.module.reexported=!0))}n&&this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())}includeAllInBundle(){this.ast.include(Wa(),!0),this.includeAllExports(!1)}includeExportsByNames(n){this.isExecuted||(Ke(this),this.graph.needsTreeshakingPass=!0);let e=!1;for(const r of n){const a=this.getVariableForExportName(r)[0];a&&(a.deoptimizePath(nn),a.included||this.includeVariable(a)),this.exports.has(r)||this.reexportDescriptions.has(r)||(e=!0)}e&&this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())}isIncluded(){return this.ast&&(this.ast.included||this.namespace.included||this.importedFromNotTreeshaken||this.exportShimVariable.included)}linkImports(){this.addModulesToImportDescriptions(this.importDescriptions),this.addModulesToImportDescriptions(this.reexportDescriptions);const n=[];for(const e of this.exportAllSources){const r=this.graph.modulesById.get(this.resolvedIds[e].id);r instanceof fn?n.push(r):this.exportAllModules.push(r)}this.exportAllModules.push(...n)}log(n,e,r){this.addLocationToLogProps(e,r),this.options.onLog(n,e)}render(n){const e=this.magicString.clone();this.ast.render(e,n),e.trim();const{usesTopLevelAwait:r}=this.astContext;return r&&n.format!=="es"&&n.format!=="system"?L((a=this.id,i=n.format,{code:"INVALID_TLA_FORMAT",id:a,message:`Module format "${i}" does not support top-level await. Use the "es" or "system" output formats rather.`})):{source:e,usesTopLevelAwait:r};var a,i}setSource({ast:n,code:e,customTransformCache:r,originalCode:a,originalSourcemap:i,resolvedIds:s,sourcemapChain:o,transformDependencies:l,transformFiles:c,...u}){$n("generate ast",3),this.info.code=e,this.originalCode=a,this.originalSourcemap=i,this.sourcemapChain=o,c&&(this.transformFiles=c),this.transformDependencies=l,this.customTransformCache=r,this.updateOptions(u);const f=n??this.tryParse();xn("generate ast",3),$n("analyze ast",3),this.resolvedIds=s??Object.create(null);const m=this.id;this.magicString=new Lt(e,{filename:this.excludeFromSourcemap?null:m,indentExclusionRanges:[]}),this.astContext={addDynamicImport:this.addDynamicImport.bind(this),addExport:this.addExport.bind(this),addImport:this.addImport.bind(this),addImportMeta:this.addImportMeta.bind(this),code:e,deoptimizationTracker:this.graph.deoptimizationTracker,error:this.error.bind(this),fileName:m,getExports:this.getExports.bind(this),getModuleExecIndex:()=>this.execIndex,getModuleName:this.basename.bind(this),getNodeConstructor:h=>pl[h]||pl.UnknownNode,getReexports:this.getReexports.bind(this),importDescriptions:this.importDescriptions,includeAllExports:()=>this.includeAllExports(!0),includeDynamicImport:this.includeDynamicImport.bind(this),includeVariableInModule:this.includeVariableInModule.bind(this),log:this.log.bind(this),magicString:this.magicString,manualPureFunctions:this.graph.pureFunctions,module:this,moduleContext:this.context,options:this.options,requestTreeshakingPass:()=>this.graph.needsTreeshakingPass=!0,traceExport:h=>this.getVariableForExportName(h)[0],traceVariable:this.traceVariable.bind(this),usesTopLevelAwait:!1},this.scope=new ml(this.graph.scope,this.astContext),this.namespace=new Xe(this.astContext),this.ast=new cl(f,{context:this.astContext,type:"Module"},this.scope),n||this.options.cache!==!1?this.info.ast=f:Object.defineProperty(this.info,"ast",{get:()=>{if(this.graph.astLru.has(m))return this.graph.astLru.get(m);{const h=this.tryParse();return this.graph.astLru.set(m,h),h}}}),xn("analyze ast",3)}toJSON(){return{assertions:this.info.assertions,ast:this.info.ast,code:this.info.code,customTransformCache:this.customTransformCache,dependencies:Array.from(this.dependencies,Li),id:this.id,meta:this.info.meta,moduleSideEffects:this.info.moduleSideEffects,originalCode:this.originalCode,originalSourcemap:this.originalSourcemap,resolvedIds:this.resolvedIds,sourcemapChain:this.sourcemapChain,syntheticNamedExports:this.info.syntheticNamedExports,transformDependencies:this.transformDependencies,transformFiles:this.transformFiles}}traceVariable(n,{importerForSideEffects:e,isExportAllSearch:r,searchedNamesAndModules:a}=Gn){const i=this.scope.variables.get(n);if(i)return i;const s=this.importDescriptions.get(n);if(s){const o=s.module;if(o instanceof hn&&s.name==="*")return o.namespace;const[l]=Ni(o,s.name,e||this,r,a);return l||this.error($r(s.name,this.id,o.id),s.start)}return null}updateOptions({meta:n,moduleSideEffects:e,syntheticNamedExports:r}){e!=null&&(this.info.moduleSideEffects=e),r!=null&&(this.info.syntheticNamedExports=r),n!=null&&Object.assign(this.info.meta,n)}addDynamicImport(n){let e=n.source;e instanceof ul?e.quasis.length===1&&e.quasis[0].value.cooked&&(e=e.quasis[0].value.cooked):e instanceof Xt&&typeof e.value=="string"&&(e=e.value),this.dynamicImports.push({argument:e,id:null,node:n,resolution:null})}addExport(n){if(n instanceof Gr)this.exports.set("default",{identifier:n.variable.getAssignedVariableName(),localName:"default"});else if(n instanceof yi){const e=n.source.value;if(this.addSource(e,n),n.exported){const r=n.exported.name;this.reexportDescriptions.set(r,{localName:"*",module:null,source:e,start:n.start})}else this.exportAllSources.add(e)}else if(n.source instanceof Xt){const e=n.source.value;this.addSource(e,n);for(const{exported:r,local:a,start:i}of n.specifiers){const s=r instanceof Xt?r.value:r.name;this.reexportDescriptions.set(s,{localName:a instanceof Xt?a.value:a.name,module:null,source:e,start:i})}}else if(n.declaration){const e=n.declaration;if(e instanceof dl)for(const r of e.declarations)for(const a of wd(r.id))this.exports.set(a,{identifier:null,localName:a});else{const r=e.id.name;this.exports.set(r,{identifier:null,localName:r})}}else for(const{local:e,exported:r}of n.specifiers){const a=e.name,i=r instanceof _n?r.name:r.value;this.exports.set(i,{identifier:null,localName:a})}}addImport(n){const e=n.source.value;this.addSource(e,n);for(const r of n.specifiers){const a=r instanceof Yo?"default":r instanceof ol?"*":r.imported instanceof _n?r.imported.name:r.imported.value;this.importDescriptions.set(r.local.name,{module:null,name:a,source:e,start:r.start})}}addImportMeta(n){this.importMetas.push(n)}addLocationToLogProps(n,e){n.id=this.id,n.pos=e;let r=this.info.code;const a=Ga(r,e,{offsetLine:1});if(a){let{column:i,line:s}=a;try{({column:i,line:s}=function(o,l){const c=o.filter(u=>!!u.mappings);n:for(;c.length>0;){const u=c.pop().mappings[l.line-1];if(u){const f=u.filter(h=>h.length>1),m=f[f.length-1];for(const h of f)if(h[0]>=l.column||h===m){l={column:h[3],line:h[2]+1};continue n}}throw new Error("Can't resolve original location of error.")}return l}(this.sourcemapChain,{column:i,line:s})),r=this.originalCode}catch(o){this.options.onLog(V,function(l,c,u,f,m){return{cause:l,code:"SOURCEMAP_ERROR",id:c,loc:{column:u,file:c,line:f},message:`Error when using sourcemap for reporting an error: ${l.message}`,pos:m}}(o,this.id,i,s,e))}xr(n,{column:i,line:s},r,this.id)}}addModulesToImportDescriptions(n){for(const e of n.values()){const{id:r}=this.resolvedIds[e.source];e.module=this.graph.modulesById.get(r)}}addRelevantSideEffectDependencies(n,e,r){const a=new Set,i=s=>{for(const o of s)a.has(o)||(a.add(o),e.has(o)?n.add(o):(o.info.moduleSideEffects||r.has(o))&&(o instanceof fn||o.hasEffects()?n.add(o):i(o.dependencies)))};i(this.dependencies),i(r)}addSource(n,e){const r=(a=e.assertions,a!=null&&a.length?Object.fromEntries(a.map(s=>[Ti(s),s.value.value])):Gn);var a;const i=this.sourcesWithAssertions.get(n);i?Xr(i,r)&&this.log(V,vr(i,r,n,this.id),e.start):this.sourcesWithAssertions.set(n,r)}getVariableFromNamespaceReexports(n,e,r){let a=null;const i=new Map,s=new Set;for(const u of this.exportAllModules){if(u.info.syntheticNamedExports===n)continue;const[f,m]=Ni(u,n,e,!0,vp(r));u instanceof fn||m?s.add(f):f instanceof Nn?a||(a=f):f&&i.set(f,u)}if(i.size>0){const u=[...i],f=u[0][0];return u.length===1?[f]:(this.options.onLog(V,(o=n,l=this.id,c=u.map(([,m])=>m.id),{binding:o,code:"NAMESPACE_CONFLICT",ids:c,message:`Conflicting namespaces: "${W(l)}" re-exports "${o}" from one of the modules ${mt(c.map(m=>W(m)))} (will be ignored).`,reexporter:l})),[null])}var o,l,c;if(s.size>0){const u=[...s],f=u[0];return u.length>1&&this.options.onLog(V,function(m,h,b,p){return{binding:m,code:"AMBIGUOUS_EXTERNAL_NAMESPACES",ids:p,message:`Ambiguous external namespace resolution: "${W(h)}" re-exports "${m}" from one of the external modules ${mt(p.map(g=>W(g)))}, guessing "${W(b)}".`,reexporter:h}}(n,this.id,f.module.id,u.map(m=>m.module.id))),[f,!0]}return a?[a]:[null]}includeAndGetAdditionalMergedNamespaces(){const n=new Set,e=new Set;for(const r of[this,...this.exportAllModules])if(r instanceof fn){const[a]=r.getVariableForExportName("*");a.include(),this.includedImports.add(a),n.add(a)}else if(r.info.syntheticNamedExports){const a=r.getSyntheticNamespace();a.include(),this.includedImports.add(a),e.add(a)}return[...e,...n]}includeDynamicImport(n){const e=this.dynamicImports.find(r=>r.node===n).resolution;if(e instanceof hn){e.includedDynamicImporters.push(this);const r=this.options.treeshake?n.getDeterministicImportedNames():void 0;r?e.includeExportsByNames(r):e.includeAllExports(!0)}}includeVariable(n){const e=n.module;if(n.included)e instanceof hn&&e!==this&&xl(n,this);else if(n.include(),this.graph.needsTreeshakingPass=!0,e instanceof hn&&(e.isExecuted||Ke(e),e!==this)){const r=xl(n,this);for(const a of r)a.isExecuted||Ke(a)}}includeVariableInModule(n){this.includeVariable(n);const e=n.module;e&&e!==this&&this.includedImports.add(n)}shimMissingExport(n){var e,r;this.options.onLog(V,(e=this.id,{binding:r=n,code:"SHIMMED_EXPORT",exporter:e,message:`Missing export "${r}" has been shimmed in module "${W(e)}".`})),this.exports.set(n,bl)}tryParse(){try{return this.graph.contextParse(this.info.code)}catch(n){return this.error(function(e,r){let a=e.message.replace(/ \(\d+:\d+\)$/,"");return r.endsWith(".json")?a+=" (Note that you need @rollup/plugin-json to import JSON files)":r.endsWith(".js")||(a+=" (Note that you need plugins to import files that are not JavaScript)"),{cause:e,code:"PARSE_ERROR",id:r,message:a}}(n,this.id),n.pos)}}}function vl(t,n,e){if(t.module instanceof hn&&t.module!==e){const r=t.module.cycles;if(r.size>0){const a=e.cycles;for(const i of a)if(r.has(i)){n.alternativeReexportModules.set(t,e);break}}}}const vp=t=>t&&new Map(Array.from(t,([n,e])=>[n,new Set(e)]));function $l(t){return t.endsWith(".js")?t.slice(0,-3):t}function kl(t,n){return t.autoId?`${t.basePath?t.basePath+"/":""}${$l(n)}`:t.id??""}function Wr(t,n,e,r,a,i,s,o="return "){const{_:l,getDirectReturnFunction:c,getFunctionIntro:u,getPropertyAccess:f,n:m,s:h}=a;if(!e)return`${m}${m}${o}${function(p,g,x,k,y){if(p.length>0)return p[0].local;for(const{defaultVariableName:v,importPath:$,isChunk:w,name:S,namedExportsMode:I,namespaceVariableName:C,reexports:B}of g)if(B)return Cl(S,B[0].imported,I,w,v,C,x,$,k,y)}(t,n,r,s,f)};`;let b="";for(const{defaultVariableName:p,importPath:g,isChunk:x,name:k,namedExportsMode:y,namespaceVariableName:v,reexports:$}of n)if($&&e){for(const w of $)if(w.reexported!=="*"){const S=Cl(k,w.imported,y,x,p,v,r,g,s,f);if(b&&(b+=m),w.imported!=="*"&&w.needsLiveBinding){const[I,C]=c([],{functionReturn:!0,lineBreakIndent:null,name:null});b+=`Object.defineProperty(exports,${l}'${w.reexported}',${l}{${m}${i}enumerable:${l}true,${m}${i}get:${l}${I}${S}${C}${m}});`}else b+=`exports${f(w.reexported)}${l}=${l}${S};`}}for(const{exported:p,local:g}of t){const x=`exports${f(p)}`;x!==g&&(b&&(b+=m),b+=`${x}${l}=${l}${g};`)}for(const{name:p,reexports:g}of n)if(g&&e){for(const x of g)if(x.reexported==="*"){b&&(b+=m);const k=`{${m}${i}if${l}(k${l}!==${l}'default'${l}&&${l}!exports.hasOwnProperty(k))${l}${$p(p,x.needsLiveBinding,i,a)}${h}${m}}`;b+=`Object.keys(${p}).forEach(${u(["k"],{isAsync:!1,name:null})}${k});`}}return b?`${m}${m}${b}`:""}function Cl(t,n,e,r,a,i,s,o,l,c){if(n==="default"){if(!r){const u=s(o),f=Rr[u]?a:t;return Vr(u,l)?`${f}${c("default")}`:f}return e?`${t}${c("default")}`:t}return n==="*"?(r?!e:Re[s(o)])?i:t:`${t}${c(n)}`}function El(t){return t([["value","true"]],{lineBreakIndent:null})}function Kr(t,n,e,{_:r,getObject:a}){if(t){if(n)return e?`Object.defineProperties(exports,${r}${a([["__esModule",El(a)],[null,`[Symbol.toStringTag]:${r}${Ve(a)}`]],{lineBreakIndent:null})});`:`Object.defineProperty(exports,${r}'__esModule',${r}${El(a)});`;if(e)return`Object.defineProperty(exports,${r}Symbol.toStringTag,${r}${Ve(a)});`}return""}const $p=(t,n,e,{_:r,getDirectReturnFunction:a,n:i})=>{if(n){const[s,o]=a([],{functionReturn:!0,lineBreakIndent:null,name:null});return`Object.defineProperty(exports,${r}k,${r}{${i}${e}${e}enumerable:${r}true,${i}${e}${e}get:${r}${s}${t}[k]${o}${i}${e}})`}return`exports[k]${r}=${r}${t}[k]`};function Hr(t,n,e,r,a,i,s,o){const{_:l,cnst:c,n:u}=o,f=new Set,m=[],h=(b,p,g)=>{f.add(p),m.push(`${c} ${b}${l}=${l}/*#__PURE__*/${p}(${g});`)};for(const{defaultVariableName:b,imports:p,importPath:g,isChunk:x,name:k,namedExportsMode:y,namespaceVariableName:v,reexports:$}of t)if(x){for(const{imported:w,reexported:S}of[...p||[],...$||[]])if(w==="*"&&S!=="*"){y||h(v,Ue,k);break}}else{const w=n(g);let S=!1,I=!1;for(const{imported:C,reexported:B}of[...p||[],...$||[]]){let U,D;C==="default"?S||(S=!0,b!==v&&(D=b,U=Rr[w])):C!=="*"||B==="*"||I||(I=!0,U=Re[w],D=v),U&&h(D,U,k)}}return`${$i(f,i,s,o,e,r,a)}${m.length>0?`${m.join(u)}${u}${u}`:""}`}function Al(t,n){return t[0]!=="."?t:n?(e=t).endsWith(".js")?e:e+".js":$l(t);var e}const kp=new Set([...ks(["assert","async_hooks","buffer","child_process","cluster","console","constants","crypto","dgram","diagnostics_channel","dns","domain","events","fs","http","http2","https","inspector","module","net","os","path","perf_hooks","process","punycode","querystring","readline","repl","stream","string_decoder","timers","tls","trace_events","tty","url","util","v8","vm","wasi","worker_threads","zlib"]),"assert/strict","dns/promises","fs/promises","path/posix","path/win32","readline/promises","stream/consumers","stream/promises","stream/web","timers/promises","util/types"]);function Di(t,n){const e=n.map(({importPath:r})=>r).filter(r=>kp.has(r)||r.startsWith("node:"));e.length!==0&&t(V,function(r){return{code:md,ids:r,message:`Creating a browser bundle that depends on Node.js built-in modules (${mt(r)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`}}(e))}const Yr=(t,n)=>t.split(".").map(n).join("");function Oi(t,n,e,r,{_:a,getPropertyAccess:i}){const s=t.split(".");s[0]=(typeof e=="function"?e(s[0]):e[s[0]])||s[0];const o=s.pop();let l=n,c=[...s.map(u=>(l+=i(u),`${l}${a}=${a}${l}${a}||${a}{}`)),`${l}${i(o)}`].join(`,${a}`)+`${a}=${a}${r}`;return s.length>0&&(c=`(${c})`),c}function wl(t){let n=t.length;for(;n--;){const{imports:e,reexports:r}=t[n];if(e||r)return t.slice(0,n+1)}return[]}const Cp=({dependencies:t,exports:n})=>{const e=new Set(n.map(r=>r.exported));e.add("default");for(const{reexports:r}of t)if(r)for(const a of r)a.reexported!=="*"&&e.add(a.reexported);return e},Ep=(t,n,{_:e,cnst:r,getObject:a,n:i})=>t?`${i}${n}${r} _starExcludes${e}=${e}${a([...t].map(s=>[s,"1"]),{lineBreakIndent:{base:n,t:n}})};`:"",Ap=(t,n,{_:e,n:r})=>t.length>0?`${r}${n}var ${t.join(`,${e}`)};`:"",wp=(t,n,e)=>zi(t.filter(r=>r.hoisted).map(r=>({name:r.exported,value:r.local})),n,e);function zi(t,n,{_:e,n:r}){return t.length===0?"":t.length===1?`exports('${t[0].name}',${e}${t[0].value});${r}${r}`:`exports({${r}`+t.map(({name:a,value:i})=>`${n}${a}:${e}${i}`).join(`,${r}`)+`${r}});${r}${r}`}const Sp=(t,n,e)=>zi(t.filter(r=>r.expression).map(r=>({name:r.exported,value:r.local})),n,e),Bp=(t,n,e)=>zi(t.filter(r=>r.local===_e).map(r=>({name:r.exported,value:_e})),n,e);function Gi(t,n,e){return t?`${n}${Yr(t,e)}`:"null"}var Ip={amd:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,id:s,indent:o,intro:l,isEntryFacade:c,isModuleFacade:u,namedExportsMode:f,log:m,outro:h,snippets:b},{amd:p,esModule:g,externalLiveBindings:x,freeze:k,interop:y,namespaceToStringTag:v,strict:$}){Di(m,e);const w=e.map(E=>`'${Al(E.importPath,p.forceJsExtensionForImports)}'`),S=e.map(E=>E.name),{n:I,getNonArrowFunctionIntro:C,_:B}=b;f&&i&&(S.unshift("exports"),w.unshift("'exports'")),n.has("require")&&(S.unshift("require"),w.unshift("'require'")),n.has("module")&&(S.unshift("module"),w.unshift("'module'"));const U=kl(p,s),D=(U?`'${U}',${B}`:"")+(w.length>0?`[${w.join(`,${B}`)}],${B}`:""),F=$?`${B}'use strict';`:"";t.prepend(`${l}${Hr(e,y,x,k,v,n,o,b)}`);const N=Wr(r,e,f,y,b,o,x);let z=Kr(f&&i,c&&(g===!0||g==="if-default-prop"&&a),u&&v,b);z&&(z=I+I+z),t.append(`${N}${z}${h}`).indent(o).prepend(`${p.define}(${D}(${C(S,{isAsync:!1,name:null})}{${F}${I}${I}`).append(`${I}${I}}));`)},cjs:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,indent:s,intro:o,isEntryFacade:l,isModuleFacade:c,namedExportsMode:u,outro:f,snippets:m},{compact:h,esModule:b,externalLiveBindings:p,freeze:g,interop:x,namespaceToStringTag:k,strict:y}){const{_:v,n:$}=m,w=y?`'use strict';${$}${$}`:"";let S=Kr(u&&i,l&&(b===!0||b==="if-default-prop"&&a),c&&k,m);S&&(S+=$+$);const I=function(U,{_:D,cnst:F,n:N},z){let E="",j=!1;for(const{importPath:G,name:Y,reexports:rn,imports:an}of U)rn||an?(E+=z&&j?",":`${E?`;${N}`:""}${F} `,j=!0,E+=`${Y}${D}=${D}require('${G}')`):(E&&(E+=z&&!j?",":`;${N}`),j=!1,E+=`require('${G}')`);return E?`${E};${N}${N}`:""}(e,m,h),C=Hr(e,x,p,g,k,n,s,m);t.prepend(`${w}${o}${S}${I}${C}`);const B=Wr(r,e,u,x,m,s,p,`module.exports${v}=${v}`);t.append(`${B}${f}`)},es:function(t,{accessedGlobals:n,indent:e,intro:r,outro:a,dependencies:i,exports:s,snippets:o},{externalLiveBindings:l,freeze:c,namespaceToStringTag:u}){const{n:f}=o,m=function(b,{_:p}){const g=[];for(const{importPath:x,reexports:k,imports:y,name:v,assertions:$}of b){const w=`'${x}'${$?`${p}assert${p}${$}`:""};`;if(k||y){if(y){let S=null,I=null;const C=[];for(const B of y)B.imported==="default"?S=B:B.imported==="*"?I=B:C.push(B);I&&g.push(`import${p}*${p}as ${I.local} from${p}${w}`),S&&C.length===0?g.push(`import ${S.local} from${p}${w}`):C.length>0&&g.push(`import ${S?`${S.local},${p}`:""}{${p}${C.map(B=>B.imported===B.local?B.imported:`${B.imported} as ${B.local}`).join(`,${p}`)}${p}}${p}from${p}${w}`)}if(k){let S=null;const I=[],C=[];for(const B of k)B.reexported==="*"?S=B:B.imported==="*"?I.push(B):C.push(B);if(S&&g.push(`export${p}*${p}from${p}${w}`),I.length>0){y&&y.some(B=>B.imported==="*"&&B.local===v)||g.push(`import${p}*${p}as ${v} from${p}${w}`);for(const B of I)g.push(`export${p}{${p}${v===B.reexported?v:`${v} as ${B.reexported}`} };`)}C.length>0&&g.push(`export${p}{${p}${C.map(B=>B.imported===B.reexported?B.imported:`${B.imported} as ${B.reexported}`).join(`,${p}`)}${p}}${p}from${p}${w}`)}}else g.push(`import${p}${w}`)}return g}(i,o);m.length>0&&(r+=m.join(f)+f+f),(r+=$i(null,n,e,o,l,c,u))&&t.prepend(r);const h=function(b,{_:p,cnst:g}){const x=[],k=[];for(const y of b)y.expression&&x.push(`${g} ${y.local}${p}=${p}${y.expression};`),k.push(y.exported===y.local?y.local:`${y.local} as ${y.exported}`);return k.length>0&&x.push(`export${p}{${p}${k.join(`,${p}`)}${p}};`),x}(s,o);h.length>0&&t.append(f+f+h.join(f).trim()),a&&t.append(a),t.trim()},iife:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,indent:s,intro:o,namedExportsMode:l,log:c,outro:u,snippets:f},{compact:m,esModule:h,extend:b,freeze:p,externalLiveBindings:g,globals:x,interop:k,name:y,namespaceToStringTag:v,strict:$}){const{_:w,getNonArrowFunctionIntro:S,getPropertyAccess:I,n:C}=f,B=y&&y.includes("."),U=!b&&!B;if(y&&U&&(Os(D=y)||Ds.test(D)))return L(function(ln){return{code:sd,message:`Given name "${ln}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`,url:En(Xm)}}(y));var D;Di(c,e);const F=wl(e),N=F.map(ln=>ln.globalName||"null"),z=F.map(ln=>ln.name);i&&!y&&c(V,{code:Xs,message:'If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.',url:En(Ps)}),l&&i&&(b?(N.unshift(`this${Yr(y,I)}${w}=${w}this${Yr(y,I)}${w}||${w}{}`),z.unshift("exports")):(N.unshift("{}"),z.unshift("exports")));const E=$?`${s}'use strict';${C}`:"",j=Hr(e,k,g,p,v,n,s,f);t.prepend(`${o}${j}`);let G=`(${S(z,{isAsync:!1,name:null})}{${C}${E}${C}`;i&&(!y||b&&l||(G=(U?`var ${y}`:`this${Yr(y,I)}`)+`${w}=${w}${G}`),B&&(G=function(ln,cn,An,{_:sn,getPropertyAccess:In,s:Jt},jn){const wn=ln.split(".");wn[0]=(typeof An=="function"?An(wn[0]):An[wn[0]])||wn[0],wn.pop();let he=cn;return wn.map(fs=>(he+=In(fs),`${he}${sn}=${sn}${he}${sn}||${sn}{}${Jt}`)).join(jn?",":`
`)+(jn&&wn.length>0?";":`
`)}(y,"this",x,f,m)+G));let Y=`${C}${C}})(${N.join(`,${w}`)});`;i&&!b&&l&&(Y=`${C}${C}${s}return exports;${Y}`);const rn=Wr(r,e,l,k,f,s,g);let an=Kr(l&&i,h===!0||h==="if-default-prop"&&a,v,f);an&&(an=C+C+an),t.append(`${rn}${an}${u}`).indent(s).prepend(G).append(Y)},system:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasExports:a,indent:i,intro:s,snippets:o,outro:l,usesTopLevelAwait:c},{externalLiveBindings:u,freeze:f,name:m,namespaceToStringTag:h,strict:b,systemNullSetters:p}){const{_:g,getFunctionIntro:x,getNonArrowFunctionIntro:k,n:y,s:v}=o,{importBindings:$,setters:w,starExcludes:S}=function(D,F,N,{_:z,cnst:E,getObject:j,getPropertyAccess:G,n:Y}){const rn=[],an=[];let ln=null;for(const{imports:cn,reexports:An}of D){const sn=[];if(cn)for(const In of cn)rn.push(In.local),In.imported==="*"?sn.push(`${In.local}${z}=${z}module;`):sn.push(`${In.local}${z}=${z}module${G(In.imported)};`);if(An){const In=[];let Jt=!1;for(const{imported:jn,reexported:wn}of An)wn==="*"?Jt=!0:In.push([wn,jn==="*"?"module":`module${G(jn)}`]);if(In.length>1||Jt){const jn=j(In,{lineBreakIndent:null});Jt?(ln||(ln=Cp({dependencies:D,exports:F})),sn.push(`${E} setter${z}=${z}${jn};`,`for${z}(${E} name in module)${z}{`,`${N}if${z}(!_starExcludes[name])${z}setter[name]${z}=${z}module[name];`,"}","exports(setter);")):sn.push(`exports(${jn});`)}else{const[jn,wn]=In[0];sn.push(`exports('${jn}',${z}${wn});`)}}an.push(sn.join(`${Y}${N}${N}${N}`))}return{importBindings:rn,setters:an,starExcludes:ln}}(e,r,i,o),I=m?`'${m}',${g}`:"",C=n.has("module")?["exports","module"]:a?["exports"]:[];let B=`System.register(${I}[`+e.map(({importPath:D})=>`'${D}'`).join(`,${g}`)+`],${g}(${k(C,{isAsync:!1,name:null})}{${y}${i}${b?"'use strict';":""}`+Ep(S,i,o)+Ap($,i,o)+`${y}${i}return${g}{${w.length>0?`${y}${i}${i}setters:${g}[${w.map(D=>D?`${x(["module"],{isAsync:!1,name:null})}{${y}${i}${i}${i}${D}${y}${i}${i}}`:p?"null":`${x([],{isAsync:!1,name:null})}{}`).join(`,${g}`)}],`:""}${y}`;B+=`${i}${i}execute:${g}(${k([],{isAsync:c,name:null})}{${y}${y}`;const U=`${i}${i}})${y}${i}}${v}${y}}));`;t.prepend(s+$i(null,n,i,o,u,f,h)+wp(r,i,o)).append(`${l}${y}${y}`+Sp(r,i,o)+Bp(r,i,o)).indent(`${i}${i}${i}`).append(U).prepend(B)},umd:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,id:s,indent:o,intro:l,namedExportsMode:c,log:u,outro:f,snippets:m},{amd:h,compact:b,esModule:p,extend:g,externalLiveBindings:x,freeze:k,interop:y,name:v,namespaceToStringTag:$,globals:w,noConflict:S,strict:I}){const{_:C,cnst:B,getFunctionIntro:U,getNonArrowFunctionIntro:D,getPropertyAccess:F,n:N,s:z}=m,E=b?"f":"factory",j=b?"g":"global";if(i&&!v)return L({code:Xs,message:'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.',url:En(Ps)});Di(u,e);const G=e.map(Un=>`'${Al(Un.importPath,h.forceJsExtensionForImports)}'`),Y=e.map(Un=>`require('${Un.importPath}')`),rn=wl(e),an=rn.map(Un=>Gi(Un.globalName,j,F)),ln=rn.map(Un=>Un.name);c&&(i||S)&&(G.unshift("'exports'"),Y.unshift("exports"),an.unshift(Oi(v,j,w,(g?`${Gi(v,j,F)}${C}||${C}`:"")+"{}",m)),ln.unshift("exports"));const cn=kl(h,s),An=(cn?`'${cn}',${C}`:"")+(G.length>0?`[${G.join(`,${C}`)}],${C}`:""),sn=h.define,In=!c&&i?`module.exports${C}=${C}`:"",Jt=I?`${C}'use strict';${N}`:"";let jn;if(S){const Un=b?"e":"exports";let ms;!c&&i?ms=`${B} ${Un}${C}=${C}${Oi(v,j,w,`${E}(${an.join(`,${C}`)})`,m)};`:ms=`${B} ${Un}${C}=${C}${an.shift()};${N}${o}${o}${E}(${[Un,...an].join(`,${C}`)});`,jn=`(${U([],{isAsync:!1,name:null})}{${N}${o}${o}${B} current${C}=${C}${function(a1,i1,{_:n_,getPropertyAccess:s1}){let o1=i1;return a1.split(".").map(l1=>o1+=s1(l1)).join(`${n_}&&${n_}`)}(v,j,m)};${N}${o}${o}${ms}${N}${o}${o}${Un}.noConflict${C}=${C}${U([],{isAsync:!1,name:null})}{${C}${Gi(v,j,F)}${C}=${C}current;${C}return ${Un}${z}${C}};${N}${o}})()`}else jn=`${E}(${an.join(`,${C}`)})`,!c&&i&&(jn=Oi(v,j,w,jn,m));const wn=i||S&&c||an.length>0,he=[E];wn&&he.unshift(j);const fs=wn?`this,${C}`:"",Zg=wn?`(${j}${C}=${C}typeof globalThis${C}!==${C}'undefined'${C}?${C}globalThis${C}:${C}${j}${C}||${C}self,${C}`:"",Qg=wn?")":"",n1=wn?`${o}typeof exports${C}===${C}'object'${C}&&${C}typeof module${C}!==${C}'undefined'${C}?${C}${In}${E}(${Y.join(`,${C}`)})${C}:${N}`:"",t1=`(${D(he,{isAsync:!1,name:null})}{${N}`+n1+`${o}typeof ${sn}${C}===${C}'function'${C}&&${C}${sn}.amd${C}?${C}${sn}(${An}${E})${C}:${N}${o}${Zg}${jn}${Qg};${N}})(${fs}(${D(ln,{isAsync:!1,name:null})}{${Jt}${N}`,e1=N+N+"}));";t.prepend(`${l}${Hr(e,y,x,k,$,n,o,m)}`);const r1=Wr(r,e,c,y,m,o,x);let ha=Kr(c&&i,p===!0||p==="if-default-prop"&&a,$,m);ha&&(ha=N+N+ha),t.append(`${r1}${ha}${f}`).trim().indent(o).append(e1).prepend(t1)}};const Sl=(t,n)=>n?`${t}
${n}`:t,Bl=(t,n)=>n?`${t}

${n}`:t;async function jp(t,n,e){try{let[s,o,l,c]=await Promise.all([n.hookReduceValue("banner",t.banner(e),[e],Sl),n.hookReduceValue("footer",t.footer(e),[e],Sl),n.hookReduceValue("intro",t.intro(e),[e],Bl),n.hookReduceValue("outro",t.outro(e),[e],Bl)]);return l&&(l+=`

`),c&&(c=`

${c}`),s&&(s+=`
`),o&&(o=`
`+o),{banner:s,footer:o,intro:l,outro:c}}catch(s){return L((r=s.message,a=s.hook,i=s.plugin,{code:Ym,message:`Could not retrieve "${a}". Check configuration of plugin "${i}".
	Error Message: ${r}`}))}var r,a,i}const Mp={amd:Jr,cjs:Jr,es:Il,iife:Jr,system:Il,umd:Jr};function Lp(t,n,e,r,a,i,s,o,l,c,u,f,m,h){const b=[...t].reverse();for(const p of b)p.scope.addUsedOutsideNames(r,a,f,m);(function(p,g,x){for(const k of g){for(const y of k.scope.variables.values())y.included&&!(y.renderBaseName||y instanceof it&&y.getOriginalVariable()!==y)&&y.setRenderNames(null,et(y.name,p,y.forbiddenNames));if(x.has(k)){const y=k.namespace;y.setRenderNames(null,et(y.name,p,y.forbiddenNames))}}})(r,b,h),Mp[a](r,e,n,i,s,o,l,c,u);for(const p of b)p.scope.deconflict(a,f,m)}function Il(t,n,e,r,a,i,s,o,l){for(const c of e.dependencies)(a||c instanceof te)&&(c.variableName=et(c.suggestedVariableName,t,null));for(const c of n){const u=c.module,f=c.name;c.isNamespace&&(a||u instanceof fn)?c.setRenderNames(null,(u instanceof fn?o.get(u):s.get(u)).variableName):u instanceof fn&&f==="default"?c.setRenderNames(null,et([...u.exportedVariables].some(([m,h])=>h==="*"&&m.included)?u.suggestedVariableName+"__default":u.suggestedVariableName,t,c.forbiddenNames)):c.setRenderNames(null,et(f,t,c.forbiddenNames))}for(const c of l)c.setRenderNames(null,et(c.name,t,c.forbiddenNames))}function Jr(t,n,{deconflictedDefault:e,deconflictedNamespace:r,dependencies:a},i,s,o,l,c){for(const u of a)u.variableName=et(u.suggestedVariableName,t,null);for(const u of r)u.namespaceVariableName=et(`${u.suggestedVariableName}__namespace`,t,null);for(const u of e)u.defaultVariableName=r.has(u)&&ip(i(u.id),o)?u.namespaceVariableName:et(`${u.suggestedVariableName}__default`,t,null);for(const u of n){const f=u.module;if(f instanceof fn){const m=c.get(f),h=u.name;if(h==="default"){const b=i(f.id),p=Rr[b]?m.defaultVariableName:m.variableName;Vr(b,o)?u.setRenderNames(p,"default"):u.setRenderNames(null,p)}else h==="*"?u.setRenderNames(null,Re[i(f.id)]?m.namespaceVariableName:m.variableName):u.setRenderNames(m.variableName,null)}else{const m=l.get(f);s&&u.isNamespace?u.setRenderNames(null,m.exportMode==="default"?m.namespaceVariableName:m.variableName):m.exportMode==="default"?u.setRenderNames(null,m.variableName):u.setRenderNames(m.variableName,m.getVariableExportName(u))}}}function Tp(t,{exports:n,name:e,format:r},a,i){const s=t.getExportNames();if(n==="default"){if(s.length!==1||s[0]!=="default")return L(to("default",s,a))}else if(n==="none"&&s.length>0)return L(to("none",s,a));return n==="auto"&&(s.length===0?n="none":s.length===1&&s[0]==="default"?n="default":(r!=="es"&&r!=="system"&&s.includes("default")&&i(V,function(o,l){return{code:pd,id:o,message:`Entry module "${W(o)}" is using named and default exports together. Consumers of your bundle will have to use \`${l||"chunk"}.default\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`,url:En(Ua)}}(a,e)),n="named")),n}function Np(t){const n=t.split(`
`),e=n.filter(i=>/^\t+/.test(i)),r=n.filter(i=>/^ {2,}/.test(i));if(e.length===0&&r.length===0)return null;if(e.length>=r.length)return"	";const a=r.reduce((i,s)=>{const o=/^ +/.exec(s)[0].length;return Math.min(o,i)},1/0);return" ".repeat(a)}function jl(t,n,e,r,a,i){const s=t.getDependenciesToBeIncluded();for(const o of s){if(o instanceof fn){n.push(i.get(o));continue}const l=a.get(o);l===r?e.has(o)||(e.add(o),jl(o,n,e,r,a,i)):n.push(l)}}const Fi="!~{",Pi="}~",Ui=new RegExp(`${Fi}[0-9a-zA-Z_$]{1,59}${Pi}`,"g"),He=(t,n)=>t.replace(Ui,e=>n.get(e)||e),Dp=(t,n,e)=>t.replace(Ui,r=>r===n?e:r),Op=(t,n)=>{const e=new Set,r=t.replace(Ui,a=>n.has(a)?(e.add(a),`${Fi}${"0".repeat(a.length-5)}${Pi}`):a);return{containedPlaceholders:e,transformedCode:r}},Zr=Symbol("bundleKeys"),Ri={type:"placeholder"};function Ml(t,n,e){return pr(t)?L(Tn(`Invalid pattern "${t}" for "${n}", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`)):t.replace(/\[(\w+)(:\d+)?]/g,(r,a,i)=>{if(!e.hasOwnProperty(a)||i&&a!=="hash")return L(Tn(`"[${a}${i||""}]" is not a valid placeholder in the "${n}" pattern.`));const s=e[a](i&&Number.parseInt(i.slice(1)));return pr(s)?L(Tn(`Invalid substitution "${s}" for placeholder "[${a}]" in "${n}" pattern, can be neither absolute nor relative path.`)):s})}function Ll(t,{[Zr]:n}){if(!n.has(t.toLowerCase()))return t;const e=xt(t);t=t.slice(0,Math.max(0,t.length-e.length));let r,a=1;for(;n.has((r=t+ ++a+e).toLowerCase()););return r}const zp=new Set([".js",".jsx",".ts",".tsx",".mjs",".mts",".cjs",".cts"]);function Gp(t,n,e,r){return(typeof n=="function"?n(t.id):n[t.id])||(e?(r(V,(i=t.id,s=t.variableName,{code:fd,id:i,message:`No name was provided for external module "${i}" in "output.globals" – guessing "${s}".`,names:[s],url:En(Km)})),t.variableName):void 0);var i,s}class St{constructor(n,e,r,a,i,s,o,l,c,u,f,m,h,b,p){this.orderedModules=n,this.inputOptions=e,this.outputOptions=r,this.unsetOptions=a,this.pluginDriver=i,this.modulesById=s,this.chunkByModule=o,this.externalChunkByModule=l,this.facadeChunkByModule=c,this.includedNamespaces=u,this.manualChunkAlias=f,this.getPlaceholder=m,this.bundle=h,this.inputBase=b,this.snippets=p,this.entryModules=[],this.exportMode="named",this.facadeModule=null,this.namespaceVariableName="",this.variableName="",this.accessedGlobalsByScope=new Map,this.dependencies=new Set,this.dynamicEntryModules=[],this.dynamicName=null,this.exportNamesByVariable=new Map,this.exports=new Set,this.exportsByName=new Map,this.fileName=null,this.implicitEntryModules=[],this.implicitlyLoadedBefore=new Set,this.imports=new Set,this.includedDynamicImports=null,this.includedReexportsByModule=new Map,this.isEmpty=!0,this.name=null,this.needsExportsShim=!1,this.preRenderedChunkInfo=null,this.preliminaryFileName=null,this.renderedChunkInfo=null,this.renderedDependencies=null,this.renderedModules=Object.create(null),this.sortedExportNames=null,this.strictFacade=!1,this.execIndex=n.length>0?n[0].execIndex:1/0;const g=new Set(n);for(const x of n){o.set(x,this),x.namespace.included&&!r.preserveModules&&u.add(x),this.isEmpty&&x.isIncluded()&&(this.isEmpty=!1),(x.info.isEntry||r.preserveModules)&&this.entryModules.push(x);for(const k of x.includedDynamicImporters)g.has(k)||(this.dynamicEntryModules.push(x),x.info.syntheticNamedExports&&(u.add(x),this.exports.add(x.namespace)));x.implicitlyLoadedAfter.size>0&&this.implicitEntryModules.push(x)}this.suggestedVariableName=za(this.generateVariableName())}static generateFacade(n,e,r,a,i,s,o,l,c,u,f,m,h,b,p){const g=new St([],n,e,r,a,i,s,o,l,c,null,m,h,b,p);g.assignFacadeName(f,u),l.has(u)||l.set(u,g);for(const x of u.getDependenciesToBeIncluded())g.dependencies.add(x instanceof hn?s.get(x):o.get(x));return!g.dependencies.has(s.get(u))&&u.info.moduleSideEffects&&u.hasEffects()&&g.dependencies.add(s.get(u)),g.ensureReexportsAreAvailableForModule(u),g.facadeModule=u,g.strictFacade=!0,g}canModuleBeFacade(n,e){const r=n.getExportNamesByVariable();for(const a of this.exports)if(!r.has(a))return!1;for(const a of e)if(!(a.module===n||r.has(a)||a instanceof Nn&&r.has(a.getBaseVariable())))return!1;return!0}finalizeChunk(n,e,r){const a=this.getRenderedChunkInfo(),i=o=>He(o,r),s=this.fileName=i(a.fileName);return{...a,code:n,dynamicImports:a.dynamicImports.map(i),fileName:s,implicitlyLoadedBefore:a.implicitlyLoadedBefore.map(i),importedBindings:Object.fromEntries(Object.entries(a.importedBindings).map(([o,l])=>[i(o),l])),imports:a.imports.map(i),map:e,referencedFiles:a.referencedFiles.map(i)}}generateExports(){this.sortedExportNames=null;const n=new Set(this.exports);if(this.facadeModule!==null&&(this.facadeModule.preserveSignature!==!1||this.strictFacade)){const e=this.facadeModule.getExportNamesByVariable();for(const[r,a]of e){this.exportNamesByVariable.set(r,[...a]);for(const i of a)this.exportsByName.set(i,r);n.delete(r)}}this.outputOptions.minifyInternalExports?function(e,r,a){let i=0;for(const s of e){let[o]=s.name;if(r.has(o))do o=jr(++i),o.charCodeAt(0)===49&&(i+=9*64**(o.length-1),o=jr(i));while(br.has(o)||r.has(o));r.set(o,s),a.set(s,[o])}}(n,this.exportsByName,this.exportNamesByVariable):function(e,r,a){for(const i of e){let s=0,o=i.name;for(;r.has(o);)o=i.name+"$"+ ++s;r.set(o,i),a.set(i,[o])}}(n,this.exportsByName,this.exportNamesByVariable),(this.outputOptions.preserveModules||this.facadeModule&&this.facadeModule.info.isEntry)&&(this.exportMode=Tp(this,this.outputOptions,this.facadeModule.id,this.inputOptions.onLog))}generateFacades(){var a;const n=[],e=new Set([...this.entryModules,...this.implicitEntryModules]),r=new Set(this.dynamicEntryModules.map(({namespace:i})=>i));for(const i of e)if(i.preserveSignature)for(const s of i.getExportNamesByVariable().keys())this.chunkByModule.get(s.module)===this&&r.add(s);for(const i of e){const s=Array.from(new Set(i.chunkNames.filter(({isUserDefined:o})=>o).map(({name:o})=>o)),o=>({name:o}));if(s.length===0&&i.isUserDefinedEntryPoint&&s.push({}),s.push(...Array.from(i.chunkFileNames,o=>({fileName:o}))),s.length===0&&s.push({}),!this.facadeModule){const o=!this.outputOptions.preserveModules&&(i.preserveSignature==="strict"||i.preserveSignature==="exports-only"&&i.getExportNamesByVariable().size>0);o&&!this.canModuleBeFacade(i,r)||(this.facadeModule=i,this.facadeChunkByModule.set(i,this),i.preserveSignature&&(this.strictFacade=o),this.assignFacadeName(s.shift(),i,this.outputOptions.preserveModules))}for(const o of s)n.push(St.generateFacade(this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.modulesById,this.chunkByModule,this.externalChunkByModule,this.facadeChunkByModule,this.includedNamespaces,i,o,this.getPlaceholder,this.bundle,this.inputBase,this.snippets))}for(const i of this.dynamicEntryModules)i.info.syntheticNamedExports||(!this.facadeModule&&this.canModuleBeFacade(i,r)?(this.facadeModule=i,this.facadeChunkByModule.set(i,this),this.strictFacade=!0,this.dynamicName=Vi(i)):this.facadeModule===i&&!this.strictFacade&&this.canModuleBeFacade(i,r)?this.strictFacade=!0:(a=this.facadeChunkByModule.get(i))!=null&&a.strictFacade||(this.includedNamespaces.add(i),this.exports.add(i.namespace)));return this.outputOptions.preserveModules||this.addNecessaryImportsForFacades(),n}getChunkName(){return this.name??(this.name=this.outputOptions.sanitizeFileName(this.getFallbackChunkName()))}getExportNames(){return this.sortedExportNames??(this.sortedExportNames=[...this.exportsByName.keys()].sort())}getFileName(){return this.fileName||this.getPreliminaryFileName().fileName}getImportPath(n){return dr(js(n,this.getFileName(),this.outputOptions.format==="amd"&&!this.outputOptions.amd.forceJsExtensionForImports,!0))}getPreliminaryFileName(){var l;if(this.preliminaryFileName)return this.preliminaryFileName;let n,e=null;const{chunkFileNames:r,entryFileNames:a,file:i,format:s,preserveModules:o}=this.outputOptions;if(i)n=ft(i);else if(this.fileName===null){const[c,u]=o||(l=this.facadeModule)!=null&&l.isUserDefinedEntryPoint?[a,"output.entryFileNames"]:[r,"output.chunkFileNames"];n=Ml(typeof c=="function"?c(this.getPreRenderedChunkInfo()):c,u,{format:()=>s,hash:f=>e||(e=this.getPlaceholder(u,f)),name:()=>this.getChunkName()}),e||(n=Ll(n,this.bundle))}else n=this.fileName;return e||(this.bundle[n]=Ri),this.preliminaryFileName={fileName:n,hashPlaceholder:e}}getRenderedChunkInfo(){return this.renderedChunkInfo?this.renderedChunkInfo:this.renderedChunkInfo={...this.getPreRenderedChunkInfo(),dynamicImports:this.getDynamicDependencies().map(Qr),fileName:this.getFileName(),implicitlyLoadedBefore:Array.from(this.implicitlyLoadedBefore,Qr),importedBindings:Fp(this.getRenderedDependencies(),Qr),imports:Array.from(this.dependencies,Qr),modules:this.renderedModules,referencedFiles:this.getReferencedFiles()}}getVariableExportName(n){return this.outputOptions.preserveModules&&n instanceof Xe?"*":this.exportNamesByVariable.get(n)[0]}link(){this.dependencies=function(n,e,r,a){const i=[],s=new Set;for(let l=e.length-1;l>=0;l--){const c=e[l];if(!s.has(c)){const u=[];jl(c,u,s,n,r,a),i.unshift(u)}}const o=new Set;for(const l of i)for(const c of l)o.add(c);return o}(this,this.orderedModules,this.chunkByModule,this.externalChunkByModule);for(const n of this.orderedModules)this.addImplicitlyLoadedBeforeFromModule(n),this.setUpChunkImportsAndExportsForModule(n)}async render(){const{dependencies:n,exportMode:e,facadeModule:r,inputOptions:{onLog:a},outputOptions:i,pluginDriver:s,snippets:o}=this,{format:l,hoistTransitiveImports:c,preserveModules:u}=i;if(c&&!u&&r!==null)for(const B of n)B instanceof St&&this.inlineChunkDependencies(B);const f=this.getPreliminaryFileName(),{accessedGlobals:m,indent:h,magicString:b,renderedSource:p,usedModules:g,usesTopLevelAwait:x}=this.renderModules(f.fileName),k=[...this.getRenderedDependencies().values()],y=e==="none"?[]:this.getChunkExportDeclarations(l);let v=y.length>0,$=!1;for(const B of k){const{reexports:U}=B;U!=null&&U.length&&(v=!0,!$&&U.some(D=>D.reexported==="default")&&($=!0),l==="es"&&(B.reexports=U.filter(({reexported:D})=>!y.find(({exported:F})=>F===D))))}if(!$){for(const{exported:B}of y)if(B==="default"){$=!0;break}}const{intro:w,outro:S,banner:I,footer:C}=await jp(i,s,this.getRenderedChunkInfo());return Ip[l](p,{accessedGlobals:m,dependencies:k,exports:y,hasDefaultExport:$,hasExports:v,id:f.fileName,indent:h,intro:w,isEntryFacade:u||r!==null&&r.info.isEntry,isModuleFacade:r!==null,log:a,namedExportsMode:e!=="default",outro:S,snippets:o,usesTopLevelAwait:x},i),I&&b.prepend(I),C&&b.append(C),{chunk:this,magicString:b,preliminaryFileName:f,usedModules:g}}addImplicitlyLoadedBeforeFromModule(n){const{chunkByModule:e,implicitlyLoadedBefore:r}=this;for(const a of n.implicitlyLoadedBefore){const i=e.get(a);i&&i!==this&&r.add(i)}}addNecessaryImportsForFacades(){for(const[n,e]of this.includedReexportsByModule)if(this.includedNamespaces.has(n))for(const r of e)this.imports.add(r)}assignFacadeName({fileName:n,name:e},r,a){n?this.fileName=n:this.name=this.outputOptions.sanitizeFileName(e||(a?this.getPreserveModulesChunkNameFromModule(r):Vi(r)))}checkCircularDependencyImport(n,e){var c;const r=n.module;if(r instanceof hn){const u=this.chunkByModule.get(r);let f;do f=e.alternativeReexportModules.get(n),f&&(this.chunkByModule.get(f)!==u&&this.inputOptions.onLog(V,(a=((c=r.getExportNamesByVariable().get(n))==null?void 0:c[0])||"*",i=r.id,s=f.id,o=e.id,l=this.outputOptions.preserveModules,{code:"CYCLIC_CROSS_CHUNK_REEXPORT",exporter:i,id:o,message:`Export "${a}" of module "${W(i)}" was reexported through module "${W(s)}" while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.
Either change the import in "${W(o)}" to point directly to the exporting module or ${l?'do not use "output.preserveModules"':'reconfigure "output.manualChunks"'} to ensure these modules end up in the same chunk.`,reexporter:s})),e=f);while(f)}var a,i,s,o,l}ensureReexportsAreAvailableForModule(n){const e=[],r=n.getExportNamesByVariable();for(const a of r.keys()){const i=a instanceof Nn,s=i?a.getBaseVariable():a;if(this.checkCircularDependencyImport(s,n),!(s instanceof Xe&&this.outputOptions.preserveModules)){const o=s.module;if(o instanceof hn){const l=this.chunkByModule.get(o);l&&l!==this&&(l.exports.add(s),e.push(s),i&&this.imports.add(s))}}}e.length>0&&this.includedReexportsByModule.set(n,e)}generateVariableName(){if(this.manualChunkAlias)return this.manualChunkAlias;const n=this.entryModules[0]||this.implicitEntryModules[0]||this.dynamicEntryModules[0]||this.orderedModules[this.orderedModules.length-1];return n?Vi(n):"chunk"}getChunkExportDeclarations(n){const e=[];for(const r of this.getExportNames()){if(r[0]==="*")continue;const a=this.exportsByName.get(r);if(!(a instanceof Nn)){const l=a.module;if(l){const c=this.chunkByModule.get(l);if(c!==this){if(!c||n!=="es")continue;const u=this.renderedDependencies.get(c);if(!u)continue;const{imports:f,reexports:m}=u,h=m==null?void 0:m.find(({reexported:p})=>p===r);if(!(f==null?void 0:f.find(({imported:p})=>p===(h==null?void 0:h.imported))))continue}}}let i=null,s=!1,o=a.getName(this.snippets.getPropertyAccess);if(a instanceof dt){for(const l of a.declarations)if(l.parent instanceof Pe||l instanceof Gr&&l.declaration instanceof Pe){s=!0;break}}else a instanceof Nn&&(i=o,n==="es"&&(o=a.renderName));e.push({exported:r,expression:i,hoisted:s,local:o})}return e}getDependenciesToBeDeconflicted(n,e,r){const a=new Set,i=new Set,s=new Set;for(const o of[...this.exportNamesByVariable.keys(),...this.imports])if(n||o.isNamespace){const l=o.module;if(l instanceof fn){const c=this.externalChunkByModule.get(l);a.add(c),n&&(o.name==="default"?Rr[r(l.id)]&&i.add(c):o.name==="*"&&Re[r(l.id)]&&s.add(c))}else{const c=this.chunkByModule.get(l);c!==this&&(a.add(c),n&&c.exportMode==="default"&&o.isNamespace&&s.add(c))}}if(e)for(const o of this.dependencies)a.add(o);return{deconflictedDefault:i,deconflictedNamespace:s,dependencies:a}}getDynamicDependencies(){return this.getIncludedDynamicImports().map(n=>n.facadeChunk||n.chunk||n.externalChunk||n.resolution).filter(n=>n!==this&&(n instanceof St||n instanceof te))}getDynamicImportStringAndAssertions(n,e){if(n instanceof fn){const r=this.externalChunkByModule.get(n);return[`'${r.getImportPath(e)}'`,r.getImportAssertions(this.snippets)]}return[n||"",this.outputOptions.format==="es"&&this.outputOptions.externalImportAssertions||null]}getFallbackChunkName(){return this.manualChunkAlias?this.manualChunkAlias:this.dynamicName?this.dynamicName:this.fileName?La(this.fileName):La(this.orderedModules[this.orderedModules.length-1].id)}getImportSpecifiers(){const{interop:n}=this.outputOptions,e=new Map;for(const r of this.imports){const a=r.module;let i,s;if(a instanceof fn){if(i=this.externalChunkByModule.get(a),s=r.name,s!=="default"&&s!=="*"&&n(a.id)==="defaultOnly")return L(ro(a.id,s,!1))}else i=this.chunkByModule.get(a),s=i.getVariableExportName(r);zn(e,i,Ms).push({imported:s,local:r.getName(this.snippets.getPropertyAccess)})}return e}getIncludedDynamicImports(){if(this.includedDynamicImports)return this.includedDynamicImports;const n=[];for(const e of this.orderedModules)for(const{node:r,resolution:a}of e.dynamicImports)r.included&&n.push(a instanceof hn?{chunk:this.chunkByModule.get(a),externalChunk:null,facadeChunk:this.facadeChunkByModule.get(a),node:r,resolution:a}:a instanceof fn?{chunk:null,externalChunk:this.externalChunkByModule.get(a),facadeChunk:null,node:r,resolution:a}:{chunk:null,externalChunk:null,facadeChunk:null,node:r,resolution:a});return this.includedDynamicImports=n}getPreRenderedChunkInfo(){if(this.preRenderedChunkInfo)return this.preRenderedChunkInfo;const{dynamicEntryModules:n,facadeModule:e,implicitEntryModules:r,orderedModules:a}=this;return this.preRenderedChunkInfo={exports:this.getExportNames(),facadeModuleId:e&&e.id,isDynamicEntry:n.length>0,isEntry:!!(e!=null&&e.info.isEntry),isImplicitEntry:r.length>0,moduleIds:a.map(({id:i})=>i),name:this.getChunkName(),type:"chunk"}}getPreserveModulesChunkNameFromModule(n){const e=Tl(n);if(e)return e;const{preserveModulesRoot:r,sanitizeFileName:a}=this.outputOptions,i=a(ke(n.id.split(Pp,1)[0])),s=xt(i),o=zp.has(s)?i.slice(0,-s.length):i;return bt(o)?r&&Hn(o).startsWith(r)?o.slice(r.length).replace(/^[/\\]/,""):ne(this.inputBase,o):`_virtual/${ft(o)}`}getReexportSpecifiers(){const{externalLiveBindings:n,interop:e}=this.outputOptions,r=new Map;for(let a of this.getExportNames()){let i,s,o=!1;if(a[0]==="*"){const l=a.slice(1);e(l)==="defaultOnly"&&this.inputOptions.onLog(V,Ad(l)),o=n,i=this.externalChunkByModule.get(this.modulesById.get(l)),s=a="*"}else{const l=this.exportsByName.get(a);if(l instanceof Nn)continue;const c=l.module;if(c instanceof hn){if(i=this.chunkByModule.get(c),i===this)continue;s=i.getVariableExportName(l),o=l.isReassigned}else{if(i=this.externalChunkByModule.get(c),s=l.name,s!=="default"&&s!=="*"&&e(c.id)==="defaultOnly")return L(ro(c.id,s,!0));o=n&&(s!=="default"||Vr(e(c.id),!0))}}zn(r,i,Ms).push({imported:s,needsLiveBinding:o,reexported:a})}return r}getReferencedFiles(){const n=new Set;for(const e of this.orderedModules)for(const r of e.importMetas){const a=r.getReferencedFileName(this.pluginDriver);a&&n.add(a)}return[...n]}getRenderedDependencies(){if(this.renderedDependencies)return this.renderedDependencies;const n=this.getImportSpecifiers(),e=this.getReexportSpecifiers(),r=new Map,a=this.getFileName();for(const i of this.dependencies){const s=n.get(i)||null,o=e.get(i)||null,l=i instanceof te||i.exportMode!=="default",c=i.getImportPath(a);r.set(i,{assertions:i instanceof te?i.getImportAssertions(this.snippets):null,defaultVariableName:i.defaultVariableName,globalName:i instanceof te&&(this.outputOptions.format==="umd"||this.outputOptions.format==="iife")&&Gp(i,this.outputOptions.globals,(s||o)!==null,this.inputOptions.onLog),importPath:c,imports:s,isChunk:i instanceof St,name:i.variableName,namedExportsMode:l,namespaceVariableName:i.namespaceVariableName,reexports:o})}return this.renderedDependencies=r}inlineChunkDependencies(n){for(const e of n.dependencies)this.dependencies.has(e)||(this.dependencies.add(e),e instanceof St&&this.inlineChunkDependencies(e))}renderModules(n){const{accessedGlobalsByScope:e,dependencies:r,exportNamesByVariable:a,includedNamespaces:i,inputOptions:{onLog:s},isEmpty:o,orderedModules:l,outputOptions:c,pluginDriver:u,renderedModules:f,snippets:m}=this,{compact:h,dynamicImportFunction:b,format:p,freeze:g,namespaceToStringTag:x}=c,{_:k,cnst:y,n:v}=m;this.setDynamicImportResolutions(n),this.setImportMetaResolutions(n),this.setIdentifierRenderResolutions();const $=new class t_{constructor(E={}){this.intro=E.intro||"",this.separator=E.separator!==void 0?E.separator:`
`,this.sources=[],this.uniqueSources=[],this.uniqueSourceIndexByFilename={}}addSource(E){if(E instanceof Lt)return this.addSource({content:E,filename:E.filename,separator:this.separator});if(!Ss(E)||!E.content)throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");if(["filename","ignoreList","indentExclusionRanges","separator"].forEach(j=>{Is.call(E,j)||(E[j]=E.content[j])}),E.separator===void 0&&(E.separator=this.separator),E.filename)if(Is.call(this.uniqueSourceIndexByFilename,E.filename)){const j=this.uniqueSources[this.uniqueSourceIndexByFilename[E.filename]];if(E.content.original!==j.content)throw new Error(`Illegal source: same filename (${E.filename}), different contents`)}else this.uniqueSourceIndexByFilename[E.filename]=this.uniqueSources.length,this.uniqueSources.push({filename:E.filename,content:E.content.original});return this.sources.push(E),this}append(E,j){return this.addSource({content:new Lt(E),separator:j&&j.separator||""}),this}clone(){const E=new t_({intro:this.intro,separator:this.separator});return this.sources.forEach(j=>{E.addSource({filename:j.filename,content:j.content.clone(),separator:j.separator})}),E}generateDecodedMap(E={}){const j=[];let G;this.sources.forEach(rn=>{Object.keys(rn.content.storedNames).forEach(an=>{~j.indexOf(an)||j.push(an)})});const Y=new Bs(E.hires);return this.intro&&Y.advance(this.intro),this.sources.forEach((rn,an)=>{an>0&&Y.advance(this.separator);const ln=rn.filename?this.uniqueSourceIndexByFilename[rn.filename]:-1,cn=rn.content,An=ja(cn.original);cn.intro&&Y.advance(cn.intro),cn.firstChunk.eachNext(sn=>{const In=An(sn.start);sn.intro.length&&Y.advance(sn.intro),rn.filename?sn.edited?Y.addEdit(ln,sn.content,In,sn.storeName?j.indexOf(sn.original):-1):Y.addUneditedChunk(ln,sn,cn.original,In,cn.sourcemapLocations):Y.advance(sn.content),sn.outro.length&&Y.advance(sn.outro)}),cn.outro&&Y.advance(cn.outro),rn.ignoreList&&ln!==-1&&(G===void 0&&(G=[]),G.push(ln))}),{file:E.file?E.file.split(/[/\\]/).pop():void 0,sources:this.uniqueSources.map(rn=>E.file?ws(E.file,rn.filename):rn.filename),sourcesContent:this.uniqueSources.map(rn=>E.includeContent?rn.content:null),names:j,mappings:Y.raw,x_google_ignoreList:G}}generateMap(E){return new mr(this.generateDecodedMap(E))}getIndentString(){const E={};return this.sources.forEach(j=>{const G=j.content._getRawIndentString();G!==null&&(E[G]||(E[G]=0),E[G]+=1)}),Object.keys(E).sort((j,G)=>E[j]-E[G])[0]||"	"}indent(E){if(arguments.length||(E=this.getIndentString()),E==="")return this;let j=!this.intro||this.intro.slice(-1)===`
`;return this.sources.forEach((G,Y)=>{const rn=G.separator!==void 0?G.separator:this.separator,an=j||Y>0&&/\r?\n$/.test(rn);G.content.indent(E,{exclude:G.indentExclusionRanges,indentStart:an}),j=G.content.lastChar()===`
`}),this.intro&&(this.intro=E+this.intro.replace(/^[^\n]/gm,(G,Y)=>Y>0?E+G:G)),this}prepend(E){return this.intro=E+this.intro,this}toString(){const E=this.sources.map((j,G)=>{const Y=j.separator!==void 0?j.separator:this.separator;return(G>0?Y:"")+j.content.toString()}).join("");return this.intro+E}isEmpty(){return!(this.intro.length&&this.intro.trim()||this.sources.some(E=>!E.content.isEmpty()))}length(){return this.sources.reduce((E,j)=>E+j.content.length(),this.intro.length)}trimLines(){return this.trim("[\\r\\n]")}trim(E){return this.trimStart(E).trimEnd(E)}trimStart(E){const j=new RegExp("^"+(E||"\\s")+"+");if(this.intro=this.intro.replace(j,""),!this.intro){let G,Y=0;do if(G=this.sources[Y++],!G)break;while(!G.content.trimStartAborted(E))}return this}trimEnd(E){const j=new RegExp((E||"\\s")+"+$");let G,Y=this.sources.length-1;do if(G=this.sources[Y--],!G){this.intro=this.intro.replace(j,"");break}while(!G.content.trimEndAborted(E));return this}}({separator:`${v}${v}`}),w=function(z,E){if(E.indent!==!0)return E.indent;for(const j of z){const G=Np(j.originalCode);if(G!==null)return G}return"	"}(l,c),S=[];let I="";const C=new Set,B=new Map,U={dynamicImportFunction:b,exportNamesByVariable:a,format:p,freeze:g,indent:w,namespaceToStringTag:x,pluginDriver:u,snippets:m,useOriginalName:null};let D=!1;for(const z of l){let E,j=0;if(z.isIncluded()||i.has(z)){const rn=z.render(U);({source:E}=rn),D||(D=rn.usesTopLevelAwait),j=E.length(),j&&(h&&E.lastLine().includes("//")&&E.append(`
`),B.set(z,E),$.addSource(E),S.push(z));const an=z.namespace;if(i.has(z)){const cn=an.renderBlock(U);an.renderFirst()?I+=v+cn:$.addSource(new Lt(cn))}const ln=e.get(z.scope);if(ln)for(const cn of ln)C.add(cn)}const{renderedExports:G,removedExports:Y}=z.getRenderedExports();f[z.id]={get code(){return(E==null?void 0:E.toString())??null},originalLength:z.originalCode.length,removedExports:Y,renderedExports:G,renderedLength:j}}I&&$.prepend(I+v+v),this.needsExportsShim&&$.prepend(`${v}${y} ${_e}${k}=${k}void 0;${v}${v}`);const F=h?$:$.trim();var N;return o&&this.getExportNames().length===0&&r.size===0&&s(V,{code:"EMPTY_BUNDLE",message:`Generated an empty chunk: "${N=this.getChunkName()}".`,names:[N]}),{accessedGlobals:C,indent:w,magicString:$,renderedSource:F,usedModules:S,usesTopLevelAwait:D}}setDynamicImportResolutions(n){const{accessedGlobalsByScope:e,outputOptions:r,pluginDriver:a,snippets:i}=this;for(const s of this.getIncludedDynamicImports())if(s.chunk){const{chunk:o,facadeChunk:l,node:c,resolution:u}=s;o===this?c.setInternalResolution(u.namespace):c.setExternalResolution((l||o).exportMode,u,r,i,a,e,`'${(l||o).getImportPath(n)}'`,!(l!=null&&l.strictFacade)&&o.exportNamesByVariable.get(u.namespace)[0],null)}else{const{node:o,resolution:l}=s,[c,u]=this.getDynamicImportStringAndAssertions(l,n);o.setExternalResolution("external",l,r,i,a,e,c,!1,u)}}setIdentifierRenderResolutions(){const{format:n,interop:e,namespaceToStringTag:r,preserveModules:a,externalLiveBindings:i}=this.outputOptions,s=new Set;for(const l of this.getExportNames()){const c=this.exportsByName.get(l);n!=="es"&&n!=="system"&&c.isReassigned&&!c.isId?c.setRenderNames("exports",l):c instanceof Nn?s.add(c):c.setRenderNames(null,null)}for(const l of this.orderedModules)if(l.needsExportShim){this.needsExportsShim=!0;break}const o=new Set(["Object","Promise"]);switch(this.needsExportsShim&&o.add(_e),r&&o.add("Symbol"),n){case"system":o.add("module").add("exports");break;case"es":break;case"cjs":o.add("module").add("require").add("__filename").add("__dirname");default:o.add("exports");for(const l of Ai)o.add(l)}Lp(this.orderedModules,this.getDependenciesToBeDeconflicted(n!=="es"&&n!=="system",n==="amd"||n==="umd"||n==="iife",e),this.imports,o,n,e,a,i,this.chunkByModule,this.externalChunkByModule,s,this.exportNamesByVariable,this.accessedGlobalsByScope,this.includedNamespaces)}setImportMetaResolutions(n){const{accessedGlobalsByScope:e,includedNamespaces:r,orderedModules:a,outputOptions:{format:i}}=this;for(const s of a){for(const o of s.importMetas)o.setResolution(i,e,n);r.has(s)&&s.namespace.prepare(e)}}setUpChunkImportsAndExportsForModule(n){const e=new Set(n.includedImports);if(!this.outputOptions.preserveModules&&this.includedNamespaces.has(n)){const r=n.namespace.getMemberVariables();for(const a of Object.values(r))e.add(a)}for(let r of e){r instanceof it&&(r=r.getOriginalVariable()),r instanceof Nn&&(r=r.getBaseVariable());const a=this.chunkByModule.get(r.module);a!==this&&(this.imports.add(r),r.module instanceof hn&&(this.checkCircularDependencyImport(r,n),r instanceof Xe&&this.outputOptions.preserveModules||a.exports.add(r)))}(this.includedNamespaces.has(n)||n.info.isEntry&&n.preserveSignature!==!1||n.includedDynamicImporters.some(r=>this.chunkByModule.get(r)!==this))&&this.ensureReexportsAreAvailableForModule(n);for(const{node:r,resolution:a}of n.dynamicImports)r.included&&a instanceof hn&&this.chunkByModule.get(a)===this&&!this.includedNamespaces.has(a)&&(this.includedNamespaces.add(a),this.ensureReexportsAreAvailableForModule(a))}}function Vi(t){return Tl(t)??La(t.id)}function Tl(t){var n,e;return((n=t.chunkNames.find(({isUserDefined:r})=>r))==null?void 0:n.name)??((e=t.chunkNames[0])==null?void 0:e.name)}function Fp(t,n){const e={};for(const[r,a]of t){const i=new Set;if(a.imports)for(const{imported:s}of a.imports)i.add(s);if(a.reexports)for(const{imported:s}of a.reexports)i.add(s);e[n(r)]=[...i]}return e}const Pp=/[#?]/,Qr=t=>t.getFileName();function*Nl(t){for(const n of t)yield*n}function Up(t,n,e,r){const{chunkDefinitions:a,modulesInManualChunks:i}=function(f){const m=[],h=new Set(f.keys()),b=Object.create(null);for(const[p,g]of f)Rp(p,b[g]||(b[g]=[]),h);for(const[p,g]of Object.entries(b))m.push({alias:p,modules:g});return{chunkDefinitions:m,modulesInManualChunks:h}}(n),{allEntries:s,dependentEntriesByModule:o,dynamicallyDependentEntriesByDynamicEntry:l,dynamicImportsByEntry:c}=function(f){const m=new Set,h=new Map,b=[],p=new Set(f);let g=0;for(const v of p){const $=new Set;b.push($);const w=new Set([v]);for(const S of w){zn(h,S,Nt).add(g);for(const I of S.getDependenciesToBeIncluded())I instanceof fn||w.add(I);for(const{resolution:I}of S.dynamicImports)I instanceof hn&&I.includedDynamicImporters.length>0&&!p.has(I)&&(m.add(I),p.add(I),$.add(I));for(const I of S.implicitlyLoadedBefore)p.has(I)||(m.add(I),p.add(I))}g++}const x=[...p],{dynamicEntries:k,dynamicImportsByEntry:y}=function(v,$,w){const S=new Map,I=new Set;for(const[B,U]of v.entries())S.set(U,B),$.has(U)&&I.add(B);const C=[];for(const B of w){const U=new Set;for(const D of B)U.add(S.get(D));C.push(U)}return{dynamicEntries:I,dynamicImportsByEntry:C}}(x,m,b);return{allEntries:x,dependentEntriesByModule:h,dynamicallyDependentEntriesByDynamicEntry:Vp(h,k,x),dynamicImportsByEntry:y}}(t),u=Dl(function*(f,m){for(const[h,b]of f)m.has(h)||(yield{dependentEntries:b,modules:[h]})}(o,i));return function(f,m,h,b){const p=b.map(()=>0n),g=b.map((y,v)=>m.has(v)?-1n:0n);let x=1n;for(const{dependentEntries:y}of f){for(const v of y)p[v]|=x;x<<=1n}const k=m;for(const[y,v]of k){k.delete(y);const $=g[y];let w=$;for(const S of v)w&=p[S]|g[S];if(w!==$){g[y]=w;for(const S of h[y])zn(k,S,Nt).add(y)}}x=1n;for(const{dependentEntries:y}of f){for(const v of y)(g[v]&x)===x&&y.delete(v);x<<=1n}}(u,l,c,s),a.push(...function(f,m,h,b){$n("optimize chunks",3);const p=function(g,x,k){const y=[],v=[],$=new Map,w=[];let S=0n,I=1n;for(const{dependentEntries:C,modules:B}of g){const U={containedAtoms:I,correlatedAtoms:0n,dependencies:new Set,dependentChunks:new Set,dependentEntries:C,modules:B,pure:!0,size:0};let D=0,F=!0;for(const N of B)$.set(N,U),N.isIncluded()&&(F&&(F=!N.hasEffects()),D+=k>1?N.estimateSize():1);U.pure=F,U.size=D,w.push(D),F||(S|=I),(D<k?y:v).push(U),I<<=1n}return y.length===0?null:(S|=function(C,B,U,D){const F=new Map;let N=0n;const z=[];for(let E=0;E<U;E++)z.push(0n);for(const E of C){E.sort(Xp);for(const j of E){const{dependencies:G,dependentEntries:Y,modules:rn}=j;for(const ln of rn)for(const cn of ln.getDependenciesToBeIncluded())if(cn instanceof fn)cn.info.moduleSideEffects&&(j.containedAtoms|=zn(F,cn,()=>{const An=D;return D<<=1n,N|=An,An}));else{const An=B.get(cn);An&&An!==j&&(G.add(An),An.dependentChunks.add(j))}const{containedAtoms:an}=j;for(const ln of Y)z[ln]|=an}}for(const E of C)for(const j of E){const{dependentEntries:G}=j;j.correlatedAtoms=-1n;for(const Y of G)j.correlatedAtoms&=z[Y]}return N}([v,y],$,x,I),{big:new Set(v),sideEffectAtoms:S,sizeByAtom:w,small:new Set(y)})}(f,m,h);return p?(h>1&&b("info",eo(f.length,p.small.size,"Initially")),function(g,x){const{small:k}=g;for(const y of k){const v=qp(y,g,x<=1?1:1/0);if(v){const{containedAtoms:$,correlatedAtoms:w,modules:S,pure:I,size:C}=y;k.delete(y),Ol(v,x,g).delete(v),v.modules.push(...S),v.size+=C,v.pure&&(v.pure=I);const{dependencies:B,dependentChunks:U,dependentEntries:D}=v;v.correlatedAtoms&=w,v.containedAtoms|=$;for(const F of y.dependentEntries)D.add(F);for(const F of y.dependencies)B.add(F),F.dependentChunks.delete(y),F.dependentChunks.add(v);for(const F of y.dependentChunks)U.add(F),F.dependencies.delete(y),F.dependencies.add(v);B.delete(v),U.delete(v),Ol(v,x,g).add(v)}}}(p,h),h>1&&b("info",eo(p.small.size+p.big.size,p.small.size,"After merging chunks")),xn("optimize chunks",3),[...p.small,...p.big]):(xn("optimize chunks",3),f)}(Dl(u),s.length,e,r).map(({modules:f})=>({alias:null,modules:f}))),a}function Rp(t,n,e){const r=new Set([t]);for(const a of r){e.add(a),n.push(a);for(const i of a.dependencies)i instanceof fn||e.has(i)||r.add(i)}}function Vp(t,n,e){const r=new Map;for(const a of n){const i=zn(r,a,Nt),s=e[a];for(const o of Nl([s.includedDynamicImporters,s.implicitlyLoadedAfter]))for(const l of t.get(o))i.add(l)}return r}function Dl(t){var n;const e=Object.create(null);for(const{dependentEntries:r,modules:a}of t){let i=0n;for(const s of r)i|=1n<<BigInt(s);(e[n=String(i)]||(e[n]={dependentEntries:new Set(r),modules:[]})).modules.push(...a)}return Object.values(e)}function qp(t,{big:n,sideEffectAtoms:e,sizeByAtom:r,small:a},i){let s=null;for(const o of Nl([a,n])){if(t===o)continue;const l=Wp(t,o,i,e,r);if(l<i){if(s=o,l===0)break;i=l}}return s}function Ol(t,n,e){return t.size<n?e.small:e.big}function Xp({size:t},{size:n}){return t-n}function Wp(t,n,e,r,a){const i=zl(t,n,e,r,a);return i<e?i+zl(n,t,e-i,r,a):1/0}function zl(t,n,e,r,a){const{correlatedAtoms:i}=n;let s=t.containedAtoms;const o=s&r;if((i&o)!==o)return 1/0;const l=new Set(t.dependencies);for(const{dependencies:c,containedAtoms:u}of l){s|=u;const f=u&r;if((i&f)!==f)return 1/0;for(const m of c){if(m===n)return 1/0;l.add(m)}}return function(c,u,f){let m=0,h=0,b=1n;const{length:p}=f;for(;h<p;h++)if((c&b)===b&&(m+=f[h]),b<<=1n,m>=u)return 1/0;return m}(s&~i,e,a)}const Kp=(t,n)=>t.execIndex>n.execIndex?1:-1;function Hp(t,n,e){const r=Symbol(t.id),a=[t.id];let i=n;for(t.cycles.add(r);i!==t;)i.cycles.add(r),a.push(i.id),i=e.get(i);return a.push(a[0]),a.reverse(),a}const Gl=(t,n)=>n?`(${t})`:t,Fl=/^(?!\d)[\w$]+$/;class Pl{constructor(n,e){this.isOriginal=!0,this.filename=n,this.content=e}traceSegment(n,e,r){return{column:e,line:n,name:r,source:this}}}class na{constructor(n,e){this.sources=e,this.names=n.names,this.mappings=n.mappings}traceMappings(){const n=[],e=new Map,r=[],a=[],i=new Map,s=[];for(const o of this.mappings){const l=[];for(const c of o){if(c.length===1)continue;const u=this.sources[c[1]];if(!u)continue;const f=u.traceSegment(c[2],c[3],c.length===5?this.names[c[4]]:"");if(f){const{column:m,line:h,name:b,source:{content:p,filename:g}}=f;let x=e.get(g);if(x===void 0)x=n.length,n.push(g),e.set(g,x),r[x]=p;else if(r[x]==null)r[x]=p;else if(p!=null&&r[x]!==p)return L(Ed(g));const k=[c[0],x,h,m];if(b){let y=i.get(b);y===void 0&&(y=a.length,a.push(b),i.set(b,y)),k[4]=y}l.push(k)}}s.push(l)}return{mappings:s,names:a,sources:n,sourcesContent:r}}traceSegment(n,e,r){const a=this.mappings[n];if(!a)return null;let i=0,s=a.length-1;for(;i<=s;){const o=i+s>>1,l=a[o];if(l[0]===e||i===s){if(l.length==1)return null;const c=this.sources[l[1]];return c?c.traceSegment(l[2],l[3],l.length===5?this.names[l[4]]:r):null}l[0]>e?s=o-1:i=o+1}return null}}function Ul(t){return function(n,e){return e.mappings?new na(e,[n]):(t(V,(r=e.plugin,{code:Ws,message:`Sourcemap is likely to be incorrect: a plugin (${r}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,plugin:r,url:En(qm)})),new na({mappings:[],names:[]},[n]));var r}}function Rl(t,n,e,r,a){let i;if(e){const s=e.sources,o=e.sourcesContent||[],l=Tt(t)||".",c=e.sourceRoot||".",u=s.map((f,m)=>new Pl(Hn(l,c,f),o[m]));i=new na(e,u)}else i=new Pl(t,n);return r.reduce(a,i)}var en={},qi=Vl;function Vl(t,n){if(!t)throw new Error(n||"Assertion failed")}Vl.equal=function(t,n,e){if(t!=n)throw new Error(e||"Assertion failed: "+t+" != "+n)};var Xi={exports:{}};typeof Object.create=="function"?Xi.exports=function(t,n){n&&(t.super_=n,t.prototype=Object.create(n.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:Xi.exports=function(t,n){if(n){t.super_=n;var e=function(){};e.prototype=n.prototype,t.prototype=new e,t.prototype.constructor=t}};var Yp=Xi.exports,Jp=qi,Zp=Yp;function Qp(t,n){return(64512&t.charCodeAt(n))==55296&&!(n<0||n+1>=t.length)&&(64512&t.charCodeAt(n+1))==56320}function ql(t){return(t>>>24|t>>>8&65280|t<<8&16711680|(255&t)<<24)>>>0}function Xl(t){return t.length===1?"0"+t:t}function Wl(t){return t.length===7?"0"+t:t.length===6?"00"+t:t.length===5?"000"+t:t.length===4?"0000"+t:t.length===3?"00000"+t:t.length===2?"000000"+t:t.length===1?"0000000"+t:t}en.inherits=Zp,en.toArray=function(t,n){if(Array.isArray(t))return t.slice();if(!t)return[];var e=[];if(typeof t=="string")if(n){if(n==="hex")for((t=t.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(t="0"+t),a=0;a<t.length;a+=2)e.push(parseInt(t[a]+t[a+1],16))}else for(var r=0,a=0;a<t.length;a++){var i=t.charCodeAt(a);i<128?e[r++]=i:i<2048?(e[r++]=i>>6|192,e[r++]=63&i|128):Qp(t,a)?(i=65536+((1023&i)<<10)+(1023&t.charCodeAt(++a)),e[r++]=i>>18|240,e[r++]=i>>12&63|128,e[r++]=i>>6&63|128,e[r++]=63&i|128):(e[r++]=i>>12|224,e[r++]=i>>6&63|128,e[r++]=63&i|128)}else for(a=0;a<t.length;a++)e[a]=0|t[a];return e},en.toHex=function(t){for(var n="",e=0;e<t.length;e++)n+=Xl(t[e].toString(16));return n},en.htonl=ql,en.toHex32=function(t,n){for(var e="",r=0;r<t.length;r++){var a=t[r];n==="little"&&(a=ql(a)),e+=Wl(a.toString(16))}return e},en.zero2=Xl,en.zero8=Wl,en.join32=function(t,n,e,r){var a=e-n;Jp(a%4==0);for(var i=new Array(a/4),s=0,o=n;s<i.length;s++,o+=4){var l;l=r==="big"?t[o]<<24|t[o+1]<<16|t[o+2]<<8|t[o+3]:t[o+3]<<24|t[o+2]<<16|t[o+1]<<8|t[o],i[s]=l>>>0}return i},en.split32=function(t,n){for(var e=new Array(4*t.length),r=0,a=0;r<t.length;r++,a+=4){var i=t[r];n==="big"?(e[a]=i>>>24,e[a+1]=i>>>16&255,e[a+2]=i>>>8&255,e[a+3]=255&i):(e[a+3]=i>>>24,e[a+2]=i>>>16&255,e[a+1]=i>>>8&255,e[a]=255&i)}return e},en.rotr32=function(t,n){return t>>>n|t<<32-n},en.rotl32=function(t,n){return t<<n|t>>>32-n},en.sum32=function(t,n){return t+n>>>0},en.sum32_3=function(t,n,e){return t+n+e>>>0},en.sum32_4=function(t,n,e,r){return t+n+e+r>>>0},en.sum32_5=function(t,n,e,r,a){return t+n+e+r+a>>>0},en.sum64=function(t,n,e,r){var a=t[n],i=r+t[n+1]>>>0,s=(i<r?1:0)+e+a;t[n]=s>>>0,t[n+1]=i},en.sum64_hi=function(t,n,e,r){return(n+r>>>0<n?1:0)+t+e>>>0},en.sum64_lo=function(t,n,e,r){return n+r>>>0},en.sum64_4_hi=function(t,n,e,r,a,i,s,o){var l=0,c=n;return l+=(c=c+r>>>0)<n?1:0,l+=(c=c+i>>>0)<i?1:0,t+e+a+s+(l+=(c=c+o>>>0)<o?1:0)>>>0},en.sum64_4_lo=function(t,n,e,r,a,i,s,o){return n+r+i+o>>>0},en.sum64_5_hi=function(t,n,e,r,a,i,s,o,l,c){var u=0,f=n;return u+=(f=f+r>>>0)<n?1:0,u+=(f=f+i>>>0)<i?1:0,u+=(f=f+o>>>0)<o?1:0,t+e+a+s+l+(u+=(f=f+c>>>0)<c?1:0)>>>0},en.sum64_5_lo=function(t,n,e,r,a,i,s,o,l,c){return n+r+i+o+c>>>0},en.rotr64_hi=function(t,n,e){return(n<<32-e|t>>>e)>>>0},en.rotr64_lo=function(t,n,e){return(t<<32-e|n>>>e)>>>0},en.shr64_hi=function(t,n,e){return t>>>e},en.shr64_lo=function(t,n,e){return(t<<32-e|n>>>e)>>>0};var Kl={},Hl=en,nh=qi;function ta(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}Kl.BlockHash=ta,ta.prototype.update=function(t,n){if(t=Hl.toArray(t,n),this.pending?this.pending=this.pending.concat(t):this.pending=t,this.pendingTotal+=t.length,this.pending.length>=this._delta8){var e=(t=this.pending).length%this._delta8;this.pending=t.slice(t.length-e,t.length),this.pending.length===0&&(this.pending=null),t=Hl.join32(t,0,t.length-e,this.endian);for(var r=0;r<t.length;r+=this._delta32)this._update(t,r,r+this._delta32)}return this},ta.prototype.digest=function(t){return this.update(this._pad()),nh(this.pending===null),this._digest(t)},ta.prototype._pad=function(){var t=this.pendingTotal,n=this._delta8,e=n-(t+this.padLength)%n,r=new Array(e+this.padLength);r[0]=128;for(var a=1;a<e;a++)r[a]=0;if(t<<=3,this.endian==="big"){for(var i=8;i<this.padLength;i++)r[a++]=0;r[a++]=0,r[a++]=0,r[a++]=0,r[a++]=0,r[a++]=t>>>24&255,r[a++]=t>>>16&255,r[a++]=t>>>8&255,r[a++]=255&t}else for(r[a++]=255&t,r[a++]=t>>>8&255,r[a++]=t>>>16&255,r[a++]=t>>>24&255,r[a++]=0,r[a++]=0,r[a++]=0,r[a++]=0,i=8;i<this.padLength;i++)r[a++]=0;return r};var ht={},st=en.rotr32;function Yl(t,n,e){return t&n^~t&e}function Jl(t,n,e){return t&n^t&e^n&e}function Zl(t,n,e){return t^n^e}ht.ft_1=function(t,n,e,r){return t===0?Yl(n,e,r):t===1||t===3?Zl(n,e,r):t===2?Jl(n,e,r):void 0},ht.ch32=Yl,ht.maj32=Jl,ht.p32=Zl,ht.s0_256=function(t){return st(t,2)^st(t,13)^st(t,22)},ht.s1_256=function(t){return st(t,6)^st(t,11)^st(t,25)},ht.g0_256=function(t){return st(t,7)^st(t,18)^t>>>3},ht.g1_256=function(t){return st(t,17)^st(t,19)^t>>>10};var ue=en,th=Kl,fe=ht,eh=qi,Zn=ue.sum32,rh=ue.sum32_4,ah=ue.sum32_5,ih=fe.ch32,sh=fe.maj32,oh=fe.s0_256,lh=fe.s1_256,ch=fe.g0_256,_h=fe.g1_256,Ql=th.BlockHash,uh=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function ot(){if(!(this instanceof ot))return new ot;Ql.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=uh,this.W=new Array(64)}ue.inherits(ot,Ql);var fh=ot;ot.blockSize=512,ot.outSize=256,ot.hmacStrength=192,ot.padLength=64,ot.prototype._update=function(t,n){for(var e=this.W,r=0;r<16;r++)e[r]=t[n+r];for(;r<e.length;r++)e[r]=rh(_h(e[r-2]),e[r-7],ch(e[r-15]),e[r-16]);var a=this.h[0],i=this.h[1],s=this.h[2],o=this.h[3],l=this.h[4],c=this.h[5],u=this.h[6],f=this.h[7];for(eh(this.k.length===e.length),r=0;r<e.length;r++){var m=ah(f,lh(l),ih(l,c,u),this.k[r],e[r]),h=Zn(oh(a),sh(a,i,s));f=u,u=c,c=l,l=Zn(o,m),o=s,s=i,i=a,a=Zn(m,h)}this.h[0]=Zn(this.h[0],a),this.h[1]=Zn(this.h[1],i),this.h[2]=Zn(this.h[2],s),this.h[3]=Zn(this.h[3],o),this.h[4]=Zn(this.h[4],l),this.h[5]=Zn(this.h[5],c),this.h[6]=Zn(this.h[6],u),this.h[7]=Zn(this.h[7],f)},ot.prototype._digest=function(t){return t==="hex"?ue.toHex32(this.h,"big"):ue.split32(this.h,"big")};var mh=ks(fh);const Ye=()=>mh();function Wi(t){if(!t)return null;if(typeof t=="string"&&(t=JSON.parse(t)),t.mappings==="")return{mappings:[],names:[],sources:[],version:3};const n=typeof t.mappings=="string"?Es.decode(t.mappings):t.mappings;return{...t,mappings:n}}async function dh(t,n,e,r,a){$n("render chunks",2),function(f){for(const m of f)m.facadeModule&&m.facadeModule.isUserDefinedEntryPoint&&m.getPreliminaryFileName()}(t);const i=await Promise.all(t.map(f=>f.render()));xn("render chunks",2),$n("transform chunks",2);const s=function(f){return Object.fromEntries(f.map(m=>{const h=m.getRenderedChunkInfo();return[h.fileName,h]}))}(t),{nonHashedChunksWithPlaceholders:o,renderedChunksByPlaceholder:l,hashDependenciesByPlaceholder:c}=await async function(f,m,h,b,p){const g=[],x=new Map,k=new Map,y=new Set;for(const{preliminaryFileName:{hashPlaceholder:v}}of f)v&&y.add(v);return await Promise.all(f.map(async({chunk:v,preliminaryFileName:{fileName:$,hashPlaceholder:w},magicString:S,usedModules:I})=>{const C={chunk:v,fileName:$,...await ph(S,$,I,m,h,b,p)},{code:B}=C;if(w){const{containedPlaceholders:U,transformedCode:D}=Op(B,y),F=Ye().update(D),N=b.hookReduceValueSync("augmentChunkHash","",[v.getRenderedChunkInfo()],(z,E)=>(E&&(z+=E),z));N&&F.update(N),x.set(w,C),k.set(w,{containedPlaceholders:U,contentHash:F.digest("hex")})}else g.push(C)})),{hashDependenciesByPlaceholder:k,nonHashedChunksWithPlaceholders:g,renderedChunksByPlaceholder:x}}(i,s,r,e,a),u=function(f,m,h){const b=new Map;for(const[p,{fileName:g}]of f){let x=Ye();const k=new Set([p]);for(const $ of k){const{containedPlaceholders:w,contentHash:S}=m.get($);x.update(S);for(const I of w)k.add(I)}let y,v;do v&&(x=Ye().update(v)),v=x.digest("hex").slice(0,p.length),y=Dp(g,p,v);while(h[Zr].has(y.toLowerCase()));h[y]=Ri,b.set(p,v)}return b}(l,c,n);(function(f,m,h,b,p,g){for(const{chunk:x,code:k,fileName:y,map:v}of f.values()){let $=He(k,m);const w=He(y,m);v&&(v.file=He(v.file,m),$+=nc(w,v,p,g)),h[w]=x.finalizeChunk($,v,m)}for(const{chunk:x,code:k,fileName:y,map:v}of b){let $=m.size>0?He(k,m):k;v&&($+=nc(y,v,p,g)),h[y]=x.finalizeChunk($,v,m)}})(l,u,n,o,e,r),xn("transform chunks",2)}async function ph(t,n,e,r,a,i,s){let o=null;const l=[];let c=await i.hookReduceArg0("renderChunk",[t.toString(),r[n],a,{chunks:r}],(k,y,v)=>{if(y==null)return k;if(typeof y=="string"&&(y={code:y,map:void 0}),y.map!==null){const $=Wi(y.map);l.push($||{missing:!0,plugin:v.name})}return y.code});const{compact:u,dir:f,file:m,sourcemap:h,sourcemapExcludeSources:b,sourcemapFile:p,sourcemapPathTransform:g,sourcemapIgnoreList:x}=a;if(u||c[c.length-1]===`
`||(c+=`
`),h){let k;$n("sourcemaps",3),k=m?Hn(p||m):f?Hn(f,n):Hn(n),o=function(y,v,$,w,S,I){const C=Ul(I),B=$.filter(j=>!j.excludeFromSourcemap).map(j=>Rl(j.id,j.originalCode,j.originalSourcemap,j.sourcemapChain,C)),U=new na(v,B),D=w.reduce(C,U);let{sources:F,sourcesContent:N,names:z,mappings:E}=D.traceMappings();if(y){const j=Tt(y);F=F.map(G=>ne(j,G)),y=ft(y)}return N=S?null:N,new mr({file:y,mappings:E,names:z,sources:F,sourcesContent:N})}(k,t.generateDecodedMap({}),e,l,b,s);for(let y=0;y<o.sources.length;++y){let v=o.sources[y];const $=`${k}.map`,w=x(v,$);typeof w!="boolean"&&L(Tn("sourcemapIgnoreList function must return a boolean.")),w&&(o.x_google_ignoreList===void 0&&(o.x_google_ignoreList=[]),o.x_google_ignoreList.includes(y)||o.x_google_ignoreList.push(y)),g&&(v=g(v,$),typeof v!="string"&&L(Tn("sourcemapPathTransform function must return a string."))),o.sources[y]=ke(v)}xn("sourcemaps",3)}return{code:c,map:o}}function nc(t,n,e,{sourcemap:r,sourcemapBaseUrl:a}){let i;if(r==="inline")i=n.toUrl();else{const s=`${ft(t)}.map`;i=a?new URL(s,a).toString():s,e.emitFile({fileName:`${t}.map`,source:n.toString(),type:"asset"})}return r==="hidden"?"":`//# ${ni}=${i}
`}class hh{constructor(n,e,r,a,i){this.outputOptions=n,this.unsetOptions=e,this.inputOptions=r,this.pluginDriver=a,this.graph=i,this.facadeChunkByModule=new Map,this.includedNamespaces=new Set}async generate(n){$n("GENERATE",1);const e=Object.create(null),r=(a=>{const i=new Set;return new Proxy(a,{deleteProperty:(s,o)=>(typeof o=="string"&&i.delete(o.toLowerCase()),Reflect.deleteProperty(s,o)),get:(s,o)=>o===Zr?i:Reflect.get(s,o),set:(s,o,l)=>(typeof o=="string"&&i.add(o.toLowerCase()),Reflect.set(s,o,l))})})(e);this.pluginDriver.setOutputBundle(r,this.outputOptions);try{$n("initialize render",2),await this.pluginDriver.hookParallel("renderStart",[this.outputOptions,this.inputOptions]),xn("initialize render",2),$n("generate chunks",2);const a=(()=>{let s=0;return(o,l=8)=>{if(l>64)return L(Tn(`Hashes cannot be longer than 64 characters, received ${l}. Check the "${o}" option.`));const c=`${Fi}${jr(++s).padStart(l-5,"0")}${Pi}`;return c.length>l?L(Tn(`To generate hashes for this number of chunks (currently ${s}), you need a minimum hash size of ${c.length}, received ${l}. Check the "${o}" option.`)):c}})(),i=await this.generateChunks(r,a);i.length>1&&function(s,o){if(s.format==="umd"||s.format==="iife")return L(bn("output.format",Fs,"UMD and IIFE output formats are not supported for code-splitting builds",s.format));if(typeof s.file=="string")return L(bn("output.file",Ae,'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));if(s.sourcemapFile)return L(bn("output.sourcemapFile",Hm,'"output.sourcemapFile" is only supported for single-file builds'));!s.amd.autoId&&s.amd.id&&o(V,bn("output.amd.id",Gs,'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'))}(this.outputOptions,this.inputOptions.onLog),this.pluginDriver.setChunkInformation(this.facadeChunkByModule);for(const s of i)s.generateExports();xn("generate chunks",2),await dh(i,r,this.pluginDriver,this.outputOptions,this.inputOptions.onLog)}catch(a){throw await this.pluginDriver.hookParallel("renderError",[a]),a}return(a=>{const i=new Set,s=Object.values(a);for(const o of s)o.type==="asset"&&o.needsCodeReference&&i.add(o.fileName);for(const o of s)if(o.type==="chunk")for(const l of o.referencedFiles)i.has(l)&&i.delete(l);for(const o of i)delete a[o]})(r),$n("generate bundle",2),await this.pluginDriver.hookSeq("generateBundle",[this.outputOptions,r,n]),this.finaliseAssets(r),xn("generate bundle",2),xn("GENERATE",1),e}async addManualChunks(n){const e=new Map,r=await Promise.all(Object.entries(n).map(async([a,i])=>({alias:a,entries:await this.graph.moduleLoader.addAdditionalModules(i)})));for(const{alias:a,entries:i}of r)for(const s of i)tc(a,s,e);return e}assignManualChunks(n){const e=[],r={getModuleIds:()=>this.graph.modulesById.keys(),getModuleInfo:this.graph.getModuleInfo};for(const i of this.graph.modulesById.values())if(i instanceof hn){const s=n(i.id,r);typeof s=="string"&&e.push([s,i])}e.sort(([i],[s])=>i>s?1:i<s?-1:0);const a=new Map;for(const[i,s]of e)tc(i,s,a);return a}finaliseAssets(n){if(this.outputOptions.validate){for(const e of Object.values(n))if("code"in e)try{this.graph.contextParse(e.code,{ecmaVersion:"latest"})}catch(r){this.inputOptions.onLog(V,vd(e,r))}}this.pluginDriver.finaliseAssets()}async generateChunks(n,e){const{experimentalMinChunkSize:r,inlineDynamicImports:a,manualChunks:i,preserveModules:s}=this.outputOptions,o=typeof i=="object"?await this.addManualChunks(i):this.assignManualChunks(i),l=function({compact:p,generatedCode:{arrowFunctions:g,constBindings:x,objectShorthand:k,reservedNamesAsProps:y}}){const{_:v,n:$,s:w}=p?{_:"",n:"",s:""}:{_:" ",n:`
`,s:";"},S=x?"const":"var",I=(D,{isAsync:F,name:N})=>`${F?"async ":""}function${N?` ${N}`:""}${v}(${D.join(`,${v}`)})${v}`,C=g?(D,{isAsync:F,name:N})=>{const z=D.length===1;return`${N?`${S} ${N}${v}=${v}`:""}${F?`async${z?" ":v}`:""}${z?D[0]:`(${D.join(`,${v}`)})`}${v}=>${v}`}:I,B=(D,{functionReturn:F,lineBreakIndent:N,name:z})=>[`${C(D,{isAsync:!1,name:z})}${g?N?`${$}${N.base}${N.t}`:"":`{${N?`${$}${N.base}${N.t}`:v}${F?"return ":""}`}`,g?`${z?";":""}${N?`${$}${N.base}`:""}`:`${w}${N?`${$}${N.base}`:v}}`],U=y?D=>Fl.test(D):D=>!br.has(D)&&Fl.test(D);return{_:v,cnst:S,getDirectReturnFunction:B,getDirectReturnIifeLeft:(D,F,{needsArrowReturnParens:N,needsWrappedFunction:z})=>{const[E,j]=B(D,{functionReturn:!0,lineBreakIndent:null,name:null});return`${Gl(`${E}${Gl(F,g&&N)}${j}`,g||z)}(`},getFunctionIntro:C,getNonArrowFunctionIntro:I,getObject(D,{lineBreakIndent:F}){const N=F?`${$}${F.base}${F.t}`:v;return`{${D.map(([z,E])=>{if(z===null)return`${N}${E}`;const j=!U(z);return z===E&&k&&!j?N+z:`${N}${j?`'${z}'`:z}:${v}${E}`}).join(",")}${D.length===0?"":F?`${$}${F.base}`:v}}`},getPropertyAccess:D=>U(D)?`.${D}`:`[${JSON.stringify(D)}]`,n:$,s:w}}(this.outputOptions),c=function(p){const g=[];for(const x of p.values())x instanceof hn&&(x.isIncluded()||x.info.isEntry||x.includedDynamicImporters.length>0)&&g.push(x);return g}(this.graph.modulesById),u=function(p){if(p.length===0)return"/";if(p.length===1)return Tt(p[0]);const g=p.slice(1).reduce((x,k)=>{const y=k.split(/\/+|\\+/);let v;for(v=0;x[v]===y[v]&&v<Math.min(x.length,y.length);v++);return x.slice(0,v)},p[0].split(/\/+|\\+/));return g.length>1?g.join("/"):"/"}(function(p,g){const x=[];for(const k of p)(k.info.isEntry||g)&&bt(k.id)&&x.push(k.id);return x}(c,s)),f=function(p,g,x){const k=new Map;for(const y of p.values())y instanceof fn&&k.set(y,new te(y,g,x));return k}(this.graph.modulesById,this.outputOptions,u),m=[],h=new Map;for(const{alias:p,modules:g}of a?[{alias:null,modules:c}]:s?c.map(x=>({alias:null,modules:[x]})):Up(this.graph.entryModules,o,r,this.inputOptions.onLog)){g.sort(Kp);const x=new St(g,this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.graph.modulesById,h,f,this.facadeChunkByModule,this.includedNamespaces,p,e,n,u,l);m.push(x)}for(const p of m)p.link();const b=[];for(const p of m)b.push(...p.generateFacades());return[...m,...b]}}function tc(t,n,e){const r=e.get(n);if(typeof r=="string"&&r!==t)return L((a=n.id,i=t,s=r,{code:od,message:`Cannot assign "${W(a)}" to the "${i}" chunk as it is already in the "${s}" chunk.`}));var a,i,s;e.set(n,t)}var gh=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,81,2,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,9,5351,0,7,14,13835,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,983,6,110,6,6,9,4759,9,787719,239],ec=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,4026,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,757,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,3104,541,1507,4938,6,4191],rc="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",Ki={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},Hi="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",yh={5:Hi,"5module":Hi+" export import",6:Hi+" const class extends export import super"},bh=/^in(stanceof)?$/,xh=new RegExp("["+rc+"]"),vh=new RegExp("["+rc+"‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿]");function Yi(t,n){for(var e=65536,r=0;r<n.length;r+=2){if((e+=n[r])>t)return!1;if((e+=n[r+1])>=t)return!0}return!1}function lt(t,n){return t<65?t===36:t<91||(t<97?t===95:t<123||(t<=65535?t>=170&&xh.test(String.fromCharCode(t)):n!==!1&&Yi(t,ec)))}function Kt(t,n){return t<48?t===36:t<58||!(t<65)&&(t<91||(t<97?t===95:t<123||(t<=65535?t>=170&&vh.test(String.fromCharCode(t)):n!==!1&&(Yi(t,ec)||Yi(t,gh)))))}var Q=function(t,n){n===void 0&&(n={}),this.label=t,this.keyword=n.keyword,this.beforeExpr=!!n.beforeExpr,this.startsExpr=!!n.startsExpr,this.isLoop=!!n.isLoop,this.isAssign=!!n.isAssign,this.prefix=!!n.prefix,this.postfix=!!n.postfix,this.binop=n.binop||null,this.updateContext=null};function qn(t,n){return new Q(t,{beforeExpr:!0,binop:n})}var Xn={beforeExpr:!0},Dn={startsExpr:!0},ea={};function Z(t,n){return n===void 0&&(n={}),n.keyword=t,ea[t]=new Q(t,n)}var d={num:new Q("num",Dn),regexp:new Q("regexp",Dn),string:new Q("string",Dn),name:new Q("name",Dn),privateId:new Q("privateId",Dn),eof:new Q("eof"),bracketL:new Q("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new Q("]"),braceL:new Q("{",{beforeExpr:!0,startsExpr:!0}),braceR:new Q("}"),parenL:new Q("(",{beforeExpr:!0,startsExpr:!0}),parenR:new Q(")"),comma:new Q(",",Xn),semi:new Q(";",Xn),colon:new Q(":",Xn),dot:new Q("."),question:new Q("?",Xn),questionDot:new Q("?."),arrow:new Q("=>",Xn),template:new Q("template"),invalidTemplate:new Q("invalidTemplate"),ellipsis:new Q("...",Xn),backQuote:new Q("`",Dn),dollarBraceL:new Q("${",{beforeExpr:!0,startsExpr:!0}),eq:new Q("=",{beforeExpr:!0,isAssign:!0}),assign:new Q("_=",{beforeExpr:!0,isAssign:!0}),incDec:new Q("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new Q("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:qn("||",1),logicalAND:qn("&&",2),bitwiseOR:qn("|",3),bitwiseXOR:qn("^",4),bitwiseAND:qn("&",5),equality:qn("==/!=/===/!==",6),relational:qn("</>/<=/>=",7),bitShift:qn("<</>>/>>>",8),plusMin:new Q("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:qn("%",10),star:qn("*",10),slash:qn("/",10),starstar:new Q("**",{beforeExpr:!0}),coalesce:qn("??",1),_break:Z("break"),_case:Z("case",Xn),_catch:Z("catch"),_continue:Z("continue"),_debugger:Z("debugger"),_default:Z("default",Xn),_do:Z("do",{isLoop:!0,beforeExpr:!0}),_else:Z("else",Xn),_finally:Z("finally"),_for:Z("for",{isLoop:!0}),_function:Z("function",Dn),_if:Z("if"),_return:Z("return",Xn),_switch:Z("switch"),_throw:Z("throw",Xn),_try:Z("try"),_var:Z("var"),_const:Z("const"),_while:Z("while",{isLoop:!0}),_with:Z("with"),_new:Z("new",{beforeExpr:!0,startsExpr:!0}),_this:Z("this",Dn),_super:Z("super",Dn),_class:Z("class",Dn),_extends:Z("extends",Xn),_export:Z("export"),_import:Z("import",Dn),_null:Z("null",Dn),_true:Z("true",Dn),_false:Z("false",Dn),_in:Z("in",{beforeExpr:!0,binop:7}),_instanceof:Z("instanceof",{beforeExpr:!0,binop:7}),_typeof:Z("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:Z("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:Z("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},Pn=/\r\n?|\n|\u2028|\u2029/,ac=new RegExp(Pn.source,"g");function Ht(t){return t===10||t===13||t===8232||t===8233}function ic(t,n,e){e===void 0&&(e=t.length);for(var r=n;r<e;r++){var a=t.charCodeAt(r);if(Ht(a))return r<e-1&&a===13&&t.charCodeAt(r+1)===10?r+2:r+1}return-1}var Ji=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Wn=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,sc=Object.prototype,$h=sc.hasOwnProperty,kh=sc.toString,Je=Object.hasOwn||function(t,n){return $h.call(t,n)},oc=Array.isArray||function(t){return kh.call(t)==="[object Array]"};function Yt(t){return new RegExp("^(?:"+t.replace(/ /g,"|")+")$")}function Bt(t){return t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode(55296+(t>>10),56320+(1023&t)))}var Ch=/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,me=function(t,n){this.line=t,this.column=n};me.prototype.offset=function(t){return new me(this.line,this.column+t)};var Ze=function(t,n,e){this.start=n,this.end=e,t.sourceFile!==null&&(this.source=t.sourceFile)};function Zi(t,n){for(var e=1,r=0;;){var a=ic(t,r,n);if(a<0)return new me(e,n-r);++e,r=a}}var ra={ecmaVersion:null,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:null,allowSuperOutsideMethod:null,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1},lc=!1;function Eh(t){var n={};for(var e in ra)n[e]=t&&Je(t,e)?t[e]:ra[e];if(n.ecmaVersion==="latest"?n.ecmaVersion=1e8:n.ecmaVersion==null?(!lc&&typeof console=="object"&&console.warn&&(lc=!0,console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)),n.ecmaVersion=11):n.ecmaVersion>=2015&&(n.ecmaVersion-=2009),n.allowReserved==null&&(n.allowReserved=n.ecmaVersion<5),t&&t.allowHashBang!=null||(n.allowHashBang=n.ecmaVersion>=14),oc(n.onToken)){var r=n.onToken;n.onToken=function(a){return r.push(a)}}return oc(n.onComment)&&(n.onComment=function(a,i){return function(s,o,l,c,u,f){var m={type:s?"Block":"Line",value:o,start:l,end:c};a.locations&&(m.loc=new Ze(this,u,f)),a.ranges&&(m.range=[l,c]),i.push(m)}}(n,n.onComment)),n}var cc=256;function Qi(t,n){return 2|(t?4:0)|(n?8:0)}var dn=function(t,n,e){this.options=t=Eh(t),this.sourceFile=t.sourceFile,this.keywords=Yt(yh[t.ecmaVersion>=6?6:t.sourceType==="module"?"5module":5]);var r="";t.allowReserved!==!0&&(r=Ki[t.ecmaVersion>=6?6:t.ecmaVersion===5?5:3],t.sourceType==="module"&&(r+=" await")),this.reservedWords=Yt(r);var a=(r?r+" ":"")+Ki.strict;this.reservedWordsStrict=Yt(a),this.reservedWordsStrictBind=Yt(a+" "+Ki.strictBind),this.input=String(n),this.containsEsc=!1,e?(this.pos=e,this.lineStart=this.input.lastIndexOf(`
`,e-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(Pn).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=d.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule=t.sourceType==="module",this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.potentialArrowInForAwait=!1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports=Object.create(null),this.pos===0&&t.allowHashBang&&this.input.slice(0,2)==="#!"&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(1),this.regexpState=null,this.privateNameStack=[]},ct={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},canAwait:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0},allowNewDotTarget:{configurable:!0},inClassStaticBlock:{configurable:!0}};dn.prototype.parse=function(){var t=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(t)},ct.inFunction.get=function(){return(2&this.currentVarScope().flags)>0},ct.inGenerator.get=function(){return(8&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},ct.inAsync.get=function(){return(4&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},ct.canAwait.get=function(){for(var t=this.scopeStack.length-1;t>=0;t--){var n=this.scopeStack[t];if(n.inClassFieldInit||n.flags&cc)return!1;if(2&n.flags)return(4&n.flags)>0}return this.inModule&&this.options.ecmaVersion>=13||this.options.allowAwaitOutsideFunction},ct.allowSuper.get=function(){var t=this.currentThisScope(),n=t.flags,e=t.inClassFieldInit;return(64&n)>0||e||this.options.allowSuperOutsideMethod},ct.allowDirectSuper.get=function(){return(128&this.currentThisScope().flags)>0},ct.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},ct.allowNewDotTarget.get=function(){var t=this.currentThisScope(),n=t.flags,e=t.inClassFieldInit;return(258&n)>0||e},ct.inClassStaticBlock.get=function(){return(this.currentVarScope().flags&cc)>0},dn.extend=function(){for(var t=[],n=arguments.length;n--;)t[n]=arguments[n];for(var e=this,r=0;r<t.length;r++)e=t[r](e);return e},dn.parse=function(t,n){return new this(n,t).parse()},dn.parseExpressionAt=function(t,n,e){var r=new this(e,t,n);return r.nextToken(),r.parseExpression()},dn.tokenizer=function(t,n){return new this(n,t)},Object.defineProperties(dn.prototype,ct);var Ln=dn.prototype,Ah=/^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;Ln.strictDirective=function(t){if(this.options.ecmaVersion<5)return!1;for(;;){Wn.lastIndex=t,t+=Wn.exec(this.input)[0].length;var n=Ah.exec(this.input.slice(t));if(!n)return!1;if((n[1]||n[2])==="use strict"){Wn.lastIndex=t+n[0].length;var e=Wn.exec(this.input),r=e.index+e[0].length,a=this.input.charAt(r);return a===";"||a==="}"||Pn.test(e[0])&&!(/[(`.[+\-/*%<>=,?^&]/.test(a)||a==="!"&&this.input.charAt(r+1)==="=")}t+=n[0].length,Wn.lastIndex=t,t+=Wn.exec(this.input)[0].length,this.input[t]===";"&&t++}},Ln.eat=function(t){return this.type===t&&(this.next(),!0)},Ln.isContextual=function(t){return this.type===d.name&&this.value===t&&!this.containsEsc},Ln.eatContextual=function(t){return!!this.isContextual(t)&&(this.next(),!0)},Ln.expectContextual=function(t){this.eatContextual(t)||this.unexpected()},Ln.canInsertSemicolon=function(){return this.type===d.eof||this.type===d.braceR||Pn.test(this.input.slice(this.lastTokEnd,this.start))},Ln.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},Ln.semicolon=function(){this.eat(d.semi)||this.insertSemicolon()||this.unexpected()},Ln.afterTrailingComma=function(t,n){if(this.type===t)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),n||this.next(),!0},Ln.expect=function(t){this.eat(t)||this.unexpected()},Ln.unexpected=function(t){this.raise(t??this.start,"Unexpected token")};var aa=function(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1};Ln.checkPatternErrors=function(t,n){if(t){t.trailingComma>-1&&this.raiseRecoverable(t.trailingComma,"Comma is not permitted after the rest element");var e=n?t.parenthesizedAssign:t.parenthesizedBind;e>-1&&this.raiseRecoverable(e,n?"Assigning to rvalue":"Parenthesized pattern")}},Ln.checkExpressionErrors=function(t,n){if(!t)return!1;var e=t.shorthandAssign,r=t.doubleProto;if(!n)return e>=0||r>=0;e>=0&&this.raise(e,"Shorthand property assignments are valid only in destructuring patterns"),r>=0&&this.raiseRecoverable(r,"Redefinition of __proto__ property")},Ln.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},Ln.isSimpleAssignTarget=function(t){return t.type==="ParenthesizedExpression"?this.isSimpleAssignTarget(t.expression):t.type==="Identifier"||t.type==="MemberExpression"};var R=dn.prototype;R.parseTopLevel=function(t){var n=Object.create(null);for(t.body||(t.body=[]);this.type!==d.eof;){var e=this.parseStatement(null,!0,n);t.body.push(e)}if(this.inModule)for(var r=0,a=Object.keys(this.undefinedExports);r<a.length;r+=1){var i=a[r];this.raiseRecoverable(this.undefinedExports[i].start,"Export '"+i+"' is not defined")}return this.adaptDirectivePrologue(t.body),this.next(),t.sourceType=this.options.sourceType,this.finishNode(t,"Program")};var ns={kind:"loop"},wh={kind:"switch"};R.isLet=function(t){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;Wn.lastIndex=this.pos;var n=Wn.exec(this.input),e=this.pos+n[0].length,r=this.input.charCodeAt(e);if(r===91||r===92)return!0;if(t)return!1;if(r===123||r>55295&&r<56320)return!0;if(lt(r,!0)){for(var a=e+1;Kt(r=this.input.charCodeAt(a),!0);)++a;if(r===92||r>55295&&r<56320)return!0;var i=this.input.slice(e,a);if(!bh.test(i))return!0}return!1},R.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;Wn.lastIndex=this.pos;var t,n=Wn.exec(this.input),e=this.pos+n[0].length;return!(Pn.test(this.input.slice(this.pos,e))||this.input.slice(e,e+8)!=="function"||e+8!==this.input.length&&(Kt(t=this.input.charCodeAt(e+8))||t>55295&&t<56320))},R.parseStatement=function(t,n,e){var r,a=this.type,i=this.startNode();switch(this.isLet(t)&&(a=d._var,r="let"),a){case d._break:case d._continue:return this.parseBreakContinueStatement(i,a.keyword);case d._debugger:return this.parseDebuggerStatement(i);case d._do:return this.parseDoStatement(i);case d._for:return this.parseForStatement(i);case d._function:return t&&(this.strict||t!=="if"&&t!=="label")&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(i,!1,!t);case d._class:return t&&this.unexpected(),this.parseClass(i,!0);case d._if:return this.parseIfStatement(i);case d._return:return this.parseReturnStatement(i);case d._switch:return this.parseSwitchStatement(i);case d._throw:return this.parseThrowStatement(i);case d._try:return this.parseTryStatement(i);case d._const:case d._var:return r=r||this.value,t&&r!=="var"&&this.unexpected(),this.parseVarStatement(i,r);case d._while:return this.parseWhileStatement(i);case d._with:return this.parseWithStatement(i);case d.braceL:return this.parseBlock(!0,i);case d.semi:return this.parseEmptyStatement(i);case d._export:case d._import:if(this.options.ecmaVersion>10&&a===d._import){Wn.lastIndex=this.pos;var s=Wn.exec(this.input),o=this.pos+s[0].length,l=this.input.charCodeAt(o);if(l===40||l===46)return this.parseExpressionStatement(i,this.parseExpression())}return this.options.allowImportExportEverywhere||(n||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),a===d._import?this.parseImport(i):this.parseExport(i,e);default:if(this.isAsyncFunction())return t&&this.unexpected(),this.next(),this.parseFunctionStatement(i,!0,!t);var c=this.value,u=this.parseExpression();return a===d.name&&u.type==="Identifier"&&this.eat(d.colon)?this.parseLabeledStatement(i,c,u,t):this.parseExpressionStatement(i,u)}},R.parseBreakContinueStatement=function(t,n){var e=n==="break";this.next(),this.eat(d.semi)||this.insertSemicolon()?t.label=null:this.type!==d.name?this.unexpected():(t.label=this.parseIdent(),this.semicolon());for(var r=0;r<this.labels.length;++r){var a=this.labels[r];if((t.label==null||a.name===t.label.name)&&(a.kind!=null&&(e||a.kind==="loop")||t.label&&e))break}return r===this.labels.length&&this.raise(t.start,"Unsyntactic "+n),this.finishNode(t,e?"BreakStatement":"ContinueStatement")},R.parseDebuggerStatement=function(t){return this.next(),this.semicolon(),this.finishNode(t,"DebuggerStatement")},R.parseDoStatement=function(t){return this.next(),this.labels.push(ns),t.body=this.parseStatement("do"),this.labels.pop(),this.expect(d._while),t.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(d.semi):this.semicolon(),this.finishNode(t,"DoWhileStatement")},R.parseForStatement=function(t){this.next();var n=this.options.ecmaVersion>=9&&this.canAwait&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(ns),this.enterScope(0),this.expect(d.parenL),this.type===d.semi)return n>-1&&this.unexpected(n),this.parseFor(t,null);var e=this.isLet();if(this.type===d._var||this.type===d._const||e){var r=this.startNode(),a=e?"let":this.value;return this.next(),this.parseVar(r,!0,a),this.finishNode(r,"VariableDeclaration"),(this.type===d._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&r.declarations.length===1?(this.options.ecmaVersion>=9&&(this.type===d._in?n>-1&&this.unexpected(n):t.await=n>-1),this.parseForIn(t,r)):(n>-1&&this.unexpected(n),this.parseFor(t,r))}var i=this.isContextual("let"),s=!1,o=new aa,l=this.parseExpression(!(n>-1)||"await",o);return this.type===d._in||(s=this.options.ecmaVersion>=6&&this.isContextual("of"))?(this.options.ecmaVersion>=9&&(this.type===d._in?n>-1&&this.unexpected(n):t.await=n>-1),i&&s&&this.raise(l.start,"The left-hand side of a for-of loop may not start with 'let'."),this.toAssignable(l,!1,o),this.checkLValPattern(l),this.parseForIn(t,l)):(this.checkExpressionErrors(o,!0),n>-1&&this.unexpected(n),this.parseFor(t,l))},R.parseFunctionStatement=function(t,n,e){return this.next(),this.parseFunction(t,Qe|(e?0:ts),!1,n)},R.parseIfStatement=function(t){return this.next(),t.test=this.parseParenExpression(),t.consequent=this.parseStatement("if"),t.alternate=this.eat(d._else)?this.parseStatement("if"):null,this.finishNode(t,"IfStatement")},R.parseReturnStatement=function(t){return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(d.semi)||this.insertSemicolon()?t.argument=null:(t.argument=this.parseExpression(),this.semicolon()),this.finishNode(t,"ReturnStatement")},R.parseSwitchStatement=function(t){var n;this.next(),t.discriminant=this.parseParenExpression(),t.cases=[],this.expect(d.braceL),this.labels.push(wh),this.enterScope(0);for(var e=!1;this.type!==d.braceR;)if(this.type===d._case||this.type===d._default){var r=this.type===d._case;n&&this.finishNode(n,"SwitchCase"),t.cases.push(n=this.startNode()),n.consequent=[],this.next(),r?n.test=this.parseExpression():(e&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),e=!0,n.test=null),this.expect(d.colon)}else n||this.unexpected(),n.consequent.push(this.parseStatement(null));return this.exitScope(),n&&this.finishNode(n,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(t,"SwitchStatement")},R.parseThrowStatement=function(t){return this.next(),Pn.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),t.argument=this.parseExpression(),this.semicolon(),this.finishNode(t,"ThrowStatement")};var Sh=[];R.parseTryStatement=function(t){if(this.next(),t.block=this.parseBlock(),t.handler=null,this.type===d._catch){var n=this.startNode();if(this.next(),this.eat(d.parenL)){n.param=this.parseBindingAtom();var e=n.param.type==="Identifier";this.enterScope(e?32:0),this.checkLValPattern(n.param,e?4:2),this.expect(d.parenR)}else this.options.ecmaVersion<10&&this.unexpected(),n.param=null,this.enterScope(0);n.body=this.parseBlock(!1),this.exitScope(),t.handler=this.finishNode(n,"CatchClause")}return t.finalizer=this.eat(d._finally)?this.parseBlock():null,t.handler||t.finalizer||this.raise(t.start,"Missing catch or finally clause"),this.finishNode(t,"TryStatement")},R.parseVarStatement=function(t,n){return this.next(),this.parseVar(t,!1,n),this.semicolon(),this.finishNode(t,"VariableDeclaration")},R.parseWhileStatement=function(t){return this.next(),t.test=this.parseParenExpression(),this.labels.push(ns),t.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(t,"WhileStatement")},R.parseWithStatement=function(t){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),t.object=this.parseParenExpression(),t.body=this.parseStatement("with"),this.finishNode(t,"WithStatement")},R.parseEmptyStatement=function(t){return this.next(),this.finishNode(t,"EmptyStatement")},R.parseLabeledStatement=function(t,n,e,r){for(var a=0,i=this.labels;a<i.length;a+=1)i[a].name===n&&this.raise(e.start,"Label '"+n+"' is already declared");for(var s=this.type.isLoop?"loop":this.type===d._switch?"switch":null,o=this.labels.length-1;o>=0;o--){var l=this.labels[o];if(l.statementStart!==t.start)break;l.statementStart=this.start,l.kind=s}return this.labels.push({name:n,kind:s,statementStart:this.start}),t.body=this.parseStatement(r?r.indexOf("label")===-1?r+"label":r:"label"),this.labels.pop(),t.label=e,this.finishNode(t,"LabeledStatement")},R.parseExpressionStatement=function(t,n){return t.expression=n,this.semicolon(),this.finishNode(t,"ExpressionStatement")},R.parseBlock=function(t,n,e){for(t===void 0&&(t=!0),n===void 0&&(n=this.startNode()),n.body=[],this.expect(d.braceL),t&&this.enterScope(0);this.type!==d.braceR;){var r=this.parseStatement(null);n.body.push(r)}return e&&(this.strict=!1),this.next(),t&&this.exitScope(),this.finishNode(n,"BlockStatement")},R.parseFor=function(t,n){return t.init=n,this.expect(d.semi),t.test=this.type===d.semi?null:this.parseExpression(),this.expect(d.semi),t.update=this.type===d.parenR?null:this.parseExpression(),this.expect(d.parenR),t.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(t,"ForStatement")},R.parseForIn=function(t,n){var e=this.type===d._in;return this.next(),n.type==="VariableDeclaration"&&n.declarations[0].init!=null&&(!e||this.options.ecmaVersion<8||this.strict||n.kind!=="var"||n.declarations[0].id.type!=="Identifier")&&this.raise(n.start,(e?"for-in":"for-of")+" loop variable declaration may not have an initializer"),t.left=n,t.right=e?this.parseExpression():this.parseMaybeAssign(),this.expect(d.parenR),t.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(t,e?"ForInStatement":"ForOfStatement")},R.parseVar=function(t,n,e){for(t.declarations=[],t.kind=e;;){var r=this.startNode();if(this.parseVarId(r,e),this.eat(d.eq)?r.init=this.parseMaybeAssign(n):e!=="const"||this.type===d._in||this.options.ecmaVersion>=6&&this.isContextual("of")?r.id.type==="Identifier"||n&&(this.type===d._in||this.isContextual("of"))?r.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),t.declarations.push(this.finishNode(r,"VariableDeclarator")),!this.eat(d.comma))break}return t},R.parseVarId=function(t,n){t.id=this.parseBindingAtom(),this.checkLValPattern(t.id,n==="var"?1:2,!1)};var Qe=1,ts=2;function Bh(t,n){var e=n.key.name,r=t[e],a="true";return n.type!=="MethodDefinition"||n.kind!=="get"&&n.kind!=="set"||(a=(n.static?"s":"i")+n.kind),r==="iget"&&a==="iset"||r==="iset"&&a==="iget"||r==="sget"&&a==="sset"||r==="sset"&&a==="sget"?(t[e]="true",!1):!!r||(t[e]=a,!1)}function ia(t,n){var e=t.computed,r=t.key;return!e&&(r.type==="Identifier"&&r.name===n||r.type==="Literal"&&r.value===n)}R.parseFunction=function(t,n,e,r,a){this.initFunction(t),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!r)&&(this.type===d.star&&n&ts&&this.unexpected(),t.generator=this.eat(d.star)),this.options.ecmaVersion>=8&&(t.async=!!r),n&Qe&&(t.id=4&n&&this.type!==d.name?null:this.parseIdent(),!t.id||n&ts||this.checkLValSimple(t.id,this.strict||t.generator||t.async?this.treatFunctionsAsVar?1:2:3));var i=this.yieldPos,s=this.awaitPos,o=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(Qi(t.async,t.generator)),n&Qe||(t.id=this.type===d.name?this.parseIdent():null),this.parseFunctionParams(t),this.parseFunctionBody(t,e,!1,a),this.yieldPos=i,this.awaitPos=s,this.awaitIdentPos=o,this.finishNode(t,n&Qe?"FunctionDeclaration":"FunctionExpression")},R.parseFunctionParams=function(t){this.expect(d.parenL),t.params=this.parseBindingList(d.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()},R.parseClass=function(t,n){this.next();var e=this.strict;this.strict=!0,this.parseClassId(t,n),this.parseClassSuper(t);var r=this.enterClassBody(),a=this.startNode(),i=!1;for(a.body=[],this.expect(d.braceL);this.type!==d.braceR;){var s=this.parseClassElement(t.superClass!==null);s&&(a.body.push(s),s.type==="MethodDefinition"&&s.kind==="constructor"?(i&&this.raise(s.start,"Duplicate constructor in the same class"),i=!0):s.key&&s.key.type==="PrivateIdentifier"&&Bh(r,s)&&this.raiseRecoverable(s.key.start,"Identifier '#"+s.key.name+"' has already been declared"))}return this.strict=e,this.next(),t.body=this.finishNode(a,"ClassBody"),this.exitClassBody(),this.finishNode(t,n?"ClassDeclaration":"ClassExpression")},R.parseClassElement=function(t){if(this.eat(d.semi))return null;var n=this.options.ecmaVersion,e=this.startNode(),r="",a=!1,i=!1,s="method",o=!1;if(this.eatContextual("static")){if(n>=13&&this.eat(d.braceL))return this.parseClassStaticBlock(e),e;this.isClassElementNameStart()||this.type===d.star?o=!0:r="static"}if(e.static=o,!r&&n>=8&&this.eatContextual("async")&&(!this.isClassElementNameStart()&&this.type!==d.star||this.canInsertSemicolon()?r="async":i=!0),!r&&(n>=9||!i)&&this.eat(d.star)&&(a=!0),!r&&!i&&!a){var l=this.value;(this.eatContextual("get")||this.eatContextual("set"))&&(this.isClassElementNameStart()?s=l:r=l)}if(r?(e.computed=!1,e.key=this.startNodeAt(this.lastTokStart,this.lastTokStartLoc),e.key.name=r,this.finishNode(e.key,"Identifier")):this.parseClassElementName(e),n<13||this.type===d.parenL||s!=="method"||a||i){var c=!e.static&&ia(e,"constructor"),u=c&&t;c&&s!=="method"&&this.raise(e.key.start,"Constructor can't have get/set modifier"),e.kind=c?"constructor":s,this.parseClassMethod(e,a,i,u)}else this.parseClassField(e);return e},R.isClassElementNameStart=function(){return this.type===d.name||this.type===d.privateId||this.type===d.num||this.type===d.string||this.type===d.bracketL||this.type.keyword},R.parseClassElementName=function(t){this.type===d.privateId?(this.value==="constructor"&&this.raise(this.start,"Classes can't have an element named '#constructor'"),t.computed=!1,t.key=this.parsePrivateIdent()):this.parsePropertyName(t)},R.parseClassMethod=function(t,n,e,r){var a=t.key;t.kind==="constructor"?(n&&this.raise(a.start,"Constructor can't be a generator"),e&&this.raise(a.start,"Constructor can't be an async method")):t.static&&ia(t,"prototype")&&this.raise(a.start,"Classes may not have a static property named prototype");var i=t.value=this.parseMethod(n,e,r);return t.kind==="get"&&i.params.length!==0&&this.raiseRecoverable(i.start,"getter should have no params"),t.kind==="set"&&i.params.length!==1&&this.raiseRecoverable(i.start,"setter should have exactly one param"),t.kind==="set"&&i.params[0].type==="RestElement"&&this.raiseRecoverable(i.params[0].start,"Setter cannot use rest params"),this.finishNode(t,"MethodDefinition")},R.parseClassField=function(t){if(ia(t,"constructor")?this.raise(t.key.start,"Classes can't have a field named 'constructor'"):t.static&&ia(t,"prototype")&&this.raise(t.key.start,"Classes can't have a static field named 'prototype'"),this.eat(d.eq)){var n=this.currentThisScope(),e=n.inClassFieldInit;n.inClassFieldInit=!0,t.value=this.parseMaybeAssign(),n.inClassFieldInit=e}else t.value=null;return this.semicolon(),this.finishNode(t,"PropertyDefinition")},R.parseClassStaticBlock=function(t){t.body=[];var n=this.labels;for(this.labels=[],this.enterScope(320);this.type!==d.braceR;){var e=this.parseStatement(null);t.body.push(e)}return this.next(),this.exitScope(),this.labels=n,this.finishNode(t,"StaticBlock")},R.parseClassId=function(t,n){this.type===d.name?(t.id=this.parseIdent(),n&&this.checkLValSimple(t.id,2,!1)):(n===!0&&this.unexpected(),t.id=null)},R.parseClassSuper=function(t){t.superClass=this.eat(d._extends)?this.parseExprSubscripts(null,!1):null},R.enterClassBody=function(){var t={declared:Object.create(null),used:[]};return this.privateNameStack.push(t),t.declared},R.exitClassBody=function(){for(var t=this.privateNameStack.pop(),n=t.declared,e=t.used,r=this.privateNameStack.length,a=r===0?null:this.privateNameStack[r-1],i=0;i<e.length;++i){var s=e[i];Je(n,s.name)||(a?a.used.push(s):this.raiseRecoverable(s.start,"Private field '#"+s.name+"' must be declared in an enclosing class"))}},R.parseExport=function(t,n){if(this.next(),this.eat(d.star))return this.options.ecmaVersion>=11&&(this.eatContextual("as")?(t.exported=this.parseModuleExportName(),this.checkExport(n,t.exported,this.lastTokStart)):t.exported=null),this.expectContextual("from"),this.type!==d.string&&this.unexpected(),t.source=this.parseExprAtom(),this.semicolon(),this.finishNode(t,"ExportAllDeclaration");if(this.eat(d._default)){var e;if(this.checkExport(n,"default",this.lastTokStart),this.type===d._function||(e=this.isAsyncFunction())){var r=this.startNode();this.next(),e&&this.next(),t.declaration=this.parseFunction(r,4|Qe,!1,e)}else if(this.type===d._class){var a=this.startNode();t.declaration=this.parseClass(a,"nullableID")}else t.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(t,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())t.declaration=this.parseStatement(null),t.declaration.type==="VariableDeclaration"?this.checkVariableExport(n,t.declaration.declarations):this.checkExport(n,t.declaration.id,t.declaration.id.start),t.specifiers=[],t.source=null;else{if(t.declaration=null,t.specifiers=this.parseExportSpecifiers(n),this.eatContextual("from"))this.type!==d.string&&this.unexpected(),t.source=this.parseExprAtom();else{for(var i=0,s=t.specifiers;i<s.length;i+=1){var o=s[i];this.checkUnreserved(o.local),this.checkLocalExport(o.local),o.local.type==="Literal"&&this.raise(o.local.start,"A string literal cannot be used as an exported binding without `from`.")}t.source=null}this.semicolon()}return this.finishNode(t,"ExportNamedDeclaration")},R.checkExport=function(t,n,e){t&&(typeof n!="string"&&(n=n.type==="Identifier"?n.name:n.value),Je(t,n)&&this.raiseRecoverable(e,"Duplicate export '"+n+"'"),t[n]=!0)},R.checkPatternExport=function(t,n){var e=n.type;if(e==="Identifier")this.checkExport(t,n,n.start);else if(e==="ObjectPattern")for(var r=0,a=n.properties;r<a.length;r+=1){var i=a[r];this.checkPatternExport(t,i)}else if(e==="ArrayPattern")for(var s=0,o=n.elements;s<o.length;s+=1){var l=o[s];l&&this.checkPatternExport(t,l)}else e==="Property"?this.checkPatternExport(t,n.value):e==="AssignmentPattern"?this.checkPatternExport(t,n.left):e==="RestElement"?this.checkPatternExport(t,n.argument):e==="ParenthesizedExpression"&&this.checkPatternExport(t,n.expression)},R.checkVariableExport=function(t,n){if(t)for(var e=0,r=n;e<r.length;e+=1){var a=r[e];this.checkPatternExport(t,a.id)}},R.shouldParseExportStatement=function(){return this.type.keyword==="var"||this.type.keyword==="const"||this.type.keyword==="class"||this.type.keyword==="function"||this.isLet()||this.isAsyncFunction()},R.parseExportSpecifiers=function(t){var n=[],e=!0;for(this.expect(d.braceL);!this.eat(d.braceR);){if(e)e=!1;else if(this.expect(d.comma),this.afterTrailingComma(d.braceR))break;var r=this.startNode();r.local=this.parseModuleExportName(),r.exported=this.eatContextual("as")?this.parseModuleExportName():r.local,this.checkExport(t,r.exported,r.exported.start),n.push(this.finishNode(r,"ExportSpecifier"))}return n},R.parseImport=function(t){return this.next(),this.type===d.string?(t.specifiers=Sh,t.source=this.parseExprAtom()):(t.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),t.source=this.type===d.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(t,"ImportDeclaration")},R.parseImportSpecifiers=function(){var t=[],n=!0;if(this.type===d.name){var e=this.startNode();if(e.local=this.parseIdent(),this.checkLValSimple(e.local,2),t.push(this.finishNode(e,"ImportDefaultSpecifier")),!this.eat(d.comma))return t}if(this.type===d.star){var r=this.startNode();return this.next(),this.expectContextual("as"),r.local=this.parseIdent(),this.checkLValSimple(r.local,2),t.push(this.finishNode(r,"ImportNamespaceSpecifier")),t}for(this.expect(d.braceL);!this.eat(d.braceR);){if(n)n=!1;else if(this.expect(d.comma),this.afterTrailingComma(d.braceR))break;var a=this.startNode();a.imported=this.parseModuleExportName(),this.eatContextual("as")?a.local=this.parseIdent():(this.checkUnreserved(a.imported),a.local=a.imported),this.checkLValSimple(a.local,2),t.push(this.finishNode(a,"ImportSpecifier"))}return t},R.parseModuleExportName=function(){if(this.options.ecmaVersion>=13&&this.type===d.string){var t=this.parseLiteral(this.value);return Ch.test(t.value)&&this.raise(t.start,"An export name cannot include a lone surrogate."),t}return this.parseIdent(!0)},R.adaptDirectivePrologue=function(t){for(var n=0;n<t.length&&this.isDirectiveCandidate(t[n]);++n)t[n].directive=t[n].expression.raw.slice(1,-1)},R.isDirectiveCandidate=function(t){return this.options.ecmaVersion>=5&&t.type==="ExpressionStatement"&&t.expression.type==="Literal"&&typeof t.expression.value=="string"&&(this.input[t.start]==='"'||this.input[t.start]==="'")};var Qn=dn.prototype;Qn.toAssignable=function(t,n,e){if(this.options.ecmaVersion>=6&&t)switch(t.type){case"Identifier":this.inAsync&&t.name==="await"&&this.raise(t.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":case"RestElement":break;case"ObjectExpression":t.type="ObjectPattern",e&&this.checkPatternErrors(e,!0);for(var r=0,a=t.properties;r<a.length;r+=1){var i=a[r];this.toAssignable(i,n),i.type!=="RestElement"||i.argument.type!=="ArrayPattern"&&i.argument.type!=="ObjectPattern"||this.raise(i.argument.start,"Unexpected token")}break;case"Property":t.kind!=="init"&&this.raise(t.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(t.value,n);break;case"ArrayExpression":t.type="ArrayPattern",e&&this.checkPatternErrors(e,!0),this.toAssignableList(t.elements,n);break;case"SpreadElement":t.type="RestElement",this.toAssignable(t.argument,n),t.argument.type==="AssignmentPattern"&&this.raise(t.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":t.operator!=="="&&this.raise(t.left.end,"Only '=' operator can be used for specifying default value."),t.type="AssignmentPattern",delete t.operator,this.toAssignable(t.left,n);break;case"ParenthesizedExpression":this.toAssignable(t.expression,n,e);break;case"ChainExpression":this.raiseRecoverable(t.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":if(!n)break;default:this.raise(t.start,"Assigning to rvalue")}else e&&this.checkPatternErrors(e,!0);return t},Qn.toAssignableList=function(t,n){for(var e=t.length,r=0;r<e;r++){var a=t[r];a&&this.toAssignable(a,n)}if(e){var i=t[e-1];this.options.ecmaVersion===6&&n&&i&&i.type==="RestElement"&&i.argument.type!=="Identifier"&&this.unexpected(i.argument.start)}return t},Qn.parseSpread=function(t){var n=this.startNode();return this.next(),n.argument=this.parseMaybeAssign(!1,t),this.finishNode(n,"SpreadElement")},Qn.parseRestBinding=function(){var t=this.startNode();return this.next(),this.options.ecmaVersion===6&&this.type!==d.name&&this.unexpected(),t.argument=this.parseBindingAtom(),this.finishNode(t,"RestElement")},Qn.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case d.bracketL:var t=this.startNode();return this.next(),t.elements=this.parseBindingList(d.bracketR,!0,!0),this.finishNode(t,"ArrayPattern");case d.braceL:return this.parseObj(!0)}return this.parseIdent()},Qn.parseBindingList=function(t,n,e){for(var r=[],a=!0;!this.eat(t);)if(a?a=!1:this.expect(d.comma),n&&this.type===d.comma)r.push(null);else{if(e&&this.afterTrailingComma(t))break;if(this.type===d.ellipsis){var i=this.parseRestBinding();this.parseBindingListItem(i),r.push(i),this.type===d.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.expect(t);break}var s=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(s),r.push(s)}return r},Qn.parseBindingListItem=function(t){return t},Qn.parseMaybeDefault=function(t,n,e){if(e=e||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(d.eq))return e;var r=this.startNodeAt(t,n);return r.left=e,r.right=this.parseMaybeAssign(),this.finishNode(r,"AssignmentPattern")},Qn.checkLValSimple=function(t,n,e){n===void 0&&(n=0);var r=n!==0;switch(t.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(t.name)&&this.raiseRecoverable(t.start,(r?"Binding ":"Assigning to ")+t.name+" in strict mode"),r&&(n===2&&t.name==="let"&&this.raiseRecoverable(t.start,"let is disallowed as a lexically bound name"),e&&(Je(e,t.name)&&this.raiseRecoverable(t.start,"Argument name clash"),e[t.name]=!0),n!==5&&this.declareName(t.name,n,t.start));break;case"ChainExpression":this.raiseRecoverable(t.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":r&&this.raiseRecoverable(t.start,"Binding member expression");break;case"ParenthesizedExpression":return r&&this.raiseRecoverable(t.start,"Binding parenthesized expression"),this.checkLValSimple(t.expression,n,e);default:this.raise(t.start,(r?"Binding":"Assigning to")+" rvalue")}},Qn.checkLValPattern=function(t,n,e){switch(n===void 0&&(n=0),t.type){case"ObjectPattern":for(var r=0,a=t.properties;r<a.length;r+=1){var i=a[r];this.checkLValInnerPattern(i,n,e)}break;case"ArrayPattern":for(var s=0,o=t.elements;s<o.length;s+=1){var l=o[s];l&&this.checkLValInnerPattern(l,n,e)}break;default:this.checkLValSimple(t,n,e)}},Qn.checkLValInnerPattern=function(t,n,e){switch(n===void 0&&(n=0),t.type){case"Property":this.checkLValInnerPattern(t.value,n,e);break;case"AssignmentPattern":this.checkLValPattern(t.left,n,e);break;case"RestElement":this.checkLValPattern(t.argument,n,e);break;default:this.checkLValPattern(t,n,e)}};var Kn=function(t,n,e,r,a){this.token=t,this.isExpr=!!n,this.preserveSpace=!!e,this.override=r,this.generator=!!a},un={b_stat:new Kn("{",!1),b_expr:new Kn("{",!0),b_tmpl:new Kn("${",!1),p_stat:new Kn("(",!1),p_expr:new Kn("(",!0),q_tmpl:new Kn("`",!0,!0,function(t){return t.tryReadTemplateToken()}),f_stat:new Kn("function",!1),f_expr:new Kn("function",!0),f_expr_gen:new Kn("function",!0,!1,null,!0),f_gen:new Kn("function",!1,!1,null,!0)},de=dn.prototype;de.initialContext=function(){return[un.b_stat]},de.curContext=function(){return this.context[this.context.length-1]},de.braceIsBlock=function(t){var n=this.curContext();return n===un.f_expr||n===un.f_stat||(t!==d.colon||n!==un.b_stat&&n!==un.b_expr?t===d._return||t===d.name&&this.exprAllowed?Pn.test(this.input.slice(this.lastTokEnd,this.start)):t===d._else||t===d.semi||t===d.eof||t===d.parenR||t===d.arrow||(t===d.braceL?n===un.b_stat:t!==d._var&&t!==d._const&&t!==d.name&&!this.exprAllowed):!n.isExpr)},de.inGeneratorContext=function(){for(var t=this.context.length-1;t>=1;t--){var n=this.context[t];if(n.token==="function")return n.generator}return!1},de.updateContext=function(t){var n,e=this.type;e.keyword&&t===d.dot?this.exprAllowed=!1:(n=e.updateContext)?n.call(this,t):this.exprAllowed=e.beforeExpr},de.overrideContext=function(t){this.curContext()!==t&&(this.context[this.context.length-1]=t)},d.parenR.updateContext=d.braceR.updateContext=function(){if(this.context.length!==1){var t=this.context.pop();t===un.b_stat&&this.curContext().token==="function"&&(t=this.context.pop()),this.exprAllowed=!t.isExpr}else this.exprAllowed=!0},d.braceL.updateContext=function(t){this.context.push(this.braceIsBlock(t)?un.b_stat:un.b_expr),this.exprAllowed=!0},d.dollarBraceL.updateContext=function(){this.context.push(un.b_tmpl),this.exprAllowed=!0},d.parenL.updateContext=function(t){var n=t===d._if||t===d._for||t===d._with||t===d._while;this.context.push(n?un.p_stat:un.p_expr),this.exprAllowed=!0},d.incDec.updateContext=function(){},d._function.updateContext=d._class.updateContext=function(t){!t.beforeExpr||t===d._else||t===d.semi&&this.curContext()!==un.p_stat||t===d._return&&Pn.test(this.input.slice(this.lastTokEnd,this.start))||(t===d.colon||t===d.braceL)&&this.curContext()===un.b_stat?this.context.push(un.f_stat):this.context.push(un.f_expr),this.exprAllowed=!1},d.backQuote.updateContext=function(){this.curContext()===un.q_tmpl?this.context.pop():this.context.push(un.q_tmpl),this.exprAllowed=!1},d.star.updateContext=function(t){if(t===d._function){var n=this.context.length-1;this.context[n]===un.f_expr?this.context[n]=un.f_expr_gen:this.context[n]=un.f_gen}this.exprAllowed=!0},d.name.updateContext=function(t){var n=!1;this.options.ecmaVersion>=6&&t!==d.dot&&(this.value==="of"&&!this.exprAllowed||this.value==="yield"&&this.inGeneratorContext())&&(n=!0),this.exprAllowed=n};var K=dn.prototype;function _c(t){return t.type==="MemberExpression"&&t.property.type==="PrivateIdentifier"||t.type==="ChainExpression"&&_c(t.expression)}K.checkPropClash=function(t,n,e){if(!(this.options.ecmaVersion>=9&&t.type==="SpreadElement"||this.options.ecmaVersion>=6&&(t.computed||t.method||t.shorthand))){var r,a=t.key;switch(a.type){case"Identifier":r=a.name;break;case"Literal":r=String(a.value);break;default:return}var i=t.kind;if(this.options.ecmaVersion>=6)r==="__proto__"&&i==="init"&&(n.proto&&(e?e.doubleProto<0&&(e.doubleProto=a.start):this.raiseRecoverable(a.start,"Redefinition of __proto__ property")),n.proto=!0);else{var s=n[r="$"+r];s?(i==="init"?this.strict&&s.init||s.get||s.set:s.init||s[i])&&this.raiseRecoverable(a.start,"Redefinition of property"):s=n[r]={init:!1,get:!1,set:!1},s[i]=!0}}},K.parseExpression=function(t,n){var e=this.start,r=this.startLoc,a=this.parseMaybeAssign(t,n);if(this.type===d.comma){var i=this.startNodeAt(e,r);for(i.expressions=[a];this.eat(d.comma);)i.expressions.push(this.parseMaybeAssign(t,n));return this.finishNode(i,"SequenceExpression")}return a},K.parseMaybeAssign=function(t,n,e){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(t);this.exprAllowed=!1}var r=!1,a=-1,i=-1,s=-1;n?(a=n.parenthesizedAssign,i=n.trailingComma,s=n.doubleProto,n.parenthesizedAssign=n.trailingComma=-1):(n=new aa,r=!0);var o=this.start,l=this.startLoc;this.type!==d.parenL&&this.type!==d.name||(this.potentialArrowAt=this.start,this.potentialArrowInForAwait=t==="await");var c=this.parseMaybeConditional(t,n);if(e&&(c=e.call(this,c,o,l)),this.type.isAssign){var u=this.startNodeAt(o,l);return u.operator=this.value,this.type===d.eq&&(c=this.toAssignable(c,!1,n)),r||(n.parenthesizedAssign=n.trailingComma=n.doubleProto=-1),n.shorthandAssign>=c.start&&(n.shorthandAssign=-1),this.type===d.eq?this.checkLValPattern(c):this.checkLValSimple(c),u.left=c,this.next(),u.right=this.parseMaybeAssign(t),s>-1&&(n.doubleProto=s),this.finishNode(u,"AssignmentExpression")}return r&&this.checkExpressionErrors(n,!0),a>-1&&(n.parenthesizedAssign=a),i>-1&&(n.trailingComma=i),c},K.parseMaybeConditional=function(t,n){var e=this.start,r=this.startLoc,a=this.parseExprOps(t,n);if(this.checkExpressionErrors(n))return a;if(this.eat(d.question)){var i=this.startNodeAt(e,r);return i.test=a,i.consequent=this.parseMaybeAssign(),this.expect(d.colon),i.alternate=this.parseMaybeAssign(t),this.finishNode(i,"ConditionalExpression")}return a},K.parseExprOps=function(t,n){var e=this.start,r=this.startLoc,a=this.parseMaybeUnary(n,!1,!1,t);return this.checkExpressionErrors(n)||a.start===e&&a.type==="ArrowFunctionExpression"?a:this.parseExprOp(a,e,r,-1,t)},K.parseExprOp=function(t,n,e,r,a){var i=this.type.binop;if(i!=null&&(!a||this.type!==d._in)&&i>r){var s=this.type===d.logicalOR||this.type===d.logicalAND,o=this.type===d.coalesce;o&&(i=d.logicalAND.binop);var l=this.value;this.next();var c=this.start,u=this.startLoc,f=this.parseExprOp(this.parseMaybeUnary(null,!1,!1,a),c,u,i,a),m=this.buildBinary(n,e,t,f,l,s||o);return(s&&this.type===d.coalesce||o&&(this.type===d.logicalOR||this.type===d.logicalAND))&&this.raiseRecoverable(this.start,"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),this.parseExprOp(m,n,e,r,a)}return t},K.buildBinary=function(t,n,e,r,a,i){r.type==="PrivateIdentifier"&&this.raise(r.start,"Private identifier can only be left side of binary expression");var s=this.startNodeAt(t,n);return s.left=e,s.operator=a,s.right=r,this.finishNode(s,i?"LogicalExpression":"BinaryExpression")},K.parseMaybeUnary=function(t,n,e,r){var a,i=this.start,s=this.startLoc;if(this.isContextual("await")&&this.canAwait)a=this.parseAwait(r),n=!0;else if(this.type.prefix){var o=this.startNode(),l=this.type===d.incDec;o.operator=this.value,o.prefix=!0,this.next(),o.argument=this.parseMaybeUnary(null,!0,l,r),this.checkExpressionErrors(t,!0),l?this.checkLValSimple(o.argument):this.strict&&o.operator==="delete"&&o.argument.type==="Identifier"?this.raiseRecoverable(o.start,"Deleting local variable in strict mode"):o.operator==="delete"&&_c(o.argument)?this.raiseRecoverable(o.start,"Private fields can not be deleted"):n=!0,a=this.finishNode(o,l?"UpdateExpression":"UnaryExpression")}else if(n||this.type!==d.privateId){if(a=this.parseExprSubscripts(t,r),this.checkExpressionErrors(t))return a;for(;this.type.postfix&&!this.canInsertSemicolon();){var c=this.startNodeAt(i,s);c.operator=this.value,c.prefix=!1,c.argument=a,this.checkLValSimple(a),this.next(),a=this.finishNode(c,"UpdateExpression")}}else(r||this.privateNameStack.length===0)&&this.unexpected(),a=this.parsePrivateIdent(),this.type!==d._in&&this.unexpected();return e||!this.eat(d.starstar)?a:n?void this.unexpected(this.lastTokStart):this.buildBinary(i,s,a,this.parseMaybeUnary(null,!1,!1,r),"**",!1)},K.parseExprSubscripts=function(t,n){var e=this.start,r=this.startLoc,a=this.parseExprAtom(t,n);if(a.type==="ArrowFunctionExpression"&&this.input.slice(this.lastTokStart,this.lastTokEnd)!==")")return a;var i=this.parseSubscripts(a,e,r,!1,n);return t&&i.type==="MemberExpression"&&(t.parenthesizedAssign>=i.start&&(t.parenthesizedAssign=-1),t.parenthesizedBind>=i.start&&(t.parenthesizedBind=-1),t.trailingComma>=i.start&&(t.trailingComma=-1)),i},K.parseSubscripts=function(t,n,e,r,a){for(var i=this.options.ecmaVersion>=8&&t.type==="Identifier"&&t.name==="async"&&this.lastTokEnd===t.end&&!this.canInsertSemicolon()&&t.end-t.start==5&&this.potentialArrowAt===t.start,s=!1;;){var o=this.parseSubscript(t,n,e,r,i,s,a);if(o.optional&&(s=!0),o===t||o.type==="ArrowFunctionExpression"){if(s){var l=this.startNodeAt(n,e);l.expression=o,o=this.finishNode(l,"ChainExpression")}return o}t=o}},K.parseSubscript=function(t,n,e,r,a,i,s){var o=this.options.ecmaVersion>=11,l=o&&this.eat(d.questionDot);r&&l&&this.raise(this.lastTokStart,"Optional chaining cannot appear in the callee of new expressions");var c=this.eat(d.bracketL);if(c||l&&this.type!==d.parenL&&this.type!==d.backQuote||this.eat(d.dot)){var u=this.startNodeAt(n,e);u.object=t,c?(u.property=this.parseExpression(),this.expect(d.bracketR)):this.type===d.privateId&&t.type!=="Super"?u.property=this.parsePrivateIdent():u.property=this.parseIdent(this.options.allowReserved!=="never"),u.computed=!!c,o&&(u.optional=l),t=this.finishNode(u,"MemberExpression")}else if(!r&&this.eat(d.parenL)){var f=new aa,m=this.yieldPos,h=this.awaitPos,b=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var p=this.parseExprList(d.parenR,this.options.ecmaVersion>=8,!1,f);if(a&&!l&&!this.canInsertSemicolon()&&this.eat(d.arrow))return this.checkPatternErrors(f,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=m,this.awaitPos=h,this.awaitIdentPos=b,this.parseArrowExpression(this.startNodeAt(n,e),p,!0,s);this.checkExpressionErrors(f,!0),this.yieldPos=m||this.yieldPos,this.awaitPos=h||this.awaitPos,this.awaitIdentPos=b||this.awaitIdentPos;var g=this.startNodeAt(n,e);g.callee=t,g.arguments=p,o&&(g.optional=l),t=this.finishNode(g,"CallExpression")}else if(this.type===d.backQuote){(l||i)&&this.raise(this.start,"Optional chaining cannot appear in the tag of tagged template expressions");var x=this.startNodeAt(n,e);x.tag=t,x.quasi=this.parseTemplate({isTagged:!0}),t=this.finishNode(x,"TaggedTemplateExpression")}return t},K.parseExprAtom=function(t,n){this.type===d.slash&&this.readRegexp();var e,r=this.potentialArrowAt===this.start;switch(this.type){case d._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),e=this.startNode(),this.next(),this.type!==d.parenL||this.allowDirectSuper||this.raise(e.start,"super() call outside constructor of a subclass"),this.type!==d.dot&&this.type!==d.bracketL&&this.type!==d.parenL&&this.unexpected(),this.finishNode(e,"Super");case d._this:return e=this.startNode(),this.next(),this.finishNode(e,"ThisExpression");case d.name:var a=this.start,i=this.startLoc,s=this.containsEsc,o=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!s&&o.name==="async"&&!this.canInsertSemicolon()&&this.eat(d._function))return this.overrideContext(un.f_expr),this.parseFunction(this.startNodeAt(a,i),0,!1,!0,n);if(r&&!this.canInsertSemicolon()){if(this.eat(d.arrow))return this.parseArrowExpression(this.startNodeAt(a,i),[o],!1,n);if(this.options.ecmaVersion>=8&&o.name==="async"&&this.type===d.name&&!s&&(!this.potentialArrowInForAwait||this.value!=="of"||this.containsEsc))return o=this.parseIdent(!1),!this.canInsertSemicolon()&&this.eat(d.arrow)||this.unexpected(),this.parseArrowExpression(this.startNodeAt(a,i),[o],!0,n)}return o;case d.regexp:var l=this.value;return(e=this.parseLiteral(l.value)).regex={pattern:l.pattern,flags:l.flags},e;case d.num:case d.string:return this.parseLiteral(this.value);case d._null:case d._true:case d._false:return(e=this.startNode()).value=this.type===d._null?null:this.type===d._true,e.raw=this.type.keyword,this.next(),this.finishNode(e,"Literal");case d.parenL:var c=this.start,u=this.parseParenAndDistinguishExpression(r,n);return t&&(t.parenthesizedAssign<0&&!this.isSimpleAssignTarget(u)&&(t.parenthesizedAssign=c),t.parenthesizedBind<0&&(t.parenthesizedBind=c)),u;case d.bracketL:return e=this.startNode(),this.next(),e.elements=this.parseExprList(d.bracketR,!0,!0,t),this.finishNode(e,"ArrayExpression");case d.braceL:return this.overrideContext(un.b_expr),this.parseObj(!1,t);case d._function:return e=this.startNode(),this.next(),this.parseFunction(e,0);case d._class:return this.parseClass(this.startNode(),!1);case d._new:return this.parseNew();case d.backQuote:return this.parseTemplate();case d._import:return this.options.ecmaVersion>=11?this.parseExprImport():this.unexpected();default:this.unexpected()}},K.parseExprImport=function(){var t=this.startNode();this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword import");var n=this.parseIdent(!0);switch(this.type){case d.parenL:return this.parseDynamicImport(t);case d.dot:return t.meta=n,this.parseImportMeta(t);default:this.unexpected()}},K.parseDynamicImport=function(t){if(this.next(),t.source=this.parseMaybeAssign(),!this.eat(d.parenR)){var n=this.start;this.eat(d.comma)&&this.eat(d.parenR)?this.raiseRecoverable(n,"Trailing comma is not allowed in import()"):this.unexpected(n)}return this.finishNode(t,"ImportExpression")},K.parseImportMeta=function(t){this.next();var n=this.containsEsc;return t.property=this.parseIdent(!0),t.property.name!=="meta"&&this.raiseRecoverable(t.property.start,"The only valid meta property for import is 'import.meta'"),n&&this.raiseRecoverable(t.start,"'import.meta' must not contain escaped characters"),this.options.sourceType==="module"||this.options.allowImportExportEverywhere||this.raiseRecoverable(t.start,"Cannot use 'import.meta' outside a module"),this.finishNode(t,"MetaProperty")},K.parseLiteral=function(t){var n=this.startNode();return n.value=t,n.raw=this.input.slice(this.start,this.end),n.raw.charCodeAt(n.raw.length-1)===110&&(n.bigint=n.raw.slice(0,-1).replace(/_/g,"")),this.next(),this.finishNode(n,"Literal")},K.parseParenExpression=function(){this.expect(d.parenL);var t=this.parseExpression();return this.expect(d.parenR),t},K.parseParenAndDistinguishExpression=function(t,n){var e,r=this.start,a=this.startLoc,i=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var s,o=this.start,l=this.startLoc,c=[],u=!0,f=!1,m=new aa,h=this.yieldPos,b=this.awaitPos;for(this.yieldPos=0,this.awaitPos=0;this.type!==d.parenR;){if(u?u=!1:this.expect(d.comma),i&&this.afterTrailingComma(d.parenR,!0)){f=!0;break}if(this.type===d.ellipsis){s=this.start,c.push(this.parseParenItem(this.parseRestBinding())),this.type===d.comma&&this.raise(this.start,"Comma is not permitted after the rest element");break}c.push(this.parseMaybeAssign(!1,m,this.parseParenItem))}var p=this.lastTokEnd,g=this.lastTokEndLoc;if(this.expect(d.parenR),t&&!this.canInsertSemicolon()&&this.eat(d.arrow))return this.checkPatternErrors(m,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=h,this.awaitPos=b,this.parseParenArrowList(r,a,c,n);c.length&&!f||this.unexpected(this.lastTokStart),s&&this.unexpected(s),this.checkExpressionErrors(m,!0),this.yieldPos=h||this.yieldPos,this.awaitPos=b||this.awaitPos,c.length>1?((e=this.startNodeAt(o,l)).expressions=c,this.finishNodeAt(e,"SequenceExpression",p,g)):e=c[0]}else e=this.parseParenExpression();if(this.options.preserveParens){var x=this.startNodeAt(r,a);return x.expression=e,this.finishNode(x,"ParenthesizedExpression")}return e},K.parseParenItem=function(t){return t},K.parseParenArrowList=function(t,n,e,r){return this.parseArrowExpression(this.startNodeAt(t,n),e,!1,r)};var Ih=[];K.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var t=this.startNode(),n=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(d.dot)){t.meta=n;var e=this.containsEsc;return t.property=this.parseIdent(!0),t.property.name!=="target"&&this.raiseRecoverable(t.property.start,"The only valid meta property for new is 'new.target'"),e&&this.raiseRecoverable(t.start,"'new.target' must not contain escaped characters"),this.allowNewDotTarget||this.raiseRecoverable(t.start,"'new.target' can only be used in functions and class static block"),this.finishNode(t,"MetaProperty")}var r=this.start,a=this.startLoc,i=this.type===d._import;return t.callee=this.parseSubscripts(this.parseExprAtom(),r,a,!0,!1),i&&t.callee.type==="ImportExpression"&&this.raise(r,"Cannot use new with import()"),this.eat(d.parenL)?t.arguments=this.parseExprList(d.parenR,this.options.ecmaVersion>=8,!1):t.arguments=Ih,this.finishNode(t,"NewExpression")},K.parseTemplateElement=function(t){var n=t.isTagged,e=this.startNode();return this.type===d.invalidTemplate?(n||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),e.value={raw:this.value,cooked:null}):e.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,`
`),cooked:this.value},this.next(),e.tail=this.type===d.backQuote,this.finishNode(e,"TemplateElement")},K.parseTemplate=function(t){t===void 0&&(t={});var n=t.isTagged;n===void 0&&(n=!1);var e=this.startNode();this.next(),e.expressions=[];var r=this.parseTemplateElement({isTagged:n});for(e.quasis=[r];!r.tail;)this.type===d.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(d.dollarBraceL),e.expressions.push(this.parseExpression()),this.expect(d.braceR),e.quasis.push(r=this.parseTemplateElement({isTagged:n}));return this.next(),this.finishNode(e,"TemplateLiteral")},K.isAsyncProp=function(t){return!t.computed&&t.key.type==="Identifier"&&t.key.name==="async"&&(this.type===d.name||this.type===d.num||this.type===d.string||this.type===d.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===d.star)&&!Pn.test(this.input.slice(this.lastTokEnd,this.start))},K.parseObj=function(t,n){var e=this.startNode(),r=!0,a={};for(e.properties=[],this.next();!this.eat(d.braceR);){if(r)r=!1;else if(this.expect(d.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(d.braceR))break;var i=this.parseProperty(t,n);t||this.checkPropClash(i,a,n),e.properties.push(i)}return this.finishNode(e,t?"ObjectPattern":"ObjectExpression")},K.parseProperty=function(t,n){var e,r,a,i,s=this.startNode();if(this.options.ecmaVersion>=9&&this.eat(d.ellipsis))return t?(s.argument=this.parseIdent(!1),this.type===d.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.finishNode(s,"RestElement")):(s.argument=this.parseMaybeAssign(!1,n),this.type===d.comma&&n&&n.trailingComma<0&&(n.trailingComma=this.start),this.finishNode(s,"SpreadElement"));this.options.ecmaVersion>=6&&(s.method=!1,s.shorthand=!1,(t||n)&&(a=this.start,i=this.startLoc),t||(e=this.eat(d.star)));var o=this.containsEsc;return this.parsePropertyName(s),!t&&!o&&this.options.ecmaVersion>=8&&!e&&this.isAsyncProp(s)?(r=!0,e=this.options.ecmaVersion>=9&&this.eat(d.star),this.parsePropertyName(s)):r=!1,this.parsePropertyValue(s,t,e,r,a,i,n,o),this.finishNode(s,"Property")},K.parsePropertyValue=function(t,n,e,r,a,i,s,o){if((e||r)&&this.type===d.colon&&this.unexpected(),this.eat(d.colon))t.value=n?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,s),t.kind="init";else if(this.options.ecmaVersion>=6&&this.type===d.parenL)n&&this.unexpected(),t.kind="init",t.method=!0,t.value=this.parseMethod(e,r);else if(n||o||!(this.options.ecmaVersion>=5)||t.computed||t.key.type!=="Identifier"||t.key.name!=="get"&&t.key.name!=="set"||this.type===d.comma||this.type===d.braceR||this.type===d.eq)this.options.ecmaVersion>=6&&!t.computed&&t.key.type==="Identifier"?((e||r)&&this.unexpected(),this.checkUnreserved(t.key),t.key.name!=="await"||this.awaitIdentPos||(this.awaitIdentPos=a),t.kind="init",n?t.value=this.parseMaybeDefault(a,i,this.copyNode(t.key)):this.type===d.eq&&s?(s.shorthandAssign<0&&(s.shorthandAssign=this.start),t.value=this.parseMaybeDefault(a,i,this.copyNode(t.key))):t.value=this.copyNode(t.key),t.shorthand=!0):this.unexpected();else{(e||r)&&this.unexpected(),t.kind=t.key.name,this.parsePropertyName(t),t.value=this.parseMethod(!1);var l=t.kind==="get"?0:1;if(t.value.params.length!==l){var c=t.value.start;t.kind==="get"?this.raiseRecoverable(c,"getter should have no params"):this.raiseRecoverable(c,"setter should have exactly one param")}else t.kind==="set"&&t.value.params[0].type==="RestElement"&&this.raiseRecoverable(t.value.params[0].start,"Setter cannot use rest params")}},K.parsePropertyName=function(t){if(this.options.ecmaVersion>=6){if(this.eat(d.bracketL))return t.computed=!0,t.key=this.parseMaybeAssign(),this.expect(d.bracketR),t.key;t.computed=!1}return t.key=this.type===d.num||this.type===d.string?this.parseExprAtom():this.parseIdent(this.options.allowReserved!=="never")},K.initFunction=function(t){t.id=null,this.options.ecmaVersion>=6&&(t.generator=t.expression=!1),this.options.ecmaVersion>=8&&(t.async=!1)},K.parseMethod=function(t,n,e){var r=this.startNode(),a=this.yieldPos,i=this.awaitPos,s=this.awaitIdentPos;return this.initFunction(r),this.options.ecmaVersion>=6&&(r.generator=t),this.options.ecmaVersion>=8&&(r.async=!!n),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(64|Qi(n,r.generator)|(e?128:0)),this.expect(d.parenL),r.params=this.parseBindingList(d.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(r,!1,!0,!1),this.yieldPos=a,this.awaitPos=i,this.awaitIdentPos=s,this.finishNode(r,"FunctionExpression")},K.parseArrowExpression=function(t,n,e,r){var a=this.yieldPos,i=this.awaitPos,s=this.awaitIdentPos;return this.enterScope(16|Qi(e,!1)),this.initFunction(t),this.options.ecmaVersion>=8&&(t.async=!!e),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,t.params=this.toAssignableList(n,!0),this.parseFunctionBody(t,!0,!1,r),this.yieldPos=a,this.awaitPos=i,this.awaitIdentPos=s,this.finishNode(t,"ArrowFunctionExpression")},K.parseFunctionBody=function(t,n,e,r){var a=n&&this.type!==d.braceL,i=this.strict,s=!1;if(a)t.body=this.parseMaybeAssign(r),t.expression=!0,this.checkParams(t,!1);else{var o=this.options.ecmaVersion>=7&&!this.isSimpleParamList(t.params);i&&!o||(s=this.strictDirective(this.end))&&o&&this.raiseRecoverable(t.start,"Illegal 'use strict' directive in function with non-simple parameter list");var l=this.labels;this.labels=[],s&&(this.strict=!0),this.checkParams(t,!i&&!s&&!n&&!e&&this.isSimpleParamList(t.params)),this.strict&&t.id&&this.checkLValSimple(t.id,5),t.body=this.parseBlock(!1,void 0,s&&!i),t.expression=!1,this.adaptDirectivePrologue(t.body.body),this.labels=l}this.exitScope()},K.isSimpleParamList=function(t){for(var n=0,e=t;n<e.length;n+=1)if(e[n].type!=="Identifier")return!1;return!0},K.checkParams=function(t,n){for(var e=Object.create(null),r=0,a=t.params;r<a.length;r+=1){var i=a[r];this.checkLValInnerPattern(i,1,n?null:e)}},K.parseExprList=function(t,n,e,r){for(var a=[],i=!0;!this.eat(t);){if(i)i=!1;else if(this.expect(d.comma),n&&this.afterTrailingComma(t))break;var s=void 0;e&&this.type===d.comma?s=null:this.type===d.ellipsis?(s=this.parseSpread(r),r&&this.type===d.comma&&r.trailingComma<0&&(r.trailingComma=this.start)):s=this.parseMaybeAssign(!1,r),a.push(s)}return a},K.checkUnreserved=function(t){var n=t.start,e=t.end,r=t.name;this.inGenerator&&r==="yield"&&this.raiseRecoverable(n,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&r==="await"&&this.raiseRecoverable(n,"Cannot use 'await' as identifier inside an async function"),this.currentThisScope().inClassFieldInit&&r==="arguments"&&this.raiseRecoverable(n,"Cannot use 'arguments' in class field initializer"),!this.inClassStaticBlock||r!=="arguments"&&r!=="await"||this.raise(n,"Cannot use "+r+" in class static initialization block"),this.keywords.test(r)&&this.raise(n,"Unexpected keyword '"+r+"'"),this.options.ecmaVersion<6&&this.input.slice(n,e).indexOf("\\")!==-1||(this.strict?this.reservedWordsStrict:this.reservedWords).test(r)&&(this.inAsync||r!=="await"||this.raiseRecoverable(n,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(n,"The keyword '"+r+"' is reserved"))},K.parseIdent=function(t){var n=this.startNode();return this.type===d.name?n.name=this.value:this.type.keyword?(n.name=this.type.keyword,n.name!=="class"&&n.name!=="function"||this.lastTokEnd===this.lastTokStart+1&&this.input.charCodeAt(this.lastTokStart)===46||this.context.pop()):this.unexpected(),this.next(!!t),this.finishNode(n,"Identifier"),t||(this.checkUnreserved(n),n.name!=="await"||this.awaitIdentPos||(this.awaitIdentPos=n.start)),n},K.parsePrivateIdent=function(){var t=this.startNode();return this.type===d.privateId?t.name=this.value:this.unexpected(),this.next(),this.finishNode(t,"PrivateIdentifier"),this.privateNameStack.length===0?this.raise(t.start,"Private field '#"+t.name+"' must be declared in an enclosing class"):this.privateNameStack[this.privateNameStack.length-1].used.push(t),t},K.parseYield=function(t){this.yieldPos||(this.yieldPos=this.start);var n=this.startNode();return this.next(),this.type===d.semi||this.canInsertSemicolon()||this.type!==d.star&&!this.type.startsExpr?(n.delegate=!1,n.argument=null):(n.delegate=this.eat(d.star),n.argument=this.parseMaybeAssign(t)),this.finishNode(n,"YieldExpression")},K.parseAwait=function(t){this.awaitPos||(this.awaitPos=this.start);var n=this.startNode();return this.next(),n.argument=this.parseMaybeUnary(null,!0,!1,t),this.finishNode(n,"AwaitExpression")};var sa=dn.prototype;sa.raise=function(t,n){var e=Zi(this.input,t);n+=" ("+e.line+":"+e.column+")";var r=new SyntaxError(n);throw r.pos=t,r.loc=e,r.raisedAt=this.pos,r},sa.raiseRecoverable=sa.raise,sa.curPosition=function(){if(this.options.locations)return new me(this.curLine,this.pos-this.lineStart)};var It=dn.prototype,jh=function(t){this.flags=t,this.var=[],this.lexical=[],this.functions=[],this.inClassFieldInit=!1};It.enterScope=function(t){this.scopeStack.push(new jh(t))},It.exitScope=function(){this.scopeStack.pop()},It.treatFunctionsAsVarInScope=function(t){return 2&t.flags||!this.inModule&&1&t.flags},It.declareName=function(t,n,e){var r=!1;if(n===2){var a=this.currentScope();r=a.lexical.indexOf(t)>-1||a.functions.indexOf(t)>-1||a.var.indexOf(t)>-1,a.lexical.push(t),this.inModule&&1&a.flags&&delete this.undefinedExports[t]}else if(n===4)this.currentScope().lexical.push(t);else if(n===3){var i=this.currentScope();r=this.treatFunctionsAsVar?i.lexical.indexOf(t)>-1:i.lexical.indexOf(t)>-1||i.var.indexOf(t)>-1,i.functions.push(t)}else for(var s=this.scopeStack.length-1;s>=0;--s){var o=this.scopeStack[s];if(o.lexical.indexOf(t)>-1&&!(32&o.flags&&o.lexical[0]===t)||!this.treatFunctionsAsVarInScope(o)&&o.functions.indexOf(t)>-1){r=!0;break}if(o.var.push(t),this.inModule&&1&o.flags&&delete this.undefinedExports[t],259&o.flags)break}r&&this.raiseRecoverable(e,"Identifier '"+t+"' has already been declared")},It.checkLocalExport=function(t){this.scopeStack[0].lexical.indexOf(t.name)===-1&&this.scopeStack[0].var.indexOf(t.name)===-1&&(this.undefinedExports[t.name]=t)},It.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},It.currentVarScope=function(){for(var t=this.scopeStack.length-1;;t--){var n=this.scopeStack[t];if(259&n.flags)return n}},It.currentThisScope=function(){for(var t=this.scopeStack.length-1;;t--){var n=this.scopeStack[t];if(259&n.flags&&!(16&n.flags))return n}};var nr=function(t,n,e){this.type="",this.start=n,this.end=0,t.options.locations&&(this.loc=new Ze(t,e)),t.options.directSourceFile&&(this.sourceFile=t.options.directSourceFile),t.options.ranges&&(this.range=[n,0])},tr=dn.prototype;function uc(t,n,e,r){return t.type=n,t.end=e,this.options.locations&&(t.loc.end=r),this.options.ranges&&(t.range[1]=e),t}tr.startNode=function(){return new nr(this,this.start,this.startLoc)},tr.startNodeAt=function(t,n){return new nr(this,t,n)},tr.finishNode=function(t,n){return uc.call(this,t,n,this.lastTokEnd,this.lastTokEndLoc)},tr.finishNodeAt=function(t,n,e,r){return uc.call(this,t,n,e,r)},tr.copyNode=function(t){var n=new nr(this,t.start,this.startLoc);for(var e in t)n[e]=t[e];return n};var fc="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",es=fc+" Extended_Pictographic",rs=es+" EBase EComp EMod EPres ExtPict",Mh={9:fc,10:es,11:es,12:rs,13:rs,14:rs},mc="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",dc="Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",pc=dc+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",hc=pc+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",gc=hc+" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",yc=gc+" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",Lh={9:dc,10:pc,11:hc,12:gc,13:yc,14:yc+" Kawi Nag_Mundari Nagm"},bc={};function Th(t){var n=bc[t]={binary:Yt(Mh[t]+" "+mc),nonBinary:{General_Category:Yt(mc),Script:Yt(Lh[t])}};n.nonBinary.Script_Extensions=n.nonBinary.Script,n.nonBinary.gc=n.nonBinary.General_Category,n.nonBinary.sc=n.nonBinary.Script,n.nonBinary.scx=n.nonBinary.Script_Extensions}for(var as=0,xc=[9,10,11,12,13,14];as<xc.length;as+=1)Th(xc[as]);var P=dn.prototype,gt=function(t){this.parser=t,this.validFlags="gim"+(t.options.ecmaVersion>=6?"uy":"")+(t.options.ecmaVersion>=9?"s":"")+(t.options.ecmaVersion>=13?"d":""),this.unicodeProperties=bc[t.options.ecmaVersion>=14?14:t.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=[],this.backReferenceNames=[]};function vc(t){return t===36||t>=40&&t<=43||t===46||t===63||t>=91&&t<=94||t>=123&&t<=125}function $c(t){return t>=65&&t<=90||t>=97&&t<=122}function kc(t){return $c(t)||t===95}function Nh(t){return kc(t)||oa(t)}function oa(t){return t>=48&&t<=57}function Cc(t){return t>=48&&t<=57||t>=65&&t<=70||t>=97&&t<=102}function Ec(t){return t>=65&&t<=70?t-65+10:t>=97&&t<=102?t-97+10:t-48}function Ac(t){return t>=48&&t<=55}gt.prototype.reset=function(t,n,e){var r=e.indexOf("u")!==-1;this.start=0|t,this.source=n+"",this.flags=e,this.switchU=r&&this.parser.options.ecmaVersion>=6,this.switchN=r&&this.parser.options.ecmaVersion>=9},gt.prototype.raise=function(t){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+t)},gt.prototype.at=function(t,n){n===void 0&&(n=!1);var e=this.source,r=e.length;if(t>=r)return-1;var a=e.charCodeAt(t);if(!n&&!this.switchU||a<=55295||a>=57344||t+1>=r)return a;var i=e.charCodeAt(t+1);return i>=56320&&i<=57343?(a<<10)+i-56613888:a},gt.prototype.nextIndex=function(t,n){n===void 0&&(n=!1);var e=this.source,r=e.length;if(t>=r)return r;var a,i=e.charCodeAt(t);return!n&&!this.switchU||i<=55295||i>=57344||t+1>=r||(a=e.charCodeAt(t+1))<56320||a>57343?t+1:t+2},gt.prototype.current=function(t){return t===void 0&&(t=!1),this.at(this.pos,t)},gt.prototype.lookahead=function(t){return t===void 0&&(t=!1),this.at(this.nextIndex(this.pos,t),t)},gt.prototype.advance=function(t){t===void 0&&(t=!1),this.pos=this.nextIndex(this.pos,t)},gt.prototype.eat=function(t,n){return n===void 0&&(n=!1),this.current(n)===t&&(this.advance(n),!0)},P.validateRegExpFlags=function(t){for(var n=t.validFlags,e=t.flags,r=0;r<e.length;r++){var a=e.charAt(r);n.indexOf(a)===-1&&this.raise(t.start,"Invalid regular expression flag"),e.indexOf(a,r+1)>-1&&this.raise(t.start,"Duplicate regular expression flag")}},P.validateRegExpPattern=function(t){this.regexp_pattern(t),!t.switchN&&this.options.ecmaVersion>=9&&t.groupNames.length>0&&(t.switchN=!0,this.regexp_pattern(t))},P.regexp_pattern=function(t){t.pos=0,t.lastIntValue=0,t.lastStringValue="",t.lastAssertionIsQuantifiable=!1,t.numCapturingParens=0,t.maxBackReference=0,t.groupNames.length=0,t.backReferenceNames.length=0,this.regexp_disjunction(t),t.pos!==t.source.length&&(t.eat(41)&&t.raise("Unmatched ')'"),(t.eat(93)||t.eat(125))&&t.raise("Lone quantifier brackets")),t.maxBackReference>t.numCapturingParens&&t.raise("Invalid escape");for(var n=0,e=t.backReferenceNames;n<e.length;n+=1){var r=e[n];t.groupNames.indexOf(r)===-1&&t.raise("Invalid named capture referenced")}},P.regexp_disjunction=function(t){for(this.regexp_alternative(t);t.eat(124);)this.regexp_alternative(t);this.regexp_eatQuantifier(t,!0)&&t.raise("Nothing to repeat"),t.eat(123)&&t.raise("Lone quantifier brackets")},P.regexp_alternative=function(t){for(;t.pos<t.source.length&&this.regexp_eatTerm(t););},P.regexp_eatTerm=function(t){return this.regexp_eatAssertion(t)?(t.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(t)&&t.switchU&&t.raise("Invalid quantifier"),!0):!!(t.switchU?this.regexp_eatAtom(t):this.regexp_eatExtendedAtom(t))&&(this.regexp_eatQuantifier(t),!0)},P.regexp_eatAssertion=function(t){var n=t.pos;if(t.lastAssertionIsQuantifiable=!1,t.eat(94)||t.eat(36))return!0;if(t.eat(92)){if(t.eat(66)||t.eat(98))return!0;t.pos=n}if(t.eat(40)&&t.eat(63)){var e=!1;if(this.options.ecmaVersion>=9&&(e=t.eat(60)),t.eat(61)||t.eat(33))return this.regexp_disjunction(t),t.eat(41)||t.raise("Unterminated group"),t.lastAssertionIsQuantifiable=!e,!0}return t.pos=n,!1},P.regexp_eatQuantifier=function(t,n){return n===void 0&&(n=!1),!!this.regexp_eatQuantifierPrefix(t,n)&&(t.eat(63),!0)},P.regexp_eatQuantifierPrefix=function(t,n){return t.eat(42)||t.eat(43)||t.eat(63)||this.regexp_eatBracedQuantifier(t,n)},P.regexp_eatBracedQuantifier=function(t,n){var e=t.pos;if(t.eat(123)){var r=0,a=-1;if(this.regexp_eatDecimalDigits(t)&&(r=t.lastIntValue,t.eat(44)&&this.regexp_eatDecimalDigits(t)&&(a=t.lastIntValue),t.eat(125)))return a!==-1&&a<r&&!n&&t.raise("numbers out of order in {} quantifier"),!0;t.switchU&&!n&&t.raise("Incomplete quantifier"),t.pos=e}return!1},P.regexp_eatAtom=function(t){return this.regexp_eatPatternCharacters(t)||t.eat(46)||this.regexp_eatReverseSolidusAtomEscape(t)||this.regexp_eatCharacterClass(t)||this.regexp_eatUncapturingGroup(t)||this.regexp_eatCapturingGroup(t)},P.regexp_eatReverseSolidusAtomEscape=function(t){var n=t.pos;if(t.eat(92)){if(this.regexp_eatAtomEscape(t))return!0;t.pos=n}return!1},P.regexp_eatUncapturingGroup=function(t){var n=t.pos;if(t.eat(40)){if(t.eat(63)&&t.eat(58)){if(this.regexp_disjunction(t),t.eat(41))return!0;t.raise("Unterminated group")}t.pos=n}return!1},P.regexp_eatCapturingGroup=function(t){if(t.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(t):t.current()===63&&t.raise("Invalid group"),this.regexp_disjunction(t),t.eat(41))return t.numCapturingParens+=1,!0;t.raise("Unterminated group")}return!1},P.regexp_eatExtendedAtom=function(t){return t.eat(46)||this.regexp_eatReverseSolidusAtomEscape(t)||this.regexp_eatCharacterClass(t)||this.regexp_eatUncapturingGroup(t)||this.regexp_eatCapturingGroup(t)||this.regexp_eatInvalidBracedQuantifier(t)||this.regexp_eatExtendedPatternCharacter(t)},P.regexp_eatInvalidBracedQuantifier=function(t){return this.regexp_eatBracedQuantifier(t,!0)&&t.raise("Nothing to repeat"),!1},P.regexp_eatSyntaxCharacter=function(t){var n=t.current();return!!vc(n)&&(t.lastIntValue=n,t.advance(),!0)},P.regexp_eatPatternCharacters=function(t){for(var n=t.pos,e=0;(e=t.current())!==-1&&!vc(e);)t.advance();return t.pos!==n},P.regexp_eatExtendedPatternCharacter=function(t){var n=t.current();return!(n===-1||n===36||n>=40&&n<=43||n===46||n===63||n===91||n===94||n===124)&&(t.advance(),!0)},P.regexp_groupSpecifier=function(t){if(t.eat(63)){if(this.regexp_eatGroupName(t))return t.groupNames.indexOf(t.lastStringValue)!==-1&&t.raise("Duplicate capture group name"),void t.groupNames.push(t.lastStringValue);t.raise("Invalid group")}},P.regexp_eatGroupName=function(t){if(t.lastStringValue="",t.eat(60)){if(this.regexp_eatRegExpIdentifierName(t)&&t.eat(62))return!0;t.raise("Invalid capture group name")}return!1},P.regexp_eatRegExpIdentifierName=function(t){if(t.lastStringValue="",this.regexp_eatRegExpIdentifierStart(t)){for(t.lastStringValue+=Bt(t.lastIntValue);this.regexp_eatRegExpIdentifierPart(t);)t.lastStringValue+=Bt(t.lastIntValue);return!0}return!1},P.regexp_eatRegExpIdentifierStart=function(t){var n=t.pos,e=this.options.ecmaVersion>=11,r=t.current(e);return t.advance(e),r===92&&this.regexp_eatRegExpUnicodeEscapeSequence(t,e)&&(r=t.lastIntValue),function(a){return lt(a,!0)||a===36||a===95}(r)?(t.lastIntValue=r,!0):(t.pos=n,!1)},P.regexp_eatRegExpIdentifierPart=function(t){var n=t.pos,e=this.options.ecmaVersion>=11,r=t.current(e);return t.advance(e),r===92&&this.regexp_eatRegExpUnicodeEscapeSequence(t,e)&&(r=t.lastIntValue),function(a){return Kt(a,!0)||a===36||a===95||a===8204||a===8205}(r)?(t.lastIntValue=r,!0):(t.pos=n,!1)},P.regexp_eatAtomEscape=function(t){return!!(this.regexp_eatBackReference(t)||this.regexp_eatCharacterClassEscape(t)||this.regexp_eatCharacterEscape(t)||t.switchN&&this.regexp_eatKGroupName(t))||(t.switchU&&(t.current()===99&&t.raise("Invalid unicode escape"),t.raise("Invalid escape")),!1)},P.regexp_eatBackReference=function(t){var n=t.pos;if(this.regexp_eatDecimalEscape(t)){var e=t.lastIntValue;if(t.switchU)return e>t.maxBackReference&&(t.maxBackReference=e),!0;if(e<=t.numCapturingParens)return!0;t.pos=n}return!1},P.regexp_eatKGroupName=function(t){if(t.eat(107)){if(this.regexp_eatGroupName(t))return t.backReferenceNames.push(t.lastStringValue),!0;t.raise("Invalid named reference")}return!1},P.regexp_eatCharacterEscape=function(t){return this.regexp_eatControlEscape(t)||this.regexp_eatCControlLetter(t)||this.regexp_eatZero(t)||this.regexp_eatHexEscapeSequence(t)||this.regexp_eatRegExpUnicodeEscapeSequence(t,!1)||!t.switchU&&this.regexp_eatLegacyOctalEscapeSequence(t)||this.regexp_eatIdentityEscape(t)},P.regexp_eatCControlLetter=function(t){var n=t.pos;if(t.eat(99)){if(this.regexp_eatControlLetter(t))return!0;t.pos=n}return!1},P.regexp_eatZero=function(t){return t.current()===48&&!oa(t.lookahead())&&(t.lastIntValue=0,t.advance(),!0)},P.regexp_eatControlEscape=function(t){var n=t.current();return n===116?(t.lastIntValue=9,t.advance(),!0):n===110?(t.lastIntValue=10,t.advance(),!0):n===118?(t.lastIntValue=11,t.advance(),!0):n===102?(t.lastIntValue=12,t.advance(),!0):n===114&&(t.lastIntValue=13,t.advance(),!0)},P.regexp_eatControlLetter=function(t){var n=t.current();return!!$c(n)&&(t.lastIntValue=n%32,t.advance(),!0)},P.regexp_eatRegExpUnicodeEscapeSequence=function(t,n){n===void 0&&(n=!1);var e,r=t.pos,a=n||t.switchU;if(t.eat(117)){if(this.regexp_eatFixedHexDigits(t,4)){var i=t.lastIntValue;if(a&&i>=55296&&i<=56319){var s=t.pos;if(t.eat(92)&&t.eat(117)&&this.regexp_eatFixedHexDigits(t,4)){var o=t.lastIntValue;if(o>=56320&&o<=57343)return t.lastIntValue=1024*(i-55296)+(o-56320)+65536,!0}t.pos=s,t.lastIntValue=i}return!0}if(a&&t.eat(123)&&this.regexp_eatHexDigits(t)&&t.eat(125)&&(e=t.lastIntValue)>=0&&e<=1114111)return!0;a&&t.raise("Invalid unicode escape"),t.pos=r}return!1},P.regexp_eatIdentityEscape=function(t){if(t.switchU)return!!this.regexp_eatSyntaxCharacter(t)||!!t.eat(47)&&(t.lastIntValue=47,!0);var n=t.current();return!(n===99||t.switchN&&n===107)&&(t.lastIntValue=n,t.advance(),!0)},P.regexp_eatDecimalEscape=function(t){t.lastIntValue=0;var n=t.current();if(n>=49&&n<=57){do t.lastIntValue=10*t.lastIntValue+(n-48),t.advance();while((n=t.current())>=48&&n<=57);return!0}return!1},P.regexp_eatCharacterClassEscape=function(t){var n=t.current();if(function(e){return e===100||e===68||e===115||e===83||e===119||e===87}(n))return t.lastIntValue=-1,t.advance(),!0;if(t.switchU&&this.options.ecmaVersion>=9&&(n===80||n===112)){if(t.lastIntValue=-1,t.advance(),t.eat(123)&&this.regexp_eatUnicodePropertyValueExpression(t)&&t.eat(125))return!0;t.raise("Invalid property name")}return!1},P.regexp_eatUnicodePropertyValueExpression=function(t){var n=t.pos;if(this.regexp_eatUnicodePropertyName(t)&&t.eat(61)){var e=t.lastStringValue;if(this.regexp_eatUnicodePropertyValue(t)){var r=t.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(t,e,r),!0}}if(t.pos=n,this.regexp_eatLoneUnicodePropertyNameOrValue(t)){var a=t.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(t,a),!0}return!1},P.regexp_validateUnicodePropertyNameAndValue=function(t,n,e){Je(t.unicodeProperties.nonBinary,n)||t.raise("Invalid property name"),t.unicodeProperties.nonBinary[n].test(e)||t.raise("Invalid property value")},P.regexp_validateUnicodePropertyNameOrValue=function(t,n){t.unicodeProperties.binary.test(n)||t.raise("Invalid property name")},P.regexp_eatUnicodePropertyName=function(t){var n=0;for(t.lastStringValue="";kc(n=t.current());)t.lastStringValue+=Bt(n),t.advance();return t.lastStringValue!==""},P.regexp_eatUnicodePropertyValue=function(t){var n=0;for(t.lastStringValue="";Nh(n=t.current());)t.lastStringValue+=Bt(n),t.advance();return t.lastStringValue!==""},P.regexp_eatLoneUnicodePropertyNameOrValue=function(t){return this.regexp_eatUnicodePropertyValue(t)},P.regexp_eatCharacterClass=function(t){if(t.eat(91)){if(t.eat(94),this.regexp_classRanges(t),t.eat(93))return!0;t.raise("Unterminated character class")}return!1},P.regexp_classRanges=function(t){for(;this.regexp_eatClassAtom(t);){var n=t.lastIntValue;if(t.eat(45)&&this.regexp_eatClassAtom(t)){var e=t.lastIntValue;!t.switchU||n!==-1&&e!==-1||t.raise("Invalid character class"),n!==-1&&e!==-1&&n>e&&t.raise("Range out of order in character class")}}},P.regexp_eatClassAtom=function(t){var n=t.pos;if(t.eat(92)){if(this.regexp_eatClassEscape(t))return!0;if(t.switchU){var e=t.current();(e===99||Ac(e))&&t.raise("Invalid class escape"),t.raise("Invalid escape")}t.pos=n}var r=t.current();return r!==93&&(t.lastIntValue=r,t.advance(),!0)},P.regexp_eatClassEscape=function(t){var n=t.pos;if(t.eat(98))return t.lastIntValue=8,!0;if(t.switchU&&t.eat(45))return t.lastIntValue=45,!0;if(!t.switchU&&t.eat(99)){if(this.regexp_eatClassControlLetter(t))return!0;t.pos=n}return this.regexp_eatCharacterClassEscape(t)||this.regexp_eatCharacterEscape(t)},P.regexp_eatClassControlLetter=function(t){var n=t.current();return!(!oa(n)&&n!==95)&&(t.lastIntValue=n%32,t.advance(),!0)},P.regexp_eatHexEscapeSequence=function(t){var n=t.pos;if(t.eat(120)){if(this.regexp_eatFixedHexDigits(t,2))return!0;t.switchU&&t.raise("Invalid escape"),t.pos=n}return!1},P.regexp_eatDecimalDigits=function(t){var n=t.pos,e=0;for(t.lastIntValue=0;oa(e=t.current());)t.lastIntValue=10*t.lastIntValue+(e-48),t.advance();return t.pos!==n},P.regexp_eatHexDigits=function(t){var n=t.pos,e=0;for(t.lastIntValue=0;Cc(e=t.current());)t.lastIntValue=16*t.lastIntValue+Ec(e),t.advance();return t.pos!==n},P.regexp_eatLegacyOctalEscapeSequence=function(t){if(this.regexp_eatOctalDigit(t)){var n=t.lastIntValue;if(this.regexp_eatOctalDigit(t)){var e=t.lastIntValue;n<=3&&this.regexp_eatOctalDigit(t)?t.lastIntValue=64*n+8*e+t.lastIntValue:t.lastIntValue=8*n+e}else t.lastIntValue=n;return!0}return!1},P.regexp_eatOctalDigit=function(t){var n=t.current();return Ac(n)?(t.lastIntValue=n-48,t.advance(),!0):(t.lastIntValue=0,!1)},P.regexp_eatFixedHexDigits=function(t,n){var e=t.pos;t.lastIntValue=0;for(var r=0;r<n;++r){var a=t.current();if(!Cc(a))return t.pos=e,!1;t.lastIntValue=16*t.lastIntValue+Ec(a),t.advance()}return!0};var la=function(t){this.type=t.type,this.value=t.value,this.start=t.start,this.end=t.end,t.options.locations&&(this.loc=new Ze(t,t.startLoc,t.endLoc)),t.options.ranges&&(this.range=[t.start,t.end])},J=dn.prototype;function wc(t){return typeof BigInt!="function"?null:BigInt(t.replace(/_/g,""))}J.next=function(t){!t&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new la(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},J.getToken=function(){return this.next(),new la(this)},typeof Symbol<"u"&&(J[Symbol.iterator]=function(){var t=this;return{next:function(){var n=t.getToken();return{done:n.type===d.eof,value:n}}}}),J.nextToken=function(){var t=this.curContext();return t&&t.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(d.eof):t.override?t.override(this):void this.readToken(this.fullCharCodeAtPos())},J.readToken=function(t){return lt(t,this.options.ecmaVersion>=6)||t===92?this.readWord():this.getTokenFromCode(t)},J.fullCharCodeAtPos=function(){var t=this.input.charCodeAt(this.pos);if(t<=55295||t>=56320)return t;var n=this.input.charCodeAt(this.pos+1);return n<=56319||n>=57344?t:(t<<10)+n-56613888},J.skipBlockComment=function(){var t=this.options.onComment&&this.curPosition(),n=this.pos,e=this.input.indexOf("*/",this.pos+=2);if(e===-1&&this.raise(this.pos-2,"Unterminated comment"),this.pos=e+2,this.options.locations)for(var r=void 0,a=n;(r=ic(this.input,a,this.pos))>-1;)++this.curLine,a=this.lineStart=r;this.options.onComment&&this.options.onComment(!0,this.input.slice(n+2,e),n,this.pos,t,this.curPosition())},J.skipLineComment=function(t){for(var n=this.pos,e=this.options.onComment&&this.curPosition(),r=this.input.charCodeAt(this.pos+=t);this.pos<this.input.length&&!Ht(r);)r=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(n+t,this.pos),n,this.pos,e,this.curPosition())},J.skipSpace=function(){n:for(;this.pos<this.input.length;){var t=this.input.charCodeAt(this.pos);switch(t){case 32:case 160:++this.pos;break;case 13:this.input.charCodeAt(this.pos+1)===10&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break n}break;default:if(!(t>8&&t<14||t>=5760&&Ji.test(String.fromCharCode(t))))break n;++this.pos}}},J.finishToken=function(t,n){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var e=this.type;this.type=t,this.value=n,this.updateContext(e)},J.readToken_dot=function(){var t=this.input.charCodeAt(this.pos+1);if(t>=48&&t<=57)return this.readNumber(!0);var n=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&t===46&&n===46?(this.pos+=3,this.finishToken(d.ellipsis)):(++this.pos,this.finishToken(d.dot))},J.readToken_slash=function(){var t=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):t===61?this.finishOp(d.assign,2):this.finishOp(d.slash,1)},J.readToken_mult_modulo_exp=function(t){var n=this.input.charCodeAt(this.pos+1),e=1,r=t===42?d.star:d.modulo;return this.options.ecmaVersion>=7&&t===42&&n===42&&(++e,r=d.starstar,n=this.input.charCodeAt(this.pos+2)),n===61?this.finishOp(d.assign,e+1):this.finishOp(r,e)},J.readToken_pipe_amp=function(t){var n=this.input.charCodeAt(this.pos+1);return n===t?this.options.ecmaVersion>=12&&this.input.charCodeAt(this.pos+2)===61?this.finishOp(d.assign,3):this.finishOp(t===124?d.logicalOR:d.logicalAND,2):n===61?this.finishOp(d.assign,2):this.finishOp(t===124?d.bitwiseOR:d.bitwiseAND,1)},J.readToken_caret=function(){return this.input.charCodeAt(this.pos+1)===61?this.finishOp(d.assign,2):this.finishOp(d.bitwiseXOR,1)},J.readToken_plus_min=function(t){var n=this.input.charCodeAt(this.pos+1);return n===t?n!==45||this.inModule||this.input.charCodeAt(this.pos+2)!==62||this.lastTokEnd!==0&&!Pn.test(this.input.slice(this.lastTokEnd,this.pos))?this.finishOp(d.incDec,2):(this.skipLineComment(3),this.skipSpace(),this.nextToken()):n===61?this.finishOp(d.assign,2):this.finishOp(d.plusMin,1)},J.readToken_lt_gt=function(t){var n=this.input.charCodeAt(this.pos+1),e=1;return n===t?(e=t===62&&this.input.charCodeAt(this.pos+2)===62?3:2,this.input.charCodeAt(this.pos+e)===61?this.finishOp(d.assign,e+1):this.finishOp(d.bitShift,e)):n!==33||t!==60||this.inModule||this.input.charCodeAt(this.pos+2)!==45||this.input.charCodeAt(this.pos+3)!==45?(n===61&&(e=2),this.finishOp(d.relational,e)):(this.skipLineComment(4),this.skipSpace(),this.nextToken())},J.readToken_eq_excl=function(t){var n=this.input.charCodeAt(this.pos+1);return n===61?this.finishOp(d.equality,this.input.charCodeAt(this.pos+2)===61?3:2):t===61&&n===62&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(d.arrow)):this.finishOp(t===61?d.eq:d.prefix,1)},J.readToken_question=function(){var t=this.options.ecmaVersion;if(t>=11){var n=this.input.charCodeAt(this.pos+1);if(n===46){var e=this.input.charCodeAt(this.pos+2);if(e<48||e>57)return this.finishOp(d.questionDot,2)}if(n===63)return t>=12&&this.input.charCodeAt(this.pos+2)===61?this.finishOp(d.assign,3):this.finishOp(d.coalesce,2)}return this.finishOp(d.question,1)},J.readToken_numberSign=function(){var t=35;if(this.options.ecmaVersion>=13&&(++this.pos,lt(t=this.fullCharCodeAtPos(),!0)||t===92))return this.finishToken(d.privateId,this.readWord1());this.raise(this.pos,"Unexpected character '"+Bt(t)+"'")},J.getTokenFromCode=function(t){switch(t){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(d.parenL);case 41:return++this.pos,this.finishToken(d.parenR);case 59:return++this.pos,this.finishToken(d.semi);case 44:return++this.pos,this.finishToken(d.comma);case 91:return++this.pos,this.finishToken(d.bracketL);case 93:return++this.pos,this.finishToken(d.bracketR);case 123:return++this.pos,this.finishToken(d.braceL);case 125:return++this.pos,this.finishToken(d.braceR);case 58:return++this.pos,this.finishToken(d.colon);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(d.backQuote);case 48:var n=this.input.charCodeAt(this.pos+1);if(n===120||n===88)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(n===111||n===79)return this.readRadixNumber(8);if(n===98||n===66)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(t);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(t);case 124:case 38:return this.readToken_pipe_amp(t);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(t);case 60:case 62:return this.readToken_lt_gt(t);case 61:case 33:return this.readToken_eq_excl(t);case 63:return this.readToken_question();case 126:return this.finishOp(d.prefix,1);case 35:return this.readToken_numberSign()}this.raise(this.pos,"Unexpected character '"+Bt(t)+"'")},J.finishOp=function(t,n){var e=this.input.slice(this.pos,this.pos+n);return this.pos+=n,this.finishToken(t,e)},J.readRegexp=function(){for(var t,n,e=this.pos;;){this.pos>=this.input.length&&this.raise(e,"Unterminated regular expression");var r=this.input.charAt(this.pos);if(Pn.test(r)&&this.raise(e,"Unterminated regular expression"),t)t=!1;else{if(r==="[")n=!0;else if(r==="]"&&n)n=!1;else if(r==="/"&&!n)break;t=r==="\\"}++this.pos}var a=this.input.slice(e,this.pos);++this.pos;var i=this.pos,s=this.readWord1();this.containsEsc&&this.unexpected(i);var o=this.regexpState||(this.regexpState=new gt(this));o.reset(e,a,s),this.validateRegExpFlags(o),this.validateRegExpPattern(o);var l=null;try{l=new RegExp(a,s)}catch{}return this.finishToken(d.regexp,{pattern:a,flags:s,value:l})},J.readInt=function(t,n,e){for(var r=this.options.ecmaVersion>=12&&n===void 0,a=e&&this.input.charCodeAt(this.pos)===48,i=this.pos,s=0,o=0,l=0,c=n??1/0;l<c;++l,++this.pos){var u=this.input.charCodeAt(this.pos),f=void 0;if(r&&u===95)a&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed in legacy octal numeric literals"),o===95&&this.raiseRecoverable(this.pos,"Numeric separator must be exactly one underscore"),l===0&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed at the first of digits"),o=u;else{if((f=u>=97?u-97+10:u>=65?u-65+10:u>=48&&u<=57?u-48:1/0)>=t)break;o=u,s=s*t+f}}return r&&o===95&&this.raiseRecoverable(this.pos-1,"Numeric separator is not allowed at the last of digits"),this.pos===i||n!=null&&this.pos-i!==n?null:s},J.readRadixNumber=function(t){var n=this.pos;this.pos+=2;var e=this.readInt(t);return e==null&&this.raise(this.start+2,"Expected number in radix "+t),this.options.ecmaVersion>=11&&this.input.charCodeAt(this.pos)===110?(e=wc(this.input.slice(n,this.pos)),++this.pos):lt(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(d.num,e)},J.readNumber=function(t){var n=this.pos;t||this.readInt(10,void 0,!0)!==null||this.raise(n,"Invalid number");var e=this.pos-n>=2&&this.input.charCodeAt(n)===48;e&&this.strict&&this.raise(n,"Invalid number");var r=this.input.charCodeAt(this.pos);if(!e&&!t&&this.options.ecmaVersion>=11&&r===110){var a=wc(this.input.slice(n,this.pos));return++this.pos,lt(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(d.num,a)}e&&/[89]/.test(this.input.slice(n,this.pos))&&(e=!1),r!==46||e||(++this.pos,this.readInt(10),r=this.input.charCodeAt(this.pos)),r!==69&&r!==101||e||((r=this.input.charCodeAt(++this.pos))!==43&&r!==45||++this.pos,this.readInt(10)===null&&this.raise(n,"Invalid number")),lt(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var i,s=(i=this.input.slice(n,this.pos),e?parseInt(i,8):parseFloat(i.replace(/_/g,"")));return this.finishToken(d.num,s)},J.readCodePoint=function(){var t;if(this.input.charCodeAt(this.pos)===123){this.options.ecmaVersion<6&&this.unexpected();var n=++this.pos;t=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,t>1114111&&this.invalidStringToken(n,"Code point out of bounds")}else t=this.readHexChar(4);return t},J.readString=function(t){for(var n="",e=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var r=this.input.charCodeAt(this.pos);if(r===t)break;r===92?(n+=this.input.slice(e,this.pos),n+=this.readEscapedChar(!1),e=this.pos):r===8232||r===8233?(this.options.ecmaVersion<10&&this.raise(this.start,"Unterminated string constant"),++this.pos,this.options.locations&&(this.curLine++,this.lineStart=this.pos)):(Ht(r)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return n+=this.input.slice(e,this.pos++),this.finishToken(d.string,n)};var Sc={};J.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(t){if(t!==Sc)throw t;this.readInvalidTemplateToken()}this.inTemplateElement=!1},J.invalidStringToken=function(t,n){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw Sc;this.raise(t,n)},J.readTmplToken=function(){for(var t="",n=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var e=this.input.charCodeAt(this.pos);if(e===96||e===36&&this.input.charCodeAt(this.pos+1)===123)return this.pos!==this.start||this.type!==d.template&&this.type!==d.invalidTemplate?(t+=this.input.slice(n,this.pos),this.finishToken(d.template,t)):e===36?(this.pos+=2,this.finishToken(d.dollarBraceL)):(++this.pos,this.finishToken(d.backQuote));if(e===92)t+=this.input.slice(n,this.pos),t+=this.readEscapedChar(!0),n=this.pos;else if(Ht(e)){switch(t+=this.input.slice(n,this.pos),++this.pos,e){case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:t+=`
`;break;default:t+=String.fromCharCode(e)}this.options.locations&&(++this.curLine,this.lineStart=this.pos),n=this.pos}else++this.pos}},J.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if(this.input[this.pos+1]!=="{")break;case"`":return this.finishToken(d.invalidTemplate,this.input.slice(this.start,this.pos))}this.raise(this.start,"Unterminated template")},J.readEscapedChar=function(t){var n=this.input.charCodeAt(++this.pos);switch(++this.pos,n){case 110:return`
`;case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return Bt(this.readCodePoint());case 116:return"	";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(this.strict&&this.invalidStringToken(this.pos-1,"Invalid escape sequence"),t){var e=this.pos-1;this.invalidStringToken(e,"Invalid escape sequence in template string")}default:if(n>=48&&n<=55){var r=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],a=parseInt(r,8);return a>255&&(r=r.slice(0,-1),a=parseInt(r,8)),this.pos+=r.length-1,n=this.input.charCodeAt(this.pos),r==="0"&&n!==56&&n!==57||!this.strict&&!t||this.invalidStringToken(this.pos-1-r.length,t?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(a)}return Ht(n)?"":String.fromCharCode(n)}},J.readHexChar=function(t){var n=this.pos,e=this.readInt(16,t);return e===null&&this.invalidStringToken(n,"Bad character escape sequence"),e},J.readWord1=function(){this.containsEsc=!1;for(var t="",n=!0,e=this.pos,r=this.options.ecmaVersion>=6;this.pos<this.input.length;){var a=this.fullCharCodeAtPos();if(Kt(a,r))this.pos+=a<=65535?1:2;else{if(a!==92)break;this.containsEsc=!0,t+=this.input.slice(e,this.pos);var i=this.pos;this.input.charCodeAt(++this.pos)!==117&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var s=this.readCodePoint();(n?lt:Kt)(s,r)||this.invalidStringToken(i,"Invalid Unicode escape"),t+=Bt(s),e=this.pos}n=!1}return t+this.input.slice(e,this.pos)},J.readWord=function(){var t=this.readWord1(),n=d.name;return this.keywords.test(t)&&(n=ea[t]),this.finishToken(n,t)};var Bc="8.8.2";dn.acorn={Parser:dn,version:Bc,defaultOptions:ra,Position:me,SourceLocation:Ze,getLineInfo:Zi,Node:nr,TokenType:Q,tokTypes:d,keywordTypes:ea,TokContext:Kn,tokContexts:un,isIdentifierChar:Kt,isIdentifierStart:lt,Token:la,isNewLine:Ht,lineBreak:Pn,lineBreakG:ac,nonASCIIwhitespace:Ji};var Dh=Object.freeze({__proto__:null,Node:nr,Parser:dn,Position:me,SourceLocation:Ze,TokContext:Kn,Token:la,TokenType:Q,defaultOptions:ra,getLineInfo:Zi,isIdentifierChar:Kt,isIdentifierStart:lt,isNewLine:Ht,keywordTypes:ea,lineBreak:Pn,lineBreakG:ac,nonASCIIwhitespace:Ji,parse:function(t,n){return dn.parse(t,n)},parseExpressionAt:function(t,n,e){return dn.parseExpressionAt(t,n,e)},tokContexts:un,tokTypes:d,tokenizer:function(t,n){return dn.tokenizer(t,n)},version:Bc});const ca=t=>()=>L(function(n){return{code:"NO_FS_IN_BROWSER",message:`Cannot access the file system (via "${n}") when using the browser build of Rollup. Make sure you supply a plugin with custom resolveId and load hooks to Rollup.`,url:En("plugin-development/#a-simple-example")}}(t)),Oh=ca("fs.mkdir"),zh=ca("fs.readFile"),Gh=ca("fs.writeFile");async function Ic(t,n,e,r,a,i,s,o,l){const c=await function(u,f,m,h,b,p,g,x){let k=null,y=null;if(b){k=new Set;for(const v of b)u===v.source&&f===v.importer&&k.add(v.plugin);y=(v,$)=>({...v,resolve:(w,S,{assertions:I,custom:C,isEntry:B,skipSelf:U}=Bn)=>h(w,S,C,B,I||Gn,U?[...b,{importer:S,plugin:$,source:w}]:b)})}return m.hookFirstAndGetPlugin("resolveId",[u,f,{assertions:x,custom:p,isEntry:g}],y,k)}(t,n,r,a,i,s,o,l);return c==null?ca("path.resolve")():c[0]}const is="at position ",ss="at output position ",Fh={delete:()=>!1,get(){},has:()=>!1,set(){}};function _a(t){return t.startsWith(is)||t.startsWith(ss)?L({code:Zm,message:"A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey."}):L({code:ad,message:`The plugin name ${t} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`})}const jc=(t,n,e=Uh)=>{const{onwarn:r,onLog:a}=t,i=Ph(e,r);if(a){const s=zt[n];return(o,l)=>a(o,Mc(l),(c,u)=>{if(c==="error")return L(_t(u));zt[c]>=s&&i(c,_t(u))})}return i},Ph=(t,n)=>n?(e,r)=>{e===V?n(Mc(r),a=>t(V,_t(a))):t(e,r)}:t,Mc=t=>(Object.defineProperty(t,"toString",{value:()=>Lc(t),writable:!0}),t),_t=t=>typeof t=="string"?{message:t}:typeof t=="function"?_t(t()):t,Lc=t=>{let n="";return t.plugin&&(n+=`(${t.plugin} plugin) `),t.loc&&(n+=`${W(t.loc.file)} (${t.loc.line}:${t.loc.column}) `),n+t.message},Uh=(t,n)=>{const e=Lc(n);switch(t){case V:return console.warn(e);case Ee:return console.debug(e);default:return console.info(e)}};function Tc(t,n,e,r,a=/$./){const i=new Set(n),s=Object.keys(t).filter(o=>!(i.has(o)||a.test(o)));s.length>0&&r(V,function(o,l,c){return{code:bd,message:`Unknown ${o}: ${l.join(", ")}. Allowed options: ${c.join(", ")}`}}(e,s,[...i].sort()))}const Rh={recommended:{annotations:!0,correctVarValueBeforeDeclaration:!1,manualPureFunctions:yn,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!1},safest:{annotations:!0,correctVarValueBeforeDeclaration:!0,manualPureFunctions:yn,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!0},smallest:{annotations:!0,correctVarValueBeforeDeclaration:!1,manualPureFunctions:yn,moduleSideEffects:()=>!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1,unknownGlobalSideEffects:!1}},Vh={es2015:{arrowFunctions:!0,constBindings:!0,objectShorthand:!0,reservedNamesAsProps:!0,symbols:!0},es5:{arrowFunctions:!1,constBindings:!1,objectShorthand:!1,reservedNamesAsProps:!0,symbols:!1}},Nc=(t,n,e,r,a)=>{const i=t==null?void 0:t.preset;if(i){const s=n[i];if(s)return{...s,...t};L(bn(`${e}.preset`,r,`valid values are ${mt(Object.keys(n))}`,i))}return((s,o,l,c)=>u=>{if(typeof u=="string"){const f=s[u];if(f)return f;L(bn(o,l,`valid values are ${c}${mt(Object.keys(s))}. You can also supply an object for more fine-grained control`,u))}return(f=>f&&typeof f=="object"?f:{})(u)})(n,e,r,a)(t)},ua=async t=>(await async function(n){do n=(await Promise.all(n)).flat(1/0);while(n.some(e=>e==null?void 0:e.then));return n}([t])).filter(Boolean);async function qh(t,n,e,r){const a=n.id,i=[];let s=t.map===null?null:Wi(t.map);const o=t.code;let l=t.ast;const c=[],u=[];let f=!1;const m=()=>f=!0;let h="";const b=t.code,p=x=>(k,y)=>{k=_t(k),y&&xr(k,y,b,a),k.id=a,k.hook="transform",x(k)};let g;try{g=await e.hookReduceArg0("transform",[b,a],function(x,k,y){let v,$;if(typeof k=="string")v=k;else{if(!k||typeof k!="object")return x;if(n.updateOptions(k),k.code==null)return(k.map||k.ast)&&r(V,function(w){return{code:hd,message:`The plugin "${w}" returned a "map" or "ast" without returning a "code". This will be ignored.`}}(y.name)),x;({code:v,map:$,ast:l}=k)}return $!==null&&i.push(Wi(typeof $=="string"?JSON.parse($):$)||{missing:!0,plugin:y.name}),v},(x,k)=>{return h=k.name,{...x,addWatchFile($){c.push($),x.addWatchFile($)},cache:f?x.cache:(y=x.cache,v=m,{delete:$=>(v(),y.delete($)),get:$=>(v(),y.get($)),has:$=>(v(),y.has($)),set:($,w)=>(v(),y.set($,w))}),debug:p(x.debug),emitFile:$=>(u.push($),e.emitFile($)),error:($,w)=>(typeof $=="string"&&($={message:$}),w&&xr($,w,b,a),$.id=a,$.hook="transform",x.error($)),getCombinedSourcemap(){const $=function(w,S,I,C,B){return C.length===0?I:{version:3,...Rl(w,S,I,C,Ul(B)).traceMappings()}}(a,o,s,i,r);return $?(s!==$&&(s=$,i.length=0),new mr({...$,file:null,sourcesContent:$.sourcesContent})):new Lt(o).generateMap({hires:!0,includeContent:!0,source:a})},info:p(x.info),setAssetSource(){return this.error({code:_d,message:"setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook."})},warn:p(x.warn)};var y,v})}catch(x){return L(we(x,h,{hook:"transform",id:a}))}return!f&&u.length>0&&(n.transformFiles=u),{ast:l,code:g,customTransformCache:f,originalCode:o,originalSourcemap:s,sourcemapChain:i,transformDependencies:c}}const os="resolveDependencies";class Xh{constructor(n,e,r,a){this.graph=n,this.modulesById=e,this.options=r,this.pluginDriver=a,this.implicitEntryModules=new Set,this.indexedEntryModules=[],this.latestLoadModulesPromise=Promise.resolve(),this.moduleLoadPromises=new Map,this.modulesWithLoadedDependencies=new Set,this.nextChunkNamePriority=0,this.nextEntryModuleIndex=0,this.resolveId=async(i,s,o,l,c,u=null)=>this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(!this.options.external(i,s,!1)&&await Ic(i,s,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,u,o,typeof l=="boolean"?l:!s,c),s,i),c),this.hasModuleSideEffects=r.treeshake?r.treeshake.moduleSideEffects:()=>!0}async addAdditionalModules(n){const e=this.extendLoadModulesPromise(Promise.all(n.map(r=>this.loadEntryModule(r,!1,void 0,null))));return await this.awaitLoadModulesPromise(),e}async addEntryModules(n,e){const r=this.nextEntryModuleIndex;this.nextEntryModuleIndex+=n.length;const a=this.nextChunkNamePriority;this.nextChunkNamePriority+=n.length;const i=await this.extendLoadModulesPromise(Promise.all(n.map(({id:s,importer:o})=>this.loadEntryModule(s,!0,o,null))).then(s=>{for(const[o,l]of s.entries()){l.isUserDefinedEntryPoint=l.isUserDefinedEntryPoint||e,Oc(l,n[o],e,a+o);const c=this.indexedEntryModules.find(u=>u.module===l);c?c.index=Math.min(c.index,r+o):this.indexedEntryModules.push({index:r+o,module:l})}return this.indexedEntryModules.sort(({index:o},{index:l})=>o>l?1:-1),s}));return await this.awaitLoadModulesPromise(),{entryModules:this.indexedEntryModules.map(({module:s})=>s),implicitEntryModules:[...this.implicitEntryModules],newEntryModules:i}}async emitChunk({fileName:n,id:e,importer:r,name:a,implicitlyLoadedAfterOneOf:i,preserveSignature:s}){const o={fileName:n||null,id:e,importer:r,name:a||null},l=i?await this.addEntryWithImplicitDependants(o,i):(await this.addEntryModules([o],!1)).newEntryModules[0];return s!=null&&(l.preserveSignature=s),l}async preloadModule(n){return(await this.fetchModule(this.getResolvedIdWithDefaults(n,Gn),void 0,!1,!n.resolveDependencies||os)).info}addEntryWithImplicitDependants(n,e){const r=this.nextChunkNamePriority++;return this.extendLoadModulesPromise(this.loadEntryModule(n.id,!1,n.importer,null).then(async a=>{if(Oc(a,n,!1,r),!a.info.isEntry){this.implicitEntryModules.add(a);const i=await Promise.all(e.map(s=>this.loadEntryModule(s,!1,n.importer,a.id)));for(const s of i)a.implicitlyLoadedAfter.add(s);for(const s of a.implicitlyLoadedAfter)s.implicitlyLoadedBefore.add(a)}return a}))}async addModuleSource(n,e,r){let a;try{a=await this.graph.fileOperationQueue.run(async()=>await this.pluginDriver.hookFirst("load",[n])??await zh(n,"utf8"))}catch(o){let l=`Could not load ${n}`;throw e&&(l+=` (imported by ${W(e)})`),l+=`: ${o.message}`,o.message=l,o}const i=typeof a=="string"?{code:a}:a!=null&&typeof a=="object"&&typeof a.code=="string"?a:L(function(o){return{code:"BAD_LOADER",message:`Error loading "${W(o)}": plugin load hook should return a string, a { code, map } object, or nothing/null.`}}(n)),s=this.graph.cachedModules.get(n);if(!s||s.customTransformCache||s.originalCode!==i.code||await this.pluginDriver.hookFirst("shouldTransformCachedModule",[{ast:s.ast,code:s.code,id:s.id,meta:s.meta,moduleSideEffects:s.moduleSideEffects,resolvedSources:s.resolvedIds,syntheticNamedExports:s.syntheticNamedExports}]))r.updateOptions(i),r.setSource(await qh(i,r,this.pluginDriver,this.options.onLog));else{if(s.transformFiles)for(const o of s.transformFiles)this.pluginDriver.emitFile(o);r.setSource(s)}}async awaitLoadModulesPromise(){let n;do n=this.latestLoadModulesPromise,await n;while(n!==this.latestLoadModulesPromise)}extendLoadModulesPromise(n){return this.latestLoadModulesPromise=Promise.all([n,this.latestLoadModulesPromise]),this.latestLoadModulesPromise.catch(()=>{}),n}async fetchDynamicDependencies(n,e){const r=await Promise.all(e.map(a=>a.then(async([i,s])=>s===null?null:typeof s=="string"?(i.resolution=s,null):i.resolution=await this.fetchResolvedDependency(W(s.id),n.id,s))));for(const a of r)a&&(n.dynamicDependencies.add(a),a.dynamicImporters.push(n.id))}async fetchModule({assertions:n,id:e,meta:r,moduleSideEffects:a,syntheticNamedExports:i},s,o,l){const c=this.modulesById.get(e);if(c instanceof hn)return s&&Xr(n,c.info.assertions)&&this.options.onLog(V,vr(c.info.assertions,n,e,s)),await this.handleExistingModule(c,o,l),c;const u=new hn(this.graph,e,this.options,o,a,i,r,n);this.modulesById.set(e,u),this.graph.watchFiles[e]=!0;const f=this.addModuleSource(e,s,u).then(()=>[this.getResolveStaticDependencyPromises(u),this.getResolveDynamicImportPromises(u),m]),m=zc(f).then(()=>this.pluginDriver.hookParallel("moduleParsed",[u.info]));m.catch(()=>{}),this.moduleLoadPromises.set(u,f);const h=await f;return l?l===os&&await m:await this.fetchModuleDependencies(u,...h),u}async fetchModuleDependencies(n,e,r,a){this.modulesWithLoadedDependencies.has(n)||(this.modulesWithLoadedDependencies.add(n),await Promise.all([this.fetchStaticDependencies(n,e),this.fetchDynamicDependencies(n,r)]),n.linkImports(),await a)}fetchResolvedDependency(n,e,r){if(r.external){const{assertions:a,external:i,id:s,moduleSideEffects:o,meta:l}=r;let c=this.modulesById.get(s);if(c){if(!(c instanceof fn))return L(function(u,f){return{code:"INVALID_EXTERNAL_ID",message:`"${u}" is imported as an external by "${W(f)}", but is already an existing non-external module id.`}}(n,e));Xr(c.info.assertions,a)&&this.options.onLog(V,vr(c.info.assertions,a,n,e))}else c=new fn(this.options,s,o,l,i!=="absolute"&&bt(s),a),this.modulesById.set(s,c);return Promise.resolve(c)}return this.fetchModule(r,e,!1,!1)}async fetchStaticDependencies(n,e){for(const r of await Promise.all(e.map(a=>a.then(([i,s])=>this.fetchResolvedDependency(i,n.id,s)))))n.dependencies.add(r),r.importers.push(n.id);if(!this.options.treeshake||n.info.moduleSideEffects==="no-treeshake")for(const r of n.dependencies)r instanceof hn&&(r.importedFromNotTreeshaken=!0)}getNormalizedResolvedIdWithoutDefaults(n,e,r){const{makeAbsoluteExternalsRelative:a}=this.options;if(n){if(typeof n=="object"){const o=n.external||this.options.external(n.id,e,!0);return{...n,external:o&&(o==="relative"||!bt(n.id)||o===!0&&ls(n.id,r,a)||"absolute")}}const s=this.options.external(n,e,!0);return{external:s&&(ls(n,r,a)||"absolute"),id:s&&a?Dc(n,e):n}}const i=a?Dc(r,e):r;return n===!1||this.options.external(i,e,!0)?{external:ls(i,r,a)||"absolute",id:i}:null}getResolveDynamicImportPromises(n){return n.dynamicImports.map(async e=>{const r=await this.resolveDynamicImport(n,typeof e.argument=="string"?e.argument:e.argument.esTreeNode,n.id,function(a){var o,l,c;const i=(c=(l=(o=a.arguments)==null?void 0:o[0])==null?void 0:l.properties.find(u=>Ti(u)==="assert"))==null?void 0:c.value;if(!i)return Gn;const s=i.properties.map(u=>{const f=Ti(u);return typeof f=="string"&&typeof u.value.value=="string"?[f,u.value.value]:null}).filter(u=>!!u);return s.length>0?Object.fromEntries(s):Gn}(e.node));return r&&typeof r=="object"&&(e.id=r.id),[e,r]})}getResolveStaticDependencyPromises(n){return Array.from(n.sourcesWithAssertions,async([e,r])=>[e,n.resolvedIds[e]=n.resolvedIds[e]||this.handleInvalidResolvedId(await this.resolveId(e,n.id,Gn,!1,r),e,n.id,r)])}getResolvedIdWithDefaults(n,e){if(!n)return null;const r=n.external||!1;return{assertions:n.assertions||e,external:r,id:n.id,meta:n.meta||{},moduleSideEffects:n.moduleSideEffects??this.hasModuleSideEffects(n.id,!!r),resolvedBy:n.resolvedBy??"rollup",syntheticNamedExports:n.syntheticNamedExports??!1}}async handleExistingModule(n,e,r){const a=this.moduleLoadPromises.get(n);if(r)return r===os?zc(a):a;if(e){n.info.isEntry=!0,this.implicitEntryModules.delete(n);for(const i of n.implicitlyLoadedAfter)i.implicitlyLoadedBefore.delete(n);n.implicitlyLoadedAfter.clear()}return this.fetchModuleDependencies(n,...await a)}handleInvalidResolvedId(n,e,r,a){return n===null?Ma(e)?L(function(i,s){return{code:Ys,exporter:i,id:s,message:`Could not resolve "${i}" from "${W(s)}"`}}(e,r)):(this.options.onLog(V,function(i,s){return{code:Ys,exporter:i,id:s,message:`"${i}" is imported by "${W(s)}", but could not be resolved – treating it as an external dependency.`,url:En("troubleshooting/#warning-treating-module-as-external-dependency")}}(e,r)),{assertions:a,external:!0,id:e,meta:{},moduleSideEffects:this.hasModuleSideEffects(e,!0),resolvedBy:"rollup",syntheticNamedExports:!1}):(n.external&&n.syntheticNamedExports&&this.options.onLog(V,function(i,s){return{code:"EXTERNAL_SYNTHETIC_EXPORTS",exporter:i,message:`External "${i}" cannot have "syntheticNamedExports" enabled (imported by "${W(s)}").`}}(e,r)),n)}async loadEntryModule(n,e,r,a){const i=await Ic(n,r,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,null,Gn,!0,Gn);return i==null?L(a===null?function(s){return{code:Hs,message:`Could not resolve entry module "${W(s)}".`}}(n):function(s,o){return{code:Xa,message:`Module "${W(s)}" that should be implicitly loaded before "${W(o)}" could not be resolved.`}}(n,a)):i===!1||typeof i=="object"&&i.external?L(a===null?function(s){return{code:Hs,message:`Entry module "${W(s)}" cannot be external.`}}(n):function(s,o){return{code:Xa,message:`Module "${W(s)}" that should be implicitly loaded before "${W(o)}" cannot be external.`}}(n,a)):this.fetchModule(this.getResolvedIdWithDefaults(typeof i=="object"?i:{id:i},Gn),void 0,e,!1)}async resolveDynamicImport(n,e,r,a){const i=await this.pluginDriver.hookFirst("resolveDynamicImport",[e,r,{assertions:a}]);if(typeof e!="string")return typeof i=="string"?i:i?this.getResolvedIdWithDefaults(i,a):null;if(i==null){const s=n.resolvedIds[e];return s?(Xr(s.assertions,a)&&this.options.onLog(V,vr(s.assertions,a,e,r)),s):n.resolvedIds[e]=this.handleInvalidResolvedId(await this.resolveId(e,n.id,Gn,!1,a),e,n.id,a)}return this.handleInvalidResolvedId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(i,r,e),a),e,r,a)}}function Dc(t,n){return Ma(t)?n?Hn(n,"..",t):Hn(t):t}function Oc(t,{fileName:n,name:e},r,a){var i;if(n!==null)t.chunkFileNames.add(n);else if(e!==null){let s=0;for(;((i=t.chunkNames[s])==null?void 0:i.priority)<a;)s++;t.chunkNames.splice(s,0,{isUserDefined:r,name:e,priority:a})}}function ls(t,n,e){return e===!0||e==="ifRelativeSource"&&Ma(n)||!bt(t)}async function zc(t){const[n,e]=await t;return Promise.all([...n,...e])}class Wh extends Ao{constructor(){super(),this.parent=null,this.variables.set("undefined",new fl)}findVariable(n){let e=this.variables.get(n);return e||(e=new ci(n),this.variables.set(n,e)),e}}function Gc(t){return Ye().update(t).digest("hex")}function Fc(t,n,e,r,a){const i=r.sanitizeFileName(t||"asset");return Ll(Ml(typeof r.assetFileNames=="function"?r.assetFileNames({name:t,source:n,type:"asset"}):r.assetFileNames,"output.assetFileNames",{ext:()=>xt(i).slice(1),extname:()=>xt(i),hash:s=>e.slice(0,Math.max(0,s||8)),name:()=>i.slice(0,Math.max(0,i.length-xt(i).length))}),a)}function Pc(t,{bundle:n},e){n[Zr].has(t.toLowerCase())?e(V,function(r){return{code:id,message:`The emitted file "${r}" overwrites a previously emitted file of the same name.`}}(t)):n[t]=Ri}const Kh=new Set(["chunk","asset","prebuilt-chunk"]);function Uc(t,n,e){if(!(typeof t=="string"||t instanceof Uint8Array)){const r=n.fileName||n.name||e;return L(Tn(`Could not set source for ${typeof r=="string"?`asset "${r}"`:"unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`))}return t}function Hh(t,n){return typeof t.fileName!="string"?L((e=t.name||n,{code:Qm,message:`Plugin error - Unable to get file name for asset "${e}". Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_<referenceId>, you need to either have set their source after "renderStart" or need to provide an explicit "fileName" when emitting them.`})):t.fileName;var e}function Yh(t,n){return t.fileName?t.fileName:n?n.get(t.module).getFileName():L((e=t.fileName||t.name,{code:td,message:`Plugin error - Unable to get file name for emitted chunk "${e}". You can only get file names once chunks have been generated after the "renderStart" hook.`}));var e}class Jh{constructor(n,e,r){this.graph=n,this.options=e,this.facadeChunkByModule=null,this.nextIdBase=1,this.output=null,this.outputFileEmitters=[],this.emitFile=a=>function(i){return!!(i&&Kh.has(i.type))}(a)?a.type==="prebuilt-chunk"?this.emitPrebuiltChunk(a):function(i){const s=i.fileName||i.name;return!s||typeof s=="string"&&!pr(s)}(a)?a.type==="chunk"?this.emitChunk(a):this.emitAsset(a):L(Tn(`The "fileName" or "name" properties of emitted chunks and assets must be strings that are neither absolute nor relative paths, received "${a.fileName||a.name}".`)):L(Tn(`Emitted files must be of type "asset", "chunk" or "prebuilt-chunk", received "${a&&a.type}".`)),this.finaliseAssets=()=>{for(const[a,i]of this.filesByReferenceId)if(i.type==="asset"&&typeof i.fileName!="string")return L({code:"ASSET_SOURCE_MISSING",message:`Plugin error creating asset "${i.name||a}" - no asset source set.`})},this.getFileName=a=>{const i=this.filesByReferenceId.get(a);return i?i.type==="chunk"?Yh(i,this.facadeChunkByModule):i.type==="prebuilt-chunk"?i.fileName:Hh(i,a):L({code:"FILE_NOT_FOUND",message:`Plugin error - Unable to get file name for unknown file "${a}".`})},this.setAssetSource=(a,i)=>{const s=this.filesByReferenceId.get(a);if(!s)return L({code:"ASSET_NOT_FOUND",message:`Plugin error - Unable to set the source for unknown asset "${a}".`});if(s.type!=="asset")return L(Tn(`Asset sources can only be set for emitted assets but "${a}" is an emitted chunk.`));if(s.source!==void 0)return L({code:"ASSET_SOURCE_ALREADY_SET",message:`Unable to set the source for asset "${s.name||a}", source already set.`});const o=Uc(i,s,a);if(this.output)this.finalizeAdditionalAsset(s,o,this.output);else{s.source=o;for(const l of this.outputFileEmitters)l.finalizeAdditionalAsset(s,o,l.output)}},this.setChunkInformation=a=>{this.facadeChunkByModule=a},this.setOutputBundle=(a,i)=>{const s=this.output={bundle:a,fileNamesBySource:new Map,outputOptions:i};for(const l of this.filesByReferenceId.values())l.fileName&&Pc(l.fileName,s,this.options.onLog);const o=new Map;for(const l of this.filesByReferenceId.values())l.type==="asset"&&l.source!==void 0?l.fileName?this.finalizeAdditionalAsset(l,l.source,s):zn(o,Gc(l.source),()=>[]).push(l):l.type==="prebuilt-chunk"&&(this.output.bundle[l.fileName]=this.createPrebuiltChunk(l));for(const[l,c]of o)this.finalizeAssetsWithSameSource(c,l,s)},this.filesByReferenceId=r?new Map(r.filesByReferenceId):new Map,r==null||r.addOutputFileEmitter(this)}addOutputFileEmitter(n){this.outputFileEmitters.push(n)}assignReferenceId(n,e){let r=e;do r=Ye().update(r).digest("hex").slice(0,8);while(this.filesByReferenceId.has(r)||this.outputFileEmitters.some(({filesByReferenceId:a})=>a.has(r)));n.referenceId=r,this.filesByReferenceId.set(r,n);for(const{filesByReferenceId:a}of this.outputFileEmitters)a.set(r,n);return r}createPrebuiltChunk(n){return{code:n.code,dynamicImports:[],exports:n.exports||[],facadeModuleId:null,fileName:n.fileName,implicitlyLoadedBefore:[],importedBindings:{},imports:[],isDynamicEntry:!1,isEntry:!1,isImplicitEntry:!1,map:n.map||null,moduleIds:[],modules:{},name:n.fileName,referencedFiles:[],type:"chunk"}}emitAsset(n){const e=n.source===void 0?void 0:Uc(n.source,n,null),r={fileName:n.fileName,name:n.name,needsCodeReference:!!n.needsCodeReference,referenceId:"",source:e,type:"asset"},a=this.assignReferenceId(r,n.fileName||n.name||String(this.nextIdBase++));if(this.output)this.emitAssetWithReferenceId(r,this.output);else for(const i of this.outputFileEmitters)i.emitAssetWithReferenceId(r,i.output);return a}emitAssetWithReferenceId(n,e){const{fileName:r,source:a}=n;r&&Pc(r,e,this.options.onLog),a!==void 0&&this.finalizeAdditionalAsset(n,a,e)}emitChunk(n){if(this.graph.phase>wt.LOAD_AND_PARSE)return L({code:qs,message:"Cannot emit chunks after module loading has finished."});if(typeof n.id!="string")return L(Tn(`Emitted chunks need to have a valid string id, received "${n.id}"`));const e={fileName:n.fileName,module:null,name:n.name||n.id,referenceId:"",type:"chunk"};return this.graph.moduleLoader.emitChunk(n).then(r=>e.module=r).catch(()=>{}),this.assignReferenceId(e,n.id)}emitPrebuiltChunk(n){if(typeof n.code!="string")return L(Tn(`Emitted prebuilt chunks need to have a valid string code, received "${n.code}".`));if(typeof n.fileName!="string"||pr(n.fileName))return L(Tn(`The "fileName" property of emitted prebuilt chunks must be strings that are neither absolute nor relative paths, received "${n.fileName}".`));const e={code:n.code,exports:n.exports,fileName:n.fileName,map:n.map,referenceId:"",type:"prebuilt-chunk"},r=this.assignReferenceId(e,e.fileName);return this.output&&(this.output.bundle[e.fileName]=this.createPrebuiltChunk(e)),r}finalizeAdditionalAsset(n,e,{bundle:r,fileNamesBySource:a,outputOptions:i}){let{fileName:s,needsCodeReference:o,referenceId:l}=n;if(!s){const f=Gc(e);s=a.get(f),s||(s=Fc(n.name,e,f,i,r),a.set(f,s))}const c={...n,fileName:s,source:e};this.filesByReferenceId.set(l,c);const u=r[s];(u==null?void 0:u.type)==="asset"?u.needsCodeReference&&(u.needsCodeReference=o):r[s]={fileName:s,name:n.name,needsCodeReference:o,source:e,type:"asset"}}finalizeAssetsWithSameSource(n,e,{bundle:r,fileNamesBySource:a,outputOptions:i}){let s,o="",l=!0;for(const c of n){l&&(l=c.needsCodeReference);const u=Fc(c.name,c.source,e,i,r);(!o||u.length<o.length||u.length===o.length&&u<o)&&(o=u,s=c)}a.set(e,o);for(const c of n){const u={...c,fileName:o};this.filesByReferenceId.set(c.referenceId,u)}r[o]={fileName:o,name:s.name,needsCodeReference:l,source:s.source,type:"asset"}}}function pe(t,n,e,r,a){return zt[t]<zt[a]?rt:(i,s)=>{s!=null&&e(V,{code:ld,message:`Plugin "${r}" tried to add a file position to a log or warning. This is only supported in the "transform" hook at the moment and will be ignored.`}),(i=_t(i)).code&&!i.pluginCode&&(i.pluginCode=i.code),i.code=n,i.plugin=r,e(t,i)}}function Zh(t,n,e,r,a,i){const{logLevel:s,onLog:o}=r;let l,c=!0;if(typeof t.cacheKey!="string"&&(t.name.startsWith(is)||t.name.startsWith(ss)||i.has(t.name)?c=!1:i.add(t.name)),n)if(c){const m=t.cacheKey||t.name;f=n[m]||(n[m]=Object.create(null)),l={delete:h=>delete f[h],get(h){const b=f[h];if(b)return b[0]=0,b[1]},has(h){const b=f[h];return!!b&&(b[0]=0,!0)},set(h,b){f[h]=[0,b]}}}else u=t.name,l={delete:()=>_a(u),get:()=>_a(u),has:()=>_a(u),set:()=>_a(u)};else l=Fh;var u,f;return{addWatchFile(m){if(e.phase>=wt.GENERATE)return this.error({code:qs,message:'Cannot call "addWatchFile" after the build has finished.'});e.watchFiles[m]=!0},cache:l,debug:pe(Ee,"PLUGIN_LOG",o,t.name,s),emitFile:a.emitFile.bind(a),error:m=>L(we(_t(m),t.name)),getFileName:a.getFileName,getModuleIds:()=>e.modulesById.keys(),getModuleInfo:e.getModuleInfo,getWatchFiles:()=>Object.keys(e.watchFiles),info:pe(Ot,"PLUGIN_LOG",o,t.name,s),load:m=>e.moduleLoader.preloadModule(m),meta:{rollupVersion:Ia,watchMode:e.watchMode},get moduleIds(){const m=e.modulesById.keys();return function*(){Gt(`Accessing "this.moduleIds" on the plugin context by plugin ${t.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,"plugin-development/#this-getmoduleids",!0,r,t.name),yield*m}()},parse:e.contextParse.bind(e),resolve:(m,h,{assertions:b,custom:p,isEntry:g,skipSelf:x}=Bn)=>e.moduleLoader.resolveId(m,h,p,g,b||Gn,x?[{importer:h,plugin:t,source:m}]:null),setAssetSource:a.setAssetSource,warn:pe(V,"PLUGIN_WARNING",o,t.name,s)}}const Qh=Object.keys({buildEnd:1,buildStart:1,closeBundle:1,closeWatcher:1,load:1,moduleParsed:1,onLog:1,options:1,resolveDynamicImport:1,resolveId:1,shouldTransformCachedModule:1,transform:1,watchChange:1});class cs{constructor(n,e,r,a,i){this.graph=n,this.options=e,this.pluginCache=a,this.sortedPlugins=new Map,this.unfulfilledActions=new Set,this.fileEmitter=new Jh(n,e,i&&i.fileEmitter),this.emitFile=this.fileEmitter.emitFile.bind(this.fileEmitter),this.getFileName=this.fileEmitter.getFileName.bind(this.fileEmitter),this.finaliseAssets=this.fileEmitter.finaliseAssets.bind(this.fileEmitter),this.setChunkInformation=this.fileEmitter.setChunkInformation.bind(this.fileEmitter),this.setOutputBundle=this.fileEmitter.setOutputBundle.bind(this.fileEmitter),this.plugins=[...i?i.plugins:[],...r];const s=new Set;if(this.pluginContexts=new Map(this.plugins.map(l=>[l,Zh(l,a,n,e,this.fileEmitter,s)])),i)for(const l of r)for(const c of Qh)c in l&&e.onLog(V,(o=l.name,{code:"INPUT_HOOK_IN_OUTPUT_PLUGIN",message:`The "${c}" hook used by the output plugin ${o} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`}));var o}createOutputPluginDriver(n){return new cs(this.graph,this.options,n,this.pluginCache,this)}getUnfulfilledHookActions(){return this.unfulfilledActions}hookFirst(n,e,r,a){return this.hookFirstAndGetPlugin(n,e,r,a).then(i=>i&&i[0])}async hookFirstAndGetPlugin(n,e,r,a){for(const i of this.getSortedPlugins(n)){if(a!=null&&a.has(i))continue;const s=await this.runHook(n,e,i,r);if(s!=null)return[s,i]}return null}hookFirstSync(n,e,r){for(const a of this.getSortedPlugins(n)){const i=this.runHookSync(n,e,a,r);if(i!=null)return i}return null}async hookParallel(n,e,r){const a=[];for(const i of this.getSortedPlugins(n))i[n].sequential?(await Promise.all(a),a.length=0,await this.runHook(n,e,i,r)):a.push(this.runHook(n,e,i,r));await Promise.all(a)}hookReduceArg0(n,[e,...r],a,i){let s=Promise.resolve(e);for(const o of this.getSortedPlugins(n))s=s.then(l=>this.runHook(n,[l,...r],o,i).then(c=>a.call(this.pluginContexts.get(o),l,c,o)));return s}hookReduceArg0Sync(n,[e,...r],a,i){for(const s of this.getSortedPlugins(n)){const o=[e,...r],l=this.runHookSync(n,o,s,i);e=a.call(this.pluginContexts.get(s),e,l,s)}return e}async hookReduceValue(n,e,r,a){const i=[],s=[];for(const o of this.getSortedPlugins(n,tg))o[n].sequential?(i.push(...await Promise.all(s)),s.length=0,i.push(await this.runHook(n,r,o))):s.push(this.runHook(n,r,o));return i.push(...await Promise.all(s)),i.reduce(a,await e)}hookReduceValueSync(n,e,r,a,i){let s=e;for(const o of this.getSortedPlugins(n)){const l=this.runHookSync(n,r,o,i);s=a.call(this.pluginContexts.get(o),s,l,o)}return s}hookSeq(n,e,r){let a=Promise.resolve();for(const i of this.getSortedPlugins(n))a=a.then(()=>this.runHook(n,e,i,r));return a.then(eg)}getSortedPlugins(n,e){return zn(this.sortedPlugins,n,()=>_s(n,this.plugins,e))}runHook(n,e,r,a){const i=r[n],s=typeof i=="object"?i.handler:i;let o=this.pluginContexts.get(r);a&&(o=a(o,r));let l=null;return Promise.resolve().then(()=>{if(typeof s!="function")return s;const c=s.apply(o,e);return c!=null&&c.then?(l=[r.name,n,e],this.unfulfilledActions.add(l),Promise.resolve(c).then(u=>(this.unfulfilledActions.delete(l),u))):c}).catch(c=>(l!==null&&this.unfulfilledActions.delete(l),L(we(c,r.name,{hook:n}))))}runHookSync(n,e,r,a){const i=r[n],s=typeof i=="object"?i.handler:i;let o=this.pluginContexts.get(r);a&&(o=a(o,r));try{return s.apply(o,e)}catch(l){return L(we(l,r.name,{hook:n}))}}}function _s(t,n,e=ng){const r=[],a=[],i=[];for(const s of n){const o=s[t];if(o){if(typeof o=="object"){if(e(o.handler,t,s),o.order==="pre"){r.push(s);continue}if(o.order==="post"){i.push(s);continue}}else e(o,t,s);a.push(s)}}return[...r,...a,...i]}function ng(t,n,e){typeof t!="function"&&L(function(r,a){return{code:Vs,hook:r,message:`Error running plugin hook "${r}" for plugin "${a}", expected a function hook or an object with a "handler" function.`,plugin:a}}(n,e.name))}function tg(t,n,e){if(typeof t!="string"&&typeof t!="function")return L(function(r,a){return{code:Vs,hook:r,message:`Error running plugin hook "${r}" for plugin "${a}", expected a string, a function hook or an object with a "handler" string or function.`,plugin:a}}(n,e.name))}function eg(){}class rg{constructor(n){this.maxParallel=n,this.queue=[],this.workerCount=0}run(n){return new Promise((e,r)=>{this.queue.push({reject:r,resolve:e,task:n}),this.work()})}async work(){if(this.workerCount>=this.maxParallel)return;let n;for(this.workerCount++;n=this.queue.shift();){const{reject:e,resolve:r,task:a}=n;try{r(await a())}catch(i){e(i)}}this.workerCount--}}class ag{constructor(n,e){var r,a;if(this.options=n,this.astLru=function(i){var s,o,l,c=i||1;function u(m,h){++s>c&&(l=o,f(1),++s),o[m]=h}function f(m){s=0,o=Object.create(null),m||(l=Object.create(null))}return f(),{clear:f,has:function(m){return o[m]!==void 0||l[m]!==void 0},get:function(m){var h=o[m];return h!==void 0?h:(h=l[m])!==void 0?(u(m,h),h):void 0},set:function(m,h){o[m]!==void 0?o[m]=h:u(m,h)}}}(5),this.cachedModules=new Map,this.deoptimizationTracker=new re,this.entryModules=[],this.modulesById=new Map,this.needsTreeshakingPass=!1,this.phase=wt.LOAD_AND_PARSE,this.scope=new Wh,this.watchFiles=Object.create(null),this.watchMode=!1,this.externalModules=[],this.implicitEntryModules=[],this.modules=[],this.getModuleInfo=i=>{const s=this.modulesById.get(i);return s?s.info:null},n.cache!==!1){if((r=n.cache)!=null&&r.modules)for(const i of n.cache.modules)this.cachedModules.set(i.id,i);this.pluginCache=((a=n.cache)==null?void 0:a.plugins)||Object.create(null);for(const i in this.pluginCache){const s=this.pluginCache[i];for(const o of Object.values(s))o[0]++}}if(e){this.watchMode=!0;const i=(...o)=>this.pluginDriver.hookParallel("watchChange",o),s=()=>this.pluginDriver.hookParallel("closeWatcher",[]);e.onCurrentRun("change",i),e.onCurrentRun("close",s)}this.pluginDriver=new cs(this,n,n.plugins,this.pluginCache),this.acornParser=dn.extend(...n.acornInjectPlugins),this.moduleLoader=new Xh(this,this.modulesById,this.options,this.pluginDriver),this.fileOperationQueue=new rg(n.maxParallelFileOps),this.pureFunctions=(({treeshake:i})=>{const s=Object.create(null);for(const o of i?i.manualPureFunctions:[]){let l=s;for(const c of o.split("."))l=l[c]||(l[c]=Object.create(null));l[si]=!0}return s})(n)}async build(){$n("generate module graph",2),await this.generateModuleGraph(),xn("generate module graph",2),$n("sort and bind modules",2),this.phase=wt.ANALYSE,this.sortModules(),xn("sort and bind modules",2),$n("mark included statements",2),this.includeStatements(),xn("mark included statements",2),this.phase=wt.GENERATE}contextParse(n,e={}){const r=e.onComment,a=[];e.onComment=r&&typeof r=="function"?(s,o,l,c,...u)=>(a.push({end:c,start:l,type:s?"Block":"Line",value:o}),r.call(e,s,o,l,c,...u)):a;const i=this.acornParser.parse(n,{...this.options.acorn,...e});return typeof r=="object"&&r.push(...a),e.onComment=r,function(s,o,l){const c=[],u=[];for(const f of s){for(const[m,h]of Rd)h.test(f.value)&&c.push({...f,annotationType:m});Fd.test(f.value)&&u.push(f)}for(const f of u)wr(o,f,!1);_o(o,{annotationIndex:0,annotations:c,code:l})}(a,i,n),i}getCache(){for(const n in this.pluginCache){const e=this.pluginCache[n];let r=!0;for(const[a,i]of Object.entries(e))i[0]>=this.options.experimentalCacheExpiry?delete e[a]:r=!1;r&&delete this.pluginCache[n]}return{modules:this.modules.map(n=>n.toJSON()),plugins:this.pluginCache}}async generateModuleGraph(){var n;if({entryModules:this.entryModules,implicitEntryModules:this.implicitEntryModules}=await this.moduleLoader.addEntryModules((n=this.options.input,Array.isArray(n)?n.map(e=>({fileName:null,id:e,implicitlyLoadedAfter:[],importer:void 0,name:null})):Object.entries(n).map(([e,r])=>({fileName:null,id:r,implicitlyLoadedAfter:[],importer:void 0,name:e}))),!0),this.entryModules.length===0)throw new Error("You must supply options.input to rollup");for(const e of this.modulesById.values())e instanceof hn?this.modules.push(e):this.externalModules.push(e)}includeStatements(){const n=[...this.entryModules,...this.implicitEntryModules];for(const e of n)Ke(e);if(this.options.treeshake){let e=1;do{$n(`treeshaking pass ${e}`,3),this.needsTreeshakingPass=!1;for(const r of this.modules)r.isExecuted&&(r.info.moduleSideEffects==="no-treeshake"?r.includeAllInBundle():r.include());if(e===1)for(const r of n)r.preserveSignature!==!1&&(r.includeAllExports(!1),this.needsTreeshakingPass=!0);xn("treeshaking pass "+e++,3)}while(this.needsTreeshakingPass)}else for(const e of this.modules)e.includeAllInBundle();for(const e of this.externalModules)e.warnUnusedImports();for(const e of this.implicitEntryModules)for(const r of e.implicitlyLoadedAfter)r.info.isEntry||r.isIncluded()||L(Cd(r))}sortModules(){const{orderedModules:n,cyclePaths:e}=function(r){let a=0;const i=[],s=new Set,o=new Set,l=new Map,c=[],u=f=>{if(f instanceof hn){for(const m of f.dependencies)l.has(m)?s.has(m)||i.push(Hp(m,f,l)):(l.set(m,f),u(m));for(const m of f.implicitlyLoadedBefore)o.add(m);for(const{resolution:m}of f.dynamicImports)m instanceof hn&&o.add(m);c.push(f)}f.execIndex=a++,s.add(f)};for(const f of r)l.has(f)||(l.set(f,null),u(f));for(const f of o)l.has(f)||(l.set(f,null),u(f));return{cyclePaths:i,orderedModules:c}}(this.entryModules);for(const r of e)this.options.onLog(V,$d(r));this.modules=n;for(const r of this.modules)r.bindReferences();this.warnForMissingExports()}warnForMissingExports(){for(const n of this.modules)for(const e of n.importDescriptions.values())e.name==="*"||e.module.getVariableForExportName(e.name)[0]||n.log(V,$r(e.name,n.id,e.module.id),e.start)}}function Rc(t,n){return n()}function Vc(t,n,e,r){t=_s("onLog",t);const a=zt[r],i=(s,o,l=Ns)=>{if(!(zt[s]<a)){for(const c of t){if(l.has(c))continue;const{onLog:u}=c,f=m=>zt[m]<a?rt:h=>i(m,_t(h),new Set(l).add(c));if(("handler"in u?u.handler:u).call({debug:f(Ee),error:m=>L(_t(m)),info:f(Ot),meta:{rollupVersion:Ia,watchMode:e},warn:f(V)},s,o)===!1)return}n(s,o)}};return i}const ig="{".charCodeAt(0),sg=" ".charCodeAt(0),qc="assert";function og(t){const n=t.acorn||Dh,{tokTypes:e,TokenType:r}=n;return class extends t{constructor(...a){super(...a),this.assertToken=new r(qc)}_codeAt(a){return this.input.charCodeAt(a)}_eat(a){this.type!==a&&this.unexpected(),this.next()}readToken(a){let i=0;for(;i<6;i++)if(this._codeAt(this.pos+i)!==qc.charCodeAt(i))return super.readToken(a);for(;this._codeAt(this.pos+i)!==ig;i++)if(this._codeAt(this.pos+i)!==sg)return super.readToken(a);return this.type.label==="{"?super.readToken(a):(this.pos+=6,this.finishToken(this.assertToken))}parseDynamicImport(a){if(this.next(),a.source=this.parseMaybeAssign(),this.eat(e.comma)){const i=this.parseObj(!1);a.arguments=[i]}return this._eat(e.parenR),this.finishNode(a,"ImportExpression")}parseExport(a,i){if(this.next(),this.eat(e.star)){if(this.options.ecmaVersion>=11&&(this.eatContextual("as")?(a.exported=this.parseIdent(!0),this.checkExport(i,a.exported.name,this.lastTokStart)):a.exported=null),this.expectContextual("from"),this.type!==e.string&&this.unexpected(),a.source=this.parseExprAtom(),this.type===this.assertToken||this.type===e._with){this.next();const m=this.parseImportAssertions();m&&(a.assertions=m)}return this.semicolon(),this.finishNode(a,"ExportAllDeclaration")}if(this.eat(e._default)){var s;if(this.checkExport(i,"default",this.lastTokStart),this.type===e._function||(s=this.isAsyncFunction())){var o=this.startNode();this.next(),s&&this.next(),a.declaration=this.parseFunction(o,5,!1,s)}else if(this.type===e._class){var l=this.startNode();a.declaration=this.parseClass(l,"nullableID")}else a.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(a,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())a.declaration=this.parseStatement(null),a.declaration.type==="VariableDeclaration"?this.checkVariableExport(i,a.declaration.declarations):this.checkExport(i,a.declaration.id.name,a.declaration.id.start),a.specifiers=[],a.source=null;else{if(a.declaration=null,a.specifiers=this.parseExportSpecifiers(i),this.eatContextual("from")){if(this.type!==e.string&&this.unexpected(),a.source=this.parseExprAtom(),this.type===this.assertToken||this.type===e._with){this.next();const m=this.parseImportAssertions();m&&(a.assertions=m)}}else{for(var c=0,u=a.specifiers;c<u.length;c+=1){var f=u[c];this.checkUnreserved(f.local),this.checkLocalExport(f.local)}a.source=null}this.semicolon()}return this.finishNode(a,"ExportNamedDeclaration")}parseImport(a){if(this.next(),this.type===e.string?(a.specifiers=[],a.source=this.parseExprAtom()):(a.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),a.source=this.type===e.string?this.parseExprAtom():this.unexpected()),this.type===this.assertToken||this.type==e._with){this.next();const i=this.parseImportAssertions();i&&(a.assertions=i)}return this.semicolon(),this.finishNode(a,"ImportDeclaration")}parseImportAssertions(){this._eat(e.braceL);const a=this.parseAssertEntries();return this._eat(e.braceR),a}parseAssertEntries(){const a=[],i=new Set;do{if(this.type===e.braceR)break;const s=this.startNode();let o;o=this.type===e.string?this.parseLiteral(this.value):this.parseIdent(!0),this.next(),s.key=o,i.has(s.key.name)&&this.raise(this.pos,"Duplicated key in assertions"),i.add(s.key.name),this.type!==e.string&&this.raise(this.pos,"Only string is supported as an assertion value"),s.value=this.parseLiteral(this.value),a.push(this.finishNode(s,"ImportAttribute"))}while(this.eat(e.comma));return a}}}function Xc(t){return Array.isArray(t)?t.filter(Boolean):t?[t]:[]}const lg=t=>({ecmaVersion:"latest",sourceType:"module",...t.acorn}),cg=t=>[og,...Xc(t.acornInjectPlugins)],_g=t=>{var n;return t.cache===!0?void 0:((n=t.cache)==null?void 0:n.cache)||t.cache},ug=t=>{if(t===!0)return()=>!0;if(typeof t=="function")return(n,...e)=>!n.startsWith("\0")&&t(n,...e)||!1;if(t){const n=new Set,e=[];for(const r of Xc(t))r instanceof RegExp?e.push(r):n.add(r);return(r,...a)=>n.has(r)||e.some(i=>i.test(r))}return()=>!1},fg=(t,n,e)=>{const r=t.inlineDynamicImports;return r&&Se('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.',Ra,!0,n,e),r},mg=t=>{const n=t.input;return n==null?[]:typeof n=="string"?[n]:n},dg=(t,n,e)=>{const r=t.manualChunks;return r&&Se('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.',qa,!0,n,e),r},pg=(t,n,e)=>{const r=t.maxParallelFileReads;typeof r=="number"&&Se('The "maxParallelFileReads" option is deprecated. Use the "maxParallelFileOps" option instead.',"configuration-options/#maxparallelfileops",!0,n,e);const a=t.maxParallelFileOps??r;return typeof a=="number"?a<=0?1/0:a:20},hg=(t,n)=>{const e=t.moduleContext;if(typeof e=="function")return r=>e(r)??n;if(e){const r=Object.create(null);for(const[a,i]of Object.entries(e))r[Hn(a)]=i;return a=>r[a]??n}return()=>n},gg=(t,n,e)=>{const r=t.preserveModules;return r&&Se('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.',"configuration-options/#output-preservemodules",!0,n,e),r},yg=t=>{if(t.treeshake===!1)return!1;const n=Nc(t.treeshake,Rh,"treeshake","configuration-options/#treeshake","false, true, ");return{annotations:n.annotations!==!1,correctVarValueBeforeDeclaration:n.correctVarValueBeforeDeclaration===!0,manualPureFunctions:n.manualPureFunctions??yn,moduleSideEffects:bg(n.moduleSideEffects),propertyReadSideEffects:n.propertyReadSideEffects==="always"?"always":n.propertyReadSideEffects!==!1,tryCatchDeoptimization:n.tryCatchDeoptimization!==!1,unknownGlobalSideEffects:n.unknownGlobalSideEffects!==!1}},bg=t=>{if(typeof t=="boolean")return()=>t;if(t==="no-external")return(n,e)=>!e;if(typeof t=="function")return(n,e)=>!!n.startsWith("\0")||t(n,e)!==!1;if(Array.isArray(t)){const n=new Set(t);return e=>n.has(e)}return t&&L(bn("treeshake.moduleSideEffects","configuration-options/#treeshake-modulesideeffects",'please use one of false, "no-external", a function or an array')),()=>!0},xg=/[\u0000-\u001F"#$&*+,:;<=>?[\]^`{|}\u007F]/g,vg=/^[a-z]:/i;function $g(t){const n=vg.exec(t),e=n?n[0]:"";return e+t.slice(e.length).replace(xg,"_")}const kg=(t,n,e)=>{const{file:r}=t;if(typeof r=="string"){if(n)return L(bn("output.file",Ae,'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));if(!Array.isArray(e.input))return L(bn("output.file",Ae,'you must set "output.dir" instead of "output.file" when providing named inputs'))}return r},Cg=t=>{const n=t.format;switch(n){case void 0:case"es":case"esm":case"module":return"es";case"cjs":case"commonjs":return"cjs";case"system":case"systemjs":return"system";case"amd":case"iife":case"umd":return n;default:return L(bn("output.format",Fs,'Valid values are "amd", "cjs", "system", "es", "iife" or "umd"',n))}},Eg=(t,n)=>{const e=(t.inlineDynamicImports??n.inlineDynamicImports)||!1,{input:r}=n;return e&&(Array.isArray(r)?r:Object.keys(r)).length>1?L(bn("output.inlineDynamicImports",Ra,'multiple inputs are not supported when "output.inlineDynamicImports" is true')):e},Ag=(t,n,e)=>{const r=(t.preserveModules??e.preserveModules)||!1;if(r){if(n)return L(bn("output.inlineDynamicImports",Ra,'this option is not supported for "output.preserveModules"'));if(e.preserveEntrySignatures===!1)return L(bn("preserveEntrySignatures","configuration-options/#preserveentrysignatures",'setting this option to false is not supported for "output.preserveModules"'))}return r},wg=(t,n)=>{const e=t.preferConst;return e!=null&&Gt('The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.',"configuration-options/#output-generatedcode-constbindings",!0,n),!!e},Sg=t=>{const{preserveModulesRoot:n}=t;if(n!=null)return Hn(n)},Bg=t=>{const n={autoId:!1,basePath:"",define:"define",forceJsExtensionForImports:!1,...t.amd};return(n.autoId||n.basePath)&&n.id?L(bn("output.amd.id",Gs,'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"')):n.basePath&&!n.autoId?L(bn("output.amd.basePath","configuration-options/#output-amd-basepath",'this option only works with "output.amd.autoId"')):n.autoId?{autoId:!0,basePath:n.basePath,define:n.define,forceJsExtensionForImports:n.forceJsExtensionForImports}:{autoId:!1,define:n.define,forceJsExtensionForImports:n.forceJsExtensionForImports,id:n.id}},fa=(t,n)=>{const e=t[n];return typeof e=="function"?e:()=>e||""},Ig=(t,n)=>{const{dir:e}=t;return typeof e=="string"&&typeof n=="string"?L(bn("output.dir",Ae,'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks')):e},jg=(t,n,e)=>{const r=t.dynamicImportFunction;return r&&(Gt('The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.',"plugin-development/#renderdynamicimport",!0,n),e!=="es"&&n.onLog(V,bn("output.dynamicImportFunction","configuration-options/#output-dynamicimportfunction",'this option is ignored for formats other than "es"'))),r},Mg=(t,n)=>{const e=t.entryFileNames;return e==null&&n.add("entryFileNames"),e??"[name].js"};function Lg(t,n){const e=t.experimentalDeepDynamicChunkOptimization;return e!=null&&Gt('The "output.experimentalDeepDynamicChunkOptimization" option is deprecated as Rollup always runs the full chunking algorithm now. The option should be removed.',Wm,!0,n),e||!1}function Tg(t,n){const e=t.exports;if(e==null)n.add("exports");else if(!["default","named","none","auto"].includes(e))return L({code:Rs,message:`"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${e}".`,url:En(Ua)});return e||"auto"}const Ng=(t,n)=>{const e=Nc(t.generatedCode,Vh,"output.generatedCode","configuration-options/#output-generatedcode","");return{arrowFunctions:e.arrowFunctions===!0,constBindings:e.constBindings===!0||n,objectShorthand:e.objectShorthand===!0,reservedNamesAsProps:e.reservedNamesAsProps!==!1,symbols:e.symbols===!0}},Dg=(t,n)=>{if(n)return"";const e=t.indent;return e===!1?"":e??!0},Wc=new Set(["compat","auto","esModule","default","defaultOnly"]),Og=t=>{const n=t.interop;if(typeof n=="function"){const e=Object.create(null);let r=null;return a=>a===null?r||us(r=n(a)):a in e?e[a]:us(e[a]=n(a))}return n===void 0?()=>"default":()=>us(n)},us=t=>Wc.has(t)?t:L(bn("output.interop",Va,`use one of ${Array.from(Wc,n=>JSON.stringify(n)).join(", ")}`,t)),zg=(t,n,e,r)=>{const a=t.manualChunks||r.manualChunks;if(a){if(n)return L(bn("output.manualChunks",qa,'this option is not supported for "output.inlineDynamicImports"'));if(e)return L(bn("output.manualChunks",qa,'this option is not supported for "output.preserveModules"'))}return a||{}},Gg=(t,n,e)=>t.minifyInternalExports??(e||n==="es"||n==="system"),Fg=(t,n,e)=>{const r=t.namespaceToStringTag;return r!=null?(Gt('The "output.namespaceToStringTag" option is deprecated. Use the "output.generatedCode.symbols" option instead.',"configuration-options/#output-generatedcode-symbols",!0,e),r):n.symbols||!1},Pg=t=>{const{sourcemapBaseUrl:n}=t;if(n)return function(r){try{new URL(r)}catch{return!1}return!0}(n)?(e=n).endsWith("/")?e:e+"/":L(bn("output.sourcemapBaseUrl","configuration-options/#output-sourcemapbaseurl",`must be a valid URL, received ${JSON.stringify(n)}`));var e};function Ug(t){return async function(n,e){const{options:r,unsetOptions:a}=await async function(l,c){if(!l)throw new Error("You must supply an options object to rollup");const u=await async function(h,b){const p=_s("options",await ua(h.plugins)),g=h.logLevel||Ot,x=Vc(p,jc(h,g),b,g);for(const k of p){const{name:y,options:v}=k,$="handler"in v?v.handler:v,w=await $.call({debug:pe(Ee,"PLUGIN_LOG",x,y,g),error:S=>L(we(_t(S),y,{hook:"onLog"})),info:pe(Ot,"PLUGIN_LOG",x,y,g),meta:{rollupVersion:Ia,watchMode:b},warn:pe(V,"PLUGIN_WARNING",x,y,g)},h);w&&(h=w)}return h}(l,c),{options:f,unsetOptions:m}=await async function(h,b){const p=new Set,g=h.context??"undefined",x=await ua(h.plugins),k=h.logLevel||Ot,y=Vc(x,jc(h,k),b,k),v=h.strictDeprecations||!1,$=pg(h,y,v),w={acorn:lg(h),acornInjectPlugins:cg(h),cache:_g(h),context:g,experimentalCacheExpiry:h.experimentalCacheExpiry??10,experimentalLogSideEffects:h.experimentalLogSideEffects||!1,external:ug(h.external),inlineDynamicImports:fg(h,y,v),input:mg(h),logLevel:k,makeAbsoluteExternalsRelative:h.makeAbsoluteExternalsRelative??"ifRelativeSource",manualChunks:dg(h,y,v),maxParallelFileOps:$,maxParallelFileReads:$,moduleContext:hg(h,g),onLog:y,onwarn:S=>y(V,S),perf:h.perf||!1,plugins:x,preserveEntrySignatures:h.preserveEntrySignatures??"exports-only",preserveModules:gg(h,y,v),preserveSymlinks:h.preserveSymlinks||!1,shimMissingExports:h.shimMissingExports||!1,strictDeprecations:v,treeshake:yg(h)};return Tc(h,[...Object.keys(w),"watch"],"input options",y,/^(output)$/),{options:w,unsetOptions:p}}(u,c);return Kc(f.plugins,is),{options:f,unsetOptions:m}}(n,e!==null);(function(l){l.perf?(We=new Map,$n=hp,xn=gp,l.plugins=l.plugins.map(xp)):($n=rt,xn=rt)})(r);const i=new ag(r,e),s=n.cache!==!1;n.cache&&(r.cache=void 0,n.cache=void 0),$n("BUILD",1),await Rc(i.pluginDriver,async()=>{try{$n("initialize",2),await i.pluginDriver.hookParallel("buildStart",[r]),xn("initialize",2),await i.build()}catch(l){const c=Object.keys(i.watchFiles);throw c.length>0&&(l.watchFiles=c),await i.pluginDriver.hookParallel("buildEnd",[l]),await i.pluginDriver.hookParallel("closeBundle",[]),l}await i.pluginDriver.hookParallel("buildEnd",[])}),xn("BUILD",1);const o={cache:s?i.getCache():void 0,async close(){o.closed||(o.closed=!0,await i.pluginDriver.hookParallel("closeBundle",[]))},closed:!1,generate:async l=>o.closed?L(Js()):Hc(!1,r,a,l,i),watchFiles:Object.keys(i.watchFiles),write:async l=>o.closed?L(Js()):Hc(!0,r,a,l,i)};return r.perf&&(o.getTimings=yp),o}(t,null)}function Kc(t,n){for(const[e,r]of t.entries())r.name||(r.name=`${n}${e+1}`)}async function Hc(t,n,e,r,a){const{options:i,outputPluginDriver:s,unsetOptions:o}=await async function(l,c,u,f){if(!l)throw new Error("You must supply an options object");const m=await ua(l.plugins);Kc(m,ss);const h=c.createOutputPluginDriver(m);return{...await Rg(u,f,l,h),outputPluginDriver:h}}(r,a.pluginDriver,n,e);return Rc(0,async()=>{const l=new hh(i,o,n,s,a),c=await l.generate(t);if(t){if($n("WRITE",1),!i.dir&&!i.file)return L({code:dd,message:'You must specify "output.file" or "output.dir" for the build.',url:En(Ae)});await Promise.all(Object.values(c).map(f=>a.fileOperationQueue.run(()=>async function(m,h){const b=Hn(h.dir||Tt(h.file),m.fileName);return await Oh(Tt(b),{recursive:!0}),Gh(b,m.type==="asset"?m.source:m.code)}(f,i)))),await s.hookParallel("writeBundle",[i,c]),xn("WRITE",1)}return u=c,{output:Object.values(u).filter(f=>Object.keys(f).length>0).sort((f,m)=>Yc(f)-Yc(m))};var u})}function Rg(t,n,e,r){return async function(a,i,s){const o=new Set(s),l=a.compact||!1,c=Cg(a),u=Eg(a,i),f=Ag(a,u,i),m=kg(a,f,i),h=wg(a,i),b=Ng(a,h),p={amd:Bg(a),assetFileNames:a.assetFileNames??"assets/[name]-[hash][extname]",banner:fa(a,"banner"),chunkFileNames:a.chunkFileNames??"[name]-[hash].js",compact:l,dir:Ig(a,m),dynamicImportFunction:jg(a,i,c),dynamicImportInCjs:a.dynamicImportInCjs??!0,entryFileNames:Mg(a,o),esModule:a.esModule??"if-default-prop",experimentalDeepDynamicChunkOptimization:Lg(a,i),experimentalMinChunkSize:a.experimentalMinChunkSize??1,exports:Tg(a,o),extend:a.extend||!1,externalImportAssertions:a.externalImportAssertions??!0,externalLiveBindings:a.externalLiveBindings??!0,file:m,footer:fa(a,"footer"),format:c,freeze:a.freeze??!0,generatedCode:b,globals:a.globals||{},hoistTransitiveImports:a.hoistTransitiveImports??!0,indent:Dg(a,l),inlineDynamicImports:u,interop:Og(a),intro:fa(a,"intro"),manualChunks:zg(a,u,f,i),minifyInternalExports:Gg(a,c,l),name:a.name,namespaceToStringTag:Fg(a,b,i),noConflict:a.noConflict||!1,outro:fa(a,"outro"),paths:a.paths||{},plugins:await ua(a.plugins),preferConst:h,preserveModules:f,preserveModulesRoot:Sg(a),sanitizeFileName:typeof a.sanitizeFileName=="function"?a.sanitizeFileName:a.sanitizeFileName===!1?g=>g:$g,sourcemap:a.sourcemap||!1,sourcemapBaseUrl:Pg(a),sourcemapExcludeSources:a.sourcemapExcludeSources||!1,sourcemapFile:a.sourcemapFile,sourcemapIgnoreList:typeof a.sourcemapIgnoreList=="function"?a.sourcemapIgnoreList:a.sourcemapIgnoreList===!1?()=>!1:g=>g.includes("node_modules"),sourcemapPathTransform:a.sourcemapPathTransform,strict:a.strict??!0,systemNullSetters:a.systemNullSetters??!0,validate:a.validate||!1};return Tc(a,Object.keys(p),"output options",i.onLog),{options:p,unsetOptions:o}}(r.hookReduceArg0Sync("outputOptions",[e],(a,i)=>i||a,a=>{const i=()=>a.error({code:nd,message:'Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.'});return{...a,emitFile:i,setAssetSource:i}}),t,n)}var er;function Yc(t){return t.type==="asset"?er.ASSET:t.isEntry?er.ENTRY_CHUNK:er.SECONDARY_CHUNK}(function(t){t[t.ENTRY_CHUNK=0]="ENTRY_CHUNK",t[t.SECONDARY_CHUNK=1]="SECONDARY_CHUNK",t[t.ASSET=2]="ASSET"})(er||(er={}));const Jc=["log","warn","info","debug","error"];console.original={};let ma=[],da=!1,Vg=(t,n)=>{const e=n.map(r=>typeof r=="object"?r instanceof Error?JSON.stringify(r,Object.getOwnPropertyNames(r)):JSON.stringify(r):r);ma.push({kind:t,args:e,date:Date.now()})},qg=(t=!1)=>{const n={apply:(e,r,a)=>{if(Vg(e.name,a),e.bind(r),t)return e(...a)}};Jc.forEach(e=>{da||(console.original[e]=console[e]),console[e]=new Proxy(console[e],n)}),da=!0},Xg=()=>{da&&Jc.forEach(t=>{console[t]=console.original[t]}),da=!1},Wg=(t=!1)=>{ma=[],qg(t)},Kg=()=>{Xg()},Zc=()=>{ma=[]},Hg=()=>ma;const rr={},Qc=Object.assign({"../../_build/default/playground/output/node_modules/melange.__private__.melange_mini_stdlib/melange_mini_stdlib.js":e_,"../../_build/default/playground/output/node_modules/melange.belt/belt.js":r_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Array.js":a_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Float.js":i_,"../../_build/default/playground/output/node_modules/melange.belt/belt_HashMap.js":s_,"../../_build/default/playground/output/node_modules/melange.belt/belt_HashMapInt.js":o_,"../../_build/default/playground/output/node_modules/melange.belt/belt_HashMapString.js":l_,"../../_build/default/playground/output/node_modules/melange.belt/belt_HashSet.js":c_,"../../_build/default/playground/output/node_modules/melange.belt/belt_HashSetInt.js":__,"../../_build/default/playground/output/node_modules/melange.belt/belt_HashSetString.js":u_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Id.js":f_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Int.js":m_,"../../_build/default/playground/output/node_modules/melange.belt/belt_List.js":d_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Map.js":p_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MapDict.js":h_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MapInt.js":g_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MapString.js":y_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableMap.js":b_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableMapInt.js":x_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableMapString.js":v_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableQueue.js":$_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableSet.js":k_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableSetInt.js":C_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableSetString.js":E_,"../../_build/default/playground/output/node_modules/melange.belt/belt_MutableStack.js":A_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Option.js":w_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Range.js":S_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Result.js":B_,"../../_build/default/playground/output/node_modules/melange.belt/belt_Set.js":I_,"../../_build/default/playground/output/node_modules/melange.belt/belt_SetDict.js":j_,"../../_build/default/playground/output/node_modules/melange.belt/belt_SetInt.js":M_,"../../_build/default/playground/output/node_modules/melange.belt/belt_SetString.js":L_,"../../_build/default/playground/output/node_modules/melange.belt/belt_SortArray.js":T_,"../../_build/default/playground/output/node_modules/melange.belt/belt_SortArrayInt.js":N_,"../../_build/default/playground/output/node_modules/melange.belt/belt_SortArrayString.js":D_,"../../_build/default/playground/output/node_modules/melange.belt/belt__.js":O_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalAVLset.js":z_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalAVLtree.js":G_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalBuckets.js":F_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalBucketsType.js":P_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalMapInt.js":U_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalMapString.js":R_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalSetBuckets.js":V_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalSetInt.js":q_,"../../_build/default/playground/output/node_modules/melange.belt/belt_internalSetString.js":X_,"../../_build/default/playground/output/node_modules/melange.dom/dom.js":W_,"../../_build/default/playground/output/node_modules/melange.dom/dom__.js":K_,"../../_build/default/playground/output/node_modules/melange.dom/dom_storage.js":H_,"../../_build/default/playground/output/node_modules/melange.js/caml.js":Y_,"../../_build/default/playground/output/node_modules/melange.js/caml_array.js":J_,"../../_build/default/playground/output/node_modules/melange.js/caml_array_extern.js":Z_,"../../_build/default/playground/output/node_modules/melange.js/caml_bytes.js":Q_,"../../_build/default/playground/output/node_modules/melange.js/caml_exceptions.js":nu,"../../_build/default/playground/output/node_modules/melange.js/caml_external_polyfill.js":tu,"../../_build/default/playground/output/node_modules/melange.js/caml_float.js":eu,"../../_build/default/playground/output/node_modules/melange.js/caml_float_extern.js":ru,"../../_build/default/playground/output/node_modules/melange.js/caml_format.js":au,"../../_build/default/playground/output/node_modules/melange.js/caml_gc.js":iu,"../../_build/default/playground/output/node_modules/melange.js/caml_hash.js":su,"../../_build/default/playground/output/node_modules/melange.js/caml_hash_primitive.js":ou,"../../_build/default/playground/output/node_modules/melange.js/caml_int32.js":lu,"../../_build/default/playground/output/node_modules/melange.js/caml_int32_extern.js":cu,"../../_build/default/playground/output/node_modules/melange.js/caml_int64.js":_u,"../../_build/default/playground/output/node_modules/melange.js/caml_int64_extern.js":uu,"../../_build/default/playground/output/node_modules/melange.js/caml_io.js":fu,"../../_build/default/playground/output/node_modules/melange.js/caml_js_exceptions.js":mu,"../../_build/default/playground/output/node_modules/melange.js/caml_lexer.js":du,"../../_build/default/playground/output/node_modules/melange.js/caml_md5.js":pu,"../../_build/default/playground/output/node_modules/melange.js/caml_module.js":hu,"../../_build/default/playground/output/node_modules/melange.js/caml_nativeint_extern.js":gu,"../../_build/default/playground/output/node_modules/melange.js/caml_obj.js":yu,"../../_build/default/playground/output/node_modules/melange.js/caml_oo.js":bu,"../../_build/default/playground/output/node_modules/melange.js/caml_oo_curry.js":xu,"../../_build/default/playground/output/node_modules/melange.js/caml_option.js":vu,"../../_build/default/playground/output/node_modules/melange.js/caml_parser.js":$u,"../../_build/default/playground/output/node_modules/melange.js/caml_splice_call.js":ku,"../../_build/default/playground/output/node_modules/melange.js/caml_string.js":Cu,"../../_build/default/playground/output/node_modules/melange.js/caml_string_extern.js":Eu,"../../_build/default/playground/output/node_modules/melange.js/caml_sys.js":Au,"../../_build/default/playground/output/node_modules/melange.js/caml_undefined_extern.js":wu,"../../_build/default/playground/output/node_modules/melange.js/curry.js":Su,"../../_build/default/playground/output/node_modules/melange.js/js.js":Bu,"../../_build/default/playground/output/node_modules/melange.js/js_OO.js":Iu,"../../_build/default/playground/output/node_modules/melange.js/js_array.js":ju,"../../_build/default/playground/output/node_modules/melange.js/js_bigint.js":Mu,"../../_build/default/playground/output/node_modules/melange.js/js_blob.js":Lu,"../../_build/default/playground/output/node_modules/melange.js/js_console.js":Tu,"../../_build/default/playground/output/node_modules/melange.js/js_date.js":Nu,"../../_build/default/playground/output/node_modules/melange.js/js_dict.js":Du,"../../_build/default/playground/output/node_modules/melange.js/js_exn.js":Ou,"../../_build/default/playground/output/node_modules/melange.js/js_file.js":zu,"../../_build/default/playground/output/node_modules/melange.js/js_float.js":Gu,"../../_build/default/playground/output/node_modules/melange.js/js_formData.js":Fu,"../../_build/default/playground/output/node_modules/melange.js/js_global.js":Pu,"../../_build/default/playground/output/node_modules/melange.js/js_int.js":Uu,"../../_build/default/playground/output/node_modules/melange.js/js_iterator.js":Ru,"../../_build/default/playground/output/node_modules/melange.js/js_json.js":Vu,"../../_build/default/playground/output/node_modules/melange.js/js_map.js":qu,"../../_build/default/playground/output/node_modules/melange.js/js_mapper_runtime.js":Xu,"../../_build/default/playground/output/node_modules/melange.js/js_math.js":Wu,"../../_build/default/playground/output/node_modules/melange.js/js_null.js":Ku,"../../_build/default/playground/output/node_modules/melange.js/js_nullable.js":Hu,"../../_build/default/playground/output/node_modules/melange.js/js_obj.js":Yu,"../../_build/default/playground/output/node_modules/melange.js/js_promise.js":Ju,"../../_build/default/playground/output/node_modules/melange.js/js_re.js":Zu,"../../_build/default/playground/output/node_modules/melange.js/js_set.js":Qu,"../../_build/default/playground/output/node_modules/melange.js/js_string.js":nf,"../../_build/default/playground/output/node_modules/melange.js/js_typed_array.js":tf,"../../_build/default/playground/output/node_modules/melange.js/js_types.js":ef,"../../_build/default/playground/output/node_modules/melange.js/js_undefined.js":rf,"../../_build/default/playground/output/node_modules/melange.js/js_weakmap.js":af,"../../_build/default/playground/output/node_modules/melange.js/js_weakset.js":sf,"../../_build/default/playground/output/node_modules/melange/arg.js":of,"../../_build/default/playground/output/node_modules/melange/array.js":lf,"../../_build/default/playground/output/node_modules/melange/arrayLabels.js":cf,"../../_build/default/playground/output/node_modules/melange/atomic.js":_f,"../../_build/default/playground/output/node_modules/melange/bool.js":uf,"../../_build/default/playground/output/node_modules/melange/buffer.js":ff,"../../_build/default/playground/output/node_modules/melange/bytes.js":mf,"../../_build/default/playground/output/node_modules/melange/bytesLabels.js":df,"../../_build/default/playground/output/node_modules/melange/callback.js":pf,"../../_build/default/playground/output/node_modules/melange/camlinternalAtomic.js":hf,"../../_build/default/playground/output/node_modules/melange/camlinternalFormat.js":gf,"../../_build/default/playground/output/node_modules/melange/camlinternalFormatBasics.js":yf,"../../_build/default/playground/output/node_modules/melange/camlinternalLazy.js":bf,"../../_build/default/playground/output/node_modules/melange/camlinternalMod.js":xf,"../../_build/default/playground/output/node_modules/melange/camlinternalOO.js":vf,"../../_build/default/playground/output/node_modules/melange/char.js":$f,"../../_build/default/playground/output/node_modules/melange/complex.js":kf,"../../_build/default/playground/output/node_modules/melange/digest.js":Cf,"../../_build/default/playground/output/node_modules/melange/domain.js":Ef,"../../_build/default/playground/output/node_modules/melange/dynarray.js":Af,"../../_build/default/playground/output/node_modules/melange/either.js":wf,"../../_build/default/playground/output/node_modules/melange/ephemeron.js":Sf,"../../_build/default/playground/output/node_modules/melange/filename.js":Bf,"../../_build/default/playground/output/node_modules/melange/float.js":If,"../../_build/default/playground/output/node_modules/melange/format.js":jf,"../../_build/default/playground/output/node_modules/melange/fun.js":Mf,"../../_build/default/playground/output/node_modules/melange/gc.js":Lf,"../../_build/default/playground/output/node_modules/melange/hashtbl.js":Tf,"../../_build/default/playground/output/node_modules/melange/in_channel.js":Nf,"../../_build/default/playground/output/node_modules/melange/int.js":Df,"../../_build/default/playground/output/node_modules/melange/int32.js":Of,"../../_build/default/playground/output/node_modules/melange/int64.js":zf,"../../_build/default/playground/output/node_modules/melange/lazy.js":Gf,"../../_build/default/playground/output/node_modules/melange/lexing.js":Ff,"../../_build/default/playground/output/node_modules/melange/list.js":Pf,"../../_build/default/playground/output/node_modules/melange/listLabels.js":Uf,"../../_build/default/playground/output/node_modules/melange/map.js":Rf,"../../_build/default/playground/output/node_modules/melange/marshal.js":Vf,"../../_build/default/playground/output/node_modules/melange/moreLabels.js":qf,"../../_build/default/playground/output/node_modules/melange/mutex.js":Xf,"../../_build/default/playground/output/node_modules/melange/obj.js":Wf,"../../_build/default/playground/output/node_modules/melange/oo.js":Kf,"../../_build/default/playground/output/node_modules/melange/option.js":Hf,"../../_build/default/playground/output/node_modules/melange/out_channel.js":Yf,"../../_build/default/playground/output/node_modules/melange/parsing.js":Jf,"../../_build/default/playground/output/node_modules/melange/printexc.js":Zf,"../../_build/default/playground/output/node_modules/melange/printf.js":Qf,"../../_build/default/playground/output/node_modules/melange/queue.js":nm,"../../_build/default/playground/output/node_modules/melange/random.js":tm,"../../_build/default/playground/output/node_modules/melange/result.js":em,"../../_build/default/playground/output/node_modules/melange/scanf.js":rm,"../../_build/default/playground/output/node_modules/melange/seq.js":am,"../../_build/default/playground/output/node_modules/melange/set.js":im,"../../_build/default/playground/output/node_modules/melange/stack.js":sm,"../../_build/default/playground/output/node_modules/melange/stdLabels.js":om,"../../_build/default/playground/output/node_modules/melange/std_exit.js":lm,"../../_build/default/playground/output/node_modules/melange/stdlib.js":cm,"../../_build/default/playground/output/node_modules/melange/string.js":_m,"../../_build/default/playground/output/node_modules/melange/stringLabels.js":um,"../../_build/default/playground/output/node_modules/melange/sys.js":fm,"../../_build/default/playground/output/node_modules/melange/type.js":mm,"../../_build/default/playground/output/node_modules/melange/uchar.js":dm,"../../_build/default/playground/output/node_modules/melange/unit.js":pm,"../../_build/default/playground/output/node_modules/melange/weak.js":hm});Object.keys(Qc).forEach(t=>{const n=Qc[t];rr[t.replace("../../_build/default/playground/output/node_modules/","")]=n});const Yg=eval,pa=new Map;async function Jg(t){if(pa.has(t))return pa.get(t);const n=fetch(t).then(async e=>{if(!e.ok)throw new Error(await e.text());return{url:e.url,body:await e.text()}}).catch(e=>{throw pa.delete(t),e});return pa.set(t,n),n}Bm("bundle",async(t,n)=>{switch(n.type){case"clear.logs":Zc(),t.logCaptures=[];break;case"bundle":const e=n.code;if(!e)return;Wg(),Zc(),rr["main.js"]=e;const r=await Ug({input:"main.js",plugins:[{name:"loader",resolveId(i,s){var o=i;return i.substring(0,2)=="./"&&s&&(o=s.substring(0,s.lastIndexOf("/")+1)+o.substring(2,i.length)),rr.hasOwnProperty(o)?o:i[0]=="/"?"https://esm.sh"+i:i.substring(0,8)!="https://"?"https://esm.sh/"+i:i},async load(i){if(rr.hasOwnProperty(i))return rr[i];{const s=await Jg(i);return s==null?void 0:s.body}}}]}),{output:a}=await r.generate({format:"iife",name:"MelangeApp"});try{e.indexOf("react/jsx-runtime")>=0||e.indexOf("react-dom/client")>=0?t.bundledCode=a[0].code:(t.bundledCode=void 0,Yg(a[0].code))}catch(i){console.error("Error while evaluating JavaScript code: "+i.message)}t.logCaptures=Hg(),Kg();break;default:throw new Error}})})();
