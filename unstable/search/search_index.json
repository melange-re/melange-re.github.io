{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Melange OCaml for JavaScript developers Melange is a backend for the OCaml compiler that emits JavaScript. Melange strives to provide the best integration with both the OCaml and JavaScript ecosystems. To know more about it start by reading the introductory tutorial , then check the Learn section for more information. Features A Solid Type System Melange leverages OCaml's powerful type system to catch more bugs at compile time. Large, complex codebases become easy to maintain and refactor. First-Class Editor and Tooling Melange fully utilizes the power of the OCaml Platform to provide integrations with editors such as VSCode, Vim, or Emacs, with features like type inspection, autocomplete, and more. It also has first-class integration with Dune , OCaml's most used build system. JavaScript Integration Whether you want to use existing JavaScript packages from NPM, or use your own JavaScript libraries in your projects, Melange has you covered. With an expressive bindings language, and an ergonomic compilation model, Melange can help you build robust applications that leverage functionality from the JavaScript ecosystem. Stable and Industry Backed Melange builds on top of decades of type system research, compiler engineering and tooling development to provide a polished developer experience. Companies like Ahrefs use Melange daily to deploy web applications for their users.","title":"Home"},{"location":"#melange","text":"OCaml for JavaScript developers Melange is a backend for the OCaml compiler that emits JavaScript. Melange strives to provide the best integration with both the OCaml and JavaScript ecosystems. To know more about it start by reading the introductory tutorial , then check the Learn section for more information.","title":"Melange"},{"location":"api/","text":"API Melange exposes three libraries: A standard library, which mostly replicates that of OCaml for compatibility: the Stdlib library Stdlib library Bindings to several browser and Node JavaScript APIs in the Js library Js library Data structures and collection types in the Belt library Belt library Using one or the other will depend on your application requirements, how much integration you need with existing JavaScript libraries, or other specific characteristics of your project. In any case, the three of them can be used in the same project without issues.","title":"API"},{"location":"api/#api","text":"Melange exposes three libraries: A standard library, which mostly replicates that of OCaml for compatibility: the Stdlib library Stdlib library Bindings to several browser and Node JavaScript APIs in the Js library Js library Data structures and collection types in the Belt library Belt library Using one or the other will depend on your application requirements, how much integration you need with existing JavaScript libraries, or other specific characteristics of your project. In any case, the three of them can be used in the same project without issues.","title":"API"},{"location":"build-system/","text":"Build system Melange is deeply integrated with Dune , the most widely used build system for OCaml. This integration enables developers to create a single project with both OCaml native executables and frontend applications that are built with Melange, and even share code between both platforms in an easy manner. Dune orchestrates and plans the work needed to compile a project, copies files when needed, and prepares everything so that Melange takes OCaml source files and convert them into JavaScript code. Let\u2019s now dive into the Melange compilation model and go through a brief guide on how to work with Dune in Melange projects. Compilation model Melange compiles a single source file to a single JavaScript module. This compilation model simplifies debugging the produced JavaScript code and allows to import assets like CSS files and fonts in the same way as one would do in a JavaScript project. It also facilitates the integration of Melange with JavaScript module bundlers such as Webpack , or other alternatives . As an example of integration with Webpack, you can refer to the Melange opam template . To create a repository based on this template, follow this link . How is Melange integrated into Dune? Dune is an OCaml build system that Melange projects can use to specify libraries and applications. It\u2019s optimized for monorepos and makes project maintenance easier. This section provides an overview of Dune\u2019s features and explains how to use it to build Melange applications. Features Dune is designed with OCaml in mind, which makes it an ideal tool for Melange developers. It provides several benefits, including: Easy specification of libraries and executables. Optimized for monorepos: no need for npm link or similar solutions. Easy project maintenance, as one can rearrange folders without updating the paths to libraries. Hygiene is maintained in Dune by building out of source: all compilation artifacts are placed in a separate _build folder. Users can optionally copy them back to the source tree . Dune provides a variety of additional features including cram tests , integration with Odoc , Melange, Js_of_ocaml , watch mode , Merlin/LSP integration for editor support, cross compilation , and generation of opam files . Creating a new project To understand how to use Dune, let\u2019s create a small Melange application. First of all, create an opam switch, as shown in the package management section : opam switch create . 4.14.1 --deps-only Install the latest versions of Dune and Melange in the switch: opam update opam install dune melange As we will be using Reason syntax, let\u2019s install the `reason` package too: opam install reason Create a file named dune-project . This file will tell Dune a few things about our project configuration: (lang dune 3.8) (using melange 0.1) The first line (lang dune 3.8) tells Dune which version of the \"Dune language\" (the language used in dune files) we want to use. Melange support in Dune is only available from version 3.8. The second line (using melange 0.1) tells Dune we want to use the Melange extension of the Dune language . Adding a library Next, create a folder lib , and a dune file inside. Put the following content inside the dune file: (library (name lib) (modes melange)) Create a file lib.ml in the same folder: Create a file lib.re in the same folder: let name = \"Jane\" let name = \"Jane\"; The top level configuration entries \u2014like the library one that appears in the dune file\u2014 are referred to as stanzas , and the inner ones \u2014like name and modes \u2014 are referred to as fields of the stanza. All stanzas are well covered in the Dune documentation site, where we can find the reference for the library stanza . Dune is designed to minimize the need for configuration changes when modifying the project folder structure. For example, you can move the lib folder to a different location within the project, and all build commands will continue to work without requiring any updates to any dune file. This feature proves to be quite convenient. Entry points with melange.emit Libraries are useful to encapsulate behavior and logical components of our application , but they won\u2019t produce any JavaScript artifacts on their own. To generate JavaScript code, we need to define an entry point of our application. In the root folder, create another dune file: (melange.emit (target app) (libraries lib)) And an app.ml file: And an app.re file: let () = Js.log Lib.name let () = Js.log(Lib.name); The melange.emit stanza tells Dune to generate JavaScript files from a set of libraries and modules. In-depth documentation about this stanza can be found in the Dune docs . The file structure of the app should look something like this: project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 lib.ml \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u2514\u2500\u2500 app.ml project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 lib.re \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u2514\u2500\u2500 app.re Building the project We can build the project now, which will produce the JavaScript code from our sources using the Melange compiler: $ dune build @melange This command tells dune to build all the targets that have an alias melange attached to them. Aliases are build targets that don\u2019t produce any file and have configurable dependencies. By default, all the targets in a melange.emit stanza and the libraries it depends on are attached to the melange alias. We can define explicit aliases though, as we will see below. If everything went well, we should be able to run the resulting JavaScript with Node.js. As we mentioned above while going through its features, Dune places all artifacts inside the _build folder to not pollute any source folders. So we will point Node to the script placed in that folder, to see the expected output: $ node _build/default/app/app.js Jane JavaScript artifacts layout In the command above we had to look for the app.js file inside an app folder, but we don\u2019t have any such folder in our sources. This folder is the one declared in the target field of the melange.emit stanza, which Dune will use to know where to place the generated JavaScript artifacts. As a more complex example, consider the following setup: project_name/ \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 foo.ml \u2514\u2500\u2500 emit \u2514\u2500\u2500 dune project_name/ \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 foo.re \u2514\u2500\u2500 emit \u2514\u2500\u2500 dune With emit/dune being: (melange.emit (target app) (libraries lib)) And lib/dune : (library (name lib) (modes melange)) Then, the JavaScript artifacts for `foo.ml` will be placed under: Then, the JavaScript artifacts for `foo.re` will be placed under: _build/default/emit/app/lib/foo.js More generically: For a melange.emit stanza defined in a dune file located in the relative workspace path $melange-emit-folder Which includes a target field named $target , like (target $target) For a source file called $name.ml $name.re , placed in the relative workspace path $path-to-source-file The path to the generated JavaScript file from $name.ml $name.re will be: _build/default/$melange-emit-folder/$target/$path-to-source-file/$name.js Guidelines for melange.emit The following recommendations around melange.emit have been tested within large industrial projects, and have proven to be helpful guidelines to deal with complexity, maintenance and build performance. To simplify access to the generated JavaScript files from tools like Webpack, it is recommended to place the dune files containing the melange.emit stanzas in the project\u2019s root folder. This ensures that the generated JavaScript files are directly placed under the _build/default/$target path. To minimize the risk of inadvertent increases in bundle size, it is advisable to reduce the number of melange.emit stanzas to a minimum, ideally just one. Having multiple melange.emit stanzas may result in multiple copies of JavaScript code generated from the same library. By consolidating the melange.emit stanzas, you can mitigate this issue and ensure more efficient bundle sizes. Using aliases The default melange alias is useful for prototyping or when working on small projects, but larger projects might define multiple entry points or melange.emit stanzas. In these cases, it is useful to have a way to build individual stanzas. To do so, one can define explicit aliases for each one of them by using the alias field. Let\u2019s define a custom alias my-app for our melange.emit stanza: (melange.emit (target app) (alias my-app) (libraries lib)) Now we can refer to this new alias: $ dune build @my-app Note that if we try to build again using the default melange alias, Dune will return an error, as there are no more targets attached to it. $ dune build @melange Error: Alias \"melange\" specified on the command line is empty. It is not defined in . or any of its descendants. Handling assets Sometimes we want to use CSS files, fonts, or other assets in our Melange projects. Due to the way Dune works, our assets will have to be copied to the _build folder and installed. To make this process as easy as possible, Dune provides a way to specify these dependencies, depending on the stanza: For library stanzas, a field melange.runtime_deps For melange.emit stanzas, a field runtime_deps Both fields are documented in the Melange page of the Dune documentation site. For the sake of learning how to work with assets in a Melange project, let\u2019s say that we want to read the string in Lib.name from a text file. We will combine the field melange.runtime_deps with some bindings to Node that Melange provides. Check the next section, \"Communicate with JavaScript\" , it you want to learn more about how bindings work. So, let\u2019s add a new file name.txt inside lib folder, that just contains the name Jane . Then, adapt the lib/dune file. We will need to add the melange.runtime_deps field, as well as a preprocessing field that will allow to use the bs.raw extension (more about these extensions in the \"Communicate with JavaScript\" section), in order to get the value of the __dirname environment variable: (library (name lib) (modes melange) (melange.runtime_deps name.txt) (preprocess (pps melange.ppx))) Finally, update lib/lib.ml to read from the recently added file: Finally, update lib/lib.re to read from the recently added file: let dir = [%mel.raw \"__dirname\"] let file = \"name.txt\" let name = Node.Fs.readFileSync (dir ^ \"/\" ^ file) `ascii let dir = [%mel.raw \"__dirname\"]; let file = \"name.txt\"; let name = Node.Fs.readFileSync(dir ++ \"/\" ++ file, `ascii); After these changes, once we build the project, we should still be able to run the application file with Node: $ dune build @my-app $ node _build/default/app/app.js Jane The same approach could be used to copy fonts, CSS or SVG files, or any other asset in your project. Dune offers great flexibility to specify dependencies. Another interesting feature are globs, that allow to simplify the configuration when depending on multiple files. For example: (melange.runtime_deps (glob_files styles/*.css) (glob_files images/*.png) (glob_files static/*.{pdf,txt})) See the dependency specification docs to learn more about it. With runtime dependencies, we have reached the end of this Dune guide for Melange developers. For further details about how Dune works and its integration with Melange, check the Dune documentation , and the Melange opam template . CommonJS or ES6 modules Melange produces JavaScript modules that export the functions they declare, and declare imports for the values and modules they depend on. By default, Melange will produce CommonJS modules, but it is possible to configure it to generate ES6 modules. Use the module_systems field in the melange.emit stanza to emit ES6 modules: (melange.emit (target app) (alias my-app) (libraries lib) (module_systems es6)) If no extension is specified, the resulting JavaScript files will use .js . You can specify a different extension with a pair (<module_system> <extension>) , e.g. (module_systems (es6 mjs)) . Multiple module systems can be used in the same field as long as their extensions are different. For example, (module_systems commonjs (es6 mjs)) will produce one set of JavaScript files using CommonJS and the .js extension, and another using ES6 and the .mjs extension.","title":"Build system"},{"location":"build-system/#build-system","text":"Melange is deeply integrated with Dune , the most widely used build system for OCaml. This integration enables developers to create a single project with both OCaml native executables and frontend applications that are built with Melange, and even share code between both platforms in an easy manner. Dune orchestrates and plans the work needed to compile a project, copies files when needed, and prepares everything so that Melange takes OCaml source files and convert them into JavaScript code. Let\u2019s now dive into the Melange compilation model and go through a brief guide on how to work with Dune in Melange projects.","title":"Build system"},{"location":"build-system/#compilation-model","text":"Melange compiles a single source file to a single JavaScript module. This compilation model simplifies debugging the produced JavaScript code and allows to import assets like CSS files and fonts in the same way as one would do in a JavaScript project. It also facilitates the integration of Melange with JavaScript module bundlers such as Webpack , or other alternatives . As an example of integration with Webpack, you can refer to the Melange opam template . To create a repository based on this template, follow this link .","title":"Compilation model"},{"location":"build-system/#how-is-melange-integrated-into-dune","text":"Dune is an OCaml build system that Melange projects can use to specify libraries and applications. It\u2019s optimized for monorepos and makes project maintenance easier. This section provides an overview of Dune\u2019s features and explains how to use it to build Melange applications.","title":"How is Melange integrated into Dune?"},{"location":"build-system/#features","text":"Dune is designed with OCaml in mind, which makes it an ideal tool for Melange developers. It provides several benefits, including: Easy specification of libraries and executables. Optimized for monorepos: no need for npm link or similar solutions. Easy project maintenance, as one can rearrange folders without updating the paths to libraries. Hygiene is maintained in Dune by building out of source: all compilation artifacts are placed in a separate _build folder. Users can optionally copy them back to the source tree . Dune provides a variety of additional features including cram tests , integration with Odoc , Melange, Js_of_ocaml , watch mode , Merlin/LSP integration for editor support, cross compilation , and generation of opam files .","title":"Features"},{"location":"build-system/#creating-a-new-project","text":"To understand how to use Dune, let\u2019s create a small Melange application. First of all, create an opam switch, as shown in the package management section : opam switch create . 4.14.1 --deps-only Install the latest versions of Dune and Melange in the switch: opam update opam install dune melange As we will be using Reason syntax, let\u2019s install the `reason` package too: opam install reason Create a file named dune-project . This file will tell Dune a few things about our project configuration: (lang dune 3.8) (using melange 0.1) The first line (lang dune 3.8) tells Dune which version of the \"Dune language\" (the language used in dune files) we want to use. Melange support in Dune is only available from version 3.8. The second line (using melange 0.1) tells Dune we want to use the Melange extension of the Dune language .","title":"Creating a new project"},{"location":"build-system/#adding-a-library","text":"Next, create a folder lib , and a dune file inside. Put the following content inside the dune file: (library (name lib) (modes melange)) Create a file lib.ml in the same folder: Create a file lib.re in the same folder: let name = \"Jane\" let name = \"Jane\"; The top level configuration entries \u2014like the library one that appears in the dune file\u2014 are referred to as stanzas , and the inner ones \u2014like name and modes \u2014 are referred to as fields of the stanza. All stanzas are well covered in the Dune documentation site, where we can find the reference for the library stanza . Dune is designed to minimize the need for configuration changes when modifying the project folder structure. For example, you can move the lib folder to a different location within the project, and all build commands will continue to work without requiring any updates to any dune file. This feature proves to be quite convenient.","title":"Adding a library"},{"location":"build-system/#entry-points-with-melangeemit","text":"Libraries are useful to encapsulate behavior and logical components of our application , but they won\u2019t produce any JavaScript artifacts on their own. To generate JavaScript code, we need to define an entry point of our application. In the root folder, create another dune file: (melange.emit (target app) (libraries lib)) And an app.ml file: And an app.re file: let () = Js.log Lib.name let () = Js.log(Lib.name); The melange.emit stanza tells Dune to generate JavaScript files from a set of libraries and modules. In-depth documentation about this stanza can be found in the Dune docs . The file structure of the app should look something like this: project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 lib.ml \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u2514\u2500\u2500 app.ml project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 lib.re \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u2514\u2500\u2500 app.re","title":"Entry points with melange.emit"},{"location":"build-system/#building-the-project","text":"We can build the project now, which will produce the JavaScript code from our sources using the Melange compiler: $ dune build @melange This command tells dune to build all the targets that have an alias melange attached to them. Aliases are build targets that don\u2019t produce any file and have configurable dependencies. By default, all the targets in a melange.emit stanza and the libraries it depends on are attached to the melange alias. We can define explicit aliases though, as we will see below. If everything went well, we should be able to run the resulting JavaScript with Node.js. As we mentioned above while going through its features, Dune places all artifacts inside the _build folder to not pollute any source folders. So we will point Node to the script placed in that folder, to see the expected output: $ node _build/default/app/app.js Jane","title":"Building the project"},{"location":"build-system/#javascript-artifacts-layout","text":"In the command above we had to look for the app.js file inside an app folder, but we don\u2019t have any such folder in our sources. This folder is the one declared in the target field of the melange.emit stanza, which Dune will use to know where to place the generated JavaScript artifacts. As a more complex example, consider the following setup: project_name/ \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 foo.ml \u2514\u2500\u2500 emit \u2514\u2500\u2500 dune project_name/ \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 foo.re \u2514\u2500\u2500 emit \u2514\u2500\u2500 dune With emit/dune being: (melange.emit (target app) (libraries lib)) And lib/dune : (library (name lib) (modes melange)) Then, the JavaScript artifacts for `foo.ml` will be placed under: Then, the JavaScript artifacts for `foo.re` will be placed under: _build/default/emit/app/lib/foo.js More generically: For a melange.emit stanza defined in a dune file located in the relative workspace path $melange-emit-folder Which includes a target field named $target , like (target $target) For a source file called $name.ml $name.re , placed in the relative workspace path $path-to-source-file The path to the generated JavaScript file from $name.ml $name.re will be: _build/default/$melange-emit-folder/$target/$path-to-source-file/$name.js","title":"JavaScript artifacts layout"},{"location":"build-system/#guidelines-for-melangeemit","text":"The following recommendations around melange.emit have been tested within large industrial projects, and have proven to be helpful guidelines to deal with complexity, maintenance and build performance. To simplify access to the generated JavaScript files from tools like Webpack, it is recommended to place the dune files containing the melange.emit stanzas in the project\u2019s root folder. This ensures that the generated JavaScript files are directly placed under the _build/default/$target path. To minimize the risk of inadvertent increases in bundle size, it is advisable to reduce the number of melange.emit stanzas to a minimum, ideally just one. Having multiple melange.emit stanzas may result in multiple copies of JavaScript code generated from the same library. By consolidating the melange.emit stanzas, you can mitigate this issue and ensure more efficient bundle sizes.","title":"Guidelines for melange.emit"},{"location":"build-system/#using-aliases","text":"The default melange alias is useful for prototyping or when working on small projects, but larger projects might define multiple entry points or melange.emit stanzas. In these cases, it is useful to have a way to build individual stanzas. To do so, one can define explicit aliases for each one of them by using the alias field. Let\u2019s define a custom alias my-app for our melange.emit stanza: (melange.emit (target app) (alias my-app) (libraries lib)) Now we can refer to this new alias: $ dune build @my-app Note that if we try to build again using the default melange alias, Dune will return an error, as there are no more targets attached to it. $ dune build @melange Error: Alias \"melange\" specified on the command line is empty. It is not defined in . or any of its descendants.","title":"Using aliases"},{"location":"build-system/#handling-assets","text":"Sometimes we want to use CSS files, fonts, or other assets in our Melange projects. Due to the way Dune works, our assets will have to be copied to the _build folder and installed. To make this process as easy as possible, Dune provides a way to specify these dependencies, depending on the stanza: For library stanzas, a field melange.runtime_deps For melange.emit stanzas, a field runtime_deps Both fields are documented in the Melange page of the Dune documentation site. For the sake of learning how to work with assets in a Melange project, let\u2019s say that we want to read the string in Lib.name from a text file. We will combine the field melange.runtime_deps with some bindings to Node that Melange provides. Check the next section, \"Communicate with JavaScript\" , it you want to learn more about how bindings work. So, let\u2019s add a new file name.txt inside lib folder, that just contains the name Jane . Then, adapt the lib/dune file. We will need to add the melange.runtime_deps field, as well as a preprocessing field that will allow to use the bs.raw extension (more about these extensions in the \"Communicate with JavaScript\" section), in order to get the value of the __dirname environment variable: (library (name lib) (modes melange) (melange.runtime_deps name.txt) (preprocess (pps melange.ppx))) Finally, update lib/lib.ml to read from the recently added file: Finally, update lib/lib.re to read from the recently added file: let dir = [%mel.raw \"__dirname\"] let file = \"name.txt\" let name = Node.Fs.readFileSync (dir ^ \"/\" ^ file) `ascii let dir = [%mel.raw \"__dirname\"]; let file = \"name.txt\"; let name = Node.Fs.readFileSync(dir ++ \"/\" ++ file, `ascii); After these changes, once we build the project, we should still be able to run the application file with Node: $ dune build @my-app $ node _build/default/app/app.js Jane The same approach could be used to copy fonts, CSS or SVG files, or any other asset in your project. Dune offers great flexibility to specify dependencies. Another interesting feature are globs, that allow to simplify the configuration when depending on multiple files. For example: (melange.runtime_deps (glob_files styles/*.css) (glob_files images/*.png) (glob_files static/*.{pdf,txt})) See the dependency specification docs to learn more about it. With runtime dependencies, we have reached the end of this Dune guide for Melange developers. For further details about how Dune works and its integration with Melange, check the Dune documentation , and the Melange opam template .","title":"Handling assets"},{"location":"build-system/#commonjs-or-es6-modules","text":"Melange produces JavaScript modules that export the functions they declare, and declare imports for the values and modules they depend on. By default, Melange will produce CommonJS modules, but it is possible to configure it to generate ES6 modules. Use the module_systems field in the melange.emit stanza to emit ES6 modules: (melange.emit (target app) (alias my-app) (libraries lib) (module_systems es6)) If no extension is specified, the resulting JavaScript files will use .js . You can specify a different extension with a pair (<module_system> <extension>) , e.g. (module_systems (es6 mjs)) . Multiple module systems can be used in the same field as long as their extensions are different. For example, (module_systems commonjs (es6 mjs)) will produce one set of JavaScript files using CommonJS and the .js extension, and another using ES6 and the .mjs extension.","title":"CommonJS or ES6 modules"},{"location":"communicate-with-javascript/","text":"Communicate with JavaScript Melange interoperates very well with JavaScript, and provides a wide array of features to consume foreign JavaScript code. To learn about these techniques, we will first go through the language concepts that they build upon, then we will see how types in Melange map to JavaScript runtime types. Finally, we will provide a variety of use cases with examples to show how to communicate to and from JavaScript. Language concepts The concepts covered in the following sections are a small subset of the OCaml language. However, they are essential for understanding how to communicate with JavaScript, and the features that Melange exposes to do so. Attributes and extension nodes In order to interact with JavaScript, Melange needs to extend the language to provide blocks that express these interactions. One approach could be to introduce new syntactic constructs (keywords and such) to do so, for example: javascript add : int -> int -> int = {|function(x,y){ return x + y }|} But this would break compatibility with OCaml, which is one of the main goals of Melange. Fortunately, OCaml provides mechanisms to extend its language without breaking compatibility with the parser or the language. These mechanisms are composed by two parts: First, some syntax additions to define parts of the code that will be extended or replaced Second, compile-time OCaml native programs called PPX rewriters , that will read the syntax additions defined above and proceed to extend or replace them The syntax additions come in two flavors, called extension nodes and attributes . Extension nodes Extension nodes are blocks that are supposed to be replaced by a specific type of PPX rewriters called extenders. Extension nodes use the % character to be identified. Extenders will take the extension node and replace it with a valid OCaml AST (abstract syntax tree). An example where Melange uses extension nodes to communicate with JavaScript is to produce \"raw\" JavaScript inside a Melange program: [%%mel.raw \"var a = 1; var b = 2\"] let add = [%mel.raw \"a + b\"] [%%mel.raw \"var a = 1; var b = 2\"]; let add = [%mel.raw \"a + b\"]; Which will generate the following JavaScript code: var a = 1; var b = 2 var add = a + b The difference between one and two percentage characters is detailed in the OCaml documentation . Attributes Attributes are \"decorations\" applied to specific parts of the code to provide additional information. In Melange, attributes are used in two ways to enhance the expressiveness of generating JavaScript code: either reusing existing OCaml built-in attributes or defining new ones. Reusing OCaml attributes The first approach is leveraging the existing OCaml\u2019s built-in attributes to be used for JavaScript generation. One prominent example of OCaml attributes that can be used in Melange projects is the unboxed attribute, which optimizes the compilation of single-field records and variants with a single tag to their raw values. This is useful when defining type aliases that we don\u2019t want to mix up, or when binding to JavaScript code that uses heterogeneous collections. An example of the latter is discussed in the variadic function arguments section. For instance: type name = | Name of string [@@unboxed] let student_name = Name \"alice\" [@unboxed] type name = | Name(string); let student_name = Name(\"alice\"); Compiles into: var student_name = \"alice\"; Other OCaml pre-built attributes like alert or deprecated can be used with Melange as well. Defining new attributes The second approach is introducing new attributes specifically designed for Melange, such as the mel.set attribute used to bind to properties of JavaScript objects. The complete list of attributes introduced by Melange can be found here . Attribute annotations can use one, two or three @ characters depending on their placement in the code and which kind of syntax tree node they are annotating. More information about attributes can be found in the dedicated OCaml manual page . Here are some samples using Melange attributes mel.set and mel.as : type document external setTitleDom : document -> string -> unit = \"title\" [@@mel.set] type t = { age : int; [@mel.as \"a\"] name : string; [@mel.as \"n\"] } type document; [@mel.set] external setTitleDom: (document, string) => unit = \"title\"; type t = { [@mel.as \"a\"] age: int, [@mel.as \"n\"] name: string, }; To learn more about preprocessors, attributes and extension nodes, check the section about PPX rewriters in the OCaml docs. External functions Most of the system that Melange exposes to communicate with JavaScript is built on top of an OCaml language construct called external . external is a keyword for declaring a value in OCaml that will interface with C code : external my_c_function : int -> string = \"someCFunctionName\" external my_c_function: int => string = \"someCFunctionName\"; It is like a let binding, except that the body of an external is a string. That string has a specific meaning depending on the context. For native OCaml, it usually refers to a C function with that name. For Melange, it refers to the functions or values that exist in the runtime JavaScript code, and will be used from Melange. In Melange, externals can be used to bind to global JavaScript objects . They can also be decorated with certain [@mel.xxx] attributes to facilitate the creation of bindings in specific scenarios. Each one of the available attributes will be further explained in the next sections. Once declared, one can use an external as a normal value. Melange external functions are turned into the expected JavaScript values, inlined into their callers during compilation, and completely erased afterwards. They don\u2019t appear in the JavaScript output, so there are no costs on bundling size. Note : it is recommended to use external functions and the [@mel.xxx] attributes in the interface files as well, as this allows some optimizations where the resulting JavaScript values can be directly inlined at the call sites. Special identity external One external worth mentioning is the following one: type foo = string type bar = int external danger_zone : foo -> bar = \"%identity\" type foo = string; type bar = int; external danger_zone: foo => bar = \"%identity\"; This is a final escape hatch which does nothing but convert from the type foo to bar . In the following sections, if you ever fail to write an external , you can fall back to using this one. But try not to. Abstract types In the subsequent sections, you will come across examples of bindings where a type is defined without being assigned to a value. Here is an example: type document type document; These types are referred to as \"abstract types\" and are commonly used together with external functions that define operations over values when communicating with JavaScript. Abstract types enable defining types for specific values originating from JavaScript while omitting unnecessary details. An illustration is the document type mentioned earlier, which has several properties . By using abstract types, one can focus solely on the required aspects of the document value that the Melange program requires, rather than defining all its properties. Consider the following example: type document external document : document = \"document\" external set_title : document -> string -> unit = \"title\" [@@mel.set] type document; external document: document = \"document\"; [@mel.set] external set_title: (document, string) => unit = \"title\"; Subsequent sections delve into the details about the mel.set attribute and how to bind to global values like document . For a comprehensive understanding of abstract types and their usefulness, refer to the \"Encapsulation\" section of the OCaml Cornell textbook . Pipe operators There are two pipe operators available in Melange: A pipe last operator |> , available in OCaml and inherited in Melange A pipe first operator |. -> , available exclusively in Melange Let\u2019s see the differences between the two. Pipe last Since version 4.01, OCaml includes a reverse application or \"pipe\" ( |> ) operator, an infix operator that applies the result from the previous expression the next function. As a backend for OCaml, Melange inherits this operator. The pipe operator could be implemented like this (the real implementation is a bit different ): let ( |> ) f g = g f let (|>) = (f, g) => g(f); This operator is useful when multiple functions are applied to some value in sequence, with the output of each function becoming the input of the next (a pipeline ). For example, assuming we have a function square defined as: let square x = x * x let square = x => x * x; We are using it like: let ten = succ (square 3) let ten = succ(square(3)); The pipe operator allows to write the computation for ten in left-to-right order, as it has left associativity : let ten = 3 |> square |> succ let ten = 3 |> square |> succ; When working with functions that can take multiple arguments, the pipe operator works best when the functions take the data we are processing as the last argument. For example: let sum = List.fold_left ( + ) 0 let sum_sq = [ 1; 2; 3 ] |> List.map square (* [1; 4; 9] *) |> sum (* 1 + 4 + 9 *) let sum = List.fold_left((+), 0); let sum_sq = [1, 2, 3] |> List.map(square) /* [1; 4; 9] */ |> sum; /* 1 + 4 + 9 */ The above example can be written concisely because the List.map function in the OCaml standard library takes the list as the second argument. This convention is sometimes referred to as \"data-last\", and is widely adopted in the OCaml ecosystem. Data-last and the pipe operator |> work great with currying, so they are a great fit for the language. However, there are some limitations when using data-last when it comes to error handling. In the given example, if we mistakenly used the wrong function: let sum_sq = [ 1; 2; 3 ] |> List.map String.cat |> sum let sum_sq = [1, 2, 3] |> List.map(String.cat) |> sum; The compiler would rightfully raise an error: 4 | [ 1; 2; 3 ] ^ Error: This expression has type int but an expression was expected of type string 1 | [ 1, 2, 3 ] ^ Error: This expression has type int but an expression was expected of type string Note that instead of telling us that we are passing the wrong function in List.map ( String.cat ), the error points to the list itself. This behavior aligns with the way type inference works, as the compiler infers types from left to right. Since [ 1; 2; 3 ] |> List.map String.cat is equivalent to List.map String.cat [ 1; 2; 3 ] , the type mismatch is detected when the list is type checked, after String.cat has been processed. With the goal of addressing this kind of limitations, Melange introduces the pipe first operator |. -> . Pipe first To overcome the constraints mentioned above, Melange introduces the pipe first operator |. -> . As its name suggests, the pipe first operator is better suited for functions where the data is passed as the first argument. The functions in the Belt library Belt library included with Melange have been designed with the data-first convention in mind, so they work best with the pipe first operator. For example, we can rewrite the example above using Belt.List.map and the pipe first operator: let sum_sq = [ 1; 2; 3 ] |. Belt.List.map square |. sum let sum_sq = [1, 2, 3]->(Belt.List.map(square))->sum; We can see the difference on the error we get if the wrong function is passed to Belt.List.map : let sum_sq = [ 1; 2; 3 ] |. Belt.List.map String.cat |. sum let sum_sq = [1, 2, 3]->(Belt.List.map(String.cat))->sum; The compiler will show this error message: 4 | |. Belt.List.map String.cat ^^^^^^^^^^ Error: This expression has type string -> string -> string but an expression was expected of type int -> 'a Type string is not compatible with type int 2 | let sum_sq = [1, 2, 3]->(Belt.List.map(String.cat))->sum; ^^^^^^^^^^ Error: This expression has type string -> string -> string but an expression was expected of type int -> 'a Type string is not compatible with type int The error points now to the function passed to Belt.List.map , which is more natural with the way the code is being written. Melange supports writing bindings to JavaScript using any of the two conventions, data-first or data-last, as shown in the \"Chaining\" section . For further details about the differences between the two operators, the data-first and data-last conventions and the trade-offs between them, one can refer to this related blog post . Data types and runtime representation This is how each Melange type is converted into JavaScript values: Melange JavaScript int number nativeint number int32 number float number string string array array tuple (3, 4) array [3, 4] bool boolean Js.Nullable.t Js.Nullable.t null / undefined Js.Re.t Js.Re.t RegExp Option.t None undefined Option.t Some( Some .. Some (None)) Some(Some( .. Some(None))) internal representation Option.t Some 2 Some(2) 2 record {x = 1; y = 2} {x: 1; y: 2} object {x: 1, y: 2} int64 array of 2 elements [high, low] high is signed, low unsigned char 'a' -> 97 (ascii code) bytes number array list [] 0 list [ x; y ] [x, y] { hd: x, tl: { hd: y, tl: 0 } } variant See below polymorphic variant See below Variants with a single non-nullary constructor: type tree = Leaf | Node of int * tree * tree (* Leaf -> 0 *) (* Node(7, Leaf, Leaf) -> { _0: 7, _1: 0, _2: 0 } *) type tree = | Leaf | Node(int, tree, tree); /* Leaf -> 0 */ /* Node(7, Leaf, Leaf) -> { _0: 7, _1: 0, _2: 0 } */ Variants with more than one non-nullary constructor: type t = A of string | B of int (* A(\"foo\") -> { TAG: 0, _0: \"Foo\" } *) (* B(2) -> { TAG: 1, _0: 2 } *) type t = | A(string) | B(int); /* A(\"foo\") -> { TAG: 0, _0: \"Foo\" } */ /* B(2) -> { TAG: 1, _0: 2 } */ Polymorphic variants: let u = `Foo (* \"Foo\" *) let v = `Foo(2) (* { NAME: \"Foo\", VAL: \"2\" } *) let u = `Foo; /* \"Foo\" */ let v = `Foo(2); /* { NAME: \"Foo\", VAL: \"2\" } */ Let\u2019s see now some of these types in detail. We will first describe the shared types , which have a transparent representation as JavaScript values, and then go through the non-shared types , that have more complex runtime representations. NOTE: Relying on the non-shared data types runtime representations by reading or writing them manually from JavaScript code that communicates with Melange code might lead to runtime errors, as these representations might change in the future. Shared types The following are types that can be shared between Melange and JavaScript almost \"as is\". Specific caveats are mentioned on the sections where they apply. Strings JavaScript strings are immutable sequences of UTF-16 encoded Unicode text. OCaml strings are immutable sequences of bytes and nowadays assumed to be UTF-8 encoded text when interpreted as textual content. This is problematic when interacting with JavaScript code, because if one tries to use some unicode characters, like: let () = Js.log \"\u4f60\u597d\" let () = Js.log(\"\u4f60\u597d\"); It will lead to some cryptic console output. To rectify this, Melange allows to define quoted string literals using the js identifier, for example: let () = Js.log {js|\u4f60\u597d\uff0c \u4e16\u754c|js} let () = Js.log({js|\u4f60\u597d\uff0c \u4e16\u754c|js}); For convenience, Melange exposes another special quoted string identifier: j . It is similar to JavaScript\u2019 string interpolation, but for variables only (not arbitrary expressions): let world = {j|\u4e16\u754c|j} let helloWorld = {j|\u4f60\u597d\uff0c$world|j} let world = {j|\u4e16\u754c|j}; let helloWorld = {j|\u4f60\u597d\uff0c$world|j}; You can surround the interpolation variable in parentheses too: {j|\u4f60 \u597d\uff0c$(world)|j} . To work with strings, the Melange standard library provides some utilities in the Stdlib.String module Stdlib.String module . The bindings to the native JavaScript functions to work with strings are in the Js.String module Js.String module . Floating-point numbers OCaml floats are IEEE 754 with a 53-bit mantissa and exponents from -1022 to 1023. This happens to be the same encoding as JavaScript numbers , so values of these types can be used transparently between Melange code and JavaScript code. The Melange standard library provides a Stdlib.Float module Stdlib.Float module . The bindings to the JavaScript APIs that manipulate float values can be found in the Js.Float module Js.Float module . Integers In Melange, integers are limited to 32 bits due to the fixed-width conversion of bitwise operations in JavaScript. While Melange integers compile to JavaScript numbers, treating them interchangeably can result in unexpected behavior due to differences in precision. Even though bitwise operations in JavaScript are constrained to 32 bits, integers themselves are represented using the same floating-point format as numbers , allowing for a larger range of representable integers in JavaScript compared to Melange. When dealing with large numbers, it is advisable to use floats instead. For instance, floats are used in bindings like Js.Date . The Melange standard library provides a Stdlib.Int module Stdlib.Int module . The bindings to work with JavaScript integers are in the Js.Int module Js.Int module . Arrays Melange arrays compile to JavaScript arrays. But note that unlike JavaScript arrays, all the values in a Melange array need to have the same type. Another difference is that OCaml arrays are fixed-sized, but on Melange side this constraint is relaxed. You can change an array\u2019s length using functions like Js.Array.push , available in the bindings to the JavaScript APIs in the Js.Array module Js.Array module . Melange standard library also has a module to work with arrays, available in the Stdlib.Array module Stdlib.Array module . Tuples OCaml tuples are compiled to JavaScript arrays. This is convenient when writing bindings that will use a JavaScript array with heterogeneous values, but that happens to have a fixed length. As a real world example of this can be found in ReasonReact , the Melange bindings for React . In these bindings, component effects dependencies are represented as OCaml tuples, so they get compiled cleanly to JavaScript arrays by Melange. For example, some code like this: let () = React.useEffect2 (fun () -> None) (foo, bar) let () = React.useEffect2(() => None, (foo, bar)); Will produce: React.useEffect(function () {}, [foo, bar]); Booleans Values of type bool compile to JavaScript booleans. Records Melange records map directly to JavaScript objects. If the record fields include non-shared data types (like variants), these values should be transformed separately, and not be directly used in JavaScript. Extensive documentation about interfacing with JavaScript objects using records can be found in the section below . Regular expressions Regular expressions created using the %mel.re extension node compile to their JavaScript counterpart. For example: let r = [%mel.re \"/b/g\"] let r = [%mel.re \"/b/g\"]; Will compile to: var r = /b/g; A regular expression like the above is of type Js.Re.t . The Js.Re module Js.Re module provides the bindings to the JavaScript functions that operate over regular expressions. Non-shared data types The following types differ too much between Melange and JavaScript, so while they can always be manipulated from JavaScript, it is recommended to transform them before doing so. Variants and polymorphic variants: Better transform them into readable JavaScript values before manipulating them from JavaScript, Melange provides some helpers to do so. Exceptions Option (a variant type): Better use the Js.Nullable.fromOption and Js.Nullable.toOption functions in the Js.Nullable module Js.Nullable module to transform them into either null or undefined values. List (also a variant type): use Array.of_list and Array.to_list in the Stdlib.Array module Stdlib.Array module . Character Int64 Lazy values List of attributes and extension nodes Attributes: These attributes are used to annotate external definitions: mel.get : read JavaScript object properties statically by name, using the dot notation . mel.get_index : read a JavaScript object\u2019s properties dynamically by using the bracket notation [] mel.module : bind to a value from a JavaScript module mel.new : bind to a JavaScript class constructor mel.obj : create a JavaScript object mel.return : automate conversion from nullable values to Option.t values mel.send : call a JavaScript object method using pipe first convention mel.send.pipe : call a JavaScript object method using pipe last convention mel.set : set JavaScript object properties statically by name, using the dot notation . mel.set_index : set JavaScript object properties dynamically by using the bracket notation [] mel.scope : reach to deeper properties inside a JavaScript object mel.splice : a deprecated attribute, is an alternate form of mel.variadic mel.variadic : bind to a function taking variadic arguments from an array These attributes are used to annotate arguments in external definitions: u : define function arguments as uncurried (manual) mel.int : compile function argument to an int mel.string : compile function argument to a string mel.this : bind to this based callbacks mel.uncurry : define function arguments as uncurried (automated) mel.unwrap : unwrap variant values These attributes are used in places like records, fields, arguments, functions, and more: mel.as : redefine the name generated in the JavaScript output code. Used in constant function arguments , variants , polymorphic variants (either inlined in external functions or in type definitions ) and record fields . deriving : generate getters and setters for some types mel.inline : forcefully inline constant values optional : omit fields in a record (combines with deriving ) Extension nodes: In order to use any of these extension nodes, you will have to add the melange PPX preprocessor to your project. To do so, add the following to the dune file: (library (name lib) (modes melange) (preprocess (pps melange.ppx))) The same field preprocess can be added to melange.emit . Here is the list of all the extension nodes supported by Melange: mel.debugger : insert debugger statements mel.external : read global values mel.obj : create JavaScript object literals mel.raw : write raw JavaScript code mel.re : insert regular expressions Generate raw JavaScript It is possible to directly write JavaScript code from a Melange file. This is unsafe, but it can be useful for prototyping or as an escape hatch. To do it, we will use the mel.raw extension : let add = [%mel.raw {| function(a, b) { console.log(\"hello from raw JavaScript!\"); return a + b; } |}] let () = Js.log (add 1 2) let add = [%mel.raw {| function(a, b) { console.log(\"hello from raw JavaScript!\"); return a + b; } |} ]; let () = Js.log(add(1, 2)); The {||} strings are called \"quoted strings\" . They are similar to JavaScript\u2019s template literals, in the sense that they are multi-line, and there is no need to escape characters inside the string. Using one percentage sign the extension name between square brackets ( [%mel.raw <string>] ) is useful to define expressions (function bodies, or other values) where the implementation is directly JavaScript. This is useful as we can attach the type signature already in the same line, to make our code safer. For example: let f : unit -> int = [%mel.raw \"function() {return 1}\"] let f: unit => int = ([%mel.raw \"function() {return 1}\"]: unit => int); Using two percentage signs ( [%%mel.raw <string>] ) the extension name without square brackets ( %mel.raw <string> ) is reserved for definitions in a structure or signature . For example: [%%mel.raw \"var a = 1\"] [%%mel.raw \"var a = 1\"]; Debugger Melange allows you to inject a debugger; expression using the mel.debugger extension: let f x y = [%mel.debugger]; x + y let f = (x, y) => { [%mel.debugger]; x + y; }; Output: function f (x,y) { debugger; // JavaScript developer tools will set a breakpoint and stop here return x + y | 0; } Detect global variables Melange provides a relatively type safe approach to use globals that might be defined either in the JavaScript runtime environment: mel.external . [%mel.external id] will check if the JavaScript value id is undefined or not, and return an Option.t value accordingly. For example: let () = match [%mel.external __DEV__] with | Some _ -> Js.log \"dev mode\" | None -> Js.log \"production mode\" let () = switch ([%mel.external __DEV__]) { | Some(_) => Js.log(\"dev mode\") | None => Js.log(\"production mode\") }; Another example: let () = match [%mel.external __filename] with | Some f -> Js.log f | None -> Js.log \"non-node environment\" let () = switch ([%mel.external __filename]) { | Some(f) => Js.log(f) | None => Js.log(\"non-node environment\") }; Inlining constant values Some JavaScript idioms require special constants to be inlined since they serve as de-facto directives for bundlers. A common example is process.env.NODE_ENV : if (process.env.NODE_ENV !== \"production\") { // Development-only code } becomes: if (\"development\" !== \"production\") { // Development-only code } In this case, bundlers such as Webpack can tell that the if statement always evaluates to a specific branch and eliminate the others. Melange provides the mel.inline attribute to achieve the same goal in generated JavaScript. Let\u2019s look at an example: external node_env : string = \"NODE_ENV\" [@@mel.scope \"process\", \"env\"] let development = \"development\" let () = if node_env <> development then Js.log \"Only in Production\" let development_inline = \"development\" [@@mel.inline] let () = if node_env <> development_inline then Js.log \"Only in Production\" [@mel.scope (\"process\", \"env\")] external node_env: string = \"NODE_ENV\"; let development = \"development\"; let () = if (node_env != development) { Js.log(\"Only in Production\"); }; [@mel.inline] let development_inline = \"development\"; let () = if (node_env != development_inline) { Js.log(\"Only in Production\"); }; As we can see in the generated JavaScript presented below: the development variable is emitted it gets used as a variable process.env.NODE_ENV !== development in the if statement the development_inline variable isn\u2019t present in the final output its value is inlined in the if statement: process.env.NODE_ENV !== \"development\" var development = \"development\"; if (process.env.NODE_ENV !== development) { console.log(\"Only in Production\"); } if (process.env.NODE_ENV !== \"development\") { console.log(\"Only in Production\"); } Bind to JavaScript objects JavaScript objects are used in a variety of use cases: As a fixed shape record . As a map or dictionary. As a class. As a module to import/export. Melange separates the binding methods for JavaScript objects based on these four use cases. This section documents the first three. Binding to JavaScript module objects is described in the \"Using functions from other JavaScript modules\" section. Objects with static shape (record-like) Using OCaml records If your JavaScript object has fixed fields, then it\u2019s conceptually like an OCaml record . Since Melange compiles records into JavaScript objects, the most common way to bind to JavaScript objects is using records. type person = { name : string; friends : string array; age : int; } external john : person = \"john\" [@@mel.module \"MySchool\"] let john_name = john.name type person = { name: string, friends: array(string), age: int, }; [@mel.module \"MySchool\"] external john: person = \"john\"; let john_name = john.name; This is the generated JavaScript: var MySchool = require(\"MySchool\"); var john_name = MySchool.john.name; External functions are documented in a previous section . The mel.module attribute is documented here . If you want or need to use different field names on the Melange and the JavaScript sides, you can use the mel.as decorator: type action = { type_ : string [@mel.as \"type\"] } let action = { type_ = \"ADD_USER\" } type action = { [@mel.as \"type\"] type_: string, }; let action = {type_: \"ADD_USER\"}; Which generates the JavaScript code: var action = { type: \"ADD_USER\" }; This is useful to map to JavaScript attribute names that cannot be expressed in Melange, for example, where the JavaScript name we want to generate is a reserved keyword . It is also possible to map a Melange record to a JavaScript array by passing indices to the mel.as decorator: type t = { foo : int; [@mel.as \"0\"] bar : string; [@mel.as \"1\"] } let value = { foo = 7; bar = \"baz\" } type t = { [@mel.as \"0\"] foo: int, [@mel.as \"1\"] bar: string, }; let value = {foo: 7, bar: \"baz\"}; And its JavaScript generated code: var value = [ 7, \"baz\" ]; Using Js.t objects Alternatively to records, Melange offers another type that can be used to produce JavaScript objects. This type is 'a Js.t , where 'a is an OCaml object . The advantage of objects versus records is that no type declaration is needed in advance, which can be helpful for prototyping or quickly generating JavaScript object literals. Melange provides some ways to create Js.t object values, as well as accessing the properties inside them. To create values, the [%mel.obj] extension is used, and the ## infix operator allows to read from the object properties: let john = [%mel.obj { name = \"john\"; age = 99 }] let t = john##name let john = {\"name\": \"john\", \"age\": 99}; let t = john##name; Which generates: var john = { name: \"john\", age: 99 }; var t = john.name; Note that object types allow for some flexibility that the record types do not have. For example, an object type can be coerced to another with fewer values or methods, while it is impossible to coerce a record type to another one with fewer fields. So different object types that share some methods can be mixed in a data structure where only their common methods are visible. To give an example, one can create a function that operates in all the object types that include a field name that is of type string, e.g.: let name_extended obj = obj##name ^ \" wayne\" let one = name_extended [%mel.obj { name = \"john\"; age = 99 }] let two = name_extended [%mel.obj { name = \"jane\"; address = \"1 infinite loop\" }] let name_extended = obj => obj##name ++ \" wayne\"; let one = name_extended({\"name\": \"john\", \"age\": 99}); let two = name_extended({\"name\": \"jane\", \"address\": \"1 infinite loop\"}); To read more about objects and polymorphism we recommend checking the OCaml docs or the OCaml manual . Using external functions We have already explored one approach for creating JavaScript object literals by using Js.t values and the mel.obj extension . Melange additionally offers the mel.obj attribute, which can be used in combination with external functions to create JavaScript objects. When these functions are called, they generate objects with fields corresponding to the labeled arguments of the function. If any of these labeled arguments are defined as optional and omitted during function application, the resulting JavaScript object will exclude the corresponding fields. This allows to create runtime objects and control whether optional keys are emitted at runtime. For example, assuming we need to bind to a JavaScript object like this: var homeRoute = { type: \"GET\", path: \"/\", action: () => console.log(\"Home\"), // options: ... }; The first three fields are required and the options field is optional. You can declare a binding function like: external route : _type:string -> path:string -> action:(string list -> unit) -> ?options:< .. > -> unit -> _ = \"\" [@@mel.obj] [@mel.obj] external route: ( ~_type: string, ~path: string, ~action: list(string) => unit, ~options: {..}=?, unit ) => _; Note that the empty string at the end of the function is used to make it syntactically valid. The value of this string is ignored by the compiler. Since there is an optional argument options , an additional unlabeled argument of type unit is included after it. It allows to omit the optional argument on function application. More information about labeled optional arguments can be found in the OCaml manual . The return type of the function should be left unspecified using the wildcard type _ . Melange will automatically infer the type of the resulting JavaScript object. In the route function, the _type argument starts with an underscore. When binding to JavaScript objects with fields that are reserved keywords in OCaml, Melange allows the use of an underscore prefix for the labeled arguments. The resulting JavaScript object will have the underscore removed from the field names. This is only required for the mel.obj attribute, while for other cases, the mel.as attribute can be used to rename fields. If we call the function like this: let homeRoute = route ~_type:\"GET\" ~path:\"/\" ~action:(fun _ -> Js.log \"Home\") () let homeRoute = route(~_type=\"GET\", ~path=\"/\", ~action=_ => Js.log(\"Home\"), ()); We get the following JavaScript, which does not include the options field since its argument wasn\u2019t present: var homeRoute = { type: \"GET\", path: \"/\", action: (function (param) { console.log(\"Home\"); }) }; Bind to object properties If you need to bind only to the property of a JavaScript object, you can use mel.get and mel.set to access it using the dot notation . : (* Abstract type for the `document` value *) type document external document : document = \"document\" external set_title : document -> string -> unit = \"title\" [@@mel.set] external get_title : document -> string = \"title\" [@@mel.get] let current = get_title document let () = set_title document \"melange\" /* Abstract type for the `document` value */ type document; external document: document = \"document\"; [@mel.set] external set_title: (document, string) => unit = \"title\"; [@mel.get] external get_title: document => string = \"title\"; let current = get_title(document); let () = set_title(document, \"melange\"); This generates: var current = document.title; document.title = \"melange\"; Alternatively, if some dynamism is required on the way the property is accessed, you can use mel.get_index and mel.set_index to access it using the bracket notation [] : type t external create : int -> t = \"Int32Array\" [@@mel.new] external get : t -> int -> int = \"\" [@@mel.get_index] external set : t -> int -> int -> unit = \"\" [@@mel.set_index] let () = let i32arr = (create 3) in set i32arr 0 42; Js.log (get i32arr 0) type t; [@mel.new] external create: int => t = \"Int32Array\"; [@mel.get_index] external get: (t, int) => int; [@mel.set_index] external set: (t, int, int) => unit; let () = { let i32arr = create(3); set(i32arr, 0, 42); Js.log(get(i32arr, 0)); }; Which generates: var i32arr = new Int32Array(3); i32arr[0] = 42; console.log(i32arr[0]); Objects with dynamic shape (dictionary-like) Sometimes JavaScript objects are used as dictionaries. In these cases: All values stored in the object belong to the same type Key-value pairs can be added or removed at runtime For this particular use case of JavaScript objects, Melange exposes a specific type Js.Dict.t . The values and functions to work with values of this type are defined in the Js.Dict module Js.Dict module , with operations like get , set , etc. Values of the type Js.Dict.t compile to JavaScript objects. JavaScript classes JavaScript classes are special kinds of objects. To interact with classes, Melange exposes mel.new to emulate e.g. new Date() : type t external create_date : unit -> t = \"Date\" [@@mel.new] let date = create_date () type t; [@mel.new] external create_date: unit => t = \"Date\"; let date = create_date(); Which generates: var date = new Date(); You can chain mel.new and mel.module if the JavaScript class you want to work with is in a separate JavaScript module: type t external book : unit -> t = \"Book\" [@@mel.new] [@@mel.module] let myBook = book () type t; [@mel.new] [@mel.module] external book: unit => t = \"Book\"; let myBook = book(); Which generates: var Book = require(\"Book\"); var myBook = new Book(); Bind to JavaScript functions or values Using global functions or values Binding to a JavaScript function available globally makes use of external , like with objects. But unlike objects, there is no need to add any attributes: (* Abstract type for `timeoutId` *) type timeoutId external setTimeout : (unit -> unit) -> int -> timeoutId = \"setTimeout\" external clearTimeout : timeoutId -> unit = \"clearTimeout\" let id = setTimeout (fun () -> Js.log \"hello\") 100 let () = clearTimeout id /* Abstract type for `timeoutId` */ type timeoutId; external setTimeout: (unit => unit, int) => timeoutId = \"setTimeout\"; external clearTimeout: timeoutId => unit = \"clearTimeout\"; let id = setTimeout(() => Js.log(\"hello\"), 100); let () = clearTimeout(id); NOTE: The bindings to setTimeout and clearTimeout are shown here for learning purposes, but they are already available in the Js.Global module Js.Global module . Generates: var id = setTimeout(function (param) { console.log(\"hello\"); }, 100); clearTimeout(id); Global bindings can also be applied to values: (* Abstract type for `document` *) type document external document : document = \"document\" let document = document /* Abstract type for `document` */ type document; external document: document = \"document\"; let document = document; Which generates: var doc = document; Using functions from other JavaScript modules mel.module allows to bind to values that belong to another JavaScript module. It accepts a string with the name of the module, or the relative path to it. external dirname : string -> string = \"dirname\" [@@mel.module \"path\"] let root = dirname \"/User/github\" [@mel.module \"path\"] external dirname: string => string = \"dirname\"; let root = dirname(\"/User/github\"); Generates: var Path = require(\"path\"); var root = Path.dirname(\"/User/github\"); Binding to properties inside a module or global For cases when we need to create bindings for a property within a module or a global JavaScript object, Melange provides the mel.scope attribute. For example, if we want to write some bindings for a specific property commands from the vscode package , we can do: type param external executeCommands : string -> param array -> unit = \"\" [@@mel.scope \"commands\"] [@@mel.module \"vscode\"] [@@mel.variadic] let f a b c = executeCommands \"hi\" [| a; b; c |] type param; [@mel.scope \"commands\"] [@mel.module \"vscode\"] [@mel.variadic] external executeCommands: (string, array(param)) => unit; let f = (a, b, c) => executeCommands(\"hi\", [|a, b, c|]); Which compiles to: var Vscode = require(\"vscode\"); function f(a, b, c) { Vscode.commands.executeCommands(\"hi\", a, b, c); } The mel.scope attribute can take multiple arguments as payload, in case we want to reach deeper into the object from the module we are importing. For example: type t external back : t = \"back\" [@@mel.module \"expo-camera\"] [@@mel.scope \"Camera\", \"Constants\", \"Type\"] let camera_type_back = back type t; [@mel.module \"expo-camera\"] [@mel.scope (\"Camera\", \"Constants\", \"Type\")] external back: t = \"back\"; let camera_type_back = back; Which generates: var ExpoCamera = require(\"expo-camera\"); var camera_type_back = ExpoCamera.Camera.Constants.Type.back; It can be used without mel.module , to created scoped bindings to global values: external imul : int -> int -> int = \"imul\" [@@mel.scope \"Math\"] let res = imul 1 2 [@mel.scope \"Math\"] external imul: (int, int) => int = \"imul\"; let res = imul(1, 2); Which produces: var res = Math.imul(1, 2); Or it can be used together with mel.new : type t external create : unit -> t = \"GUI\" [@@mel.new] [@@mel.scope \"default\"] [@@mel.module \"dat.gui\"] let gui = create () type t; [@mel.new] [@mel.scope \"default\"] [@mel.module \"dat.gui\"] external create: unit => t = \"GUI\"; let gui = create(); Which generates: var DatGui = require(\"dat.gui\"); var gui = new (DatGui.default.GUI)(); Labeled arguments OCaml has labeled arguments , which can also be optional, and work with external as well. Labeled arguments can be useful to provide more information about the arguments of a JavaScript function that is called from Melange. Let\u2019s say we have the following JavaScript function, that we want to call from Melange: // MyGame.js function draw(x, y, border) { // let\u2019s assume `border` is optional and defaults to false } draw(10, 20) draw(20, 20, true) When writing Melange bindings, we can add labeled arguments to make things more clear: external draw : x:int -> y:int -> ?border:bool -> unit -> unit = \"draw\" [@@module \"MyGame\"] let () = draw ~x:10 ~y:20 ~border:true () let () = draw ~x:10 ~y:20 () [@module \"MyGame\"] external draw: (~x: int, ~y: int, ~border: bool=?, unit) => unit = \"draw\"; let () = draw(~x=10, ~y=20, ~border=true, ()); let () = draw(~x=10, ~y=20, ()); Generates: var MyGame = require(\"MyGame\"); MyGame.draw(10, 20, true); MyGame.draw(10, 20, undefined); The generated JavaScript function is the same, but now the usage in Melange is much clearer. Note : in this particular case, a final param of type unit, () must be added after border , since border is an optional argument at the last position. Not having the last param unit would lead to a warning, which is explained in detail in the OCaml documentation . Note that you can freely reorder the labeled arguments when applying the function on the Melange side. The generated code will maintain the original order that was used when declaring the function: external draw : x:int -> y:int -> ?border:bool -> unit -> unit = \"draw\" [@@module \"MyGame\"] let () = draw ~x:10 ~y:20 () let () = draw ~y:20 ~x:10 () [@module \"MyGame\"] external draw: (~x: int, ~y: int, ~border: bool=?, unit) => unit = \"draw\"; let () = draw(~x=10, ~y=20, ()); let () = draw(~y=20, ~x=10, ()); Generates: var MyGame = require(\"MyGame\"); MyGame.draw(10, 20, undefined); MyGame.draw(10, 20, undefined); Calling an object method If we need to call a JavaScript method, Melange provides the attribute mel.send . In the following snippets, we will be referring to a type Dom.element , which is provided within the library melange.dom . You can add it to your project by including (libraries melange.dom) to your dune file: (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : document -> string -> Dom.element = \"getElementById\" [@@mel.send] let el = get_by_id document \"my-id\" /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send] external get_by_id: (document, string) => Dom.element = \"getElementById\"; let el = get_by_id(document, \"my-id\"); Generates: var el = document.getElementById(\"my-id\"); When using mel.send , the first argument will be the object that holds the property with the function we want to call. This combines well with the pipe first operator |. -> , see the \"Chaining\" section below. If we want to design our bindings to be used with OCaml pipe last operator |> , there is an alternate mel.send.pipe attribute. Let\u2019s rewrite the example above using it: (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : string -> Dom.element = \"getElementById\" [@@mel.send.pipe: document] let el = get_by_id \"my-id\" document /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send.pipe: document] external get_by_id: string => Dom.element = \"getElementById\"; let el = get_by_id(\"my-id\", document); Generates the same code as mel.send : var el = document.getElementById(\"my-id\"); Chaining It is common to find this kind of API in JavaScript: foo().bar().baz() . This kind of API can be designed with Melange externals. Depending on which convention we want to use, there are two attributes available: For a data-first convention, the mel.send attribute, in combination with the pipe first operator |. -> For a data-last convention, the mel.send.pipe attribute, in combination with OCaml pipe last operator |> . Let\u2019s see first an example of chaining using data-first convention with the pipe first operator |. -> : (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : document -> string -> Dom.element = \"getElementById\" [@@mel.send] external get_by_classname : Dom.element -> string -> Dom.element = \"getElementsByClassName\" [@@mel.send] let el = document |. get_by_id \"my-id\" |. get_by_classname \"my-class\" /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send] external get_by_id: (document, string) => Dom.element = \"getElementById\"; [@mel.send] external get_by_classname: (Dom.element, string) => Dom.element = \"getElementsByClassName\"; let el = document->(get_by_id(\"my-id\"))->(get_by_classname(\"my-class\")); Will generate: var el = document.getElementById(\"my-id\").getElementsByClassName(\"my-class\"); Now with pipe last operator |> : (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : string -> Dom.element = \"getElementById\" [@@mel.send.pipe: document] external get_by_classname : string -> Dom.element = \"getElementsByClassName\" [@@mel.send.pipe: Dom.element] let el = document |> get_by_id \"my-id\" |> get_by_classname \"my-class\" /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send.pipe: document] external get_by_id: string => Dom.element = \"getElementById\"; [@mel.send.pipe: Dom.element] external get_by_classname: string => Dom.element = \"getElementsByClassName\"; let el = document |> get_by_id(\"my-id\") |> get_by_classname(\"my-class\"); Will generate the same JavaScript as the pipe first version: var el = document.getElementById(\"my-id\").getElementsByClassName(\"my-class\"); Variadic function arguments Sometimes JavaScript functions take an arbitrary amount of arguments. For these cases, Melange provides the mel.variadic attribute, which can be attached to the external declaration. However, there is one caveat: all the variadic arguments need to belong to the same type. external join : string array -> string = \"join\" [@@mel.module \"path\"] [@@mel.variadic] let v = join [| \"a\"; \"b\" |] [@mel.module \"path\"] [@mel.variadic] external join: array(string) => string = \"join\"; let v = join([|\"a\", \"b\"|]); Generates: var Path = require(\"path\"); var v = Path.join(\"a\", \"b\"); If more dynamism is needed, there is a way to inject elements with different types in the array and still have Melange compile to JavaScript values that are not wrapped using the OCaml unboxed attribute, which was mentioned in the OCaml attributes section : type hide = Hide : 'a -> hide [@@unboxed] external join : hide array -> string = \"join\" [@@mel.module \"path\"] [@@mel.variadic] let v = join [| Hide \"a\"; Hide 2 |] [@unboxed] type hide = | Hide('a): hide; [@mel.module \"path\"] [@mel.variadic] external join: array(hide) => string = \"join\"; let v = join([|Hide(\"a\"), Hide(2)|]); Compiles to: var Path = require(\"path\"); var v = Path.join(\"a\", 2); Bind to a polymorphic function Some JavaScript libraries will define functions where the arguments can vary on both type and shape. There are two approaches to bind to those, depending on how dynamic they are. Approach 1: Multiple external functions If it is possible to enumerate the many forms an overloaded JavaScript function can take, a flexible approach is to bind to each form individually: external drawCat : unit -> unit = \"draw\" [@@mel.module \"MyGame\"] external drawDog : giveName:string -> unit = \"draw\" [@@mel.module \"MyGame\"] external draw : string -> useRandomAnimal:bool -> unit = \"draw\" [@@mel.module \"MyGame\"] [@mel.module \"MyGame\"] external drawCat: unit => unit = \"draw\"; [@mel.module \"MyGame\"] external drawDog: (~giveName: string) => unit = \"draw\"; [@mel.module \"MyGame\"] external draw: (string, ~useRandomAnimal: bool) => unit = \"draw\"; Note how all three externals bind to the same JavaScript function, draw . Approach 2: Polymorphic variant + mel.unwrap In some cases, the function has a constant number of arguments but the type of the argument can vary. For cases like this, we can model the argument as a variant and use the mel.unwrap attribute in the external. Let\u2019s say we want to bind to the following JavaScript function: function padLeft(value, padding) { if (typeof padding === \"number\") { return Array(padding + 1).join(\" \") + value; } if (typeof padding === \"string\") { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } As the padding argument can be either a number or a string, we can use mel.unwrap to define it. It is important to note that mel.unwrap imposes certain requirements on the type it is applied to: It needs to be a polymorphic variant Its definition needs to be inlined Each variant tag needs to have an argument The variant type can not be opened (can\u2019t use > ) external padLeft: string -> ([ `Str of string | `Int of int ] [@mel.unwrap]) -> string = \"padLeft\" let _ = padLeft \"Hello World\" (`Int 4) let _ = padLeft \"Hello World\" (`Str \"Message from Melange: \") external padLeft: (string, [@mel.unwrap] [ | `Str(string) | `Int(int)]) => string = \"padLeft\"; let _ = padLeft(\"Hello World\", `Int(4)); let _ = padLeft(\"Hello World\", `Str(\"Message from Melange: \")); Which produces the following JavaScript: padLeft(\"Hello World\", 4); padLeft(\"Hello World\", \"Message from Melange: \"); As we saw in the Non-shared data types section, we should rather avoid passing variants directly to the JavaScript side. By using mel.unwrap we get the best of both worlds: from Melange we can use variants, while JavaScript gets the raw values inside them. Using polymorphic variants to bind to enums Some JavaScript APIs take a limited subset of values as input. For example, Node\u2019s fs.readFileSync second argument can only take a few given string values: \"ascii\" , \"utf8\" , etc. Some other functions can take values from a few given integers, like the createStatusBarItem function in VS Code API, which can take an alignment parameter that can only be 1 or 2 . One could still type these parameters as just string or int , but this would not prevent consumers of the external function from calling it using values that are unsupported by the JavaScript function. Let\u2019s see how we can use polymorphic variants to avoid runtime errors. If the values are strings, we can use the mel.string attribute: external read_file_sync : name:string -> ([ `utf8 | `ascii ][@mel.string]) -> string = \"readFileSync\" [@@mel.module \"fs\"] let _ = read_file_sync ~name:\"xx.txt\" `ascii [@mel.module \"fs\"] external read_file_sync: (~name: string, [@mel.string] [ | `utf8 | `ascii]) => string = \"readFileSync\"; let _ = read_file_sync(~name=\"xx.txt\", `ascii); Which generates: var Fs = require(\"fs\"); Fs.readFileSync(\"xx.txt\", \"ascii\"); This technique can be combined with the mel.as attribute to modify the strings produced from the polymorphic variant values. For example: type document type style external document : document = \"document\" external get_by_id : document -> string -> Dom.element = \"getElementById\" [@@mel.send] external style : Dom.element -> style = \"style\" [@@mel.get] external transition_timing_function : style -> ([ `ease | `easeIn [@mel.as \"ease-in\"] | `easeOut [@mel.as \"ease-out\"] | `easeInOut [@mel.as \"ease-in-out\"] | `linear ] [@mel.string]) -> unit = \"transitionTimingFunction\" [@@mel.set] let element_style = style (get_by_id document \"my-id\") let () = transition_timing_function element_style `easeIn type document; type style; external document: document = \"document\"; [@mel.send] external get_by_id: (document, string) => Dom.element = \"getElementById\"; [@mel.get] external style: Dom.element => style = \"style\"; [@mel.set] external transition_timing_function: ( style, [@mel.string] [ | `ease | [@mel.as \"ease-in\"] `easeIn | [@mel.as \"ease-out\"] `easeOut | [@mel.as \"ease-in-out\"] `easeInOut | `linear ] ) => unit = \"transitionTimingFunction\"; let element_style = style(get_by_id(document, \"my-id\")); let () = transition_timing_function(element_style, `easeIn); This will generate: var element_style = document.getElementById(\"my-id\").style; element_style.transitionTimingFunction = \"ease-in\"; Aside from producing string values, Melange also offers mel.int to produce integer values. mel.int can also be combined with mel.as : external test_int_type : ([ `on_closed | `on_open [@mel.as 20] | `in_bin ][@mel.int]) -> int = \"testIntType\" let value = test_int_type `on_open external test_int_type: ([@mel.int] [ | `on_closed | [@mel.as 20] `on_open | `in_bin]) => int = \"testIntType\"; let value = test_int_type(`on_open); In this example, on_closed will be encoded as 0, on_open will be 20 due to the attribute mel.as and in_bin will be 21, because if no mel.as annotation is provided for a variant tag, the compiler continues assigning values counting up from the previous one. This code generates: var value = testIntType(20); Using polymorphic variants to bind to event listeners Polymorphic variants can also be used to wrap event listeners, or any other kind of callback, for example: type readline external on : readline -> ([ `close of unit -> unit | `line of string -> unit ][@mel.string]) -> readline = \"on\" [@@mel.send] let register rl = rl |. on (`close (fun event -> ())) |. on (`line (fun line -> Js.log line)) type readline; [@mel.send] external on: ( readline, [@mel.string] [ | `close(unit => unit) | `line(string => unit)] ) => readline = \"on\"; let register = rl => rl->(on(`close(event => ())))->(on(`line(line => Js.log(line)))); This generates: function register(rl) { return rl .on(\"close\", function($$event) {}) .on(\"line\", function(line) { console.log(line); }); } Constant values as arguments Sometimes we want to call a JavaScript function and make sure one of the arguments is always constant. For this, the [@mel.as] attribute can be combined with the wildcard pattern _ : external process_on_exit : (_[@mel.as \"exit\"]) -> (int -> unit) -> unit = \"process.on\" let () = process_on_exit (fun exit_code -> Js.log (\"error code: \" ^ string_of_int exit_code)) external process_on_exit: ([@mel.as \"exit\"] _, int => unit) => unit = \"process.on\"; let () = process_on_exit(exit_code => Js.log(\"error code: \" ++ string_of_int(exit_code)) ); This generates: process.on(\"exit\", function (exitCode) { console.log(\"error code: \" + exitCode.toString()); }); The mel.as \"exit\" and the wildcard _ pattern together will tell Melange to compile the first argument of the JavaScript function to the string \"exit\" . You can also use any JSON literal by passing a quoted string to mel.as : mel.as {json|true|json} or mel.as {json|{\"name\": \"John\"}|json} . Binding to callbacks In OCaml, all functions have arity 1. This means that if you define a function like this: let add x y = x + y let add = (x, y) => x + y; Its type will be int -> int -> int . This means that one can partially apply add by calling add 1 , which will return another function expecting the second argument of the addition. This kind of functions are called \"curried\" functions, more information about currying in OCaml can be found in this chapter of the \"OCaml Programming: Correct + Efficient + Beautiful\" book. This is incompatible with how function calling conventions work in JavaScript, where all function calls always apply all the arguments. To continue the example, let\u2019s say we have an add function implemented in JavaScript, similar to the one above: var add = function (a, b) { return a + b; }; If we call add(1) , the function will be totally applied, with b having undefined value. And as JavaScript will try to add 1 with undefined , we will get NaN as a result. To illustrate this difference and how it affects Melange bindings, let\u2019s say we want to write bindings for a JavaScript function like this: function map (a, b, f){ var i = Math.min(a.length, b.length); var c = new Array(i); for(var j = 0; j < i; ++j){ c[j] = f(a[i],b[i]) } return c ; } A naive external function declaration could be as below: external map : 'a array -> 'b array -> ('a -> 'b -> 'c) -> 'c array = \"map\" external map: (array('a), array('b), ('a, 'b) => 'c) => array('c) = \"map\"; Unfortunately, this is not completely correct. The issue is in the callback function, with type 'a -> 'b -> 'c . This means that map will expect a function like add described above. But as we said, in OCaml, having two arguments means just to have two functions that take one argument. Let\u2019s rewrite add to make the problem a bit more clear: let add x = let partial y = x + y in partial let add = x => { let partial = y => x + y; partial; }; This will be compiled to: function add(x) { return (function (y) { return x + y | 0; }); } Now if we ever used our external function map with our add function by calling map arr1 arr2 add it would not work as expected. JavaScript function application does not work the same as in OCaml, so the function call in the map implementation, f(a[i],b[i]) , would be applied over the outer JavaScript function add , which only takes one argument x , and b[i] would be just discarded. The value returned from the operation would not be the addition of the two numbers, but rather the inner anonymous callback. To solve this mismatch between OCaml and JavaScript functions and their application, Melange provides a special attribute @u that can be used to annotate external functions that need to be \"uncurried\". In Reason syntax, this attribute does not need to be written explicitly, as it is deeply integrated with the Reason parser. To specify some function type as \"uncurried\", one just needs to add the dot character . to the function type. For example, (. 'a, 'b) => 'c instead of ('a, 'b) => 'c . In the example above: external map : 'a array -> 'b array -> (('a -> 'b -> 'c)[@u]) -> 'c array = \"map\" external map: (array('a), array('b), (. 'a, 'b) => 'c) => array('c) = \"map\"; Here ('a -> 'b -> 'c [@u]) (. 'a, 'b) => 'c will be interpreted as having arity 2. In general, 'a0 -> 'a1 ...\u200b 'aN -> 'b0 [@u] is the same as 'a0 -> 'a1 ...\u200b 'aN -> 'b0 . 'a0, 'a1, ...\u200b 'aN => 'b0 is the same as 'a0, 'a1, ...\u200b 'aN => 'b0 except the former\u2019s arity is guaranteed to be N while the latter is unknown. If we try now to call map using add : let add x y = x + y let _ = map [||] [||] add let add = (x, y) => x + y; let _ = map([||], [||], add); We will get an error: let _ = map [||] [||] add ^^^ This expression has type int -> int -> int but an expression was expected of type ('a -> 'b -> 'c) Js.Fn.arity2 To solve this, we add @u . in the function definition as well: let add = fun [@u] x y -> x + y let add = (. x, y) => x + y; Annotating function definitions can be quite cumbersome when writing a lot of externals. To work around the verbosity, Melange offers another attribute called mel.uncurry . Let\u2019s see how we could use it in the previous example. We just need to replace u with mel.uncurry : external map : 'a array -> 'b array -> (('a -> 'b -> 'c)[@mel.uncurry]) -> 'c array = \"map\" external map: (array('a), array('b), [@mel.uncurry] (('a, 'b) => 'c)) => array('c) = \"map\"; Now if we try to call map with a regular add function: let add x y = x + y let _ = map [||] [||] add let add = (x, y) => x + y; let _ = map([||], [||], add); Everything works fine now, without having to attach any attributes to add . The main difference between u and mel.uncurry is that the latter only works with externals. mel.uncurry is the recommended option to use for bindings, while u remains useful for those use cases where performance is crucial and we want the JavaScript functions generated from OCaml ones to not be applied partially. Modeling this -based Callbacks Many JavaScript libraries have callbacks which rely on the this keyword , for example: x.onload = function(v) { console.log(this.response + v) } Inside the x.onload callback, this would be pointing to x . It would not be correct to declare x.onload of type unit -> unit . Instead, Melange introduces a special attribute, mel.this , which allows to type x as this: type x external x : x = \"x\" external set_onload : x -> ((x -> int -> unit)[@mel.this]) -> unit = \"onload\" [@@mel.set] external resp : x -> int = \"response\" [@@mel.get] let _ = set_onload x begin fun [@mel.this] o v -> Js.log (resp o + v) end type x; external x: x = \"x\"; [@mel.set] external set_onload: (x, [@mel.this] ((x, int) => unit)) => unit = \"onload\"; [@mel.get] external resp: x => int = \"response\"; let _ = set_onload(x, [@mel.this] (o, v) => Js.log(resp(o) + v)); Which generates: x.onload = function (v) { var o = this; console.log((o.response + v) | 0); }; Note that the first argument will be reserved for this . Wrapping returned nullable values JavaScript models null and undefined differently, whereas it can be useful to treat both as 'a option option('a) in Melange. Melange understands the mel.return attribute in externals to model how nullable return types should be wrapped at the bindings boundary. An external value with mel.return converts the return value to an option type, avoiding the need for extra wrapping / unwrapping with functions such as Js.Nullable.toOption . type element type document external get_by_id : document -> string -> element option = \"getElementById\" [@@mel.send] [@@mel.return nullable] let test document = let elem = get_by_id document \"header\" in match elem with | None -> 1 | Some _element -> 2 type element; type document; [@mel.send] [@mel.return nullable] external get_by_id: (document, string) => option(element) = \"getElementById\"; let test = document => { let elem = get_by_id(document, \"header\"); switch (elem) { | None => 1 | Some(_element) => 2 }; }; Which generates: function test($$document) { var elem = $$document.getElementById(\"header\"); if (elem == null) { return 1; } else { return 2; } } The mel.return attribute takes an attribute payload, as seen with [@@mel.return nullable] [@mel.return nullable] above. Currently 4 directives are supported: null_to_opt , undefined_to_opt , nullable and identity . nullable is encouraged, as it will convert from null and undefined to option type. identity will make sure that compiler will do nothing about the returned value. It is rarely used, but introduced here for debugging purposes. Generate getters, setters and constructors As we saw in a previous section , there are some types in Melange that compile to values that are not easy to manipulate from JavaScript. To facilitate the communication from JavaScript code with values of these types, Melange includes an attribute deriving that helps generating conversion functions, as well as functions to create values from these types. In particular, for variants and polymorphic variants. Additionally, deriving can be used with record types, to generate setters and getters as well as creation functions. Variants Creating values Use @deriving accessors on a variant type to create constructor values for each branch. type action = | Click | Submit of string | Cancel [@@deriving accessors] [@deriving accessors] type action = | Click | Submit(string) | Cancel; Melange will generate one let definition for each variant tag, implemented as follows: For variant tags with payloads, it will be a function that takes the payload value as a parameter. For variant tags without payloads, it will be a constant with the runtime value of the tag. Given the action type definition above, annotated with deriving , Melange will generate something similar to the following code: type action = | Click | Submit of string | Cancel let click = (Click : action) let submit param = (Submit param : action) let cancel = (Cancel : action) type action = | Click | Submit(string) | Cancel; let click: action = Click; let submit = (param): action => Submit(param); let cancel: action = Cancel; Which will result in the following JavaScript code after compilation: function submit(param_0) { return /* Submit */{ _0: param_0 }; } var click = /* Click */0; var cancel = /* Cancel */1; Note the generated definitions are lower-cased, and they can be safely used from JavaScript code. For example, if the above JavaScript generated code was located in a generators.js file, the definitions can be used like this: const generators = require('./generators.js'); const hello = generators.submit(\"Hello\"); const click = generators.click; Conversion functions Use @deriving jsConverter on a variant type to create converter functions that allow to transform back and forth between JavaScript integers and Melange variant values. There are a few differences with @deriving accessors : jsConverter works with the mel.as attribute, while accessors does not jsConverter does not support variant tags with payload, while accessors does jsConverter generates functions to transform values back and forth, while accessors generates functions to create values Let\u2019s see a version of the previous example, adapted to work with jsConverter given the constraints above: type action = | Click | Submit [@mel.as 3] | Cancel [@@deriving jsConverter] [@deriving jsConverter] type action = | Click | [@mel.as 3] Submit | Cancel; This will generate a couple of functions with the following types: val actionToJs : action -> int val actionFromJs : int -> action option external actionToJs: action => int = ; external actionFromJs: int => option(action) = ; actionToJs returns integers from values of action type. It will start with 0 for Click , 3 for Submit (because it was annotated with mel.as ), and then 4 for Cancel , in the same way that we described when using mel.int with polymorphic variants . actionFromJs returns a value of type option , because not every integer can be converted into a variant tag of the action type. Hide runtime types For extra type safety, we can hide the runtime representation of variants ( int ) from the generated functions, by using jsConverter { newType } payload with @deriving : type action = | Click | Submit [@mel.as 3] | Cancel [@@deriving jsConverter { newType }] [@deriving jsConverter({newType: newType})] type action = | Click | [@mel.as 3] Submit | Cancel; This feature relies on abstract types to hide the JavaScript runtime representation. It will generate functions with the following types: val actionToJs : action -> abs_action val actionFromJs : abs_action -> action external actionToJs: action => abs_action = ; external actionFromJs: abs_action => action = ; In the case of actionFromJs , the return value, unlike the previous case, is not an option type. This is an example of \"correct by construction\": the only way to create an abs_action is by calling the actionToJs function. Polymorphic variants The @deriving jsConverter attribute is applicable to polymorphic variants as well. NOTE: Similarly to variants, the @deriving jsConverter attribute cannot be used when the polymorphic variant tags have payloads. Refer to the section on runtime representation to learn more about how polymorphic variants are represented in JavaScript. Let\u2019s see an example: type action = [ `Click | `Submit [@mel.as \"submit\"] | `Cancel ] [@@deriving jsConverter] [@deriving jsConverter] type action = [ | `Click | [@mel.as \"submit\"] `Submit | `Cancel]; Akin to the variant example, the following two functions will be generated: val actionToJs : action -> string val actionFromJs : string -> action option external actionToJs: action => string = ; external actionFromJs: string => option(action) = ; The jsConverter { newType } payload can also be used with polymorphic variants. Records Accessing fields Use @deriving accessors on a record type to create accessor functions for its record field names. type pet = { name : string } [@@deriving accessors] let pets = [| { name = \"Brutus\" }; { name = \"Mochi\" } |] let () = pets |. Belt.Array.map name |. Js.Array2.joinWith \"&\" |. Js.log [@deriving accessors] type pet = {name: string}; let pets = [|{name: \"Brutus\"}, {name: \"Mochi\"}|]; let () = pets->(Belt.Array.map(name))->(Js.Array2.joinWith(\"&\"))->Js.log; Melange will generate a function for each field defined in the record. In this case, a function name that allows to get that field from any record of type pet : let name (param : pet) = param.name let name = (param: pet) => param.name; Considering all the above, the produced JavaScript will be: function name(param) { return param.name; } var pets = [ { name: \"Brutus\" }, { name: \"Mochi\" } ]; console.log(Belt_Array.map(pets, name).join(\"&\")); Convert records into abstract types When binding to JavaScript objects, it is generally recommended to use records since Melange precisely uses objects as their runtime representation. This approach was discussed in the section about binding to JavaScript objects . But there\u2019s a specific case where records may not be enough: when we want to emit a JavaScript object where some of the keys might be present or absent. For instance, consider the following record: type person = { name : string; age : int option; } type person = { name: string, age: option(int), }; An example of this use-case would be expecting { name = \"John\"; age = None } to generate a JavaScript such as {name: \"Carl\"} , where the age key doesn\u2019t appear. The @deriving abstract attribute exists to solve this problem. When present in a record type, @deriving abstract makes the record definition abstract and generates the following functions instead: A constructor function for creating values of the type Getters and setters for accessing the record fields @deriving abstract effectively models a record-shaped JavaScript object exclusively through a set of (generated) functions derived from attribute annotations on the OCaml type definition. Let\u2019s see an example. Considering this Melange code: type person = { name : string; age : int option; [@optional] } [@@deriving abstract] [@deriving abstract] type person = { name: string, [@optional] age: option(int), }; Melange will make the person type abstract and generate constructor, getter and setter functions. In our example, the OCaml signature would look like this after preprocessing: type person val person : name:string -> ?age:int -> unit -> person val nameGet : person -> string val ageGet : person -> int option type person; external person: (~name: string, ~age: int=?, unit) => person = ; external nameGet: person => string = ; external ageGet: person => option(int) = ; The person function can be used to create values of person . It is the only possible way to create values of this type, since Melange makes it abstract. Using literals like { name = \"Alice\"; age = None } directly doesn\u2019t type check. Here is an example of how we can use it: let alice = person ~name:\"Alice\" ~age:20 () let bob = person ~name:\"Bob\" () let alice = person(~name=\"Alice\", ~age=20, ()); let bob = person(~name=\"Bob\", ()); This will generate the following JavaScript code. Note how there is no JavaScript runtime overhead: var alice = { name: \"Alice\", age: 20 }; var bob = { name: \"Bob\" }; The person function uses labeled arguments to represent record fields. Because there is an optional argument age , it takes a last argument of type unit . This non-labeled argument allows to omit the optional argument on function application. Further details about optional labeled arguments can be found in the corresponding section of the OCaml manual . The functions nameGet and ageGet are accessors for each record field: let twenty = ageGet alice let bob = nameGet bob let twenty = ageGet(alice); let bob = nameGet(bob); This generates: var twenty = alice.age; var bob = bob.name; The functions are named by appending Get to the field names of the record to prevent potential clashes with other values within the module. If shorter names are preferred for the getter functions, there is an alternate { abstract = light } payload that can be passed to deriving : type person = { name : string; age : int; } [@@deriving abstract { light }] let alice = person ~name:\"Alice\" ~age:20 let aliceName = name alice [@deriving abstract({light: light})] type person = { name: string, age: int, }; let alice = person(~name=\"Alice\", ~age=20); let aliceName = name(alice); Which generates: var alice = { name: \"Alice\", age: 20 }; var aliceName = alice.name; In this example, the getter functions share the same names as the object fields. Another distinction from the previous example is that the person constructor function no longer requires the final unit argument since we have excluded the optional field in this case. NOTE: The mel.as attribute can still be applied to record fields when the record type is annotated with deriving , allowing for the renaming of fields in the resulting JavaScript objects, as demonstrated in the section about binding to objects with static shape . However, the option to pass indices to the mel.as decorator (like [@mel.as \"0\"] ) to change the runtime representation to an array is not available when using deriving . Compatibility with OCaml features The @deriving abstract attribute and its lightweight variant can be used with mutable fields and private types , which are features inherited by Melange from OCaml. When the record type has mutable fields, Melange will generate setter functions for them. For example: type person = { name : string; mutable age : int; } [@@deriving abstract] let alice = person ~name:\"Alice\" ~age:20 let () = ageSet alice 21 [@deriving abstract] type person = { name: string, mutable age: int, }; let alice = person(~name=\"Alice\", ~age=20); let () = ageSet(alice, 21); This will generate: var alice = { name: \"Alice\", age: 20 }; alice.age = 21; If the mutable keyword is omitted from the interface file, Melange will not include the setter function in the module signature, preventing other modules from mutating any values from the type. Private types can be used to prevent Melange from creating the constructor function. For example, if we define person type as private: type person = private { name : string; age : int; } [@@deriving abstract] [@deriving abstract] type person = pri { name: string, age: int, }; The accessors nameGet and ageGet will still be generated, but not the constructor person . This is useful when binding to JavaScript objects while preventing any Melange code from creating values of such type. Use Melange code from JavaScript As mentioned in the build system section , Melange allows to produce both CommonJS and ES6 modules. In both cases, using Melange-generated JavaScript code from any hand-written JavaScript file works as expected. The following definition: let print name = \"Hello\" ^ name let print = name => \"Hello\" ++ name; Will generate this JavaScript code, when using CommonJS (the default): function print(name) { return \"Hello\" + name; } exports.print = print; When using ES6 (through the (module_systems es6) field in melange.emit ) this code will be generated: function print(name) { return \"Hello\" + name; } export { print , } So one can use either require or import (depending on the module system of choice) to import the print value in a JavaScript file. Default ES6 values One special case occur when working with JavaScript imports in ES6 modules that look like this: import ten from 'numbers.js'; This import expects numbers.js to have a default export, like: export default ten = 10; To emulate this kind of exports from Melange, one just needs to define a default value. For example, in a file named numbers.ml numbers.re : let default = 10 let default = 10; That way, Melange will set the value on the default export so it can be consumed as default import on the JavaScript side.","title":"Communicate with JavaScript"},{"location":"communicate-with-javascript/#communicate-with-javascript","text":"Melange interoperates very well with JavaScript, and provides a wide array of features to consume foreign JavaScript code. To learn about these techniques, we will first go through the language concepts that they build upon, then we will see how types in Melange map to JavaScript runtime types. Finally, we will provide a variety of use cases with examples to show how to communicate to and from JavaScript.","title":"Communicate with JavaScript"},{"location":"communicate-with-javascript/#language-concepts","text":"The concepts covered in the following sections are a small subset of the OCaml language. However, they are essential for understanding how to communicate with JavaScript, and the features that Melange exposes to do so.","title":"Language concepts"},{"location":"communicate-with-javascript/#attributes-and-extension-nodes","text":"In order to interact with JavaScript, Melange needs to extend the language to provide blocks that express these interactions. One approach could be to introduce new syntactic constructs (keywords and such) to do so, for example: javascript add : int -> int -> int = {|function(x,y){ return x + y }|} But this would break compatibility with OCaml, which is one of the main goals of Melange. Fortunately, OCaml provides mechanisms to extend its language without breaking compatibility with the parser or the language. These mechanisms are composed by two parts: First, some syntax additions to define parts of the code that will be extended or replaced Second, compile-time OCaml native programs called PPX rewriters , that will read the syntax additions defined above and proceed to extend or replace them The syntax additions come in two flavors, called extension nodes and attributes .","title":"Attributes and extension nodes"},{"location":"communicate-with-javascript/#extension-nodes","text":"Extension nodes are blocks that are supposed to be replaced by a specific type of PPX rewriters called extenders. Extension nodes use the % character to be identified. Extenders will take the extension node and replace it with a valid OCaml AST (abstract syntax tree). An example where Melange uses extension nodes to communicate with JavaScript is to produce \"raw\" JavaScript inside a Melange program: [%%mel.raw \"var a = 1; var b = 2\"] let add = [%mel.raw \"a + b\"] [%%mel.raw \"var a = 1; var b = 2\"]; let add = [%mel.raw \"a + b\"]; Which will generate the following JavaScript code: var a = 1; var b = 2 var add = a + b The difference between one and two percentage characters is detailed in the OCaml documentation .","title":"Extension nodes"},{"location":"communicate-with-javascript/#attributes","text":"Attributes are \"decorations\" applied to specific parts of the code to provide additional information. In Melange, attributes are used in two ways to enhance the expressiveness of generating JavaScript code: either reusing existing OCaml built-in attributes or defining new ones.","title":"Attributes"},{"location":"communicate-with-javascript/#reusing-ocaml-attributes","text":"The first approach is leveraging the existing OCaml\u2019s built-in attributes to be used for JavaScript generation. One prominent example of OCaml attributes that can be used in Melange projects is the unboxed attribute, which optimizes the compilation of single-field records and variants with a single tag to their raw values. This is useful when defining type aliases that we don\u2019t want to mix up, or when binding to JavaScript code that uses heterogeneous collections. An example of the latter is discussed in the variadic function arguments section. For instance: type name = | Name of string [@@unboxed] let student_name = Name \"alice\" [@unboxed] type name = | Name(string); let student_name = Name(\"alice\"); Compiles into: var student_name = \"alice\"; Other OCaml pre-built attributes like alert or deprecated can be used with Melange as well.","title":"Reusing OCaml attributes"},{"location":"communicate-with-javascript/#defining-new-attributes","text":"The second approach is introducing new attributes specifically designed for Melange, such as the mel.set attribute used to bind to properties of JavaScript objects. The complete list of attributes introduced by Melange can be found here . Attribute annotations can use one, two or three @ characters depending on their placement in the code and which kind of syntax tree node they are annotating. More information about attributes can be found in the dedicated OCaml manual page . Here are some samples using Melange attributes mel.set and mel.as : type document external setTitleDom : document -> string -> unit = \"title\" [@@mel.set] type t = { age : int; [@mel.as \"a\"] name : string; [@mel.as \"n\"] } type document; [@mel.set] external setTitleDom: (document, string) => unit = \"title\"; type t = { [@mel.as \"a\"] age: int, [@mel.as \"n\"] name: string, }; To learn more about preprocessors, attributes and extension nodes, check the section about PPX rewriters in the OCaml docs.","title":"Defining new attributes"},{"location":"communicate-with-javascript/#external-functions","text":"Most of the system that Melange exposes to communicate with JavaScript is built on top of an OCaml language construct called external . external is a keyword for declaring a value in OCaml that will interface with C code : external my_c_function : int -> string = \"someCFunctionName\" external my_c_function: int => string = \"someCFunctionName\"; It is like a let binding, except that the body of an external is a string. That string has a specific meaning depending on the context. For native OCaml, it usually refers to a C function with that name. For Melange, it refers to the functions or values that exist in the runtime JavaScript code, and will be used from Melange. In Melange, externals can be used to bind to global JavaScript objects . They can also be decorated with certain [@mel.xxx] attributes to facilitate the creation of bindings in specific scenarios. Each one of the available attributes will be further explained in the next sections. Once declared, one can use an external as a normal value. Melange external functions are turned into the expected JavaScript values, inlined into their callers during compilation, and completely erased afterwards. They don\u2019t appear in the JavaScript output, so there are no costs on bundling size. Note : it is recommended to use external functions and the [@mel.xxx] attributes in the interface files as well, as this allows some optimizations where the resulting JavaScript values can be directly inlined at the call sites.","title":"External functions"},{"location":"communicate-with-javascript/#special-identity-external","text":"One external worth mentioning is the following one: type foo = string type bar = int external danger_zone : foo -> bar = \"%identity\" type foo = string; type bar = int; external danger_zone: foo => bar = \"%identity\"; This is a final escape hatch which does nothing but convert from the type foo to bar . In the following sections, if you ever fail to write an external , you can fall back to using this one. But try not to.","title":"Special identity external"},{"location":"communicate-with-javascript/#abstract-types","text":"In the subsequent sections, you will come across examples of bindings where a type is defined without being assigned to a value. Here is an example: type document type document; These types are referred to as \"abstract types\" and are commonly used together with external functions that define operations over values when communicating with JavaScript. Abstract types enable defining types for specific values originating from JavaScript while omitting unnecessary details. An illustration is the document type mentioned earlier, which has several properties . By using abstract types, one can focus solely on the required aspects of the document value that the Melange program requires, rather than defining all its properties. Consider the following example: type document external document : document = \"document\" external set_title : document -> string -> unit = \"title\" [@@mel.set] type document; external document: document = \"document\"; [@mel.set] external set_title: (document, string) => unit = \"title\"; Subsequent sections delve into the details about the mel.set attribute and how to bind to global values like document . For a comprehensive understanding of abstract types and their usefulness, refer to the \"Encapsulation\" section of the OCaml Cornell textbook .","title":"Abstract types"},{"location":"communicate-with-javascript/#pipe-operators","text":"There are two pipe operators available in Melange: A pipe last operator |> , available in OCaml and inherited in Melange A pipe first operator |. -> , available exclusively in Melange Let\u2019s see the differences between the two.","title":"Pipe operators"},{"location":"communicate-with-javascript/#pipe-last","text":"Since version 4.01, OCaml includes a reverse application or \"pipe\" ( |> ) operator, an infix operator that applies the result from the previous expression the next function. As a backend for OCaml, Melange inherits this operator. The pipe operator could be implemented like this (the real implementation is a bit different ): let ( |> ) f g = g f let (|>) = (f, g) => g(f); This operator is useful when multiple functions are applied to some value in sequence, with the output of each function becoming the input of the next (a pipeline ). For example, assuming we have a function square defined as: let square x = x * x let square = x => x * x; We are using it like: let ten = succ (square 3) let ten = succ(square(3)); The pipe operator allows to write the computation for ten in left-to-right order, as it has left associativity : let ten = 3 |> square |> succ let ten = 3 |> square |> succ; When working with functions that can take multiple arguments, the pipe operator works best when the functions take the data we are processing as the last argument. For example: let sum = List.fold_left ( + ) 0 let sum_sq = [ 1; 2; 3 ] |> List.map square (* [1; 4; 9] *) |> sum (* 1 + 4 + 9 *) let sum = List.fold_left((+), 0); let sum_sq = [1, 2, 3] |> List.map(square) /* [1; 4; 9] */ |> sum; /* 1 + 4 + 9 */ The above example can be written concisely because the List.map function in the OCaml standard library takes the list as the second argument. This convention is sometimes referred to as \"data-last\", and is widely adopted in the OCaml ecosystem. Data-last and the pipe operator |> work great with currying, so they are a great fit for the language. However, there are some limitations when using data-last when it comes to error handling. In the given example, if we mistakenly used the wrong function: let sum_sq = [ 1; 2; 3 ] |> List.map String.cat |> sum let sum_sq = [1, 2, 3] |> List.map(String.cat) |> sum; The compiler would rightfully raise an error: 4 | [ 1; 2; 3 ] ^ Error: This expression has type int but an expression was expected of type string 1 | [ 1, 2, 3 ] ^ Error: This expression has type int but an expression was expected of type string Note that instead of telling us that we are passing the wrong function in List.map ( String.cat ), the error points to the list itself. This behavior aligns with the way type inference works, as the compiler infers types from left to right. Since [ 1; 2; 3 ] |> List.map String.cat is equivalent to List.map String.cat [ 1; 2; 3 ] , the type mismatch is detected when the list is type checked, after String.cat has been processed. With the goal of addressing this kind of limitations, Melange introduces the pipe first operator |. -> .","title":"Pipe last"},{"location":"communicate-with-javascript/#pipe-first","text":"To overcome the constraints mentioned above, Melange introduces the pipe first operator |. -> . As its name suggests, the pipe first operator is better suited for functions where the data is passed as the first argument. The functions in the Belt library Belt library included with Melange have been designed with the data-first convention in mind, so they work best with the pipe first operator. For example, we can rewrite the example above using Belt.List.map and the pipe first operator: let sum_sq = [ 1; 2; 3 ] |. Belt.List.map square |. sum let sum_sq = [1, 2, 3]->(Belt.List.map(square))->sum; We can see the difference on the error we get if the wrong function is passed to Belt.List.map : let sum_sq = [ 1; 2; 3 ] |. Belt.List.map String.cat |. sum let sum_sq = [1, 2, 3]->(Belt.List.map(String.cat))->sum; The compiler will show this error message: 4 | |. Belt.List.map String.cat ^^^^^^^^^^ Error: This expression has type string -> string -> string but an expression was expected of type int -> 'a Type string is not compatible with type int 2 | let sum_sq = [1, 2, 3]->(Belt.List.map(String.cat))->sum; ^^^^^^^^^^ Error: This expression has type string -> string -> string but an expression was expected of type int -> 'a Type string is not compatible with type int The error points now to the function passed to Belt.List.map , which is more natural with the way the code is being written. Melange supports writing bindings to JavaScript using any of the two conventions, data-first or data-last, as shown in the \"Chaining\" section . For further details about the differences between the two operators, the data-first and data-last conventions and the trade-offs between them, one can refer to this related blog post .","title":"Pipe first"},{"location":"communicate-with-javascript/#data-types-and-runtime-representation","text":"This is how each Melange type is converted into JavaScript values: Melange JavaScript int number nativeint number int32 number float number string string array array tuple (3, 4) array [3, 4] bool boolean Js.Nullable.t Js.Nullable.t null / undefined Js.Re.t Js.Re.t RegExp Option.t None undefined Option.t Some( Some .. Some (None)) Some(Some( .. Some(None))) internal representation Option.t Some 2 Some(2) 2 record {x = 1; y = 2} {x: 1; y: 2} object {x: 1, y: 2} int64 array of 2 elements [high, low] high is signed, low unsigned char 'a' -> 97 (ascii code) bytes number array list [] 0 list [ x; y ] [x, y] { hd: x, tl: { hd: y, tl: 0 } } variant See below polymorphic variant See below Variants with a single non-nullary constructor: type tree = Leaf | Node of int * tree * tree (* Leaf -> 0 *) (* Node(7, Leaf, Leaf) -> { _0: 7, _1: 0, _2: 0 } *) type tree = | Leaf | Node(int, tree, tree); /* Leaf -> 0 */ /* Node(7, Leaf, Leaf) -> { _0: 7, _1: 0, _2: 0 } */ Variants with more than one non-nullary constructor: type t = A of string | B of int (* A(\"foo\") -> { TAG: 0, _0: \"Foo\" } *) (* B(2) -> { TAG: 1, _0: 2 } *) type t = | A(string) | B(int); /* A(\"foo\") -> { TAG: 0, _0: \"Foo\" } */ /* B(2) -> { TAG: 1, _0: 2 } */ Polymorphic variants: let u = `Foo (* \"Foo\" *) let v = `Foo(2) (* { NAME: \"Foo\", VAL: \"2\" } *) let u = `Foo; /* \"Foo\" */ let v = `Foo(2); /* { NAME: \"Foo\", VAL: \"2\" } */ Let\u2019s see now some of these types in detail. We will first describe the shared types , which have a transparent representation as JavaScript values, and then go through the non-shared types , that have more complex runtime representations. NOTE: Relying on the non-shared data types runtime representations by reading or writing them manually from JavaScript code that communicates with Melange code might lead to runtime errors, as these representations might change in the future.","title":"Data types and runtime representation"},{"location":"communicate-with-javascript/#shared-types","text":"The following are types that can be shared between Melange and JavaScript almost \"as is\". Specific caveats are mentioned on the sections where they apply.","title":"Shared types"},{"location":"communicate-with-javascript/#strings","text":"JavaScript strings are immutable sequences of UTF-16 encoded Unicode text. OCaml strings are immutable sequences of bytes and nowadays assumed to be UTF-8 encoded text when interpreted as textual content. This is problematic when interacting with JavaScript code, because if one tries to use some unicode characters, like: let () = Js.log \"\u4f60\u597d\" let () = Js.log(\"\u4f60\u597d\"); It will lead to some cryptic console output. To rectify this, Melange allows to define quoted string literals using the js identifier, for example: let () = Js.log {js|\u4f60\u597d\uff0c \u4e16\u754c|js} let () = Js.log({js|\u4f60\u597d\uff0c \u4e16\u754c|js}); For convenience, Melange exposes another special quoted string identifier: j . It is similar to JavaScript\u2019 string interpolation, but for variables only (not arbitrary expressions): let world = {j|\u4e16\u754c|j} let helloWorld = {j|\u4f60\u597d\uff0c$world|j} let world = {j|\u4e16\u754c|j}; let helloWorld = {j|\u4f60\u597d\uff0c$world|j}; You can surround the interpolation variable in parentheses too: {j|\u4f60 \u597d\uff0c$(world)|j} . To work with strings, the Melange standard library provides some utilities in the Stdlib.String module Stdlib.String module . The bindings to the native JavaScript functions to work with strings are in the Js.String module Js.String module .","title":"Strings"},{"location":"communicate-with-javascript/#floating-point-numbers","text":"OCaml floats are IEEE 754 with a 53-bit mantissa and exponents from -1022 to 1023. This happens to be the same encoding as JavaScript numbers , so values of these types can be used transparently between Melange code and JavaScript code. The Melange standard library provides a Stdlib.Float module Stdlib.Float module . The bindings to the JavaScript APIs that manipulate float values can be found in the Js.Float module Js.Float module .","title":"Floating-point numbers"},{"location":"communicate-with-javascript/#integers","text":"In Melange, integers are limited to 32 bits due to the fixed-width conversion of bitwise operations in JavaScript. While Melange integers compile to JavaScript numbers, treating them interchangeably can result in unexpected behavior due to differences in precision. Even though bitwise operations in JavaScript are constrained to 32 bits, integers themselves are represented using the same floating-point format as numbers , allowing for a larger range of representable integers in JavaScript compared to Melange. When dealing with large numbers, it is advisable to use floats instead. For instance, floats are used in bindings like Js.Date . The Melange standard library provides a Stdlib.Int module Stdlib.Int module . The bindings to work with JavaScript integers are in the Js.Int module Js.Int module .","title":"Integers"},{"location":"communicate-with-javascript/#arrays","text":"Melange arrays compile to JavaScript arrays. But note that unlike JavaScript arrays, all the values in a Melange array need to have the same type. Another difference is that OCaml arrays are fixed-sized, but on Melange side this constraint is relaxed. You can change an array\u2019s length using functions like Js.Array.push , available in the bindings to the JavaScript APIs in the Js.Array module Js.Array module . Melange standard library also has a module to work with arrays, available in the Stdlib.Array module Stdlib.Array module .","title":"Arrays"},{"location":"communicate-with-javascript/#tuples","text":"OCaml tuples are compiled to JavaScript arrays. This is convenient when writing bindings that will use a JavaScript array with heterogeneous values, but that happens to have a fixed length. As a real world example of this can be found in ReasonReact , the Melange bindings for React . In these bindings, component effects dependencies are represented as OCaml tuples, so they get compiled cleanly to JavaScript arrays by Melange. For example, some code like this: let () = React.useEffect2 (fun () -> None) (foo, bar) let () = React.useEffect2(() => None, (foo, bar)); Will produce: React.useEffect(function () {}, [foo, bar]);","title":"Tuples"},{"location":"communicate-with-javascript/#booleans","text":"Values of type bool compile to JavaScript booleans.","title":"Booleans"},{"location":"communicate-with-javascript/#records","text":"Melange records map directly to JavaScript objects. If the record fields include non-shared data types (like variants), these values should be transformed separately, and not be directly used in JavaScript. Extensive documentation about interfacing with JavaScript objects using records can be found in the section below .","title":"Records"},{"location":"communicate-with-javascript/#regular-expressions","text":"Regular expressions created using the %mel.re extension node compile to their JavaScript counterpart. For example: let r = [%mel.re \"/b/g\"] let r = [%mel.re \"/b/g\"]; Will compile to: var r = /b/g; A regular expression like the above is of type Js.Re.t . The Js.Re module Js.Re module provides the bindings to the JavaScript functions that operate over regular expressions.","title":"Regular expressions"},{"location":"communicate-with-javascript/#non-shared-data-types","text":"The following types differ too much between Melange and JavaScript, so while they can always be manipulated from JavaScript, it is recommended to transform them before doing so. Variants and polymorphic variants: Better transform them into readable JavaScript values before manipulating them from JavaScript, Melange provides some helpers to do so. Exceptions Option (a variant type): Better use the Js.Nullable.fromOption and Js.Nullable.toOption functions in the Js.Nullable module Js.Nullable module to transform them into either null or undefined values. List (also a variant type): use Array.of_list and Array.to_list in the Stdlib.Array module Stdlib.Array module . Character Int64 Lazy values","title":"Non-shared data types"},{"location":"communicate-with-javascript/#list-of-attributes-and-extension-nodes","text":"Attributes: These attributes are used to annotate external definitions: mel.get : read JavaScript object properties statically by name, using the dot notation . mel.get_index : read a JavaScript object\u2019s properties dynamically by using the bracket notation [] mel.module : bind to a value from a JavaScript module mel.new : bind to a JavaScript class constructor mel.obj : create a JavaScript object mel.return : automate conversion from nullable values to Option.t values mel.send : call a JavaScript object method using pipe first convention mel.send.pipe : call a JavaScript object method using pipe last convention mel.set : set JavaScript object properties statically by name, using the dot notation . mel.set_index : set JavaScript object properties dynamically by using the bracket notation [] mel.scope : reach to deeper properties inside a JavaScript object mel.splice : a deprecated attribute, is an alternate form of mel.variadic mel.variadic : bind to a function taking variadic arguments from an array These attributes are used to annotate arguments in external definitions: u : define function arguments as uncurried (manual) mel.int : compile function argument to an int mel.string : compile function argument to a string mel.this : bind to this based callbacks mel.uncurry : define function arguments as uncurried (automated) mel.unwrap : unwrap variant values These attributes are used in places like records, fields, arguments, functions, and more: mel.as : redefine the name generated in the JavaScript output code. Used in constant function arguments , variants , polymorphic variants (either inlined in external functions or in type definitions ) and record fields . deriving : generate getters and setters for some types mel.inline : forcefully inline constant values optional : omit fields in a record (combines with deriving ) Extension nodes: In order to use any of these extension nodes, you will have to add the melange PPX preprocessor to your project. To do so, add the following to the dune file: (library (name lib) (modes melange) (preprocess (pps melange.ppx))) The same field preprocess can be added to melange.emit . Here is the list of all the extension nodes supported by Melange: mel.debugger : insert debugger statements mel.external : read global values mel.obj : create JavaScript object literals mel.raw : write raw JavaScript code mel.re : insert regular expressions","title":"List of attributes and extension nodes"},{"location":"communicate-with-javascript/#generate-raw-javascript","text":"It is possible to directly write JavaScript code from a Melange file. This is unsafe, but it can be useful for prototyping or as an escape hatch. To do it, we will use the mel.raw extension : let add = [%mel.raw {| function(a, b) { console.log(\"hello from raw JavaScript!\"); return a + b; } |}] let () = Js.log (add 1 2) let add = [%mel.raw {| function(a, b) { console.log(\"hello from raw JavaScript!\"); return a + b; } |} ]; let () = Js.log(add(1, 2)); The {||} strings are called \"quoted strings\" . They are similar to JavaScript\u2019s template literals, in the sense that they are multi-line, and there is no need to escape characters inside the string. Using one percentage sign the extension name between square brackets ( [%mel.raw <string>] ) is useful to define expressions (function bodies, or other values) where the implementation is directly JavaScript. This is useful as we can attach the type signature already in the same line, to make our code safer. For example: let f : unit -> int = [%mel.raw \"function() {return 1}\"] let f: unit => int = ([%mel.raw \"function() {return 1}\"]: unit => int); Using two percentage signs ( [%%mel.raw <string>] ) the extension name without square brackets ( %mel.raw <string> ) is reserved for definitions in a structure or signature . For example: [%%mel.raw \"var a = 1\"] [%%mel.raw \"var a = 1\"];","title":"Generate raw JavaScript"},{"location":"communicate-with-javascript/#debugger","text":"Melange allows you to inject a debugger; expression using the mel.debugger extension: let f x y = [%mel.debugger]; x + y let f = (x, y) => { [%mel.debugger]; x + y; }; Output: function f (x,y) { debugger; // JavaScript developer tools will set a breakpoint and stop here return x + y | 0; }","title":"Debugger"},{"location":"communicate-with-javascript/#detect-global-variables","text":"Melange provides a relatively type safe approach to use globals that might be defined either in the JavaScript runtime environment: mel.external . [%mel.external id] will check if the JavaScript value id is undefined or not, and return an Option.t value accordingly. For example: let () = match [%mel.external __DEV__] with | Some _ -> Js.log \"dev mode\" | None -> Js.log \"production mode\" let () = switch ([%mel.external __DEV__]) { | Some(_) => Js.log(\"dev mode\") | None => Js.log(\"production mode\") }; Another example: let () = match [%mel.external __filename] with | Some f -> Js.log f | None -> Js.log \"non-node environment\" let () = switch ([%mel.external __filename]) { | Some(f) => Js.log(f) | None => Js.log(\"non-node environment\") };","title":"Detect global variables"},{"location":"communicate-with-javascript/#inlining-constant-values","text":"Some JavaScript idioms require special constants to be inlined since they serve as de-facto directives for bundlers. A common example is process.env.NODE_ENV : if (process.env.NODE_ENV !== \"production\") { // Development-only code } becomes: if (\"development\" !== \"production\") { // Development-only code } In this case, bundlers such as Webpack can tell that the if statement always evaluates to a specific branch and eliminate the others. Melange provides the mel.inline attribute to achieve the same goal in generated JavaScript. Let\u2019s look at an example: external node_env : string = \"NODE_ENV\" [@@mel.scope \"process\", \"env\"] let development = \"development\" let () = if node_env <> development then Js.log \"Only in Production\" let development_inline = \"development\" [@@mel.inline] let () = if node_env <> development_inline then Js.log \"Only in Production\" [@mel.scope (\"process\", \"env\")] external node_env: string = \"NODE_ENV\"; let development = \"development\"; let () = if (node_env != development) { Js.log(\"Only in Production\"); }; [@mel.inline] let development_inline = \"development\"; let () = if (node_env != development_inline) { Js.log(\"Only in Production\"); }; As we can see in the generated JavaScript presented below: the development variable is emitted it gets used as a variable process.env.NODE_ENV !== development in the if statement the development_inline variable isn\u2019t present in the final output its value is inlined in the if statement: process.env.NODE_ENV !== \"development\" var development = \"development\"; if (process.env.NODE_ENV !== development) { console.log(\"Only in Production\"); } if (process.env.NODE_ENV !== \"development\") { console.log(\"Only in Production\"); }","title":"Inlining constant values"},{"location":"communicate-with-javascript/#bind-to-javascript-objects","text":"JavaScript objects are used in a variety of use cases: As a fixed shape record . As a map or dictionary. As a class. As a module to import/export. Melange separates the binding methods for JavaScript objects based on these four use cases. This section documents the first three. Binding to JavaScript module objects is described in the \"Using functions from other JavaScript modules\" section.","title":"Bind to JavaScript objects"},{"location":"communicate-with-javascript/#objects-with-static-shape-record-like","text":"","title":"Objects with static shape (record-like)"},{"location":"communicate-with-javascript/#using-ocaml-records","text":"If your JavaScript object has fixed fields, then it\u2019s conceptually like an OCaml record . Since Melange compiles records into JavaScript objects, the most common way to bind to JavaScript objects is using records. type person = { name : string; friends : string array; age : int; } external john : person = \"john\" [@@mel.module \"MySchool\"] let john_name = john.name type person = { name: string, friends: array(string), age: int, }; [@mel.module \"MySchool\"] external john: person = \"john\"; let john_name = john.name; This is the generated JavaScript: var MySchool = require(\"MySchool\"); var john_name = MySchool.john.name; External functions are documented in a previous section . The mel.module attribute is documented here . If you want or need to use different field names on the Melange and the JavaScript sides, you can use the mel.as decorator: type action = { type_ : string [@mel.as \"type\"] } let action = { type_ = \"ADD_USER\" } type action = { [@mel.as \"type\"] type_: string, }; let action = {type_: \"ADD_USER\"}; Which generates the JavaScript code: var action = { type: \"ADD_USER\" }; This is useful to map to JavaScript attribute names that cannot be expressed in Melange, for example, where the JavaScript name we want to generate is a reserved keyword . It is also possible to map a Melange record to a JavaScript array by passing indices to the mel.as decorator: type t = { foo : int; [@mel.as \"0\"] bar : string; [@mel.as \"1\"] } let value = { foo = 7; bar = \"baz\" } type t = { [@mel.as \"0\"] foo: int, [@mel.as \"1\"] bar: string, }; let value = {foo: 7, bar: \"baz\"}; And its JavaScript generated code: var value = [ 7, \"baz\" ];","title":"Using OCaml records"},{"location":"communicate-with-javascript/#using-jst-objects","text":"Alternatively to records, Melange offers another type that can be used to produce JavaScript objects. This type is 'a Js.t , where 'a is an OCaml object . The advantage of objects versus records is that no type declaration is needed in advance, which can be helpful for prototyping or quickly generating JavaScript object literals. Melange provides some ways to create Js.t object values, as well as accessing the properties inside them. To create values, the [%mel.obj] extension is used, and the ## infix operator allows to read from the object properties: let john = [%mel.obj { name = \"john\"; age = 99 }] let t = john##name let john = {\"name\": \"john\", \"age\": 99}; let t = john##name; Which generates: var john = { name: \"john\", age: 99 }; var t = john.name; Note that object types allow for some flexibility that the record types do not have. For example, an object type can be coerced to another with fewer values or methods, while it is impossible to coerce a record type to another one with fewer fields. So different object types that share some methods can be mixed in a data structure where only their common methods are visible. To give an example, one can create a function that operates in all the object types that include a field name that is of type string, e.g.: let name_extended obj = obj##name ^ \" wayne\" let one = name_extended [%mel.obj { name = \"john\"; age = 99 }] let two = name_extended [%mel.obj { name = \"jane\"; address = \"1 infinite loop\" }] let name_extended = obj => obj##name ++ \" wayne\"; let one = name_extended({\"name\": \"john\", \"age\": 99}); let two = name_extended({\"name\": \"jane\", \"address\": \"1 infinite loop\"}); To read more about objects and polymorphism we recommend checking the OCaml docs or the OCaml manual .","title":"Using Js.t objects"},{"location":"communicate-with-javascript/#using-external-functions","text":"We have already explored one approach for creating JavaScript object literals by using Js.t values and the mel.obj extension . Melange additionally offers the mel.obj attribute, which can be used in combination with external functions to create JavaScript objects. When these functions are called, they generate objects with fields corresponding to the labeled arguments of the function. If any of these labeled arguments are defined as optional and omitted during function application, the resulting JavaScript object will exclude the corresponding fields. This allows to create runtime objects and control whether optional keys are emitted at runtime. For example, assuming we need to bind to a JavaScript object like this: var homeRoute = { type: \"GET\", path: \"/\", action: () => console.log(\"Home\"), // options: ... }; The first three fields are required and the options field is optional. You can declare a binding function like: external route : _type:string -> path:string -> action:(string list -> unit) -> ?options:< .. > -> unit -> _ = \"\" [@@mel.obj] [@mel.obj] external route: ( ~_type: string, ~path: string, ~action: list(string) => unit, ~options: {..}=?, unit ) => _; Note that the empty string at the end of the function is used to make it syntactically valid. The value of this string is ignored by the compiler. Since there is an optional argument options , an additional unlabeled argument of type unit is included after it. It allows to omit the optional argument on function application. More information about labeled optional arguments can be found in the OCaml manual . The return type of the function should be left unspecified using the wildcard type _ . Melange will automatically infer the type of the resulting JavaScript object. In the route function, the _type argument starts with an underscore. When binding to JavaScript objects with fields that are reserved keywords in OCaml, Melange allows the use of an underscore prefix for the labeled arguments. The resulting JavaScript object will have the underscore removed from the field names. This is only required for the mel.obj attribute, while for other cases, the mel.as attribute can be used to rename fields. If we call the function like this: let homeRoute = route ~_type:\"GET\" ~path:\"/\" ~action:(fun _ -> Js.log \"Home\") () let homeRoute = route(~_type=\"GET\", ~path=\"/\", ~action=_ => Js.log(\"Home\"), ()); We get the following JavaScript, which does not include the options field since its argument wasn\u2019t present: var homeRoute = { type: \"GET\", path: \"/\", action: (function (param) { console.log(\"Home\"); }) };","title":"Using external functions"},{"location":"communicate-with-javascript/#bind-to-object-properties","text":"If you need to bind only to the property of a JavaScript object, you can use mel.get and mel.set to access it using the dot notation . : (* Abstract type for the `document` value *) type document external document : document = \"document\" external set_title : document -> string -> unit = \"title\" [@@mel.set] external get_title : document -> string = \"title\" [@@mel.get] let current = get_title document let () = set_title document \"melange\" /* Abstract type for the `document` value */ type document; external document: document = \"document\"; [@mel.set] external set_title: (document, string) => unit = \"title\"; [@mel.get] external get_title: document => string = \"title\"; let current = get_title(document); let () = set_title(document, \"melange\"); This generates: var current = document.title; document.title = \"melange\"; Alternatively, if some dynamism is required on the way the property is accessed, you can use mel.get_index and mel.set_index to access it using the bracket notation [] : type t external create : int -> t = \"Int32Array\" [@@mel.new] external get : t -> int -> int = \"\" [@@mel.get_index] external set : t -> int -> int -> unit = \"\" [@@mel.set_index] let () = let i32arr = (create 3) in set i32arr 0 42; Js.log (get i32arr 0) type t; [@mel.new] external create: int => t = \"Int32Array\"; [@mel.get_index] external get: (t, int) => int; [@mel.set_index] external set: (t, int, int) => unit; let () = { let i32arr = create(3); set(i32arr, 0, 42); Js.log(get(i32arr, 0)); }; Which generates: var i32arr = new Int32Array(3); i32arr[0] = 42; console.log(i32arr[0]);","title":"Bind to object properties"},{"location":"communicate-with-javascript/#objects-with-dynamic-shape-dictionary-like","text":"Sometimes JavaScript objects are used as dictionaries. In these cases: All values stored in the object belong to the same type Key-value pairs can be added or removed at runtime For this particular use case of JavaScript objects, Melange exposes a specific type Js.Dict.t . The values and functions to work with values of this type are defined in the Js.Dict module Js.Dict module , with operations like get , set , etc. Values of the type Js.Dict.t compile to JavaScript objects.","title":"Objects with dynamic shape (dictionary-like)"},{"location":"communicate-with-javascript/#javascript-classes","text":"JavaScript classes are special kinds of objects. To interact with classes, Melange exposes mel.new to emulate e.g. new Date() : type t external create_date : unit -> t = \"Date\" [@@mel.new] let date = create_date () type t; [@mel.new] external create_date: unit => t = \"Date\"; let date = create_date(); Which generates: var date = new Date(); You can chain mel.new and mel.module if the JavaScript class you want to work with is in a separate JavaScript module: type t external book : unit -> t = \"Book\" [@@mel.new] [@@mel.module] let myBook = book () type t; [@mel.new] [@mel.module] external book: unit => t = \"Book\"; let myBook = book(); Which generates: var Book = require(\"Book\"); var myBook = new Book();","title":"JavaScript classes"},{"location":"communicate-with-javascript/#bind-to-javascript-functions-or-values","text":"","title":"Bind to JavaScript functions or values"},{"location":"communicate-with-javascript/#using-global-functions-or-values","text":"Binding to a JavaScript function available globally makes use of external , like with objects. But unlike objects, there is no need to add any attributes: (* Abstract type for `timeoutId` *) type timeoutId external setTimeout : (unit -> unit) -> int -> timeoutId = \"setTimeout\" external clearTimeout : timeoutId -> unit = \"clearTimeout\" let id = setTimeout (fun () -> Js.log \"hello\") 100 let () = clearTimeout id /* Abstract type for `timeoutId` */ type timeoutId; external setTimeout: (unit => unit, int) => timeoutId = \"setTimeout\"; external clearTimeout: timeoutId => unit = \"clearTimeout\"; let id = setTimeout(() => Js.log(\"hello\"), 100); let () = clearTimeout(id); NOTE: The bindings to setTimeout and clearTimeout are shown here for learning purposes, but they are already available in the Js.Global module Js.Global module . Generates: var id = setTimeout(function (param) { console.log(\"hello\"); }, 100); clearTimeout(id); Global bindings can also be applied to values: (* Abstract type for `document` *) type document external document : document = \"document\" let document = document /* Abstract type for `document` */ type document; external document: document = \"document\"; let document = document; Which generates: var doc = document;","title":"Using global functions or values"},{"location":"communicate-with-javascript/#using-functions-from-other-javascript-modules","text":"mel.module allows to bind to values that belong to another JavaScript module. It accepts a string with the name of the module, or the relative path to it. external dirname : string -> string = \"dirname\" [@@mel.module \"path\"] let root = dirname \"/User/github\" [@mel.module \"path\"] external dirname: string => string = \"dirname\"; let root = dirname(\"/User/github\"); Generates: var Path = require(\"path\"); var root = Path.dirname(\"/User/github\");","title":"Using functions from other JavaScript modules"},{"location":"communicate-with-javascript/#binding-to-properties-inside-a-module-or-global","text":"For cases when we need to create bindings for a property within a module or a global JavaScript object, Melange provides the mel.scope attribute. For example, if we want to write some bindings for a specific property commands from the vscode package , we can do: type param external executeCommands : string -> param array -> unit = \"\" [@@mel.scope \"commands\"] [@@mel.module \"vscode\"] [@@mel.variadic] let f a b c = executeCommands \"hi\" [| a; b; c |] type param; [@mel.scope \"commands\"] [@mel.module \"vscode\"] [@mel.variadic] external executeCommands: (string, array(param)) => unit; let f = (a, b, c) => executeCommands(\"hi\", [|a, b, c|]); Which compiles to: var Vscode = require(\"vscode\"); function f(a, b, c) { Vscode.commands.executeCommands(\"hi\", a, b, c); } The mel.scope attribute can take multiple arguments as payload, in case we want to reach deeper into the object from the module we are importing. For example: type t external back : t = \"back\" [@@mel.module \"expo-camera\"] [@@mel.scope \"Camera\", \"Constants\", \"Type\"] let camera_type_back = back type t; [@mel.module \"expo-camera\"] [@mel.scope (\"Camera\", \"Constants\", \"Type\")] external back: t = \"back\"; let camera_type_back = back; Which generates: var ExpoCamera = require(\"expo-camera\"); var camera_type_back = ExpoCamera.Camera.Constants.Type.back; It can be used without mel.module , to created scoped bindings to global values: external imul : int -> int -> int = \"imul\" [@@mel.scope \"Math\"] let res = imul 1 2 [@mel.scope \"Math\"] external imul: (int, int) => int = \"imul\"; let res = imul(1, 2); Which produces: var res = Math.imul(1, 2); Or it can be used together with mel.new : type t external create : unit -> t = \"GUI\" [@@mel.new] [@@mel.scope \"default\"] [@@mel.module \"dat.gui\"] let gui = create () type t; [@mel.new] [@mel.scope \"default\"] [@mel.module \"dat.gui\"] external create: unit => t = \"GUI\"; let gui = create(); Which generates: var DatGui = require(\"dat.gui\"); var gui = new (DatGui.default.GUI)();","title":"Binding to properties inside a module or global"},{"location":"communicate-with-javascript/#labeled-arguments","text":"OCaml has labeled arguments , which can also be optional, and work with external as well. Labeled arguments can be useful to provide more information about the arguments of a JavaScript function that is called from Melange. Let\u2019s say we have the following JavaScript function, that we want to call from Melange: // MyGame.js function draw(x, y, border) { // let\u2019s assume `border` is optional and defaults to false } draw(10, 20) draw(20, 20, true) When writing Melange bindings, we can add labeled arguments to make things more clear: external draw : x:int -> y:int -> ?border:bool -> unit -> unit = \"draw\" [@@module \"MyGame\"] let () = draw ~x:10 ~y:20 ~border:true () let () = draw ~x:10 ~y:20 () [@module \"MyGame\"] external draw: (~x: int, ~y: int, ~border: bool=?, unit) => unit = \"draw\"; let () = draw(~x=10, ~y=20, ~border=true, ()); let () = draw(~x=10, ~y=20, ()); Generates: var MyGame = require(\"MyGame\"); MyGame.draw(10, 20, true); MyGame.draw(10, 20, undefined); The generated JavaScript function is the same, but now the usage in Melange is much clearer. Note : in this particular case, a final param of type unit, () must be added after border , since border is an optional argument at the last position. Not having the last param unit would lead to a warning, which is explained in detail in the OCaml documentation . Note that you can freely reorder the labeled arguments when applying the function on the Melange side. The generated code will maintain the original order that was used when declaring the function: external draw : x:int -> y:int -> ?border:bool -> unit -> unit = \"draw\" [@@module \"MyGame\"] let () = draw ~x:10 ~y:20 () let () = draw ~y:20 ~x:10 () [@module \"MyGame\"] external draw: (~x: int, ~y: int, ~border: bool=?, unit) => unit = \"draw\"; let () = draw(~x=10, ~y=20, ()); let () = draw(~y=20, ~x=10, ()); Generates: var MyGame = require(\"MyGame\"); MyGame.draw(10, 20, undefined); MyGame.draw(10, 20, undefined);","title":"Labeled arguments"},{"location":"communicate-with-javascript/#calling-an-object-method","text":"If we need to call a JavaScript method, Melange provides the attribute mel.send . In the following snippets, we will be referring to a type Dom.element , which is provided within the library melange.dom . You can add it to your project by including (libraries melange.dom) to your dune file: (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : document -> string -> Dom.element = \"getElementById\" [@@mel.send] let el = get_by_id document \"my-id\" /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send] external get_by_id: (document, string) => Dom.element = \"getElementById\"; let el = get_by_id(document, \"my-id\"); Generates: var el = document.getElementById(\"my-id\"); When using mel.send , the first argument will be the object that holds the property with the function we want to call. This combines well with the pipe first operator |. -> , see the \"Chaining\" section below. If we want to design our bindings to be used with OCaml pipe last operator |> , there is an alternate mel.send.pipe attribute. Let\u2019s rewrite the example above using it: (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : string -> Dom.element = \"getElementById\" [@@mel.send.pipe: document] let el = get_by_id \"my-id\" document /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send.pipe: document] external get_by_id: string => Dom.element = \"getElementById\"; let el = get_by_id(\"my-id\", document); Generates the same code as mel.send : var el = document.getElementById(\"my-id\");","title":"Calling an object method"},{"location":"communicate-with-javascript/#chaining","text":"It is common to find this kind of API in JavaScript: foo().bar().baz() . This kind of API can be designed with Melange externals. Depending on which convention we want to use, there are two attributes available: For a data-first convention, the mel.send attribute, in combination with the pipe first operator |. -> For a data-last convention, the mel.send.pipe attribute, in combination with OCaml pipe last operator |> . Let\u2019s see first an example of chaining using data-first convention with the pipe first operator |. -> : (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : document -> string -> Dom.element = \"getElementById\" [@@mel.send] external get_by_classname : Dom.element -> string -> Dom.element = \"getElementsByClassName\" [@@mel.send] let el = document |. get_by_id \"my-id\" |. get_by_classname \"my-class\" /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send] external get_by_id: (document, string) => Dom.element = \"getElementById\"; [@mel.send] external get_by_classname: (Dom.element, string) => Dom.element = \"getElementsByClassName\"; let el = document->(get_by_id(\"my-id\"))->(get_by_classname(\"my-class\")); Will generate: var el = document.getElementById(\"my-id\").getElementsByClassName(\"my-class\"); Now with pipe last operator |> : (* Abstract type for the `document` global *) type document external document : document = \"document\" external get_by_id : string -> Dom.element = \"getElementById\" [@@mel.send.pipe: document] external get_by_classname : string -> Dom.element = \"getElementsByClassName\" [@@mel.send.pipe: Dom.element] let el = document |> get_by_id \"my-id\" |> get_by_classname \"my-class\" /* Abstract type for the `document` global */ type document; external document: document = \"document\"; [@mel.send.pipe: document] external get_by_id: string => Dom.element = \"getElementById\"; [@mel.send.pipe: Dom.element] external get_by_classname: string => Dom.element = \"getElementsByClassName\"; let el = document |> get_by_id(\"my-id\") |> get_by_classname(\"my-class\"); Will generate the same JavaScript as the pipe first version: var el = document.getElementById(\"my-id\").getElementsByClassName(\"my-class\");","title":"Chaining"},{"location":"communicate-with-javascript/#variadic-function-arguments","text":"Sometimes JavaScript functions take an arbitrary amount of arguments. For these cases, Melange provides the mel.variadic attribute, which can be attached to the external declaration. However, there is one caveat: all the variadic arguments need to belong to the same type. external join : string array -> string = \"join\" [@@mel.module \"path\"] [@@mel.variadic] let v = join [| \"a\"; \"b\" |] [@mel.module \"path\"] [@mel.variadic] external join: array(string) => string = \"join\"; let v = join([|\"a\", \"b\"|]); Generates: var Path = require(\"path\"); var v = Path.join(\"a\", \"b\"); If more dynamism is needed, there is a way to inject elements with different types in the array and still have Melange compile to JavaScript values that are not wrapped using the OCaml unboxed attribute, which was mentioned in the OCaml attributes section : type hide = Hide : 'a -> hide [@@unboxed] external join : hide array -> string = \"join\" [@@mel.module \"path\"] [@@mel.variadic] let v = join [| Hide \"a\"; Hide 2 |] [@unboxed] type hide = | Hide('a): hide; [@mel.module \"path\"] [@mel.variadic] external join: array(hide) => string = \"join\"; let v = join([|Hide(\"a\"), Hide(2)|]); Compiles to: var Path = require(\"path\"); var v = Path.join(\"a\", 2);","title":"Variadic function arguments"},{"location":"communicate-with-javascript/#bind-to-a-polymorphic-function","text":"Some JavaScript libraries will define functions where the arguments can vary on both type and shape. There are two approaches to bind to those, depending on how dynamic they are.","title":"Bind to a polymorphic function"},{"location":"communicate-with-javascript/#approach-1-multiple-external-functions","text":"If it is possible to enumerate the many forms an overloaded JavaScript function can take, a flexible approach is to bind to each form individually: external drawCat : unit -> unit = \"draw\" [@@mel.module \"MyGame\"] external drawDog : giveName:string -> unit = \"draw\" [@@mel.module \"MyGame\"] external draw : string -> useRandomAnimal:bool -> unit = \"draw\" [@@mel.module \"MyGame\"] [@mel.module \"MyGame\"] external drawCat: unit => unit = \"draw\"; [@mel.module \"MyGame\"] external drawDog: (~giveName: string) => unit = \"draw\"; [@mel.module \"MyGame\"] external draw: (string, ~useRandomAnimal: bool) => unit = \"draw\"; Note how all three externals bind to the same JavaScript function, draw .","title":"Approach 1: Multiple external functions"},{"location":"communicate-with-javascript/#approach-2-polymorphic-variant-melunwrap","text":"In some cases, the function has a constant number of arguments but the type of the argument can vary. For cases like this, we can model the argument as a variant and use the mel.unwrap attribute in the external. Let\u2019s say we want to bind to the following JavaScript function: function padLeft(value, padding) { if (typeof padding === \"number\") { return Array(padding + 1).join(\" \") + value; } if (typeof padding === \"string\") { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } As the padding argument can be either a number or a string, we can use mel.unwrap to define it. It is important to note that mel.unwrap imposes certain requirements on the type it is applied to: It needs to be a polymorphic variant Its definition needs to be inlined Each variant tag needs to have an argument The variant type can not be opened (can\u2019t use > ) external padLeft: string -> ([ `Str of string | `Int of int ] [@mel.unwrap]) -> string = \"padLeft\" let _ = padLeft \"Hello World\" (`Int 4) let _ = padLeft \"Hello World\" (`Str \"Message from Melange: \") external padLeft: (string, [@mel.unwrap] [ | `Str(string) | `Int(int)]) => string = \"padLeft\"; let _ = padLeft(\"Hello World\", `Int(4)); let _ = padLeft(\"Hello World\", `Str(\"Message from Melange: \")); Which produces the following JavaScript: padLeft(\"Hello World\", 4); padLeft(\"Hello World\", \"Message from Melange: \"); As we saw in the Non-shared data types section, we should rather avoid passing variants directly to the JavaScript side. By using mel.unwrap we get the best of both worlds: from Melange we can use variants, while JavaScript gets the raw values inside them.","title":"Approach 2: Polymorphic variant + mel.unwrap"},{"location":"communicate-with-javascript/#using-polymorphic-variants-to-bind-to-enums","text":"Some JavaScript APIs take a limited subset of values as input. For example, Node\u2019s fs.readFileSync second argument can only take a few given string values: \"ascii\" , \"utf8\" , etc. Some other functions can take values from a few given integers, like the createStatusBarItem function in VS Code API, which can take an alignment parameter that can only be 1 or 2 . One could still type these parameters as just string or int , but this would not prevent consumers of the external function from calling it using values that are unsupported by the JavaScript function. Let\u2019s see how we can use polymorphic variants to avoid runtime errors. If the values are strings, we can use the mel.string attribute: external read_file_sync : name:string -> ([ `utf8 | `ascii ][@mel.string]) -> string = \"readFileSync\" [@@mel.module \"fs\"] let _ = read_file_sync ~name:\"xx.txt\" `ascii [@mel.module \"fs\"] external read_file_sync: (~name: string, [@mel.string] [ | `utf8 | `ascii]) => string = \"readFileSync\"; let _ = read_file_sync(~name=\"xx.txt\", `ascii); Which generates: var Fs = require(\"fs\"); Fs.readFileSync(\"xx.txt\", \"ascii\"); This technique can be combined with the mel.as attribute to modify the strings produced from the polymorphic variant values. For example: type document type style external document : document = \"document\" external get_by_id : document -> string -> Dom.element = \"getElementById\" [@@mel.send] external style : Dom.element -> style = \"style\" [@@mel.get] external transition_timing_function : style -> ([ `ease | `easeIn [@mel.as \"ease-in\"] | `easeOut [@mel.as \"ease-out\"] | `easeInOut [@mel.as \"ease-in-out\"] | `linear ] [@mel.string]) -> unit = \"transitionTimingFunction\" [@@mel.set] let element_style = style (get_by_id document \"my-id\") let () = transition_timing_function element_style `easeIn type document; type style; external document: document = \"document\"; [@mel.send] external get_by_id: (document, string) => Dom.element = \"getElementById\"; [@mel.get] external style: Dom.element => style = \"style\"; [@mel.set] external transition_timing_function: ( style, [@mel.string] [ | `ease | [@mel.as \"ease-in\"] `easeIn | [@mel.as \"ease-out\"] `easeOut | [@mel.as \"ease-in-out\"] `easeInOut | `linear ] ) => unit = \"transitionTimingFunction\"; let element_style = style(get_by_id(document, \"my-id\")); let () = transition_timing_function(element_style, `easeIn); This will generate: var element_style = document.getElementById(\"my-id\").style; element_style.transitionTimingFunction = \"ease-in\"; Aside from producing string values, Melange also offers mel.int to produce integer values. mel.int can also be combined with mel.as : external test_int_type : ([ `on_closed | `on_open [@mel.as 20] | `in_bin ][@mel.int]) -> int = \"testIntType\" let value = test_int_type `on_open external test_int_type: ([@mel.int] [ | `on_closed | [@mel.as 20] `on_open | `in_bin]) => int = \"testIntType\"; let value = test_int_type(`on_open); In this example, on_closed will be encoded as 0, on_open will be 20 due to the attribute mel.as and in_bin will be 21, because if no mel.as annotation is provided for a variant tag, the compiler continues assigning values counting up from the previous one. This code generates: var value = testIntType(20);","title":"Using polymorphic variants to bind to enums"},{"location":"communicate-with-javascript/#using-polymorphic-variants-to-bind-to-event-listeners","text":"Polymorphic variants can also be used to wrap event listeners, or any other kind of callback, for example: type readline external on : readline -> ([ `close of unit -> unit | `line of string -> unit ][@mel.string]) -> readline = \"on\" [@@mel.send] let register rl = rl |. on (`close (fun event -> ())) |. on (`line (fun line -> Js.log line)) type readline; [@mel.send] external on: ( readline, [@mel.string] [ | `close(unit => unit) | `line(string => unit)] ) => readline = \"on\"; let register = rl => rl->(on(`close(event => ())))->(on(`line(line => Js.log(line)))); This generates: function register(rl) { return rl .on(\"close\", function($$event) {}) .on(\"line\", function(line) { console.log(line); }); }","title":"Using polymorphic variants to bind to event listeners"},{"location":"communicate-with-javascript/#constant-values-as-arguments","text":"Sometimes we want to call a JavaScript function and make sure one of the arguments is always constant. For this, the [@mel.as] attribute can be combined with the wildcard pattern _ : external process_on_exit : (_[@mel.as \"exit\"]) -> (int -> unit) -> unit = \"process.on\" let () = process_on_exit (fun exit_code -> Js.log (\"error code: \" ^ string_of_int exit_code)) external process_on_exit: ([@mel.as \"exit\"] _, int => unit) => unit = \"process.on\"; let () = process_on_exit(exit_code => Js.log(\"error code: \" ++ string_of_int(exit_code)) ); This generates: process.on(\"exit\", function (exitCode) { console.log(\"error code: \" + exitCode.toString()); }); The mel.as \"exit\" and the wildcard _ pattern together will tell Melange to compile the first argument of the JavaScript function to the string \"exit\" . You can also use any JSON literal by passing a quoted string to mel.as : mel.as {json|true|json} or mel.as {json|{\"name\": \"John\"}|json} .","title":"Constant values as arguments"},{"location":"communicate-with-javascript/#binding-to-callbacks","text":"In OCaml, all functions have arity 1. This means that if you define a function like this: let add x y = x + y let add = (x, y) => x + y; Its type will be int -> int -> int . This means that one can partially apply add by calling add 1 , which will return another function expecting the second argument of the addition. This kind of functions are called \"curried\" functions, more information about currying in OCaml can be found in this chapter of the \"OCaml Programming: Correct + Efficient + Beautiful\" book. This is incompatible with how function calling conventions work in JavaScript, where all function calls always apply all the arguments. To continue the example, let\u2019s say we have an add function implemented in JavaScript, similar to the one above: var add = function (a, b) { return a + b; }; If we call add(1) , the function will be totally applied, with b having undefined value. And as JavaScript will try to add 1 with undefined , we will get NaN as a result. To illustrate this difference and how it affects Melange bindings, let\u2019s say we want to write bindings for a JavaScript function like this: function map (a, b, f){ var i = Math.min(a.length, b.length); var c = new Array(i); for(var j = 0; j < i; ++j){ c[j] = f(a[i],b[i]) } return c ; } A naive external function declaration could be as below: external map : 'a array -> 'b array -> ('a -> 'b -> 'c) -> 'c array = \"map\" external map: (array('a), array('b), ('a, 'b) => 'c) => array('c) = \"map\"; Unfortunately, this is not completely correct. The issue is in the callback function, with type 'a -> 'b -> 'c . This means that map will expect a function like add described above. But as we said, in OCaml, having two arguments means just to have two functions that take one argument. Let\u2019s rewrite add to make the problem a bit more clear: let add x = let partial y = x + y in partial let add = x => { let partial = y => x + y; partial; }; This will be compiled to: function add(x) { return (function (y) { return x + y | 0; }); } Now if we ever used our external function map with our add function by calling map arr1 arr2 add it would not work as expected. JavaScript function application does not work the same as in OCaml, so the function call in the map implementation, f(a[i],b[i]) , would be applied over the outer JavaScript function add , which only takes one argument x , and b[i] would be just discarded. The value returned from the operation would not be the addition of the two numbers, but rather the inner anonymous callback. To solve this mismatch between OCaml and JavaScript functions and their application, Melange provides a special attribute @u that can be used to annotate external functions that need to be \"uncurried\". In Reason syntax, this attribute does not need to be written explicitly, as it is deeply integrated with the Reason parser. To specify some function type as \"uncurried\", one just needs to add the dot character . to the function type. For example, (. 'a, 'b) => 'c instead of ('a, 'b) => 'c . In the example above: external map : 'a array -> 'b array -> (('a -> 'b -> 'c)[@u]) -> 'c array = \"map\" external map: (array('a), array('b), (. 'a, 'b) => 'c) => array('c) = \"map\"; Here ('a -> 'b -> 'c [@u]) (. 'a, 'b) => 'c will be interpreted as having arity 2. In general, 'a0 -> 'a1 ...\u200b 'aN -> 'b0 [@u] is the same as 'a0 -> 'a1 ...\u200b 'aN -> 'b0 . 'a0, 'a1, ...\u200b 'aN => 'b0 is the same as 'a0, 'a1, ...\u200b 'aN => 'b0 except the former\u2019s arity is guaranteed to be N while the latter is unknown. If we try now to call map using add : let add x y = x + y let _ = map [||] [||] add let add = (x, y) => x + y; let _ = map([||], [||], add); We will get an error: let _ = map [||] [||] add ^^^ This expression has type int -> int -> int but an expression was expected of type ('a -> 'b -> 'c) Js.Fn.arity2 To solve this, we add @u . in the function definition as well: let add = fun [@u] x y -> x + y let add = (. x, y) => x + y; Annotating function definitions can be quite cumbersome when writing a lot of externals. To work around the verbosity, Melange offers another attribute called mel.uncurry . Let\u2019s see how we could use it in the previous example. We just need to replace u with mel.uncurry : external map : 'a array -> 'b array -> (('a -> 'b -> 'c)[@mel.uncurry]) -> 'c array = \"map\" external map: (array('a), array('b), [@mel.uncurry] (('a, 'b) => 'c)) => array('c) = \"map\"; Now if we try to call map with a regular add function: let add x y = x + y let _ = map [||] [||] add let add = (x, y) => x + y; let _ = map([||], [||], add); Everything works fine now, without having to attach any attributes to add . The main difference between u and mel.uncurry is that the latter only works with externals. mel.uncurry is the recommended option to use for bindings, while u remains useful for those use cases where performance is crucial and we want the JavaScript functions generated from OCaml ones to not be applied partially.","title":"Binding to callbacks"},{"location":"communicate-with-javascript/#modeling-this-based-callbacks","text":"Many JavaScript libraries have callbacks which rely on the this keyword , for example: x.onload = function(v) { console.log(this.response + v) } Inside the x.onload callback, this would be pointing to x . It would not be correct to declare x.onload of type unit -> unit . Instead, Melange introduces a special attribute, mel.this , which allows to type x as this: type x external x : x = \"x\" external set_onload : x -> ((x -> int -> unit)[@mel.this]) -> unit = \"onload\" [@@mel.set] external resp : x -> int = \"response\" [@@mel.get] let _ = set_onload x begin fun [@mel.this] o v -> Js.log (resp o + v) end type x; external x: x = \"x\"; [@mel.set] external set_onload: (x, [@mel.this] ((x, int) => unit)) => unit = \"onload\"; [@mel.get] external resp: x => int = \"response\"; let _ = set_onload(x, [@mel.this] (o, v) => Js.log(resp(o) + v)); Which generates: x.onload = function (v) { var o = this; console.log((o.response + v) | 0); }; Note that the first argument will be reserved for this .","title":"Modeling this-based Callbacks"},{"location":"communicate-with-javascript/#wrapping-returned-nullable-values","text":"JavaScript models null and undefined differently, whereas it can be useful to treat both as 'a option option('a) in Melange. Melange understands the mel.return attribute in externals to model how nullable return types should be wrapped at the bindings boundary. An external value with mel.return converts the return value to an option type, avoiding the need for extra wrapping / unwrapping with functions such as Js.Nullable.toOption . type element type document external get_by_id : document -> string -> element option = \"getElementById\" [@@mel.send] [@@mel.return nullable] let test document = let elem = get_by_id document \"header\" in match elem with | None -> 1 | Some _element -> 2 type element; type document; [@mel.send] [@mel.return nullable] external get_by_id: (document, string) => option(element) = \"getElementById\"; let test = document => { let elem = get_by_id(document, \"header\"); switch (elem) { | None => 1 | Some(_element) => 2 }; }; Which generates: function test($$document) { var elem = $$document.getElementById(\"header\"); if (elem == null) { return 1; } else { return 2; } } The mel.return attribute takes an attribute payload, as seen with [@@mel.return nullable] [@mel.return nullable] above. Currently 4 directives are supported: null_to_opt , undefined_to_opt , nullable and identity . nullable is encouraged, as it will convert from null and undefined to option type. identity will make sure that compiler will do nothing about the returned value. It is rarely used, but introduced here for debugging purposes.","title":"Wrapping returned nullable values"},{"location":"communicate-with-javascript/#generate-getters-setters-and-constructors","text":"As we saw in a previous section , there are some types in Melange that compile to values that are not easy to manipulate from JavaScript. To facilitate the communication from JavaScript code with values of these types, Melange includes an attribute deriving that helps generating conversion functions, as well as functions to create values from these types. In particular, for variants and polymorphic variants. Additionally, deriving can be used with record types, to generate setters and getters as well as creation functions.","title":"Generate getters, setters and constructors"},{"location":"communicate-with-javascript/#variants","text":"","title":"Variants"},{"location":"communicate-with-javascript/#creating-values","text":"Use @deriving accessors on a variant type to create constructor values for each branch. type action = | Click | Submit of string | Cancel [@@deriving accessors] [@deriving accessors] type action = | Click | Submit(string) | Cancel; Melange will generate one let definition for each variant tag, implemented as follows: For variant tags with payloads, it will be a function that takes the payload value as a parameter. For variant tags without payloads, it will be a constant with the runtime value of the tag. Given the action type definition above, annotated with deriving , Melange will generate something similar to the following code: type action = | Click | Submit of string | Cancel let click = (Click : action) let submit param = (Submit param : action) let cancel = (Cancel : action) type action = | Click | Submit(string) | Cancel; let click: action = Click; let submit = (param): action => Submit(param); let cancel: action = Cancel; Which will result in the following JavaScript code after compilation: function submit(param_0) { return /* Submit */{ _0: param_0 }; } var click = /* Click */0; var cancel = /* Cancel */1; Note the generated definitions are lower-cased, and they can be safely used from JavaScript code. For example, if the above JavaScript generated code was located in a generators.js file, the definitions can be used like this: const generators = require('./generators.js'); const hello = generators.submit(\"Hello\"); const click = generators.click;","title":"Creating values"},{"location":"communicate-with-javascript/#conversion-functions","text":"Use @deriving jsConverter on a variant type to create converter functions that allow to transform back and forth between JavaScript integers and Melange variant values. There are a few differences with @deriving accessors : jsConverter works with the mel.as attribute, while accessors does not jsConverter does not support variant tags with payload, while accessors does jsConverter generates functions to transform values back and forth, while accessors generates functions to create values Let\u2019s see a version of the previous example, adapted to work with jsConverter given the constraints above: type action = | Click | Submit [@mel.as 3] | Cancel [@@deriving jsConverter] [@deriving jsConverter] type action = | Click | [@mel.as 3] Submit | Cancel; This will generate a couple of functions with the following types: val actionToJs : action -> int val actionFromJs : int -> action option external actionToJs: action => int = ; external actionFromJs: int => option(action) = ; actionToJs returns integers from values of action type. It will start with 0 for Click , 3 for Submit (because it was annotated with mel.as ), and then 4 for Cancel , in the same way that we described when using mel.int with polymorphic variants . actionFromJs returns a value of type option , because not every integer can be converted into a variant tag of the action type.","title":"Conversion functions"},{"location":"communicate-with-javascript/#hide-runtime-types","text":"For extra type safety, we can hide the runtime representation of variants ( int ) from the generated functions, by using jsConverter { newType } payload with @deriving : type action = | Click | Submit [@mel.as 3] | Cancel [@@deriving jsConverter { newType }] [@deriving jsConverter({newType: newType})] type action = | Click | [@mel.as 3] Submit | Cancel; This feature relies on abstract types to hide the JavaScript runtime representation. It will generate functions with the following types: val actionToJs : action -> abs_action val actionFromJs : abs_action -> action external actionToJs: action => abs_action = ; external actionFromJs: abs_action => action = ; In the case of actionFromJs , the return value, unlike the previous case, is not an option type. This is an example of \"correct by construction\": the only way to create an abs_action is by calling the actionToJs function.","title":"Hide runtime types"},{"location":"communicate-with-javascript/#polymorphic-variants","text":"The @deriving jsConverter attribute is applicable to polymorphic variants as well. NOTE: Similarly to variants, the @deriving jsConverter attribute cannot be used when the polymorphic variant tags have payloads. Refer to the section on runtime representation to learn more about how polymorphic variants are represented in JavaScript. Let\u2019s see an example: type action = [ `Click | `Submit [@mel.as \"submit\"] | `Cancel ] [@@deriving jsConverter] [@deriving jsConverter] type action = [ | `Click | [@mel.as \"submit\"] `Submit | `Cancel]; Akin to the variant example, the following two functions will be generated: val actionToJs : action -> string val actionFromJs : string -> action option external actionToJs: action => string = ; external actionFromJs: string => option(action) = ; The jsConverter { newType } payload can also be used with polymorphic variants.","title":"Polymorphic variants"},{"location":"communicate-with-javascript/#records_1","text":"","title":"Records"},{"location":"communicate-with-javascript/#accessing-fields","text":"Use @deriving accessors on a record type to create accessor functions for its record field names. type pet = { name : string } [@@deriving accessors] let pets = [| { name = \"Brutus\" }; { name = \"Mochi\" } |] let () = pets |. Belt.Array.map name |. Js.Array2.joinWith \"&\" |. Js.log [@deriving accessors] type pet = {name: string}; let pets = [|{name: \"Brutus\"}, {name: \"Mochi\"}|]; let () = pets->(Belt.Array.map(name))->(Js.Array2.joinWith(\"&\"))->Js.log; Melange will generate a function for each field defined in the record. In this case, a function name that allows to get that field from any record of type pet : let name (param : pet) = param.name let name = (param: pet) => param.name; Considering all the above, the produced JavaScript will be: function name(param) { return param.name; } var pets = [ { name: \"Brutus\" }, { name: \"Mochi\" } ]; console.log(Belt_Array.map(pets, name).join(\"&\"));","title":"Accessing fields"},{"location":"communicate-with-javascript/#convert-records-into-abstract-types","text":"When binding to JavaScript objects, it is generally recommended to use records since Melange precisely uses objects as their runtime representation. This approach was discussed in the section about binding to JavaScript objects . But there\u2019s a specific case where records may not be enough: when we want to emit a JavaScript object where some of the keys might be present or absent. For instance, consider the following record: type person = { name : string; age : int option; } type person = { name: string, age: option(int), }; An example of this use-case would be expecting { name = \"John\"; age = None } to generate a JavaScript such as {name: \"Carl\"} , where the age key doesn\u2019t appear. The @deriving abstract attribute exists to solve this problem. When present in a record type, @deriving abstract makes the record definition abstract and generates the following functions instead: A constructor function for creating values of the type Getters and setters for accessing the record fields @deriving abstract effectively models a record-shaped JavaScript object exclusively through a set of (generated) functions derived from attribute annotations on the OCaml type definition. Let\u2019s see an example. Considering this Melange code: type person = { name : string; age : int option; [@optional] } [@@deriving abstract] [@deriving abstract] type person = { name: string, [@optional] age: option(int), }; Melange will make the person type abstract and generate constructor, getter and setter functions. In our example, the OCaml signature would look like this after preprocessing: type person val person : name:string -> ?age:int -> unit -> person val nameGet : person -> string val ageGet : person -> int option type person; external person: (~name: string, ~age: int=?, unit) => person = ; external nameGet: person => string = ; external ageGet: person => option(int) = ; The person function can be used to create values of person . It is the only possible way to create values of this type, since Melange makes it abstract. Using literals like { name = \"Alice\"; age = None } directly doesn\u2019t type check. Here is an example of how we can use it: let alice = person ~name:\"Alice\" ~age:20 () let bob = person ~name:\"Bob\" () let alice = person(~name=\"Alice\", ~age=20, ()); let bob = person(~name=\"Bob\", ()); This will generate the following JavaScript code. Note how there is no JavaScript runtime overhead: var alice = { name: \"Alice\", age: 20 }; var bob = { name: \"Bob\" }; The person function uses labeled arguments to represent record fields. Because there is an optional argument age , it takes a last argument of type unit . This non-labeled argument allows to omit the optional argument on function application. Further details about optional labeled arguments can be found in the corresponding section of the OCaml manual . The functions nameGet and ageGet are accessors for each record field: let twenty = ageGet alice let bob = nameGet bob let twenty = ageGet(alice); let bob = nameGet(bob); This generates: var twenty = alice.age; var bob = bob.name; The functions are named by appending Get to the field names of the record to prevent potential clashes with other values within the module. If shorter names are preferred for the getter functions, there is an alternate { abstract = light } payload that can be passed to deriving : type person = { name : string; age : int; } [@@deriving abstract { light }] let alice = person ~name:\"Alice\" ~age:20 let aliceName = name alice [@deriving abstract({light: light})] type person = { name: string, age: int, }; let alice = person(~name=\"Alice\", ~age=20); let aliceName = name(alice); Which generates: var alice = { name: \"Alice\", age: 20 }; var aliceName = alice.name; In this example, the getter functions share the same names as the object fields. Another distinction from the previous example is that the person constructor function no longer requires the final unit argument since we have excluded the optional field in this case. NOTE: The mel.as attribute can still be applied to record fields when the record type is annotated with deriving , allowing for the renaming of fields in the resulting JavaScript objects, as demonstrated in the section about binding to objects with static shape . However, the option to pass indices to the mel.as decorator (like [@mel.as \"0\"] ) to change the runtime representation to an array is not available when using deriving .","title":"Convert records into abstract types"},{"location":"communicate-with-javascript/#compatibility-with-ocaml-features","text":"The @deriving abstract attribute and its lightweight variant can be used with mutable fields and private types , which are features inherited by Melange from OCaml. When the record type has mutable fields, Melange will generate setter functions for them. For example: type person = { name : string; mutable age : int; } [@@deriving abstract] let alice = person ~name:\"Alice\" ~age:20 let () = ageSet alice 21 [@deriving abstract] type person = { name: string, mutable age: int, }; let alice = person(~name=\"Alice\", ~age=20); let () = ageSet(alice, 21); This will generate: var alice = { name: \"Alice\", age: 20 }; alice.age = 21; If the mutable keyword is omitted from the interface file, Melange will not include the setter function in the module signature, preventing other modules from mutating any values from the type. Private types can be used to prevent Melange from creating the constructor function. For example, if we define person type as private: type person = private { name : string; age : int; } [@@deriving abstract] [@deriving abstract] type person = pri { name: string, age: int, }; The accessors nameGet and ageGet will still be generated, but not the constructor person . This is useful when binding to JavaScript objects while preventing any Melange code from creating values of such type.","title":"Compatibility with OCaml features"},{"location":"communicate-with-javascript/#use-melange-code-from-javascript","text":"As mentioned in the build system section , Melange allows to produce both CommonJS and ES6 modules. In both cases, using Melange-generated JavaScript code from any hand-written JavaScript file works as expected. The following definition: let print name = \"Hello\" ^ name let print = name => \"Hello\" ++ name; Will generate this JavaScript code, when using CommonJS (the default): function print(name) { return \"Hello\" + name; } exports.print = print; When using ES6 (through the (module_systems es6) field in melange.emit ) this code will be generated: function print(name) { return \"Hello\" + name; } export { print , } So one can use either require or import (depending on the module system of choice) to import the print value in a JavaScript file.","title":"Use Melange code from JavaScript"},{"location":"communicate-with-javascript/#default-es6-values","text":"One special case occur when working with JavaScript imports in ES6 modules that look like this: import ten from 'numbers.js'; This import expects numbers.js to have a default export, like: export default ten = 10; To emulate this kind of exports from Melange, one just needs to define a default value. For example, in a file named numbers.ml numbers.re : let default = 10 let default = 10; That way, Melange will set the value on the default export so it can be consumed as default import on the JavaScript side.","title":"Default ES6 values"},{"location":"community/","text":"Community The community tends to congregate in the following forums: OCaml Discourse Web Forum is a friendly, online forum for OCaml discussion. If you prefer to have long-form conversation rather than just chatting, this is the place to do it. Reason Discord , where there is a specific #melange channel OCaml Discord Melange GitHub repository Resources The following are resources about Melange collected around the web: David Sancho chats to Antonio Monteiro about OCaml and Melange (May 2023) \" Ahrefs.com is now built with Melange \" announcement","title":"Community"},{"location":"community/#community","text":"The community tends to congregate in the following forums: OCaml Discourse Web Forum is a friendly, online forum for OCaml discussion. If you prefer to have long-form conversation rather than just chatting, this is the place to do it. Reason Discord , where there is a specific #melange channel OCaml Discord Melange GitHub repository","title":"Community"},{"location":"community/#resources","text":"The following are resources about Melange collected around the web: David Sancho chats to Antonio Monteiro about OCaml and Melange (May 2023) \" Ahrefs.com is now built with Melange \" announcement","title":"Resources"},{"location":"getting-started/","text":"Getting started Get up and running with Melange in no time! Install a package manager To work with Melange, you need to install a package manager compatible with OCaml. If you are not sure which one to use, we recommend opam , a source-based package manager for OCaml, but there are other alternatives available. Instructions for installing opam on different operating systems can be found at the opam install page , and you can find a whole section about it on this website. Template The easiest way to get started with Melange is by using the melange-opam-template . You can clone it from this link , and follow the instructions in the readme file to configure the local opam switch and download the necessary dependencies to build the project. Editor integration One of the goals of Melange is to remain compatible with OCaml. One of the major benefits of this compatibility is that developers working on Melange projects can use the same editor tooling as they would for OCaml. OCaml developer tooling has been built, tested, and refined over the years, with plugins available for many editors. The most actively maintained plugins are for Visual Studio Code, Emacs, and Vim. For Visual Studio Code, install the OCaml Platform Visual Studio Code extension from the Visual Studio Marketplace. When you load an OCaml source file for the first time, you may be prompted to select the toolchain to use. Select the version of OCaml you are using from the list, such as 4.14.1. Further instructions for configuration can be found in the extension repository . For Emacs and Vim, the configuration may vary depending on the case, and there are several options available. You can read about them in the editor setup page of the OCamlverse documentation site. NOTE: Melange editor integration currently only works with 4.14.x, even though it can compile melange projects on other OCaml switches. Alternative package managers (experimental) Melange can also be used with other package managers. The following instructions apply to Nix and esy . Nix Melange provides an overlay that can be: referenced from a Nix flake overlayed onto a nixpkgs package set Make sure Nix is installed. The following flake.nix illustrates how to set up a Melange development environment. { description = \"Melange starter\"; inputs = { flake-utils.url = \"github:numtide/flake-utils\"; nixpkgs.url = \"github:nixos/nixpkgs\"; # Depend on the Melange flake, which provides the overlay melange.url = \"github:melange-re/melange\"; }; outputs = { self, nixpkgs, flake-utils, melange }: flake-utils.lib.eachDefaultSystem (system: let pkgs = nixpkgs.legacyPackages.${system}.appendOverlays [ # Set the OCaml set of packages to the 4.14 release line (self: super: { ocamlPackages = super.ocaml-ng.ocamlPackages_4_14; }) # Apply the Melange overlay melange.overlays.default ]; inherit (pkgs) ocamlPackages; in { devShells.default = pkgs.mkShell { nativeBuildInputs = with ocamlPackages; [ ocaml dune_3 findlib ocaml-lsp ocamlPackages.melange ]; buildInputs = [ ocamlPackages.melange ]; }; }); } To enter a Melange development shell, run nix develop -c $SHELL . esy First, make sure esy is installed . npm i -g esy does the trick in most setups. The following is an example esy.json that can help start a Melange project. A project template for esy is also available if you prefer to start from a template . { \"name\": \"melange-project\", \"dependencies\": { \"ocaml\": \"4.14.x\", \"@opam/dune\": \">= 3.8.0\", \"@opam/melange\": \"*\" }, \"devDependencies\": { \"@opam/ocaml-lsp-server\": \"*\" }, \"esy\": { \"build\": [ \"dune build @melange\" ] } } Run: esy install to build and make all dependencies available esy shell to enter a Melange development environment","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Get up and running with Melange in no time!","title":"Getting started"},{"location":"getting-started/#install-a-package-manager","text":"To work with Melange, you need to install a package manager compatible with OCaml. If you are not sure which one to use, we recommend opam , a source-based package manager for OCaml, but there are other alternatives available. Instructions for installing opam on different operating systems can be found at the opam install page , and you can find a whole section about it on this website.","title":"Install a package manager"},{"location":"getting-started/#template","text":"The easiest way to get started with Melange is by using the melange-opam-template . You can clone it from this link , and follow the instructions in the readme file to configure the local opam switch and download the necessary dependencies to build the project.","title":"Template"},{"location":"getting-started/#editor-integration","text":"One of the goals of Melange is to remain compatible with OCaml. One of the major benefits of this compatibility is that developers working on Melange projects can use the same editor tooling as they would for OCaml. OCaml developer tooling has been built, tested, and refined over the years, with plugins available for many editors. The most actively maintained plugins are for Visual Studio Code, Emacs, and Vim. For Visual Studio Code, install the OCaml Platform Visual Studio Code extension from the Visual Studio Marketplace. When you load an OCaml source file for the first time, you may be prompted to select the toolchain to use. Select the version of OCaml you are using from the list, such as 4.14.1. Further instructions for configuration can be found in the extension repository . For Emacs and Vim, the configuration may vary depending on the case, and there are several options available. You can read about them in the editor setup page of the OCamlverse documentation site. NOTE: Melange editor integration currently only works with 4.14.x, even though it can compile melange projects on other OCaml switches.","title":"Editor integration"},{"location":"getting-started/#alternative-package-managers-experimental","text":"Melange can also be used with other package managers. The following instructions apply to Nix and esy .","title":"Alternative package managers (experimental)"},{"location":"getting-started/#nix","text":"Melange provides an overlay that can be: referenced from a Nix flake overlayed onto a nixpkgs package set Make sure Nix is installed. The following flake.nix illustrates how to set up a Melange development environment. { description = \"Melange starter\"; inputs = { flake-utils.url = \"github:numtide/flake-utils\"; nixpkgs.url = \"github:nixos/nixpkgs\"; # Depend on the Melange flake, which provides the overlay melange.url = \"github:melange-re/melange\"; }; outputs = { self, nixpkgs, flake-utils, melange }: flake-utils.lib.eachDefaultSystem (system: let pkgs = nixpkgs.legacyPackages.${system}.appendOverlays [ # Set the OCaml set of packages to the 4.14 release line (self: super: { ocamlPackages = super.ocaml-ng.ocamlPackages_4_14; }) # Apply the Melange overlay melange.overlays.default ]; inherit (pkgs) ocamlPackages; in { devShells.default = pkgs.mkShell { nativeBuildInputs = with ocamlPackages; [ ocaml dune_3 findlib ocaml-lsp ocamlPackages.melange ]; buildInputs = [ ocamlPackages.melange ]; }; }); } To enter a Melange development shell, run nix develop -c $SHELL .","title":"Nix"},{"location":"getting-started/#esy","text":"First, make sure esy is installed . npm i -g esy does the trick in most setups. The following is an example esy.json that can help start a Melange project. A project template for esy is also available if you prefer to start from a template . { \"name\": \"melange-project\", \"dependencies\": { \"ocaml\": \"4.14.x\", \"@opam/dune\": \">= 3.8.0\", \"@opam/melange\": \"*\" }, \"devDependencies\": { \"@opam/ocaml-lsp-server\": \"*\" }, \"esy\": { \"build\": [ \"dune build @melange\" ] } } Run: esy install to build and make all dependencies available esy shell to enter a Melange development environment","title":"esy"},{"location":"melange-for-x-developers/","text":"Melange for X developers If you are familiar with other languages, here you will find sections that compare Melange to a few of them, so it might help you get up and running quickly. In particular: JavaScript TypeScript Js_of_ocaml ReScript For JavaScript developers Melange is a thin layer over OCaml , a strongly typed functional programming language with an emphasis on expressiveness and safety. Melange\u2019s goal is to help web developers build and maintain JavaScript applications safely, thanks to OCaml expressive and powerful type system. Melange allows to build applications using either OCaml syntax or Reason syntax. If you don\u2019t know which one to choose, we recommend Reason , as it has been designed with JavaScript developers in mind. Reason syntax has first-class support for JSX , and there are bindings like ReasonReact that build on top of that functionality to provide a great developer experience. Another advantage is that programs written using Reason syntax are fully compatible with those written in OCaml syntax. Here is the cheat sheet with some equivalents between JavaScript and Reason syntaxes: Variable JavaScript OCaml (Reason syntax) const x = 5; let x = 5; var x = y; No equivalent let x = 5; x = x + 1; let x = ref(5); x := x^ + 1; String & Character JavaScript OCaml (Reason syntax) \"Hello world!\" Same 'Hello world!' Strings must use \" Characters are strings 'a' \"hello \" + \"world\" \"hello \" ++ \"world\" Boolean JavaScript OCaml (Reason syntax) true , false Same !true Same || , && , <= , >= , < , > Same a === b , a !== b Same No deep equality (recursive compare) a == b , a != b a == b No equality with implicit casting Number JavaScript OCaml (Reason syntax) 3 Same * 3.1415 Same 3 + 4 Same 3.0 + 4.5 3.0 +. 4.5 5 % 3 5 mod 3 * JavaScript has no distinction between integer and float. Object/Record JavaScript OCaml (Reason syntax) no static types type point = {x: int, mutable y: int} {x: 30, y: 20} Same point.x Same point.y = 30; Same {...point, x: 30} Same Array JavaScript OCaml (Reason syntax) [1, 2, 3] [|1, 2, 3|] myArray[1] = 10 Same [1, \"Bob\", true] * (1, \"Bob\", true) No immutable list [1, 2, 3] * Tuples can be simulated in JavaScript with arrays, as JavaScript arrays can contain multiple types of elements. Null JavaScript OCaml (Reason syntax) null , undefined None * * There are no nulls, nor null bugs in OCaml. But it does have an option type for when you actually need nullability. Function JavaScript OCaml (Reason syntax) arg => retVal (arg) => retVal function named(arg) {...} let named = (arg) => ... const f = function(arg) {...} let f = (arg) => ... add(4, add(5, 6)) Same Blocks JavaScript OCaml (Reason syntax) const myFun = (x, y) => { const doubleX = x + x; const doubleY = y + y; return doubleX + doubleY }; let myFun = (x, y) => { let doubleX = x + x; let doubleY = y + y; doubleX + doubleY }; Currying JavaScript OCaml (Reason syntax) let add = a => b => a + b let add = (a, b) => a + b Both JavaScript and OCaml support currying, but OCaml currying is built-in and optimized to avoid intermediate function allocation and calls , whenever possible. If-else JavaScript OCaml (Reason syntax) if (a) {b} else {c} Same a ? b : c Same switch switch but with pattern matching Destructuring JavaScript OCaml (Reason syntax) const {a, b} = data let {a, b} = data const [a, b] = data let [|a, b|] = data * const {a: aa, b: bb} = data let {a: aa, b: bb} = data * This will cause the compiler to warn that not all cases are handled, because data could be of length other than 2. Better switch to pattern-matching instead. Loop JavaScript OCaml (Reason syntax) for (let i = 0; i <= 10; i++) {...} for (i in 0 to 10) {...} for (let i = 10; i >= 0; i--) {...} for (i in 10 downto 0) {...} while (true) {...} Same JSX JavaScript OCaml (Reason syntax) <Foo bar=1 baz=\"hi\" onClick={bla} /> Same <Foo bar=bar /> <Foo bar /> * <input checked /> <input checked=true /> No children spread <Foo>...children</Foo> * Note the argument punning when creating elements. Exception JavaScript OCaml (Reason syntax) throw new SomeError(...) raise(SomeError(...)) try {a} catch (Err) {...} finally {...} try (a) { | Err => ...} * * No finally. Blocks In OCaml, \"sequence expressions\" are created with {} and evaluate to their last statement. In JavaScript, this can be simulated via an immediately-invoked function expression (since function bodies have their own local scope). JavaScript OCaml (Reason syntax) let res = (function() { const x = 23; const y = 34; return x + y; })(); let res = { let x = 23; let y = 34; x + y }; Comments JavaScript OCaml (Reason syntax) /* Comment */ Same // Line comment Same For TypeScript developers The approach to typing applications using Melange differs somewhat from TypeScript. TypeScript has been designed with a focus on compatibility with JavaScript, as outlined in its design goals . On the other hand, Melange is built upon OCaml, a compiler known for its emphasis on expressiveness and safety. These are some of the differences between both. Type inference In TypeScript, the types for the input parameters have to be defined: let sum = (a: number, b: number) => a + b; OCaml can infer types without barely any type annotations. For example, we can define a function that adds two numbers as: let add x y = x + y let add = (x, y) => x + y; Algebraic data types It is not possible to build an ADT in TypeScript the same way as in OCaml. Discriminated unions would be the closest analog to them, with libraries like ts-pattern as an alternative to the lack of support for pattern matching in the language. In OCaml, algebraic data types (ADTs) are a commonly used functionality of the language. They allow you to build your own types from small blocks. And with pattern matching , it is easy to access this data. Nominal typing In TypeScript, all typing is structural. This means that it is hard sometimes to establish a boundary or separation between two types that have the same implementation. For these cases, nominal typing can be emulated using tags: type Email = string & { readonly __tag: unique symbol }; type City = string & { readonly __tag: unique symbol }; In OCaml, nominal typing is fully supported. Some of the core language types like records and variants are nominal. This means that even if you declare exactly the same type twice, functions that operate on values from one type will not be compatible with the other type. There is also structural typing, used for OCaml objects and polymorphic variants . Immutability TypeScript has two base primitives to work with immutability: const and readonly . The first one is used to prevent variable reference change. const a = 1; a = 2; // Error: Cannot assign to 'a' because it is a constant. And the second one is used to make properties immutable. type A = { readonly x: number; } const a: A = { x: 1 }; a.x = 12; // Error: Cannot assign to 'x' because it is a read-only property. Nevertheless, there are some problems here. const and readonly only block reference changes but do nothing about values. With const a = [1, 2, 3] or readonly x: number[] , you can still change the contents of an array. OCaml provides data types with immutability in mind, like lists, records, or maps. Strictness and soundness In TypeScript, you have the flexibility to use types like any or other expansive types such as Function . However, TypeScript provides the strict option in the tsconfig.json file to mitigate the usage of these less type-safe constructs. On the other hand, OCaml does not offer a similar option to enable or disable strictness. In OCaml, the language itself promotes type safety without the need for explicit configuration options to enforce stricter behavior. TypeScript, as mentioned in its handbook , may sacrifice soundness for practicality when needed. In contrast, OCaml implementations provide unsound methods like the identity primitive but they are generally discouraged and rarely used. The OCaml community places a strong emphasis on maintaining soundness and prefers safer alternatives to ensure code correctness. Cheatsheet The following are some conversions between TypeScript and OCaml idioms, in the OCaml side we use Reason syntax for familiarity, as mentioned in section for JavaScript developers . Type aliases TypeScript OCaml (Reason syntax) type Email = string; type email = string; Abstract types TypeScript OCaml (Reason syntax) type Email = string & { readonly __tag: unique symbol }; /* in interface `rei` file */ type email; /* in implementation `re` file */ type email = string; Union types / Variants TypeScript OCaml (Reason syntax) type Result = \"Error\" | \"Success\"; type result = Error | Success type Result = | { type: \"Error\"; message: string } | { type: \"Success\"; n: number }; type result = | Error(string) | Success(int) Immutability TypeScript OCaml (Reason syntax) const a = 1; type A = { readonly x: number }; type ImmutableA = Readonly ; const arr: ReadonlyArray = [1, 2, 3]; type A = { readonly [x: string]: number }; Enabled by default Currying TypeScript OCaml (Reason syntax) type addT = (_: number) => (_: number) => number; const add: addT = (l) => (r) => l + r; add(5)(3); Enabled by default Parametric polymorphism TypeScript OCaml (Reason syntax) type length = <T>(_: T[]) => number; let length: list('a) => int; For Js_of_ocaml developers There are many similarities between Js_of_ocaml and Melange: Both compile OCaml to JavaScript. Both are available as libraries in the official opam repository. Both have access to the OCaml platform developer toolchain: the OCaml LSP server, Merlin, and the different editor extensions. Both have implemented extensive integration with Dune. However, while Js_of_ocaml transforms OCaml bytecode into JavaScript, Melange starts the conversion process earlier in the compiler pipeline, as it transforms the compiler lambda representation into JavaScript. Js_of_ocaml is a project with years of development and evolution behind it, while Melange appearance is relatively recent in comparison. These aspects translate into different trade-offs. Compared to Js_of_ocaml: Melange can be installed in an OCaml 5 opam switch, but the editor integration is not working at the time (May 2023). Similarly, any OCaml 5 features like effects are currently unsupported in Melange. Js_of_ocaml allows to compile the compiler itself and create \"toplevels\", which is not possible with Melange. Marshal is well supported in Js_of_ocaml, while Melange does not support it. Libraries like Unix or Str are available in Js_of_ocaml but not in Melange. Js_of_ocaml supports sourcemaps, which Melange do not support yet (as of May 2023). On the upside, in Melange: Consuming existing JavaScript packages might be a bit easier in Melange, thanks to its compilation model and the extensive availability of mechanisms to bind to JavaScript code. There is great support for some of the most used JavaScript libraries like ReactJS or GraphQL clients. The generated JavaScript bundles are generally smaller. The generated JavaScript code is generally more readable. Melange can generate ES6 or commonjs while Js_of_ocaml generates an IIFE (Immediately Invoked Function Expression) (as of Sep 2023) Straight-forward integration with modern JavaScript tooling like Webpack, NextJS, etc. This is possible thanks to the 1 module \\<-> 1 JavaScript file compilation model. For ReScript developers As a project that shares a common ancestry with ReScript, Melange inherits a lot of its characteristics: The compilation model involves compiling a single module into a single JavaScript file. The libraries provided by ReScript (Belt and Js) are available in Melange too. The mechanisms provided for communicating with JavaScript code are mostly the same. However, one of Melange\u2019s goals is to maximize compatibility with the OCaml ecosystem. This goal translates into fundamental differences in how Melange and ReScript function from the perspective of both library authors and users. Package manager ReScript projects rely exclusively on npm for all packages they depend on. Melange projects, on the other hand, will use opam for native packages, and npm for JavaScript ones. Melange package management is explained in detail in the dedicated section . Build system ReScript has its own build system, originally based on Ninja. Melange defers to Dune for build orchestration, as it is explained in detail in the corresponding section . By integrating with Dune, Melange can benefit from the multiple features provided. One of the most useful features is first-class supports for monorepos. But there are multiple others, like virtual libraries, watch mode, or integrations with tools like odoc . The divergences caused by the different build systems have a lot of implications and nuances that might be too complex to explain in this section, but some of the specific details have been discussed in the OCaml forum . Source-based vs pre-built distribution While with ReScript every dependency can be downloaded with just npm, Melange projects will have to use opam and npm. This is a trade-off: on one hand, some Melange projects might need to include two package configuration files. But on the other hand they can benefit from opam\u2019s source-based package distribution model for things like PPXs, linters, or any other OCaml tooling. In comparison, consuming any OCaml tool in ReScript is more challenging. Since ReScript lacks a native toolchain, authors of the tools need to provide pre-built binaries for all the supported systems and architectures. This poses difficulties for the authors in terms of maintenance, and it can also result in certain users being unable to access these tools if their systems or architectures are not included in the pre-built binaries. OCaml compiler version ReScript is compatible with the 4.06 version of the OCaml compiler, while Melange is compatible with the version 4.14 (as of May 2023). The Melange roadmap for Q2 includes a milestone to upgrade to the latest version of the compiler to the 5.x release line. Editor integration Melange is fully compatible with the OCaml platform editor tools , which makes possible to work in projects that include OCaml and Melange code using the same editor configuration. ReScript has its own set of editor plugins . Feature choice and alignment with OCaml ReScript\u2019s goal is to model the language to bring it as close to JavaScript as possible. From the website introduction section : ReScript looks like JS, acts like JS, and compiles to the highest quality of clean, readable and performant JS (...) New features added to ReScript might close its alignment with JavaScript, but some of these features can lead to greater divergence from OCaml. As Melange prioritizes compatibility with OCaml, it avoids incorporating those features that widen the gap between the two. Here is a non-exhaustive list of the features that ReScript has added and will not be supported in Melange: The async / await syntax: similar functionality can be achieved in Melange through the usage of binding operators (introduced in OCaml 4.13). Optional fields in records, like type t = { x : int, @optional y : int } . Uncurried by default. The restriction above only applies to features that compromise compatibility with OCaml, but otherwise Melange can incorporate bugfixes or new functionality from ReScript. On the other hand, as Melange goal is to keep up with the version of the OCaml compiler, there are features inherited from OCaml that are not supported by ReScript at the moment (May 2023), for example: Binding operators / let bindings Better type errors for some specific cases Additions to the stdlib The whole list of changes added to the OCaml compiler can be checked here . Syntax ReScript encourages using the new syntax for any new code. While OCaml syntax might be supported today, its usage is not documented. Reason syntax is no longer supported. Melange supports and documents both Reason and OCaml syntaxes. It also includes a best-effort support for ReScript syntax for backwards compatibility, provided through the rescript-syntax package, available in opam . To build any code written using ReScript syntax, the only requirement is to download this package, as Melange and Dune will already coordinate to make use of it when res or resi files are found.","title":"Melange for X developers"},{"location":"melange-for-x-developers/#melange-for-x-developers","text":"If you are familiar with other languages, here you will find sections that compare Melange to a few of them, so it might help you get up and running quickly. In particular: JavaScript TypeScript Js_of_ocaml ReScript","title":"Melange for X developers"},{"location":"melange-for-x-developers/#for-javascript-developers","text":"Melange is a thin layer over OCaml , a strongly typed functional programming language with an emphasis on expressiveness and safety. Melange\u2019s goal is to help web developers build and maintain JavaScript applications safely, thanks to OCaml expressive and powerful type system. Melange allows to build applications using either OCaml syntax or Reason syntax. If you don\u2019t know which one to choose, we recommend Reason , as it has been designed with JavaScript developers in mind. Reason syntax has first-class support for JSX , and there are bindings like ReasonReact that build on top of that functionality to provide a great developer experience. Another advantage is that programs written using Reason syntax are fully compatible with those written in OCaml syntax. Here is the cheat sheet with some equivalents between JavaScript and Reason syntaxes:","title":"For JavaScript developers"},{"location":"melange-for-x-developers/#variable","text":"JavaScript OCaml (Reason syntax) const x = 5; let x = 5; var x = y; No equivalent let x = 5; x = x + 1; let x = ref(5); x := x^ + 1;","title":"Variable"},{"location":"melange-for-x-developers/#string-character","text":"JavaScript OCaml (Reason syntax) \"Hello world!\" Same 'Hello world!' Strings must use \" Characters are strings 'a' \"hello \" + \"world\" \"hello \" ++ \"world\"","title":"String &amp; Character"},{"location":"melange-for-x-developers/#boolean","text":"JavaScript OCaml (Reason syntax) true , false Same !true Same || , && , <= , >= , < , > Same a === b , a !== b Same No deep equality (recursive compare) a == b , a != b a == b No equality with implicit casting","title":"Boolean"},{"location":"melange-for-x-developers/#number","text":"JavaScript OCaml (Reason syntax) 3 Same * 3.1415 Same 3 + 4 Same 3.0 + 4.5 3.0 +. 4.5 5 % 3 5 mod 3 * JavaScript has no distinction between integer and float.","title":"Number"},{"location":"melange-for-x-developers/#objectrecord","text":"JavaScript OCaml (Reason syntax) no static types type point = {x: int, mutable y: int} {x: 30, y: 20} Same point.x Same point.y = 30; Same {...point, x: 30} Same","title":"Object/Record"},{"location":"melange-for-x-developers/#array","text":"JavaScript OCaml (Reason syntax) [1, 2, 3] [|1, 2, 3|] myArray[1] = 10 Same [1, \"Bob\", true] * (1, \"Bob\", true) No immutable list [1, 2, 3] * Tuples can be simulated in JavaScript with arrays, as JavaScript arrays can contain multiple types of elements.","title":"Array"},{"location":"melange-for-x-developers/#null","text":"JavaScript OCaml (Reason syntax) null , undefined None * * There are no nulls, nor null bugs in OCaml. But it does have an option type for when you actually need nullability.","title":"Null"},{"location":"melange-for-x-developers/#function","text":"JavaScript OCaml (Reason syntax) arg => retVal (arg) => retVal function named(arg) {...} let named = (arg) => ... const f = function(arg) {...} let f = (arg) => ... add(4, add(5, 6)) Same","title":"Function"},{"location":"melange-for-x-developers/#blocks","text":"JavaScript OCaml (Reason syntax) const myFun = (x, y) => { const doubleX = x + x; const doubleY = y + y; return doubleX + doubleY }; let myFun = (x, y) => { let doubleX = x + x; let doubleY = y + y; doubleX + doubleY };","title":"Blocks"},{"location":"melange-for-x-developers/#currying","text":"JavaScript OCaml (Reason syntax) let add = a => b => a + b let add = (a, b) => a + b Both JavaScript and OCaml support currying, but OCaml currying is built-in and optimized to avoid intermediate function allocation and calls , whenever possible.","title":"Currying"},{"location":"melange-for-x-developers/#if-else","text":"JavaScript OCaml (Reason syntax) if (a) {b} else {c} Same a ? b : c Same switch switch but with pattern matching","title":"If-else"},{"location":"melange-for-x-developers/#destructuring","text":"JavaScript OCaml (Reason syntax) const {a, b} = data let {a, b} = data const [a, b] = data let [|a, b|] = data * const {a: aa, b: bb} = data let {a: aa, b: bb} = data * This will cause the compiler to warn that not all cases are handled, because data could be of length other than 2. Better switch to pattern-matching instead.","title":"Destructuring"},{"location":"melange-for-x-developers/#loop","text":"JavaScript OCaml (Reason syntax) for (let i = 0; i <= 10; i++) {...} for (i in 0 to 10) {...} for (let i = 10; i >= 0; i--) {...} for (i in 10 downto 0) {...} while (true) {...} Same","title":"Loop"},{"location":"melange-for-x-developers/#jsx","text":"JavaScript OCaml (Reason syntax) <Foo bar=1 baz=\"hi\" onClick={bla} /> Same <Foo bar=bar /> <Foo bar /> * <input checked /> <input checked=true /> No children spread <Foo>...children</Foo> * Note the argument punning when creating elements.","title":"JSX"},{"location":"melange-for-x-developers/#exception","text":"JavaScript OCaml (Reason syntax) throw new SomeError(...) raise(SomeError(...)) try {a} catch (Err) {...} finally {...} try (a) { | Err => ...} * * No finally.","title":"Exception"},{"location":"melange-for-x-developers/#blocks_1","text":"In OCaml, \"sequence expressions\" are created with {} and evaluate to their last statement. In JavaScript, this can be simulated via an immediately-invoked function expression (since function bodies have their own local scope). JavaScript OCaml (Reason syntax) let res = (function() { const x = 23; const y = 34; return x + y; })(); let res = { let x = 23; let y = 34; x + y };","title":"Blocks"},{"location":"melange-for-x-developers/#comments","text":"JavaScript OCaml (Reason syntax) /* Comment */ Same // Line comment Same","title":"Comments"},{"location":"melange-for-x-developers/#for-typescript-developers","text":"The approach to typing applications using Melange differs somewhat from TypeScript. TypeScript has been designed with a focus on compatibility with JavaScript, as outlined in its design goals . On the other hand, Melange is built upon OCaml, a compiler known for its emphasis on expressiveness and safety. These are some of the differences between both.","title":"For TypeScript developers"},{"location":"melange-for-x-developers/#type-inference","text":"In TypeScript, the types for the input parameters have to be defined: let sum = (a: number, b: number) => a + b; OCaml can infer types without barely any type annotations. For example, we can define a function that adds two numbers as: let add x y = x + y let add = (x, y) => x + y;","title":"Type inference"},{"location":"melange-for-x-developers/#algebraic-data-types","text":"It is not possible to build an ADT in TypeScript the same way as in OCaml. Discriminated unions would be the closest analog to them, with libraries like ts-pattern as an alternative to the lack of support for pattern matching in the language. In OCaml, algebraic data types (ADTs) are a commonly used functionality of the language. They allow you to build your own types from small blocks. And with pattern matching , it is easy to access this data.","title":"Algebraic data types"},{"location":"melange-for-x-developers/#nominal-typing","text":"In TypeScript, all typing is structural. This means that it is hard sometimes to establish a boundary or separation between two types that have the same implementation. For these cases, nominal typing can be emulated using tags: type Email = string & { readonly __tag: unique symbol }; type City = string & { readonly __tag: unique symbol }; In OCaml, nominal typing is fully supported. Some of the core language types like records and variants are nominal. This means that even if you declare exactly the same type twice, functions that operate on values from one type will not be compatible with the other type. There is also structural typing, used for OCaml objects and polymorphic variants .","title":"Nominal typing"},{"location":"melange-for-x-developers/#immutability","text":"TypeScript has two base primitives to work with immutability: const and readonly . The first one is used to prevent variable reference change. const a = 1; a = 2; // Error: Cannot assign to 'a' because it is a constant. And the second one is used to make properties immutable. type A = { readonly x: number; } const a: A = { x: 1 }; a.x = 12; // Error: Cannot assign to 'x' because it is a read-only property. Nevertheless, there are some problems here. const and readonly only block reference changes but do nothing about values. With const a = [1, 2, 3] or readonly x: number[] , you can still change the contents of an array. OCaml provides data types with immutability in mind, like lists, records, or maps.","title":"Immutability"},{"location":"melange-for-x-developers/#strictness-and-soundness","text":"In TypeScript, you have the flexibility to use types like any or other expansive types such as Function . However, TypeScript provides the strict option in the tsconfig.json file to mitigate the usage of these less type-safe constructs. On the other hand, OCaml does not offer a similar option to enable or disable strictness. In OCaml, the language itself promotes type safety without the need for explicit configuration options to enforce stricter behavior. TypeScript, as mentioned in its handbook , may sacrifice soundness for practicality when needed. In contrast, OCaml implementations provide unsound methods like the identity primitive but they are generally discouraged and rarely used. The OCaml community places a strong emphasis on maintaining soundness and prefers safer alternatives to ensure code correctness.","title":"Strictness and soundness"},{"location":"melange-for-x-developers/#cheatsheet","text":"The following are some conversions between TypeScript and OCaml idioms, in the OCaml side we use Reason syntax for familiarity, as mentioned in section for JavaScript developers .","title":"Cheatsheet"},{"location":"melange-for-x-developers/#type-aliases","text":"TypeScript OCaml (Reason syntax) type Email = string; type email = string;","title":"Type aliases"},{"location":"melange-for-x-developers/#abstract-types","text":"TypeScript OCaml (Reason syntax) type Email = string & { readonly __tag: unique symbol }; /* in interface `rei` file */ type email; /* in implementation `re` file */ type email = string;","title":"Abstract types"},{"location":"melange-for-x-developers/#union-types-variants","text":"TypeScript OCaml (Reason syntax) type Result = \"Error\" | \"Success\"; type result = Error | Success type Result = | { type: \"Error\"; message: string } | { type: \"Success\"; n: number }; type result = | Error(string) | Success(int)","title":"Union types / Variants"},{"location":"melange-for-x-developers/#immutability_1","text":"TypeScript OCaml (Reason syntax) const a = 1; type A = { readonly x: number }; type ImmutableA = Readonly ; const arr: ReadonlyArray = [1, 2, 3]; type A = { readonly [x: string]: number }; Enabled by default","title":"Immutability"},{"location":"melange-for-x-developers/#currying_1","text":"TypeScript OCaml (Reason syntax) type addT = (_: number) => (_: number) => number; const add: addT = (l) => (r) => l + r; add(5)(3); Enabled by default","title":"Currying"},{"location":"melange-for-x-developers/#parametric-polymorphism","text":"TypeScript OCaml (Reason syntax) type length = <T>(_: T[]) => number; let length: list('a) => int;","title":"Parametric polymorphism"},{"location":"melange-for-x-developers/#for-js_of_ocaml-developers","text":"There are many similarities between Js_of_ocaml and Melange: Both compile OCaml to JavaScript. Both are available as libraries in the official opam repository. Both have access to the OCaml platform developer toolchain: the OCaml LSP server, Merlin, and the different editor extensions. Both have implemented extensive integration with Dune. However, while Js_of_ocaml transforms OCaml bytecode into JavaScript, Melange starts the conversion process earlier in the compiler pipeline, as it transforms the compiler lambda representation into JavaScript. Js_of_ocaml is a project with years of development and evolution behind it, while Melange appearance is relatively recent in comparison. These aspects translate into different trade-offs. Compared to Js_of_ocaml: Melange can be installed in an OCaml 5 opam switch, but the editor integration is not working at the time (May 2023). Similarly, any OCaml 5 features like effects are currently unsupported in Melange. Js_of_ocaml allows to compile the compiler itself and create \"toplevels\", which is not possible with Melange. Marshal is well supported in Js_of_ocaml, while Melange does not support it. Libraries like Unix or Str are available in Js_of_ocaml but not in Melange. Js_of_ocaml supports sourcemaps, which Melange do not support yet (as of May 2023). On the upside, in Melange: Consuming existing JavaScript packages might be a bit easier in Melange, thanks to its compilation model and the extensive availability of mechanisms to bind to JavaScript code. There is great support for some of the most used JavaScript libraries like ReactJS or GraphQL clients. The generated JavaScript bundles are generally smaller. The generated JavaScript code is generally more readable. Melange can generate ES6 or commonjs while Js_of_ocaml generates an IIFE (Immediately Invoked Function Expression) (as of Sep 2023) Straight-forward integration with modern JavaScript tooling like Webpack, NextJS, etc. This is possible thanks to the 1 module \\<-> 1 JavaScript file compilation model.","title":"For Js_of_ocaml developers"},{"location":"melange-for-x-developers/#for-rescript-developers","text":"As a project that shares a common ancestry with ReScript, Melange inherits a lot of its characteristics: The compilation model involves compiling a single module into a single JavaScript file. The libraries provided by ReScript (Belt and Js) are available in Melange too. The mechanisms provided for communicating with JavaScript code are mostly the same. However, one of Melange\u2019s goals is to maximize compatibility with the OCaml ecosystem. This goal translates into fundamental differences in how Melange and ReScript function from the perspective of both library authors and users.","title":"For ReScript developers"},{"location":"melange-for-x-developers/#package-manager","text":"ReScript projects rely exclusively on npm for all packages they depend on. Melange projects, on the other hand, will use opam for native packages, and npm for JavaScript ones. Melange package management is explained in detail in the dedicated section .","title":"Package manager"},{"location":"melange-for-x-developers/#build-system","text":"ReScript has its own build system, originally based on Ninja. Melange defers to Dune for build orchestration, as it is explained in detail in the corresponding section . By integrating with Dune, Melange can benefit from the multiple features provided. One of the most useful features is first-class supports for monorepos. But there are multiple others, like virtual libraries, watch mode, or integrations with tools like odoc . The divergences caused by the different build systems have a lot of implications and nuances that might be too complex to explain in this section, but some of the specific details have been discussed in the OCaml forum .","title":"Build system"},{"location":"melange-for-x-developers/#source-based-vs-pre-built-distribution","text":"While with ReScript every dependency can be downloaded with just npm, Melange projects will have to use opam and npm. This is a trade-off: on one hand, some Melange projects might need to include two package configuration files. But on the other hand they can benefit from opam\u2019s source-based package distribution model for things like PPXs, linters, or any other OCaml tooling. In comparison, consuming any OCaml tool in ReScript is more challenging. Since ReScript lacks a native toolchain, authors of the tools need to provide pre-built binaries for all the supported systems and architectures. This poses difficulties for the authors in terms of maintenance, and it can also result in certain users being unable to access these tools if their systems or architectures are not included in the pre-built binaries.","title":"Source-based vs pre-built distribution"},{"location":"melange-for-x-developers/#ocaml-compiler-version","text":"ReScript is compatible with the 4.06 version of the OCaml compiler, while Melange is compatible with the version 4.14 (as of May 2023). The Melange roadmap for Q2 includes a milestone to upgrade to the latest version of the compiler to the 5.x release line.","title":"OCaml compiler version"},{"location":"melange-for-x-developers/#editor-integration","text":"Melange is fully compatible with the OCaml platform editor tools , which makes possible to work in projects that include OCaml and Melange code using the same editor configuration. ReScript has its own set of editor plugins .","title":"Editor integration"},{"location":"melange-for-x-developers/#feature-choice-and-alignment-with-ocaml","text":"ReScript\u2019s goal is to model the language to bring it as close to JavaScript as possible. From the website introduction section : ReScript looks like JS, acts like JS, and compiles to the highest quality of clean, readable and performant JS (...) New features added to ReScript might close its alignment with JavaScript, but some of these features can lead to greater divergence from OCaml. As Melange prioritizes compatibility with OCaml, it avoids incorporating those features that widen the gap between the two. Here is a non-exhaustive list of the features that ReScript has added and will not be supported in Melange: The async / await syntax: similar functionality can be achieved in Melange through the usage of binding operators (introduced in OCaml 4.13). Optional fields in records, like type t = { x : int, @optional y : int } . Uncurried by default. The restriction above only applies to features that compromise compatibility with OCaml, but otherwise Melange can incorporate bugfixes or new functionality from ReScript. On the other hand, as Melange goal is to keep up with the version of the OCaml compiler, there are features inherited from OCaml that are not supported by ReScript at the moment (May 2023), for example: Binding operators / let bindings Better type errors for some specific cases Additions to the stdlib The whole list of changes added to the OCaml compiler can be checked here .","title":"Feature choice and alignment with OCaml"},{"location":"melange-for-x-developers/#syntax","text":"ReScript encourages using the new syntax for any new code. While OCaml syntax might be supported today, its usage is not documented. Reason syntax is no longer supported. Melange supports and documents both Reason and OCaml syntaxes. It also includes a best-effort support for ReScript syntax for backwards compatibility, provided through the rescript-syntax package, available in opam . To build any code written using ReScript syntax, the only requirement is to download this package, as Melange and Dune will already coordinate to make use of it when res or resi files are found.","title":"Syntax"},{"location":"new-to-ocaml/","text":"New to OCaml? As a backend for the OCaml compiler, Melange shares many similarities with the OCaml language. Nevertheless, there are some notable differences between the two. This documentation aims to clarify these distinctions. For features that Melange inherits from OCaml, readers will be directed to the main OCaml documentation. If you are completely new to OCaml, it is recommended to familiarize yourself with the language first. Learn OCaml is a good starting point. but we recommend the following tutorials from the official OCaml website: A First Hour With OCaml OCaml Exercises","title":"New to OCaml?"},{"location":"new-to-ocaml/#new-to-ocaml","text":"As a backend for the OCaml compiler, Melange shares many similarities with the OCaml language. Nevertheless, there are some notable differences between the two. This documentation aims to clarify these distinctions. For features that Melange inherits from OCaml, readers will be directed to the main OCaml documentation. If you are completely new to OCaml, it is recommended to familiarize yourself with the language first. Learn OCaml is a good starting point. but we recommend the following tutorials from the official OCaml website: A First Hour With OCaml OCaml Exercises","title":"New to OCaml?"},{"location":"package-management/","text":"Package management Melange can consume packages from both the npm registry and the opam repository . For Melange libraries and bindings (compile-time dependencies), use one of the package management alternatives described in Getting started . The rest of this guide assumes you're using opam. For JavaScript packages required by Melange bindings (runtime dependencies), use npm (or any of its alternatives ). Integrating with opam provides Melange projects with a native toolchain. Opam has been designed for the OCaml language, and it enables Melange projects to have first-class access to PPXs , compiler libraries, editor integration software and other tools. In the following sections, we explain in detail how to use opam to define the dependencies of our application, as well as how to publish packages in the public opam repository. However, this documentation is not exhaustive and only covers what we believe are the most important parts for Melange developers. If you want to learn more about opam, please refer to the opam manual and FAQ page . opam for Melange developers Before diving into specifics about using opam, there are the two relevant differences between opam and npm that are worth mentioning. 1. One version of each package At any given time, any opam switch can only install at most a single version of a package. This is known as a flat dependency graph, and some package managers (like Bower ) follow a similar approach. A flat dependency graph means that, for example, it is impossible to have two versions of reason-react installed in the same project. This avoids some headaches when one inadvertently installs two versions of a dependency. Also, and specifically for Melange, it helps keep the resulting JavaScript bundle lean and reduce page load for browser-based applications. On the other hand, upgrading your project dependencies to more recent versions might become tricky. Due to the restriction where only one version of a package can be installed, there is a higher chance for conflicts between the constraints of the transitive dependencies. If opam cannot find a solution, these conflicts need to be solved manually. This generally involves updating the conflicting dependency to make it compatible with a newer version of Melange or a transient dependency. 2. A source-based package manager for a compiled language opam distributes just the source code of the packages and leaves the compilation step to a build phase that runs when consuming them, after they have been fetched. As a package manager for a compiled language like OCaml, opam has first-class support for this build step. Every package must tell opam how it should be built, and the way to do this is by using the build field in the package .opam file. This is different than how npm is used: most published packages in the npm registry don\u2019t rely on a build step. As Melange relies on OCaml packages for the compilation step (either PPXs, linters, instrumentation, or any other build-time package), it\u2019s integrated with the native toolchain that OCaml programmers are familiar with, which relieves library authors of the burden of creating and distributing pre-built versions of their packages. Let\u2019s go now through the most common actions with opam when working on Melange projects. The following guide is based on the amazing opam for npm/yarn users guide by Louis ( @khady ). Initial configuration The first thing to do is to install opam. There is an official documentation page on installation. Most of the time, we can get it from your package manager. Otherwise, binaries are provided for every platform. There is a necessary first step before using opam: opam init -a Here is what the documentation of the opam init command says: The init command initialises a local \"opam root\" (by default, ~/.opam/ ) that holds opam\u2019s data and packages. This is a necessary step for normal operation of opam. The initial software repositories are fetched, and an initial 'switch' can also be installed, according to the configuration and options. These can be afterwards configured using opam switch and opam repository. Additionally, this command allows to customise some aspects of opam\u2019s shell integration, when run initially (avoiding the interactive dialog), but also at any later time. The interesting parts are: The opam root is at ~/.opam opam uses shell integration to make our life easier opam uses the concept of a switch A switch is the equivalent of the node_modules folder in npm\u2019s world. It contains all the packages that are installed. There are local switches and global switches, in the same way we can have a node_modules folder local to our project or install global dependencies using yarn global or npm install -g . Global switches can be handy sometimes, but to avoid confusion, the recommendation is to avoid them. The default settings can be changed if the -a option is omitted while calling opam init . Minimal app.opam file The equivalent to package.json is an app.opam file, where app is the name of the package. It is possible to have multiple opam files in the same directory or project. There is no opam command to manipulate the opam file. A command similar to npm init or yarn add does not exist in opam, so the updates in .opam files have to be done by hand. A minimal .opam file looks like this: opam-version: \"2.0\" name: \"my-app\" authors: \"Louis\" homepage: \"https://github.com/khady/example\" maintainer: \"ex@ample.com\" dev-repo: \"git+ssh://git@github.com:khady/example.git\" bug-reports: \"https://github.com/khady/example/issues\" version: \"0.1\" build: [ [ \"dune\" \"subst\" ] {pinned} [ \"dune\" \"build\" \"-p\" name \"-j\" jobs ] ] depends: [ \"dune\" {build} ] build: tells opam that dune is needed only to build the project. Installing packages The first thing we need is a local switch in the current project. To verify if a switch exists already, we can look for a _opam directory at the root of the project or use the opam switch command to identify if a switch already exists in the project folder. If it does not exist, we can create it with: opam switch create . 4.14.1 --deps-only If it exists, we can install the dependencies of the project with: opam install . --deps-only Add new packages To add a new package to the opam switch, we can do: opam install <package_name> But opam will not modify the app.opam file during the installation, this has to be done by hand, by adding the name of the package in the depends field. Linking packages for development This can be achieved with opam pin . For example, to pin a package to a specific commit on GitHub: opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#61bfbfaf8c971dec5152bce7e528d30552c70bc5 Branch names can also be used. opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#feature For packages that are already published in the opam repository, a shortcut to pin to the latest version is to use the --dev-repo flag, e.g. opam pin add melange.dev --dev-repo To remove the pinning for any package, use opam unpin <package_name> or opam pin remove <package_name> . For other options, the command is well described in the official documentation . Upgrading packages There is one big difference compared to npm: opam stores a local copy of the opam repository, like apt-get does in Debian. So before doing any upgrades, we might want to update this copy before: opam update Then, to upgrade the installed packages to the latest version, run: opam upgrade <package_name> opam upgrade is also able to upgrade all the packages of the local switch if no package name is given. Dev dependencies You can use the with-dev-setup field to define dependencies that are only required at development time. For example: depends: [ \"ocamlformat\" {with-dev-setup} ] This has to be combined with the --with-dev-setup flag when installing dependencies, e.g. opam install --deps-only --with-dev-setup . Lock files Lock files aren\u2019t as used in the opam world as somewhere else, but they can be used as follows: Using opam lock to generate the lock file when needed (basically after each opam install or opam upgrade ). Adding --locked to all the opam install --deps-only and opam switch create . commands. Bindings and package management When writing Melange libraries that bind to existing JavaScript packages, the users of the Melange library will have to make sure that those JavaScript packages are installed. This is similar to how OCaml bindings to system libraries work, see examples like ocaml-mariadb or ocurl . The advantage of this approach \u2014as opposed to vendoring the JavaScript packages inside the bindings\u2014 is that it gives users of the bindings complete flexibility over the way these JavaScript packages are downloaded and bundled. Finding and using Melange compatible packages opam packages Melange packages are usually available on opam . Package search is available in the opam CLI via opam search <package-name> , e.g. opam search reason-react . You can run opam install <package-name> to download, build and install opam packages in your switch. Remember that opam won't automatically add the dependency to <your-project>.opam file, so it must be added manually: ... depends: [ ... \"reason-react\" {>= \"0.11.0\"} ] To use a library from the installed package, add the library name to the dune file under the libraries field. For example, if our project structure looks like: project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 dune \u2502 \u251c\u2500\u2500 ReactComponent1.ml \u2502 \u251c\u2500\u2500 ReactComponent2.ml \u2502 \u2514\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 data.ml \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u251c\u2500\u2500 package.json \u2514\u2500\u2500 ... project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 dune \u2502 \u251c\u2500\u2500 ReactComponent1.re \u2502 \u251c\u2500\u2500 ReactComponent2.re \u2502 \u2514\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 data.re \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u251c\u2500\u2500 package.json \u2514\u2500\u2500 ... then reason-react should be added to the dune file under the src folder: (melange.emit (target output) (alias react) (libraries lib reason-react) (preprocess (pps reactjs-jsx-ppx)) (module_systems es6)) Some libraries will only work after being processed by an accompanying PPX, e.g., reason-react requires preprocessing with reactjs-jsx-ppx . These preprocessors may be installed together with the library as part of the same package, or they might be part of a different package, in which case they need to be installed separately. Unpublished opam packages opam packages that have not yet been published may be installed with the opam pin command. For example, opam pin add melange-fetch.dev git+https://github.com/melange-community/melange-fetch will obtain melange-fetch from its Git repository and install it on your switch. Your <your-project>.opam file should then be updated in two places: ... depends: [ ... \"melange-fetch\" {dev} ] pin-depends: [ [ \"melange-fetch.dev\" \"git+https://github.com/melange-community/melange-fetch\" ] ] Once installed, the libraries included in the package can be added to the dune file: (melange.emit (target output) (alias react) (libraries lib reason-react melange-fetch) (preprocess (pps reactjs-jsx-ppx)) (module_systems es6)) npm packages A number of Melange compatible packages can be found on npm. Many older, but still useful, compatible BuckleScript libraries can be found on npm, e.g., bs-json . Run npm install @glennsl/bs-json to add the dependency locally and record it in the package.json file at the root of our project. Dune needs to be made aware of the newly installed package. The subdir stanza can be handy in these cases: (subdir node_modules (dirs @glennsl) (subdir @glennsl/bs-json/src (library (name bs_json) (wrapped false) (modes melange))) If the dune file contains the line (dirs :standard \\ node_modules) , it should be removed, so that Dune can process the new Melange sources under the node_modules folder. In our project structure above we have the file data.ml data.re under the folder src/lib . If we want use the bs-json library from within the data.ml data.re file then we need to add the library name to the dune file in the same folder, i.e., src/lib/dune : (library (name data) (libraries bs_json) (modes melange)) Note that the library bs-json was defined as bs_json in the subdir stanza and is referenced as bs_json in the dune file. This is necessary as Dune wrapped libraries will only expose a single top-level module named after the library, so the library name has to be a valid module name. This is why library names with characters like - are not valid. We can add new subdir stanzas for every package we'd like to consume this way. See this dune file for a larger example that uses multiple npm packages.","title":"Package management"},{"location":"package-management/#package-management","text":"Melange can consume packages from both the npm registry and the opam repository . For Melange libraries and bindings (compile-time dependencies), use one of the package management alternatives described in Getting started . The rest of this guide assumes you're using opam. For JavaScript packages required by Melange bindings (runtime dependencies), use npm (or any of its alternatives ). Integrating with opam provides Melange projects with a native toolchain. Opam has been designed for the OCaml language, and it enables Melange projects to have first-class access to PPXs , compiler libraries, editor integration software and other tools. In the following sections, we explain in detail how to use opam to define the dependencies of our application, as well as how to publish packages in the public opam repository. However, this documentation is not exhaustive and only covers what we believe are the most important parts for Melange developers. If you want to learn more about opam, please refer to the opam manual and FAQ page .","title":"Package management"},{"location":"package-management/#opam-for-melange-developers","text":"Before diving into specifics about using opam, there are the two relevant differences between opam and npm that are worth mentioning. 1. One version of each package At any given time, any opam switch can only install at most a single version of a package. This is known as a flat dependency graph, and some package managers (like Bower ) follow a similar approach. A flat dependency graph means that, for example, it is impossible to have two versions of reason-react installed in the same project. This avoids some headaches when one inadvertently installs two versions of a dependency. Also, and specifically for Melange, it helps keep the resulting JavaScript bundle lean and reduce page load for browser-based applications. On the other hand, upgrading your project dependencies to more recent versions might become tricky. Due to the restriction where only one version of a package can be installed, there is a higher chance for conflicts between the constraints of the transitive dependencies. If opam cannot find a solution, these conflicts need to be solved manually. This generally involves updating the conflicting dependency to make it compatible with a newer version of Melange or a transient dependency. 2. A source-based package manager for a compiled language opam distributes just the source code of the packages and leaves the compilation step to a build phase that runs when consuming them, after they have been fetched. As a package manager for a compiled language like OCaml, opam has first-class support for this build step. Every package must tell opam how it should be built, and the way to do this is by using the build field in the package .opam file. This is different than how npm is used: most published packages in the npm registry don\u2019t rely on a build step. As Melange relies on OCaml packages for the compilation step (either PPXs, linters, instrumentation, or any other build-time package), it\u2019s integrated with the native toolchain that OCaml programmers are familiar with, which relieves library authors of the burden of creating and distributing pre-built versions of their packages. Let\u2019s go now through the most common actions with opam when working on Melange projects. The following guide is based on the amazing opam for npm/yarn users guide by Louis ( @khady ).","title":"opam for Melange developers"},{"location":"package-management/#initial-configuration","text":"The first thing to do is to install opam. There is an official documentation page on installation. Most of the time, we can get it from your package manager. Otherwise, binaries are provided for every platform. There is a necessary first step before using opam: opam init -a Here is what the documentation of the opam init command says: The init command initialises a local \"opam root\" (by default, ~/.opam/ ) that holds opam\u2019s data and packages. This is a necessary step for normal operation of opam. The initial software repositories are fetched, and an initial 'switch' can also be installed, according to the configuration and options. These can be afterwards configured using opam switch and opam repository. Additionally, this command allows to customise some aspects of opam\u2019s shell integration, when run initially (avoiding the interactive dialog), but also at any later time. The interesting parts are: The opam root is at ~/.opam opam uses shell integration to make our life easier opam uses the concept of a switch A switch is the equivalent of the node_modules folder in npm\u2019s world. It contains all the packages that are installed. There are local switches and global switches, in the same way we can have a node_modules folder local to our project or install global dependencies using yarn global or npm install -g . Global switches can be handy sometimes, but to avoid confusion, the recommendation is to avoid them. The default settings can be changed if the -a option is omitted while calling opam init .","title":"Initial configuration"},{"location":"package-management/#minimal-appopam-file","text":"The equivalent to package.json is an app.opam file, where app is the name of the package. It is possible to have multiple opam files in the same directory or project. There is no opam command to manipulate the opam file. A command similar to npm init or yarn add does not exist in opam, so the updates in .opam files have to be done by hand. A minimal .opam file looks like this: opam-version: \"2.0\" name: \"my-app\" authors: \"Louis\" homepage: \"https://github.com/khady/example\" maintainer: \"ex@ample.com\" dev-repo: \"git+ssh://git@github.com:khady/example.git\" bug-reports: \"https://github.com/khady/example/issues\" version: \"0.1\" build: [ [ \"dune\" \"subst\" ] {pinned} [ \"dune\" \"build\" \"-p\" name \"-j\" jobs ] ] depends: [ \"dune\" {build} ] build: tells opam that dune is needed only to build the project.","title":"Minimal app.opam file"},{"location":"package-management/#installing-packages","text":"The first thing we need is a local switch in the current project. To verify if a switch exists already, we can look for a _opam directory at the root of the project or use the opam switch command to identify if a switch already exists in the project folder. If it does not exist, we can create it with: opam switch create . 4.14.1 --deps-only If it exists, we can install the dependencies of the project with: opam install . --deps-only","title":"Installing packages"},{"location":"package-management/#add-new-packages","text":"To add a new package to the opam switch, we can do: opam install <package_name> But opam will not modify the app.opam file during the installation, this has to be done by hand, by adding the name of the package in the depends field.","title":"Add new packages"},{"location":"package-management/#linking-packages-for-development","text":"This can be achieved with opam pin . For example, to pin a package to a specific commit on GitHub: opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#61bfbfaf8c971dec5152bce7e528d30552c70bc5 Branch names can also be used. opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#feature For packages that are already published in the opam repository, a shortcut to pin to the latest version is to use the --dev-repo flag, e.g. opam pin add melange.dev --dev-repo To remove the pinning for any package, use opam unpin <package_name> or opam pin remove <package_name> . For other options, the command is well described in the official documentation .","title":"Linking packages for development"},{"location":"package-management/#upgrading-packages","text":"There is one big difference compared to npm: opam stores a local copy of the opam repository, like apt-get does in Debian. So before doing any upgrades, we might want to update this copy before: opam update Then, to upgrade the installed packages to the latest version, run: opam upgrade <package_name> opam upgrade is also able to upgrade all the packages of the local switch if no package name is given.","title":"Upgrading packages"},{"location":"package-management/#dev-dependencies","text":"You can use the with-dev-setup field to define dependencies that are only required at development time. For example: depends: [ \"ocamlformat\" {with-dev-setup} ] This has to be combined with the --with-dev-setup flag when installing dependencies, e.g. opam install --deps-only --with-dev-setup .","title":"Dev dependencies"},{"location":"package-management/#lock-files","text":"Lock files aren\u2019t as used in the opam world as somewhere else, but they can be used as follows: Using opam lock to generate the lock file when needed (basically after each opam install or opam upgrade ). Adding --locked to all the opam install --deps-only and opam switch create . commands.","title":"Lock files"},{"location":"package-management/#bindings-and-package-management","text":"When writing Melange libraries that bind to existing JavaScript packages, the users of the Melange library will have to make sure that those JavaScript packages are installed. This is similar to how OCaml bindings to system libraries work, see examples like ocaml-mariadb or ocurl . The advantage of this approach \u2014as opposed to vendoring the JavaScript packages inside the bindings\u2014 is that it gives users of the bindings complete flexibility over the way these JavaScript packages are downloaded and bundled.","title":"Bindings and package management"},{"location":"package-management/#finding-and-using-melange-compatible-packages","text":"","title":"Finding and using Melange compatible packages"},{"location":"package-management/#opam-packages","text":"Melange packages are usually available on opam . Package search is available in the opam CLI via opam search <package-name> , e.g. opam search reason-react . You can run opam install <package-name> to download, build and install opam packages in your switch. Remember that opam won't automatically add the dependency to <your-project>.opam file, so it must be added manually: ... depends: [ ... \"reason-react\" {>= \"0.11.0\"} ] To use a library from the installed package, add the library name to the dune file under the libraries field. For example, if our project structure looks like: project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 dune \u2502 \u251c\u2500\u2500 ReactComponent1.ml \u2502 \u251c\u2500\u2500 ReactComponent2.ml \u2502 \u2514\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 data.ml \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u251c\u2500\u2500 package.json \u2514\u2500\u2500 ... project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 dune \u2502 \u251c\u2500\u2500 ReactComponent1.re \u2502 \u251c\u2500\u2500 ReactComponent2.re \u2502 \u2514\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 data.re \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u251c\u2500\u2500 package.json \u2514\u2500\u2500 ... then reason-react should be added to the dune file under the src folder: (melange.emit (target output) (alias react) (libraries lib reason-react) (preprocess (pps reactjs-jsx-ppx)) (module_systems es6)) Some libraries will only work after being processed by an accompanying PPX, e.g., reason-react requires preprocessing with reactjs-jsx-ppx . These preprocessors may be installed together with the library as part of the same package, or they might be part of a different package, in which case they need to be installed separately.","title":"opam packages"},{"location":"package-management/#unpublished-opam-packages","text":"opam packages that have not yet been published may be installed with the opam pin command. For example, opam pin add melange-fetch.dev git+https://github.com/melange-community/melange-fetch will obtain melange-fetch from its Git repository and install it on your switch. Your <your-project>.opam file should then be updated in two places: ... depends: [ ... \"melange-fetch\" {dev} ] pin-depends: [ [ \"melange-fetch.dev\" \"git+https://github.com/melange-community/melange-fetch\" ] ] Once installed, the libraries included in the package can be added to the dune file: (melange.emit (target output) (alias react) (libraries lib reason-react melange-fetch) (preprocess (pps reactjs-jsx-ppx)) (module_systems es6))","title":"Unpublished opam packages"},{"location":"package-management/#npm-packages","text":"A number of Melange compatible packages can be found on npm. Many older, but still useful, compatible BuckleScript libraries can be found on npm, e.g., bs-json . Run npm install @glennsl/bs-json to add the dependency locally and record it in the package.json file at the root of our project. Dune needs to be made aware of the newly installed package. The subdir stanza can be handy in these cases: (subdir node_modules (dirs @glennsl) (subdir @glennsl/bs-json/src (library (name bs_json) (wrapped false) (modes melange))) If the dune file contains the line (dirs :standard \\ node_modules) , it should be removed, so that Dune can process the new Melange sources under the node_modules folder. In our project structure above we have the file data.ml data.re under the folder src/lib . If we want use the bs-json library from within the data.ml data.re file then we need to add the library name to the dune file in the same folder, i.e., src/lib/dune : (library (name data) (libraries bs_json) (modes melange)) Note that the library bs-json was defined as bs_json in the subdir stanza and is referenced as bs_json in the dune file. This is necessary as Dune wrapped libraries will only expose a single top-level module named after the library, so the library name has to be a valid module name. This is why library names with characters like - are not valid. We can add new subdir stanzas for every package we'd like to consume this way. See this dune file for a larger example that uses multiple npm packages.","title":"npm packages"},{"location":"rationale/","text":"Why Melange OCaml offers an industrial-strength, state-of-the-art type system and provides type inference with very few type annotations, proving invaluable in managing large projects. JavaScript is one of the most pervasive platforms to deploy and run software. Thanks to years of efforts to improve the different VMs available, the JavaScript code running on browsers and other environments is heavily optimized and can support use cases for large products and tools. Melange helps developers and companies bring the advantages of the OCaml platform to users of the Web platform in a way that makes it easy for developers to integrate with both ecosystems. A bit of history To better understand where Melange comes from, it might help to go through some of the related projects that have appeared over the last decade or so. Js_of_ocaml Js_of_ocaml is another OCaml to JavaScript compiler that was made public in 2011. In the presentation paper published in 2013, it is explicitly mentioned that one of its design goals was to remain as compatible as possible with the OCaml compiler, without requiring a lot of maintenance work, as the OCaml community was not excessively large at the time. To achieve this goal, Js_of_ocaml picks the bytecode generated by OCaml batch compilation and generates JavaScript from it. OCaml bytecode has a very stable interface, so Js_of_ocaml can easily upgrade to new versions of the compiler. Due to this design decision, it can also remain compatible with most of the OCaml ecosystem, as long as the tools or libraries don\u2019t rely on C code. The downside of using bytecode is that it gets harder to communicate with existing JavaScript code. This is due to both the constraints on runtime representations that Js_of_ocaml can use for OCaml values, and also the compilation model used, where one bytecode program is compiled to one JavaScript program, but it is not possible to generate an individual JavaScript module from one OCaml module. Another downside is that the resulting JavaScript is hard to read, as it is converted from a low-level representation like bytecode. BuckleScript Then, in 2016, Bob Zhang suggests on a Js_of_ocaml repository issue the possibility to start converting to JavaScript from an earlier stage of the compilation process, instead of using bytecode. This proposal fundamentally diverges from Js_of_ocaml original design and goals, so he starts working on what will become BuckleScript. BuckleScript gets some inspiration from Js_of_ocaml, for example in the way that JavaScript objects are represented with Js.t . But it differs from Js_of_ocaml in many ways: it can generate more readable and lighter code. It also generates one .js file per module, which makes it easier to integrate with existing JavaScript codebases. BuckleScript puts a big emphasis on communicating with JavaScript code through a rich collection of attributes applied to external primitives. Reason Around the same year, a project called Reason appears at Facebook. Led by Jordan Walke, the idea is to create an alternate syntax for OCaml that is closer to C and JavaScript. Even if Reason has no take on which platform the code is deployed \u2014native applications binaries, or web applications using JavaScript as a target language\u2014, BuckleScript adds first class support for Reason from early on. At that point, it becomes evident that the combination of Reason with BuckleScript is a great match: BuckleScript provides tools and infrastructure to work with JavaScript ecosystem, while Reason allows developers to write their programs in a syntax they are familiar with. Over time, and with help of other Facebook employees and the community providing bindings to pervasive JavaScript libraries like React.js with reason-react , the combination of Reason and BuckleScript gains adoption. BuckleScript gets rebranded However, at some point the goals of both BuckleScript and Reason projects become harder to reconcile. In August 2020, the BuckleScript team decides to rename to ReScript, stops adding support for the latest versions of the Reason parser, and replaces it with a new parser that changes the syntax. The reasons for the rebranding are explained in the official ReScript blog post . The rebranding is trying to ease onboarding and adoption of the ReScript language, giving the project more chances to compete with mainstream compiled-to-JavaScript languages like TypeScript. However, for many existing users of BuckleScript and Reason, it is the explicit confirmation of something that had been hinted implicitly before: ReScript goals are not compatible with providing a good integration with the OCaml ecosystem. Melange: back to OCaml This is where Melange comes in. A few weeks after the rebranding of BuckleScript to ReScript, Ant\u00f3nio Monteiro starts working on a fork of BuckleScript with a simple (not easy) goal: replace the Ninja build system , which BuckleScript had been using from its creation, with Dune , which is the most used build system for OCaml projects. This fork of BuckleScript is later named Melange. After finishing the switch from Ninja to Dune, several additional features are added to bring it closer to OCaml. Some examples are the upgrade of the OCaml compiler version used by Melange, or modeling the changes to the OCaml compiler that Melange uses as just a plain library, instead of a full fork of the upstream compiler. In September 2022, Ahrefs decides to invest on Melange by funding a project to deepen the integration between Dune and Melange. This project achieves its completion in Spring 2023, with the migration of Ahrefs frontend codebase to Melange and the new public releases that support it: version 3.8 of Dune and 1.0 of Melange. Looking forward While reaching v1.0 marks a major milestone for Melange, it is only the beginning of the journey. The Melange team remains committed to continuously improving Melange, ensuring it remains a robust and efficient tool for OCaml developers targeting the JavaScript platform. The roadmap page details past work and current goals of Melange.","title":"Why"},{"location":"rationale/#why-melange","text":"OCaml offers an industrial-strength, state-of-the-art type system and provides type inference with very few type annotations, proving invaluable in managing large projects. JavaScript is one of the most pervasive platforms to deploy and run software. Thanks to years of efforts to improve the different VMs available, the JavaScript code running on browsers and other environments is heavily optimized and can support use cases for large products and tools. Melange helps developers and companies bring the advantages of the OCaml platform to users of the Web platform in a way that makes it easy for developers to integrate with both ecosystems.","title":"Why Melange"},{"location":"rationale/#a-bit-of-history","text":"To better understand where Melange comes from, it might help to go through some of the related projects that have appeared over the last decade or so.","title":"A bit of history"},{"location":"rationale/#js_of_ocaml","text":"Js_of_ocaml is another OCaml to JavaScript compiler that was made public in 2011. In the presentation paper published in 2013, it is explicitly mentioned that one of its design goals was to remain as compatible as possible with the OCaml compiler, without requiring a lot of maintenance work, as the OCaml community was not excessively large at the time. To achieve this goal, Js_of_ocaml picks the bytecode generated by OCaml batch compilation and generates JavaScript from it. OCaml bytecode has a very stable interface, so Js_of_ocaml can easily upgrade to new versions of the compiler. Due to this design decision, it can also remain compatible with most of the OCaml ecosystem, as long as the tools or libraries don\u2019t rely on C code. The downside of using bytecode is that it gets harder to communicate with existing JavaScript code. This is due to both the constraints on runtime representations that Js_of_ocaml can use for OCaml values, and also the compilation model used, where one bytecode program is compiled to one JavaScript program, but it is not possible to generate an individual JavaScript module from one OCaml module. Another downside is that the resulting JavaScript is hard to read, as it is converted from a low-level representation like bytecode.","title":"Js_of_ocaml"},{"location":"rationale/#bucklescript","text":"Then, in 2016, Bob Zhang suggests on a Js_of_ocaml repository issue the possibility to start converting to JavaScript from an earlier stage of the compilation process, instead of using bytecode. This proposal fundamentally diverges from Js_of_ocaml original design and goals, so he starts working on what will become BuckleScript. BuckleScript gets some inspiration from Js_of_ocaml, for example in the way that JavaScript objects are represented with Js.t . But it differs from Js_of_ocaml in many ways: it can generate more readable and lighter code. It also generates one .js file per module, which makes it easier to integrate with existing JavaScript codebases. BuckleScript puts a big emphasis on communicating with JavaScript code through a rich collection of attributes applied to external primitives.","title":"BuckleScript"},{"location":"rationale/#reason","text":"Around the same year, a project called Reason appears at Facebook. Led by Jordan Walke, the idea is to create an alternate syntax for OCaml that is closer to C and JavaScript. Even if Reason has no take on which platform the code is deployed \u2014native applications binaries, or web applications using JavaScript as a target language\u2014, BuckleScript adds first class support for Reason from early on. At that point, it becomes evident that the combination of Reason with BuckleScript is a great match: BuckleScript provides tools and infrastructure to work with JavaScript ecosystem, while Reason allows developers to write their programs in a syntax they are familiar with. Over time, and with help of other Facebook employees and the community providing bindings to pervasive JavaScript libraries like React.js with reason-react , the combination of Reason and BuckleScript gains adoption.","title":"Reason"},{"location":"rationale/#bucklescript-gets-rebranded","text":"However, at some point the goals of both BuckleScript and Reason projects become harder to reconcile. In August 2020, the BuckleScript team decides to rename to ReScript, stops adding support for the latest versions of the Reason parser, and replaces it with a new parser that changes the syntax. The reasons for the rebranding are explained in the official ReScript blog post . The rebranding is trying to ease onboarding and adoption of the ReScript language, giving the project more chances to compete with mainstream compiled-to-JavaScript languages like TypeScript. However, for many existing users of BuckleScript and Reason, it is the explicit confirmation of something that had been hinted implicitly before: ReScript goals are not compatible with providing a good integration with the OCaml ecosystem.","title":"BuckleScript gets rebranded"},{"location":"rationale/#melange-back-to-ocaml","text":"This is where Melange comes in. A few weeks after the rebranding of BuckleScript to ReScript, Ant\u00f3nio Monteiro starts working on a fork of BuckleScript with a simple (not easy) goal: replace the Ninja build system , which BuckleScript had been using from its creation, with Dune , which is the most used build system for OCaml projects. This fork of BuckleScript is later named Melange. After finishing the switch from Ninja to Dune, several additional features are added to bring it closer to OCaml. Some examples are the upgrade of the OCaml compiler version used by Melange, or modeling the changes to the OCaml compiler that Melange uses as just a plain library, instead of a full fork of the upstream compiler. In September 2022, Ahrefs decides to invest on Melange by funding a project to deepen the integration between Dune and Melange. This project achieves its completion in Spring 2023, with the migration of Ahrefs frontend codebase to Melange and the new public releases that support it: version 3.8 of Dune and 1.0 of Melange.","title":"Melange: back to OCaml"},{"location":"rationale/#looking-forward","text":"While reaching v1.0 marks a major milestone for Melange, it is only the beginning of the journey. The Melange team remains committed to continuously improving Melange, ensuring it remains a robust and efficient tool for OCaml developers targeting the JavaScript platform. The roadmap page details past work and current goals of Melange.","title":"Looking forward"},{"location":"roadmap/","text":"Roadmap This page contains: a historical overview of Melange development details of the Melange roadmap, offering a clear view into the current priorities and features being worked on. Please note that the roadmap is a rough outline and is subject to change. We encourage you to provide feedback, suggestions, and feature requests through any of the available communication channels . Q2 2023 Roadmap","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"This page contains: a historical overview of Melange development details of the Melange roadmap, offering a clear view into the current priorities and features being worked on. Please note that the roadmap is a rough outline and is subject to change. We encourage you to provide feedback, suggestions, and feature requests through any of the available communication channels .","title":"Roadmap"},{"location":"roadmap/#q2-2023","text":"Roadmap","title":"Q2 2023"}]}