<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>String (melange.Js.String)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="canonical" href="https://melange.re/v2.1.0/api/ml/melange/Js/String/index.html" /></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">melange</a> &#x00BB; <a href="../index.html">Js</a> &#x00BB; String</nav><header class="odoc-preamble"><h1>Module <code><span>Js.String</span></code></h1><p>Provide bindings to JS string</p><p>JavaScript String API</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make value</code> converts the given value to a string</p><pre class="language-ocaml"><code>make 3.5 = &quot;3.5&quot;;;
make [|1;2;3|]) = &quot;1,2,3&quot;;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-fromCharCode"><a href="#val-fromCharCode" class="anchor"></a><code><span><span class="keyword">val</span> fromCharCode : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>fromCharCode n</code> creates a string containing the character corresponding to that number; <i>n</i> ranges from 0 to 65535. If out of range, the lower 16 bits of the value are used. Thus, <code>fromCharCode 0x1F63A</code> gives the same result as <code>fromCharCode 0xF63A</code>.</p><pre class="language-ocaml"><code>fromCharCode 65 = &quot;A&quot;;;
fromCharCode 0x3c8 = {js|Ïˆ|js};;
fromCharCode 0xd55c = {js|í•œ|js};;
fromCharCode -64568 = {js|Ïˆ|js};;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-fromCharCodeMany"><a href="#val-fromCharCodeMany" class="anchor"></a><code><span><span class="keyword">val</span> fromCharCodeMany : <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>fromCharCodeMany [|n1;n2;n3|]</code> creates a string from the characters corresponding to the given numbers, using the same rules as <code>fromCharCode</code>.</p><pre class="language-ocaml"><code>fromCharCodeMany([|0xd55c, 0xae00, 33|]) = {js|í•œê¸€!|js};;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-fromCodePoint"><a href="#val-fromCodePoint" class="anchor"></a><code><span><span class="keyword">val</span> fromCodePoint : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>fromCodePoint n</code> creates a string containing the character corresponding to that numeric code point. If the number is not a valid code point, <b>raises</b> <code>RangeError</code>. Thus, <code>fromCodePoint 0x1F63A</code> will produce a correct value, unlike <code>fromCharCode 0x1F63A</code>, and <code>fromCodePoint -5</code> will raise a <code>RangeError</code>.</p><pre class="language-ocaml"><code>fromCodePoint 65 = &quot;A&quot;;;
fromCodePoint 0x3c8 = {js|Ïˆ|js};;
fromCodePoint 0xd55c = {js|í•œ|js};;
fromCodePoint 0x1f63a = {js|ðŸ˜º|js};;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-fromCodePointMany"><a href="#val-fromCodePointMany" class="anchor"></a><code><span><span class="keyword">val</span> fromCodePointMany : <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>fromCharCodeMany [|n1;n2;n3|]</code> creates a string from the characters corresponding to the given code point numbers, using the same rules as <code>fromCodePoint</code>.</p><pre class="language-ocaml"><code>fromCodePointMany([|0xd55c; 0xae00; 0x1f63a|]) = {js|í•œê¸€ðŸ˜º|js}</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length s</code> returns the length of the given string.</p><pre class="language-ocaml"><code>length &quot;abcd&quot; = 4;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>get s n</code> returns as a string the character at the given index number. If <code>n</code> is out of range, this function returns <code>undefined</code>, so at some point this function may be modified to return <code>t option</code>.</p><pre class="language-ocaml"><code>get &quot;Reason&quot; 0 = &quot;R&quot;;;
get &quot;Reason&quot; 4 = &quot;o&quot;;;
get {js|Ráº½asÃ¶Å„|js} 5 = {js|Å„|js};;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-charAt"><a href="#val-charAt" class="anchor"></a><code><span><span class="keyword">val</span> charAt : <span>index:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>charAt ~index s</code> gets the character at position <code>index</code> within string <code>s</code>. If <code>index</code> is negative or greater than the length of <code>s</code>, returns the empty string. If the string contains characters outside the range <code>\u0000-\uffff</code>, it will return the first 16-bit value at that position in the string.</p><pre class="language-ocaml"><code>charAt ~index:0 &quot;Reason&quot; = &quot;R&quot;
charAt ~index:12 &quot;Reason&quot; = &quot;&quot;;
charAt ~index:5 {js|Ráº½asÃ¶Å„|js} = {js|Å„|js}</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-charCodeAt"><a href="#val-charCodeAt" class="anchor"></a><code><span><span class="keyword">val</span> charCodeAt : <span>index:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>charCodeAt s ~index</code> returns the character code at position <code>index</code> in string <code>s</code>; the result is in the range 0-65535, unlke <code>codePointAt</code>, so it will not work correctly for characters with code points greater than or equal to <code>0x10000</code>. The return type is <code>float</code> because this function returns <code>NaN</code> if <code>index</code> is less than zero or greater than the length of the string.</p><pre class="language-ocaml"><code>charCodeAt ~index:0 {js|ðŸ˜º|js} = 0xd83d
codePointAt ~index:0 {js|ðŸ˜º|js} = Some 0x1f63a</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-codePointAt"><a href="#val-codePointAt" class="anchor"></a><code><span><span class="keyword">val</span> codePointAt : <span>index:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>codePointAt s ~index</code> returns the code point at position <code>index</code> within string <code>s</code> as a <code>Some</code> value. The return value handles code points greater than or equal to <code>0x10000</code>. If there is no code point at the given position, the function returns <code>None</code>.</p><pre class="language-ocaml"><code>codePointAt ~index:1 {js|Â¿ðŸ˜º?|js} = Some 0x1f63a
codePointAt ~index:5 &quot;abc&quot; = None</code></pre></div></div><p>ES2015</p><div class="odoc-spec"><div class="spec value external anchored" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span>other:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>concat ~other original</code> returns a new string with <code>other</code> added after <code>original</code>.</p><pre class="language-ocaml"><code>concat ~other:&quot;bell&quot; &quot;cow&quot; = &quot;cowbell&quot;;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-concatMany"><a href="#val-concatMany" class="anchor"></a><code><span><span class="keyword">val</span> concatMany : <span>strings:<span><a href="#type-t">t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>concatMany ~strings original</code> returns a new string consisting of each item of the array of strings <code>strings</code> added to the <code>original</code> string.</p><pre class="language-ocaml"><code>concatMany ~strings:[|&quot;2nd&quot;; &quot;3rd&quot;; &quot;4th&quot;|] &quot;1st&quot; = &quot;1st2nd3rd4th&quot;;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-endsWith"><a href="#val-endsWith" class="anchor"></a><code><span><span class="keyword">val</span> endsWith : <span>suffix:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>endsWith ~suffix ?len str</code> returns <code>true</code> if the <code>str</code> ends with <code>suffix</code>, <code>false</code> otherwise. If <code>len</code> is specified, `endsWith` only takes into account the first <code>len</code> characters.</p><pre class="language-ocaml"><code>endsWith ~suffix:&quot;cd&quot; ~len:4 &quot;abcd&quot; = true;;
endsWith ~suffix:&quot;cd&quot; ~len:3 &quot;abcde&quot; = false;;
endsWith ~suffix:&quot;cde&quot; ~len:99 &quot;abcde&quot; = true;;
endsWith ~suffix:&quot;ple&quot; ~len:7 &quot;example.dat&quot; = true;;
endsWith ~suffix:&quot;World!&quot; &quot;Hello, World!&quot; = true;;
endsWith ~suffix:&quot;world!&quot; &quot;Hello, World!&quot; = false;; (* case-sensitive *)
endsWith ~suffix:&quot;World&quot; &quot;Hello, World!&quot; = false;; (* exact match *)</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-includes"><a href="#val-includes" class="anchor"></a><code><span><span class="keyword">val</span> includes : <span>search:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>includes ~search ?start s</code> returns <code>true</code> if <code>search</code> is found anywhere within <code>s</code> starting at character number <code>start</code> (where 0 is the first character), <code>false</code> otherwise.</p><pre class="language-ocaml"><code>includes ~search:&quot;gram&quot; &quot;programmer&quot; = true;;
includes ~search:&quot;er&quot; &quot;programmer&quot; = true;;
includes ~search:&quot;pro&quot; &quot;programmer&quot; = true;;
includes ~search:&quot;xyz&quot; &quot;programmer&quot; = false;;
includes ~search:&quot;gram&quot; ~start:1 &quot;programmer&quot; = true;;
includes ~search:&quot;gram&quot; ~start:4 &quot;programmer&quot; = false;;
includes ~search:{js|í•œ|js} ~start:1 {js|ëŒ€í•œë¯¼êµ­|js} = true;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-indexOf"><a href="#val-indexOf" class="anchor"></a><code><span><span class="keyword">val</span> indexOf : <span>search:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>indexOf ~search ?start s</code> returns the position at which <code>search</code> was found within <code>s</code> starting at character position <code>start</code>, or <code>-1</code> if <code>search</code> is not found in that portion of <code>s</code>. The return value is relative to the beginning of the string, no matter where the search started from.</p><pre class="language-ocaml"><code>indexOf ~search:&quot;ok&quot; &quot;bookseller&quot; = 2;;
indexOf ~search:&quot;sell&quot; &quot;bookseller&quot; = 4;;
indexOf ~search:&quot;ee&quot; &quot;beekeeper&quot; = 1;;
indexOf ~search:&quot;xyz&quot; &quot;bookseller&quot; = -1;;
indexOf ~search:&quot;ok&quot; ~start:1 &quot;bookseller&quot; = 2;;
indexOf ~search:&quot;sell&quot; ~start:2 &quot;bookseller&quot; = 4;;
indexOf ~search:&quot;sell&quot; ~start:5 &quot;bookseller&quot; = -1;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-lastIndexOf"><a href="#val-lastIndexOf" class="anchor"></a><code><span><span class="keyword">val</span> lastIndexOf : <span>search:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>lastIndexOf ~search ~start s</code> returns the position of the <i>last</i> occurrence of <code>searchValue</code> within <code>s</code>, searching backwards from the given <code>start</code> position. Returns <code>-1</code> if <code>searchValue</code> is not in <code>s</code>. The return value is always relative to the beginning of the string.</p><pre class="language-ocaml"><code>lastIndexOf ~search:&quot;ok&quot; &quot;bookseller&quot; = 2;;
lastIndexOf ~search:&quot;ee&quot; &quot;beekeeper&quot; = 4;;
lastIndexOf ~search:&quot;xyz&quot; &quot;abcdefg&quot; = -1;;
lastIndexOf ~search:&quot;ok&quot; ~start:6 &quot;bookseller&quot; = 2;;
lastIndexOf ~search:&quot;ee&quot; ~start:8 &quot;beekeeper&quot; = 4;;
lastIndexOf ~search:&quot;ee&quot; ~start:3 &quot;beekeeper&quot; = 1;;
lastIndexOf ~search:&quot;xyz&quot; ~start:4 &quot;abcdefg&quot; = -1;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-localeCompare"><a href="#val-localeCompare" class="anchor"></a><code><span><span class="keyword">val</span> localeCompare : <span>other:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>localeCompare ~other:comparison reference</code> returns:</p><ul><li>a negative value if <code>reference</code> comes before <code>comparison</code> in sort order</li><li>zero if <code>reference</code> and <code>comparison</code> have the same sort order</li><li>a positive value if <code>reference</code> comes after <code>comparison</code> in sort order</li></ul><pre class="language-ocaml"><code>(localeCompare ~other:&quot;ant&quot; &quot;zebra&quot;) &gt; 0.0;;
(localeCompare ~other:&quot;zebra&quot; &quot;ant&quot;) &lt; 0.0;;
(localeCompare ~other:&quot;cat&quot; &quot;cat&quot;) = 0.0;;
(localeCompare ~other:&quot;cat&quot; &quot;CAT&quot;) &gt; 0.0;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-match_"><a href="#val-match_" class="anchor"></a><code><span><span class="keyword">val</span> match_ : <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="#type-t">t</a> option</span> array</span> option</span></span></code></div><div class="spec-doc"><p><code>match ~regexp str</code> matches a string against the given <code>regexp</code>. If there is no match, it returns <code>None</code>. For regular expressions without the <code>g</code> modifier, if there is a match, the return value is <code>Some array</code> where the array contains:</p><ul><li>The entire matched string</li><li>Any capture groups if the <code>regexp</code> had parentheses</li></ul><p>For regular expressions with the <code>g</code> modifier, a matched expression returns <code>Some array</code> with all the matched substrings and no capture groups.</p><pre class="language-ocaml"><code>match &quot;The better bats&quot; ~regexp:[%re &quot;/b[aeiou]t/&quot;] = Some [|&quot;bet&quot;|]
match &quot;The better bats&quot; ~regexp:[%re &quot;/b[aeiou]t/g&quot;] = Some [|&quot;bet&quot;;&quot;bat&quot;|]
match &quot;Today is 2018-04-05.&quot; ~regexp:[%re &quot;/(\\d+)-(\\d+)-(\\d+)/&quot;] = Some [|&quot;2018-04-05&quot;; &quot;2018&quot;; &quot;04&quot;; &quot;05&quot;|]
match &quot;The large container.&quot; ~regexp:[%re &quot;/b[aeiou]g/&quot;] = None</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span><span class="keyword">val</span> normalize : <span>?form:<span>[ `NFC <span>| `NFD</span> <span>| `NFKC</span> <span>| `NFKD</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>normalize ~form str</code> returns the normalized Unicode string using the specified form of normalization, which may be one of:</p><ul><li><code>`NFC</code> â€” Normalization Form Canonical Composition.</li><li><code>`NFD</code> â€” Normalization Form Canonical Decomposition.</li><li><code>`NFKC</code> â€” Normalization Form Compatibility Composition.</li><li><code>`NFKD</code> â€” Normalization Form Compatibility Decomposition.</li></ul><p>If <code>form</code> is omitted, <code>`NFC</code> is used.</p><p>Consider the character <code>Ã£</code>, which can be represented as the single codepoint <code>\u00e3</code> or the combination of a lower case letter A <code>\u0061</code> and a combining tilde <code>\u0303</code>. Normalization ensures that both can be stored in an equivalent binary representation.</p><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <a href="https://www.unicode.org/reports/tr15/tr15-45.html" class="value">https://www.unicode.org/reports/tr15/tr15-45.html</a> <p>Unicode technical report for details</p></li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span>count:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>repeat ~count s</code> returns a string that consists of <code>count</code> repetitions of <code>s</code>. Raises <code>RangeError</code> if <code>n</code> is negative.</p><pre class="language-ocaml"><code>repeat ~count:3 &quot;ha&quot; = &quot;hahaha&quot;
repeat ~count:0 &quot;empty&quot; = &quot;&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span><span class="keyword">val</span> replace : <span>search:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>replacement:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>replace ~search ~replacement string</code> returns a new string which is identical to <code>string</code> except with the first matching instance of <code>search</code> replaced by <code>replacement</code>.</p><p><code>search</code> is treated as a verbatim string to match, not a regular expression.</p><pre class="language-ocaml"><code>replace ~search:&quot;old&quot; ~replacement:&quot;new&quot; &quot;old string&quot; = &quot;new string&quot;
replace ~search:&quot;the&quot; ~replacement:&quot;this&quot; &quot;the cat and the dog&quot; = &quot;this cat and the dog&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-replaceByRe"><a href="#val-replaceByRe" class="anchor"></a><code><span><span class="keyword">val</span> replaceByRe : <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span> <span>replacement:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>replaceByRe ~regexp ~replacement string</code> returns a new string where occurrences matching <code>regexp</code> have been replaced by <code>replacement</code>.</p><pre class="language-ocaml"><code>replaceByRe ~regexp:[%re &quot;/[aeiou]/g&quot;] ~replacement:&quot;x&quot; &quot;vowels be gone&quot; = &quot;vxwxls bx gxnx&quot;
replaceByRe ~regexp:[%re &quot;/(\\w+) (\\w+)/&quot;] ~replacement:&quot;$2, $1&quot; &quot;Juan Fulano&quot; = &quot;Fulano, Juan&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-unsafeReplaceBy0"><a href="#val-unsafeReplaceBy0" class="anchor"></a><code><span><span class="keyword">val</span> unsafeReplaceBy0 : <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>unsafeReplaceBy0 ~regexp ~f s</code> returns a new string with some or all matches of a pattern with no capturing parentheses replaced by the value returned from the given function. The function receives as its parameters the matched string, the offset at which the match begins, and the whole string being matched</p><pre class="language-ocaml"><code>let str = &quot;beautiful vowels&quot;
let re = [%re &quot;/[aeiou]/g&quot;]
let matchFn matchPart offset wholeString = Js.String.toUpperCase matchPart

let replaced = Js.String.unsafeReplaceBy0 ~regexp:re ~f:matchFn str

let () = Js.log replaced (* prints &quot;bEAUtifUl vOwEls&quot; *)</code></pre><p>@see &lt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-unsafeReplaceBy1"><a href="#val-unsafeReplaceBy1" class="anchor"></a><code><span><span class="keyword">val</span> unsafeReplaceBy1 : 
  <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>unsafeReplaceBy1 ~regexp ~f s</code> returns a new string with some or all matches of a pattern with one set of capturing parentheses replaced by the value returned from the given function. The function receives as its parameters the matched string, the captured strings, the offset at which the match begins, and the whole string being matched.</p><pre class="language-ocaml"><code>let str = &quot;increment 23&quot;
let re = [%re &quot;/increment (\\d+)/g&quot;]
let matchFn matchPart p1 offset wholeString =
  wholeString ^ &quot; is &quot; ^ (string_of_int ((int_of_string p1) + 1))

let replaced = Js.String.unsafeReplaceBy1 ~regexp:re ~f:matchFn str

let () = Js.log replaced (* prints &quot;increment 23 is 24&quot; *)</code></pre><p>@see &lt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-unsafeReplaceBy2"><a href="#val-unsafeReplaceBy2" class="anchor"></a><code><span><span class="keyword">val</span> unsafeReplaceBy2 : 
  <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>unsafeReplaceBy2 ~regexp ~f s</code> returns a new string with some or all matches of a pattern with two sets of capturing parentheses replaced by the value returned from the given function. The function receives as its parameters the matched string, the captured strings, the offset at which the match begins, and the whole string being matched.</p><pre class="language-ocaml"><code>let str = &quot;7 times 6&quot;
let re = [%re &quot;/(\\d+) times (\\d+)/&quot;]
let matchFn matchPart p1 p2 offset wholeString =
  string_of_int ((int_of_string p1) * (int_of_string p2))

let replaced = Js.String.unsafeReplaceBy2 ~regexp:re ~f:matchFn str

let () = Js.log replaced (* prints &quot;42&quot; *)</code></pre><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter" class="value">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter</a> <p>MDN</p></li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-unsafeReplaceBy3"><a href="#val-unsafeReplaceBy3" class="anchor"></a><code><span><span class="keyword">val</span> unsafeReplaceBy3 : 
  <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>unsafeReplaceBy3 ~regexp ~f s</code> returns a new string with some or all matches of a pattern with three sets of capturing parentheses replaced by the value returned from the given function. The function receives as its parameters the matched string, the captured strings, the offset at which the match begins, and the whole string being matched.</p><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter" class="value">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter</a> <p>MDN</p></li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-search"><a href="#val-search" class="anchor"></a><code><span><span class="keyword">val</span> search : <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>search ~regexp str</code> returns the starting position of the first match of <code>regexp</code> in the given <code>str</code>, or -1 if there is no match.</p><pre class="language-ocaml"><code>search ~regexp:[%re &quot;/\\d+/&quot;] &quot;testing 1 2 3&quot; = 8;;
search ~regexp:[%re &quot;/\\d+/&quot;] &quot;no numbers&quot; = -1;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-slice"><a href="#val-slice" class="anchor"></a><code><span><span class="keyword">val</span> slice : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>?end_:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>slice ?start ?end str</code> returns the substring of <code>str</code> starting at character <code>start</code> up to but not including <code>end</code></p><p>If either <code>start</code> or <code>end</code> is negative, then it is evaluated as <code>length str
    - start</code> (or <code>length str - end</code>).</p><p>If <code>end</code> is greater than the length of <code>str</code>, then it is treated as <code>length
    str</code>.</p><p>If <code>start</code> is greater than <code>end</code>, <code>slice</code> returns the empty string.</p><pre class="language-ocaml"><code>slice ~start:2 ~end_:5 &quot;abcdefg&quot; = &quot;cde&quot;;;
slice ~start:2 ~end_:9 &quot;abcdefg&quot; = &quot;cdefg&quot;;;
slice ~start:(-4) ~end_:(-2) &quot;abcdefg&quot; = &quot;de&quot;;;
slice ~start:5 ~end_:1 &quot;abcdefg&quot; = &quot;&quot;;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span>?sep:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?limit:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> array</span></span></code></div><div class="spec-doc"><p><code>split ?sep ?limit str</code> splits the given <code>str</code> at every occurrence of <code>sep</code> and returns an array of the first <code>limit</code> resulting substrings. If <code>limit</code> is negative or greater than the number of substrings, the array will contain all the substrings.</p><pre class="language-ocaml"><code>split ~sep:&quot;/&quot; ~limit: 3 &quot;ant/bee/cat/dog/elk&quot; = [|&quot;ant&quot;; &quot;bee&quot;; &quot;cat&quot;|];;
split ~sep:&quot;/&quot; ~limit: 0 &quot;ant/bee/cat/dog/elk&quot; = [| |];;
split ~sep:&quot;/&quot; ~limit: 9 &quot;ant/bee/cat/dog/elk&quot; = [|&quot;ant&quot;; &quot;bee&quot;; &quot;cat&quot;; &quot;dog&quot;; &quot;elk&quot;|];;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-splitByRe"><a href="#val-splitByRe" class="anchor"></a><code><span><span class="keyword">val</span> splitByRe : <span>regexp:<span class="xref-unresolved">Js__.Js_re.t</span> <span class="arrow">&#45;&gt;</span></span> <span>?limit:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> option</span> array</span></span></code></div><div class="spec-doc"><p><code>splitByRe str ~regexp ?limit ()</code> splits the given <code>str</code> at every occurrence of <code>regexp</code> and returns an array of the first <code>limit</code> resulting substrings. If <code>limit</code> is negative or greater than the number of substrings, the array will contain all the substrings.</p><pre class="language-ocaml"><code>splitByRe ~regexp:[%re &quot;/\\s*:\\s*/&quot;] ~limit:3 &quot;one: two: three: four&quot; = [|&quot;one&quot;; &quot;two&quot;; &quot;three&quot;|];;
splitByRe ~regexp:[%re &quot;/\\s*:\\s*/&quot;] ~limit:0 &quot;one: two: three: four&quot; = [| |];;
splitByRe ~regexp:[%re &quot;/\\s*:\\s*/&quot;] ~limit:8 &quot;one: two: three: four&quot; = [|&quot;one&quot;; &quot;two&quot;; &quot;three&quot;; &quot;four&quot;|];;</code></pre><p>;</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-startsWith"><a href="#val-startsWith" class="anchor"></a><code><span><span class="keyword">val</span> startsWith : <span>prefix:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>startsWith ~prefix ?start str</code> returns <code>true</code> if the <code>str</code> starts with <code>prefix</code> starting at position <code>start</code>, <code>false</code> otherwise. If <code>start</code> is negative, the search starts at the beginning of <code>str</code>.</p><pre class="language-ocaml"><code>startsWith ~prefix:&quot;Hello&quot; ~start:0 &quot;Hello, World!&quot; = true;;
startsWith ~prefix:&quot;World&quot; ~start:7 &quot;Hello, World!&quot; = true;;
startsWith ~prefix:&quot;World&quot; ~start:8 &quot;Hello, World!&quot; = false;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-substr"><a href="#val-substr" class="anchor"></a><code><span><span class="keyword">val</span> substr : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>substr ?start ?len str</code> returns the substring of <code>str</code> of length <code>len</code> starting at position <code>start</code>.</p><p>If <code>start</code> is less than zero, the starting position is the length of <code>str</code></p><ul><li><code>start</code>.</li></ul><p>If <code>start</code> is greater than or equal to the length of <code>str</code>, returns the empty string.</p><p>If <code>len</code> is less than or equal to zero, returns the empty string.</p><pre class="language-ocaml"><code>substr ~start:3 ~len:4 &quot;abcdefghij&quot; = &quot;defghij&quot;
substr ~start:(-3) ~len:4 &quot;abcdefghij&quot; = &quot;hij&quot;
substr ~start:12 ~len:2 &quot;abcdefghij&quot; = &quot;&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-substring"><a href="#val-substring" class="anchor"></a><code><span><span class="keyword">val</span> substring : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>?end_:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>substring ~start ~end_ str</code> returns characters <code>start</code> up to but not including <code>end_</code> from <code>str</code>.</p><p>If <code>start</code> is less than zero, it is treated as zero.</p><p>If <code>end_</code> is zero or negative, the empty string is returned.</p><p>If <code>start</code> is greater than <code>end_</code>, the start and finish points are swapped.</p><pre class="language-ocaml"><code>substring ~start:3 ~end_:6 &quot;playground&quot; = &quot;ygr&quot;;;
substring ~start:6 ~end_:3 &quot;playground&quot; = &quot;ygr&quot;;;
substring ~start:4 ~end_:12 &quot;playground&quot; = &quot;ground&quot;;;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-toLowerCase"><a href="#val-toLowerCase" class="anchor"></a><code><span><span class="keyword">val</span> toLowerCase : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>toLowerCase str</code> converts <code>str</code> to lower case using the locale-insensitive case mappings in the Unicode Character Database. Notice that the conversion can give different results depending upon context, for example with the Greek letter sigma, which has two different lower case forms when it is the last character in a string or not.</p><pre class="language-ocaml"><code>toLowerCase &quot;ABC&quot; = &quot;abc&quot;;;
toLowerCase {js|Î£Î |js} = {js|ÏƒÏ€|js};;
toLowerCase {js|Î Î£|js} = {js|Ï€Ï‚|js};;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-toLocaleLowerCase"><a href="#val-toLocaleLowerCase" class="anchor"></a><code><span><span class="keyword">val</span> toLocaleLowerCase : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>toLocaleLowerCase str</code> converts <code>str</code> to lower case using the current locale</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-toUpperCase"><a href="#val-toUpperCase" class="anchor"></a><code><span><span class="keyword">val</span> toUpperCase : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>toUpperCase str</code> converts <code>str</code> to upper case using the locale-insensitive case mappings in the Unicode Character Database. Notice that the conversion can expand the number of letters in the result; for example the German <code>ÃŸ</code> capitalizes to two <code>S</code>es in a row.</p><pre class="language-ocaml"><code>toUpperCase &quot;abc&quot; = &quot;ABC&quot;;;
toUpperCase {js|StraÃŸe|js} = {js|STRASSE|js};;
toUpperCase {js|Ï€Ï‚|js} = {js|Î Î£|js};;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-toLocaleUpperCase"><a href="#val-toLocaleUpperCase" class="anchor"></a><code><span><span class="keyword">val</span> toLocaleUpperCase : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>toLocaleUpperCase str</code> converts <code>str</code> to upper case using the current locale</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>trim str</code> returns a string that is <code>str</code> with whitespace stripped from both ends. Internal whitespace is not removed.</p><pre class="language-ocaml"><code>trim &quot;   abc def   &quot; = &quot;abc def&quot;
trim &quot;\n\r\t abc def \n\n\t\r &quot; = &quot;abc def&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-anchor"><a href="#val-anchor" class="anchor"></a><code><span><span class="keyword">val</span> anchor : <span>name:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>anchor ~name:anchorName anchorText</code> creates a string with an HTML <code>&lt;a&gt;</code> element with <code>name</code> attribute of <code>anchorName</code> and <code>anchorText</code> as its content.</p><pre class="language-ocaml"><code>anchor ~name:&quot;page1&quot; &quot;Page One&quot; = &quot;&lt;a name=\&quot;page1\&quot;&gt;Page One&lt;/a&gt;&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-link"><a href="#val-link" class="anchor"></a><code><span><span class="keyword">val</span> link : <span>href:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>link ~href:urlText linkText</code> creates a string with an HTML <code>&lt;a&gt;</code> element with <code>href</code> attribute of <code>urlText</code> and <code>linkText</code> as its content.</p><pre class="language-ocaml"><code>link ~href:&quot;page2.html&quot; &quot;Go to page two&quot; = &quot;&lt;a href=\&quot;page2.html\&quot;&gt;Go to page two&lt;/a&gt;&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-unsafeToArrayLike"><a href="#val-unsafeToArrayLike" class="anchor"></a><code><span><span class="keyword">val</span> unsafeToArrayLike : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Js__.Js_array.array_like</span></span></span></code></div></div></div></body></html>
