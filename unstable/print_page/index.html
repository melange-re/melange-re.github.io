<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="OCaml for JavaScript developers">
<meta name="ahrefs-site-verification" content="418209e997de7b3e1afdfd3575944e61695804a30ab7c7f5bf27f64d32935cda">

    <title>Print Site - Melange</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../css/print-site-enum-headings1.css" rel="stylesheet" />
        <link href="../css/print-site-enum-headings2.css" rel="stylesheet" />
        <link href="../css/print-site-enum-headings3.css" rel="stylesheet" />
        <link href="../css/print-site-enum-headings4.css" rel="stylesheet" />
        <link href="../css/print-site-enum-headings5.css" rel="stylesheet" />
        <link href="../css/print-site-enum-headings6.css" rel="stylesheet" />
        <link href="../css/print-site.css" rel="stylesheet" />
        <link href="../css/extra.css" rel="stylesheet" />
        <link href="../css/version-select.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Print Site";
        var mkdocs_page_input_path = "print_page.md";
        var mkdocs_page_url = "/print_page/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/ocaml.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 

        <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function () {
            remove_material_navigation();remove_mkdocs_theme_navigation();generate_toc();
        })
        </script>
        </head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Melange
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="/unstable/search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../rationale/">Why</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Learn</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../new-to-ocaml/">New to OCaml?</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../package-management/">Package management</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build-system/">Build system</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../communicate-with-javascript/">Communicate with JavaScript</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../melange-for-x-developers/">Melange for X developers</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Reference</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../api/">API</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Try</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../try/">Playground</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Talk</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../community/">Community</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Melange</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>Print Site</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div id="print-site-page" class="print-site-enumerate-headings print-site-enumerate-figures">
        <section class="print-page">
            <div id="print-page-toc" data-toc-depth="3">
                <nav role='navigation' class='print-page-toc-nav'>
                <h1 class='print-page-toc-title'>Table of Contents</h1>
                </nav>
            </div>
        </section>
        <section class="print-page" id="index"><h1 id="index-melange">Melange</h1>
<div id="home-subtitle">OCaml for JavaScript developers</div>

<hr />
<p>Melange is a backend for the OCaml compiler that emits JavaScript. Melange
strives to provide the best integration with both the OCaml and JavaScript
ecosystems. To know more about it start by reading the <a href="#getting-started">introductory
tutorial</a>, then check the <a href="#learn">Learn</a> section for more
information.</p>
<!-- Temporarily disabled in readthedocs mode
<div class="text-center">
<a href="#getting-started" class="btn btn-primary" role="button">Getting Started</a>
<a href="#learn" class="btn btn-primary" role="button">Learn</a>
</div>
-->

<div class="jumbotron">
<h2 class="display-4 text-center">Features</h2>
<div class="row">
  <div class="col-sm-6">
    <div class="card">
      <div class="card-body">
        <h3 class="card-title">A Solid Type System</h3>
        <p class="card-text">
            Melange leverages OCaml's powerful type system to catch more bugs at
            compile time. Large, complex codebases become easy to maintain and
            refactor.
        </p>
      </div>
    </div>
  </div>
  <div class="col-sm-6">
    <div class="card">
      <div class="card-body">
        <h3 class="card-title">First-Class Editor and Tooling</h3>
        <p class="card-text">
            Melange fully utilizes the power of
            <a href="https://ocaml.org/docs/platform">the OCaml Platform</a>
            to provide integrations with editors such as VSCode, Vim, or Emacs,
            with features like type inspection, autocomplete, and more. It also
            has first-class integration with <a
            href="https://dune.build/">Dune</a>, OCaml's most used build system.
        </p>
      </div>
    </div>
  </div>
</div>

<div class="row">
  <div class="col-sm-6">
    <div class="card">
      <div class="card-body">
        <h3 class="card-title">JavaScript Integration</h3>
        <p class="card-text">
            Whether you want to use existing JavaScript packages from NPM, or
            use your own JavaScript libraries in your projects, Melange has you
            covered. With an expressive bindings language, and an ergonomic
            compilation model, Melange can help you build robust applications
            that leverage functionality from the JavaScript ecosystem.
        </p>
      </div>
    </div>
  </div>
  <div class="col-sm-6">
    <div class="card">
      <div class="card-body">
        <h3 class="card-title">Stable and Industry Backed</h3>
        <p class="card-text">
            Melange builds on top of decades of type system research, compiler
            engineering and tooling development to provide a polished
            developer experience. Companies like Ahrefs use Melange daily to
            deploy web applications for their users.
        </p>
      </div>
    </div>
  </div>
</div>
</div></section><section class="print-page" id="rationale"><h1 id="rationale-why-melange">Why Melange</h1>
<p>OCaml offers an industrial-strength, state-of-the-art type system and provides
type inference with very few type annotations, proving invaluable in managing
large projects.</p>
<p>JavaScript is one of the most pervasive platforms to deploy and run software.
Thanks to years of efforts to improve the different VMs available, the
JavaScript code running on browsers and other environments is heavily optimized
and can support use cases for large products and tools.</p>
<p>Melange helps developers and companies bring the advantages of the OCaml
platform to users of the Web platform in a way that makes it easy for developers
to integrate with both ecosystems.</p>
<h2 id="rationale-a-bit-of-history">A bit of history</h2>
<p>To better understand where Melange comes from, it might help to go through some
of the related projects that have appeared over the last decade or so.</p>
<h3 id="rationale-js_of_ocaml">Js_of_ocaml</h3>
<p><a href="https://github.com/ocsigen/js_of_ocaml/">Js_of_ocaml</a> is another OCaml to
JavaScript compiler that was made public in 2011. In <a href="https://www.irif.fr/~vouillon/publi/js_of_ocaml.pdf">the presentation
paper</a> published in 2013,
it is explicitly mentioned that one of its design goals was to remain as
compatible as possible with the OCaml compiler, without requiring a lot of
maintenance work, as the OCaml community was not excessively large at the time.</p>
<p>To achieve this goal, Js_of_ocaml picks the bytecode generated by OCaml <a href="https://ocaml.org/manual/comp.html">batch
compilation</a> and generates JavaScript from
it. OCaml bytecode has a very stable interface, so Js_of_ocaml can easily
upgrade to new versions of the compiler. Due to this design decision, it can
also remain compatible with most of the OCaml ecosystem, as long as the tools or
libraries don’t rely on C code.</p>
<p>The downside of using bytecode is that it gets harder to communicate with
existing JavaScript code. This is due to both the constraints on runtime
representations that Js_of_ocaml can use for OCaml values, and also the
compilation model used, where one bytecode program is compiled to one JavaScript
program, but it is not possible to generate an individual JavaScript module from
one OCaml module.</p>
<p>Another downside is that the resulting JavaScript is hard to read, as it is
converted from a low-level representation like bytecode.</p>
<h3 id="rationale-bucklescript">BuckleScript</h3>
<p>Then, in 2016, Bob Zhang suggests <a href="https://github.com/ocsigen/Js_of_ocaml/issues/338">on a Js_of_ocaml repository
issue</a> the possibility to
start converting to JavaScript from an earlier stage of the compilation process,
instead of using bytecode. This proposal fundamentally diverges from
Js_of_ocaml original design and goals, so he starts working on what will
become BuckleScript.</p>
<p>BuckleScript gets some inspiration from Js_of_ocaml, for example in the way
that JavaScript objects are represented with <code>Js.t</code>. But it differs from
Js_of_ocaml in many ways: it can generate more readable and lighter code. It
also generates one <code>.js</code> file per module, which makes it easier to integrate
with existing JavaScript codebases. BuckleScript puts a big emphasis on
communicating with JavaScript code through a rich collection of attributes
applied to <code>external</code> primitives.</p>
<h3 id="rationale-reason">Reason</h3>
<p>Around the same year, a project called <a href="https://reasonml.github.io/">Reason</a>
appears at Facebook. Led by Jordan Walke, the idea is to create an alternate
syntax for OCaml that is closer to C and JavaScript. Even if Reason has no take
on which platform the code is deployed —native applications binaries, or web
applications using JavaScript as a target language—, BuckleScript adds first
class support for Reason from early on. At that point, it becomes evident that
the combination of Reason with BuckleScript is a great match: BuckleScript
provides tools and infrastructure to work with JavaScript ecosystem, while
Reason allows developers to write their programs in a syntax they are familiar
with.</p>
<p>Over time, and with help of other Facebook employees and the community providing
bindings to pervasive JavaScript libraries like React.js with
<a href="https://github.com/reasonml/reason-react/"><code>reason-react</code></a>, the combination of
Reason and BuckleScript gains adoption.</p>
<h3 id="rationale-bucklescript-gets-rebranded">BuckleScript gets rebranded</h3>
<p>However, at some point the goals of both BuckleScript and Reason projects become
harder to reconcile. In August 2020, the BuckleScript team decides to rename to
ReScript, stops adding support for the latest versions of the Reason parser, and
replaces it with a new parser that changes the syntax. The reasons for the
rebranding are explained in <a href="https://rescript-lang.org/blog/bucklescript-is-rebranding">the official ReScript blog
post</a>.</p>
<p>The rebranding is trying to ease onboarding and adoption of the ReScript
language, giving the project more chances to compete with mainstream
compiled-to-JavaScript languages like TypeScript. However, for many existing
users of BuckleScript and Reason, it is the explicit confirmation of something
that had been hinted implicitly before: ReScript goals are not compatible with
providing a good integration with the OCaml ecosystem.</p>
<h3 id="rationale-melange-back-to-ocaml">Melange: back to OCaml</h3>
<p>This is where Melange comes in. A few weeks after the rebranding of BuckleScript
to ReScript, António Monteiro starts working on a fork of BuckleScript with a
simple (not easy) goal: replace the <a href="https://ninja-build.org/">Ninja build
system</a>, which BuckleScript had been using from its
creation, with <a href="https://dune.build/">Dune</a>, which is the most used build system
for OCaml projects.</p>
<p>This fork of BuckleScript is later named Melange. After finishing the switch
from Ninja to Dune, several additional features are added to bring it closer to
OCaml. Some examples are the upgrade of the OCaml compiler version used by
Melange, or modeling the changes to the OCaml compiler that Melange uses as just
a plain library, instead of a full fork of the upstream compiler.</p>
<p>In September 2022, Ahrefs decides to invest on Melange by funding a project to
deepen the integration between Dune and Melange. This project achieves its
completion in Spring 2023, with the <a href="https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4">migration of Ahrefs frontend codebase to
Melange</a>
and the new public releases that support it: version 3.8 of Dune and 1.0 of
Melange.</p></section><section class="print-page" id="getting-started"><h1 id="getting-started-getting-started">Getting started</h1>
<p class="centered">Get up and running with Melange in no time!</p>

<hr />
<h2 id="getting-started-install-a-package-manager">Install a package manager</h2>
<p>To work with Melange, you need to install a package manager compatible with
OCaml. If you are not sure which one to use, we recommend
<a href="https://opam.ocaml.org/">opam</a>, a source-based package manager for OCaml, but
there are <a href="#getting-started-alternative-package-managers-experimental">other alternatives</a>
available.</p>
<p>Instructions for installing opam on different operating systems can be found at
the opam <a href="https://opam.ocaml.org/doc/Install.html">install page</a>, and you can
find <a href="#package-management">a whole section about it</a> on this website.</p>
<h2 id="getting-started-template">Template</h2>
<p>The easiest way to get started with Melange is by using the
<a href="https://github.com/melange-re/melange-opam-template">melange-opam-template</a>.
You can clone it from <a href="https://github.com/melange-re/melange-opam-template/generate">this
link</a>, and follow
the instructions in the <a href="https://github.com/melange-re/melange-opam-template/blob/main/README.md">readme
file</a>
to configure the <a href="https://opam.ocaml.org/blog/opam-local-switches/">local opam
switch</a> and download the
necessary dependencies to build the project.</p>
<h2 id="getting-started-editor-integration">Editor integration</h2>
<p>One of the goals of Melange is to remain compatible with OCaml. One of the major
benefits of this compatibility is that developers working on Melange projects
can use the same editor tooling as they would for OCaml.</p>
<p>OCaml developer tooling has been built, tested, and refined over the years, with
plugins available for many editors. The most actively maintained plugins are for
Visual Studio Code, Emacs, and Vim.</p>
<p>For Visual Studio Code, install the <a href="https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform">OCaml Platform Visual Studio Code
extension</a>
from the Visual Studio Marketplace. When you load an OCaml source file for the
first time, you may be prompted to select the toolchain to use. Select the
version of OCaml you are using from the list, such as 4.14.1. Further
instructions for configuration can be found in the <a href="https://github.com/ocamllabs/vscode-ocaml-platform#setting-up-the-extension-for-your-project">extension
repository</a>.</p>
<p>For Emacs and Vim, the configuration may vary depending on the case, and there
are several options available. You can read about them in the <a href="http://ocamlverse.net/content/editor_setup.html">editor setup
page</a> of the OCamlverse
documentation site.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> Melange editor integration currently only works with 4.14.x, even
though it can compile melange projects on other OCaml switches.</p>
</blockquote>
<h2 id="getting-started-alternative-package-managers-experimental">Alternative package managers (experimental)</h2>
<p>Melange can also be used with other package managers. The following instructions
apply to <a href="#getting-started-nix">Nix</a> and <a href="#getting-started-esy">esy</a>.</p>
<h3 id="getting-started-nix"><a href="https://nixos.org/">Nix</a></h3>
<p>Melange provides an overlay that can be:</p>
<ul>
<li>referenced from a <a href="https://nixos.wiki/wiki/Flakes">Nix flake</a></li>
<li>overlayed onto a <code>nixpkgs</code> package set</li>
</ul>
<p>Make sure <a href="https://nixos.org/download.html">Nix</a> is installed. The following
<code>flake.nix</code> illustrates how to set up a Melange development environment.</p>
<pre><code class="language-nix">{
  description = &quot;Melange starter&quot;;

  inputs = {
    flake-utils.url = &quot;github:numtide/flake-utils&quot;;
    nixpkgs.url = &quot;github:nixos/nixpkgs&quot;;

    # Depend on the Melange flake, which provides the overlay
    melange.url = &quot;github:melange-re/melange&quot;;
  };

  outputs = { self, nixpkgs, flake-utils, melange }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system}.appendOverlays [
          # Set the OCaml set of packages to the 4.14 release line
          (self: super: { ocamlPackages = super.ocaml-ng.ocamlPackages_4_14; })
          # Apply the Melange overlay
          melange.overlays.default
        ];
        inherit (pkgs) ocamlPackages;
      in

      {
        devShells.default = pkgs.mkShell {
          nativeBuildInputs = with ocamlPackages; [
            ocaml
            dune_3
            findlib
            ocaml-lsp
            ocamlPackages.melange
          ];
          buildInputs = [ ocamlPackages.melange ];
        };
      });
}
</code></pre>
<p>To enter a Melange development shell, run <code>nix develop -c $SHELL</code>.</p>
<h3 id="getting-started-esy"><a href="https://esy.sh/">esy</a></h3>
<p>First, make sure <code>esy</code> is
<a href="https://esy.sh/docs/en/getting-started.html#install-esy">installed</a>. <code>npm i -g
esy</code> does the trick in most setups.</p>
<p>The following is an example <code>esy.json</code> that can help start a Melange project. A
<a href="https://github.com/melange-re/melange-esy-template">project template for esy</a>
is also available if you prefer to <a href="https://github.com/melange-re/melange-esy-template/generate">start from a
template</a>.</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;melange-project&quot;,
  &quot;dependencies&quot;: {
    &quot;ocaml&quot;: &quot;4.14.x&quot;,
    &quot;@opam/dune&quot;: &quot;&gt;= 3.8.0&quot;,
    &quot;@opam/melange&quot;: &quot;*&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@opam/ocaml-lsp-server&quot;: &quot;*&quot;
  },
  &quot;esy&quot;: {
    &quot;build&quot;: [
      &quot;dune build @melange&quot;
    ]
  }
}
</code></pre>
<p>Run:</p>
<ol>
<li><code>esy install</code> to build and make all dependencies available</li>
<li><code>esy shell</code> to enter a Melange development environment</li>
</ol></section>
                        <h1 class='nav-section-title' id='section-learn'>
                            Learn <a class='headerlink' href='#section-learn' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="new-to-ocaml"><h1 id="new-to-ocaml-new-to-ocaml">New to OCaml?</h1>
<p>As a backend for the OCaml compiler, Melange shares many similarities with the
OCaml language. Nevertheless, there are some notable differences between the
two. This documentation aims to clarify these distinctions. For features that
Melange inherits from OCaml, readers will be directed to the main OCaml
documentation.</p>
<p>If you are completely new to OCaml, it is recommended to familiarize yourself
with the language first. <a href="https://ocaml.org/docs">Learn OCaml</a> is a good
starting point. but we recommend the following tutorials from the official OCaml
website:</p>
<ul>
<li><a href="https://ocaml.org/docs/first-hour">A First Hour With OCaml</a></li>
<li><a href="https://ocaml.org/problems">OCaml Exercises</a></li>
</ul></section><section class="print-page" id="package-management"><h1 id="package-management-package-management">Package management</h1>
<p>Melange can consume packages from both the <a href="https://www.npmjs.com/">npm
registry</a> and the <a href="https://opam.ocaml.org/packages/">opam
repository</a>.</p>
<ul>
<li>For Melange libraries and bindings (compile-time dependencies), use one of
  the package management alternatives described in <a href="#getting-started">Getting
  started</a>. The rest of this guide assumes you're using
  opam.</li>
<li>For JavaScript packages required by Melange bindings (runtime dependencies),
  use <a href="https://docs.npmjs.com/cli/">npm</a> (or <a href="https://npmtrends.com/@microsoft/rush-vs-bolt-vs-pnpm-vs-rush-vs-yarn">any of its
  alternatives</a>).</li>
</ul>
<p>Integrating with opam provides Melange projects with a native toolchain. Opam
has been designed for the OCaml language, and it enables Melange projects to
have first-class access to <a href="https://ocaml.org/docs/metaprogramming">PPXs</a>,
compiler libraries, editor integration software and other tools.</p>
<p>In the following sections, we explain in detail how to use opam to define the
dependencies of our application, as well as how to publish packages in the
public opam repository. However, this documentation is not exhaustive and only
covers what we believe are the most important parts for Melange developers. If
you want to learn more about opam, please refer to the <a href="https://opam.ocaml.org/doc/Manual.html">opam
manual</a> and <a href="https://opam.ocaml.org/doc/FAQ.html">FAQ
page</a>.</p>
<h2 id="package-management-opam-for-melange-developers">opam for Melange developers</h2>
<p>Before diving into specifics about using opam, there are the two relevant
differences between opam and npm that are worth mentioning.</p>
<p><strong>1. One version of each package</strong></p>
<p>At any given time, any opam switch can only install <em>at most</em> a single version
of a package. This is known as a flat dependency graph, and some package
managers (like <a href="https://bower.io/">Bower</a>) follow a similar approach.</p>
<p>A flat dependency graph means that, for example, it is impossible to have two
versions of <a href="https://github.com/reasonml/reason-react/"><code>reason-react</code></a>
installed in the same project. This avoids some headaches when one inadvertently
installs two versions of a dependency. Also, and specifically for Melange, it
helps keep the resulting JavaScript bundle lean and reduce page load for
browser-based applications.</p>
<p>On the other hand, upgrading your project dependencies to more recent versions
might become tricky. Due to the restriction where only one version of a package
can be installed, there is a higher chance for conflicts between the constraints
of the transitive dependencies. If opam cannot find a solution, these conflicts
need to be solved manually. This generally involves updating the conflicting
dependency to make it compatible with a newer version of Melange or a transient
dependency.</p>
<p><strong>2. A source-based package manager for a compiled language</strong></p>
<p>opam distributes just the source code of the packages and leaves the compilation
step to a build phase that runs when consuming them, after they have been
fetched. As a package manager for a compiled language like OCaml, opam has
first-class support for this build step. Every package must tell opam how it
should be built, and the way to do this is by using the <a href="https://opam.ocaml.org/doc/Manual.html#opamfield-build"><code>build</code>
field</a> in the package
<code>.opam</code> file. This is different than how npm is used: most published packages in
the npm registry don’t rely on a build step.</p>
<p>As Melange relies on OCaml packages for the compilation step (either PPXs,
linters, instrumentation, or any other build-time package), it’s integrated with
the native toolchain that OCaml programmers are familiar with, which relieves
library authors of the burden of creating and distributing pre-built versions of
their packages.</p>
<hr />
<p>Let’s go now through the most common actions with opam when working on Melange
projects. The following guide is based on the amazing <a href="http://ocamlverse.net/content/opam_npm.html">opam for npm/yarn
users</a> guide by Louis
(<a href="https://github.com/Khady">@khady</a>).</p>
<h3 id="package-management-initial-configuration">Initial configuration</h3>
<p>The first thing to do is to install opam. There is an <a href="https://opam.ocaml.org/doc/Install.html">official documentation
page</a> on installation. Most of the
time, we can get it from your package manager. Otherwise, binaries are provided
for every platform.</p>
<p>There is a necessary first step before using opam:</p>
<pre><code class="language-text">opam init -a
</code></pre>
<p>Here is what the documentation of the <code>opam init</code> command says:</p>
<blockquote>
<p>The init command initialises a local "opam root" (by default, <code>~/.opam/</code>) that
holds opam’s data and packages. This is a necessary step for normal operation
of opam. The initial software repositories are fetched, and an initial
'switch' can also be installed, according to the configuration and options.
These can be afterwards configured using opam switch and opam repository.</p>
<p>Additionally, this command allows to customise some aspects of opam’s shell
integration, when run initially (avoiding the interactive dialog), but also at
any later time.</p>
</blockquote>
<p>The interesting parts are:</p>
<ul>
<li>The opam root is at <code>~/.opam</code></li>
<li>opam uses shell integration to make our life easier</li>
<li>opam uses the concept of a <em>switch</em></li>
</ul>
<p>A switch is the equivalent of the <code>node_modules</code> folder in npm’s world. It
contains all the packages that are installed. There are local switches and
global switches, in the same way we can have a <code>node_modules</code> folder local to
our project or install global dependencies using <code>yarn global</code> or <code>npm install
-g</code>. Global switches can be handy sometimes, but to avoid confusion, the
recommendation is to avoid them.</p>
<p>The default settings can be changed if the <code>-a</code> option is omitted while calling
<code>opam init</code>.</p>
<h3 id="package-management-minimal-appopam-file">Minimal <code>app.opam</code> file</h3>
<p>The equivalent to <code>package.json</code> is an <code>app.opam</code> file, where <code>app</code> is the name
of the package. It is possible to have multiple opam files in the same directory
or project.</p>
<p>There is no opam command to manipulate the opam file. A command similar to <code>npm
init</code> or <code>yarn add</code> does not exist in opam, so the updates in <code>.opam</code> files have
to be done by hand.</p>
<p>A minimal <code>.opam</code> file looks like this:</p>
<pre><code class="language-text">opam-version: &quot;2.0&quot;
name: &quot;my-app&quot;
authors: &quot;Louis&quot;
homepage: &quot;https://github.com/khady/example&quot;
maintainer: &quot;ex@ample.com&quot;
dev-repo: &quot;git+ssh://git@github.com:khady/example.git&quot;
bug-reports: &quot;https://github.com/khady/example/issues&quot;
version: &quot;0.1&quot;
build: [
  [ &quot;dune&quot; &quot;subst&quot; ] {pinned}
  [ &quot;dune&quot; &quot;build&quot; &quot;-p&quot; name &quot;-j&quot; jobs ]
]
depends: [
  &quot;dune&quot; {build}
]
</code></pre>
<p><code>build:</code> tells opam that <code>dune</code> is needed only to build the project.</p>
<h3 id="package-management-installing-packages">Installing packages</h3>
<p>The first thing we need is a local switch in the current project. To verify if a
switch exists already, we can look for a <code>_opam</code> directory at the root of the
project or use the <code>opam switch</code> command to identify if a switch already exists
in the project folder.</p>
<p>If it does not exist, we can create it with:</p>
<pre><code class="language-text">opam switch create . 4.14.1 --deps-only
</code></pre>
<p>If it exists, we can install the dependencies of the project with:</p>
<pre><code class="language-text">opam install . --deps-only
</code></pre>
<h3 id="package-management-add-new-packages">Add new packages</h3>
<p>To add a new package to the opam switch, we can do:</p>
<pre><code class="language-text">opam install &lt;package_name&gt;
</code></pre>
<p>But opam will not modify the <code>app.opam</code> file during the installation, this has
to be done by hand, by adding the name of the package in the <code>depends</code> field.</p>
<h3 id="package-management-linking-packages-for-development">Linking packages for development</h3>
<p>This can be achieved with <code>opam pin</code>. For example, to pin a package to a
specific commit on GitHub:</p>
<pre><code class="language-text">opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#61bfbfaf8c971dec5152bce7e528d30552c70bc5
</code></pre>
<p>Branch names can also be used.</p>
<pre><code class="language-text">opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#feature
</code></pre>
<p>For packages that are already published in the opam repository, a shortcut to
pin to the latest version is to use the <code>--dev-repo</code> flag, e.g.</p>
<pre><code class="language-text">opam pin add melange.dev --dev-repo
</code></pre>
<p>To remove the pinning for any package, use <code>opam unpin &lt;package_name&gt;</code> or <code>opam
pin remove &lt;package_name&gt;</code>.</p>
<p>For other options, the command is well described in <a href="https://opam.ocaml.org/doc/Usage.html#opam-pin">the official
documentation</a>.</p>
<h3 id="package-management-upgrading-packages">Upgrading packages</h3>
<p>There is one big difference compared to npm: opam stores a local copy of the
opam repository, like <code>apt-get</code> does in Debian. So before doing any upgrades, we
might want to update this copy before:</p>
<pre><code class="language-text">opam update
</code></pre>
<p>Then, to upgrade the installed packages to the latest version, run:</p>
<pre><code class="language-text">opam upgrade &lt;package_name&gt;
</code></pre>
<p><code>opam upgrade</code> is also able to upgrade <em>all</em> the packages of the local switch if
no package name is given.</p>
<h3 id="package-management-dev-dependencies">Dev dependencies</h3>
<p>You can use the <a href="https://opam.ocaml.org/doc/Manual.html#pkgvar-with-dev-setup"><code>with-dev-setup</code>
field</a> to define
dependencies that are only required at development time. For example:</p>
<pre><code>depends: [
  &quot;ocamlformat&quot; {with-dev-setup}
]
</code></pre>
<p>This has to be combined with the <code>--with-dev-setup</code> flag when installing
dependencies, e.g. <code>opam install --deps-only --with-dev-setup</code>.</p>
<h3 id="package-management-lock-files">Lock files</h3>
<p>Lock files aren’t as used in the opam world as somewhere else, but they can be
used as follows:</p>
<ul>
<li>Using <code>opam lock</code> to generate the lock file when needed (basically after each
  <code>opam install</code> or <code>opam upgrade</code>).</li>
<li>Adding <code>--locked</code> to all the <code>opam install --deps-only</code> and <code>opam switch
  create .</code> commands.</li>
</ul>
<h3 id="package-management-bindings-and-package-management">Bindings and package management</h3>
<p>When writing Melange libraries that bind to existing JavaScript packages, the
users of the Melange library will have to make sure that those JavaScript
packages are installed.</p>
<p>This is similar to how OCaml bindings to system libraries work, see examples
like
<a href="https://github.com/andrenth/ocaml-mariadb/blob/9db2e4d8dec7c584213d0e0f03d079a36a35d9d5/README.md?plain=1#L18-L20"><code>ocaml-mariadb</code></a>
or
<a href="https://github.com/ygrek/ocurl/blob/f0c6f47d6f3d25282648439dc4ade5810a993710/README.md?plain=1#L16"><code>ocurl</code></a>.</p>
<p>The advantage of this approach —as opposed to vendoring the JavaScript packages
inside the bindings— is that it gives users of the bindings complete flexibility
over the way these JavaScript packages are downloaded and bundled.</p></section><section class="print-page" id="build-system"><h1 id="build-system-build-system">Build system</h1>
<p>Melange is deeply integrated with <a href="https://dune.build/">Dune</a>, the most widely
used build system for OCaml. This integration enables developers to create a
single project with both OCaml native executables and frontend applications that
are built with Melange, and even share code between both platforms in an easy
manner.</p>
<p>Dune orchestrates and plans the work needed to compile a project, copies files
when needed, and prepares everything so that Melange takes OCaml source files
and convert them into JavaScript code.</p>
<p>Let’s now dive into the Melange compilation model and go through a brief guide
on how to work with Dune in Melange projects.</p>
<h3 id="build-system-compilation-model">Compilation model</h3>
<p>Melange compiles a single source file to a single JavaScript module. This
compilation model simplifies debugging the produced JavaScript code and allows
to import assets like CSS files and fonts in the same way as one would do in a
JavaScript project. It also facilitates the integration of Melange with
JavaScript module bundlers such as <a href="https://webpack.js.org/">Webpack</a>, or <a href="https://npmtrends.com/@vercel/ncc-vs-esbuild-vs-parcel-vs-rollup">other
alternatives</a>.</p>
<p>As an example of integration with Webpack, you can refer to the <a href="https://github.com/melange-re/melange-opam-template">Melange opam
template</a>. To create a
repository based on this template, follow <a href="https://github.com/melange-re/melange-opam-template/generate">this
link</a>.</p>
<h3 id="build-system-how-is-melange-integrated-into-dune">How is Melange integrated into Dune?</h3>
<p>Dune is an OCaml build system that Melange projects can use to specify libraries
and applications. It’s optimized for monorepos and makes project maintenance
easier. This section provides an overview of Dune’s features and explains how to
use it to build Melange applications.</p>
<h4 id="build-system-features">Features</h4>
<p>Dune is designed with OCaml in mind, which makes it an ideal tool for Melange
developers. It provides several benefits, including:</p>
<ul>
<li>Easy specification of libraries and executables.</li>
<li>Optimized for monorepos: no need for <code>npm link</code> or similar solutions.</li>
<li>Easy project maintenance, as one can rearrange folders without updating the
  paths to libraries.</li>
<li>Hygiene is maintained in Dune by building out of source: all compilation
  artifacts are placed in a separate <code>_build</code> folder. Users can optionally <a href="https://dune.readthedocs.io/en/stable/dune-files.html#promote">copy
  them back to the source
  tree</a>.</li>
<li>Dune provides a variety of additional features including <a href="https://dune.readthedocs.io/en/stable/tests.html">cram
  tests</a>, integration with
  <a href="https://dune.readthedocs.io/en/stable/documentation.html">Odoc</a>, Melange,
  <a href="https://dune.readthedocs.io/en/stable/jsoo.html">Js_of_ocaml</a>, <a href="https://dune.readthedocs.io/en/stable/usage.html#watch-mode">watch
  mode</a>, Merlin/LSP
  integration for editor support, <a href="https://dune.readthedocs.io/en/stable/cross-compilation.html">cross
  compilation</a>,
  and <a href="https://dune.readthedocs.io/en/stable/howto/opam-file-generation.html">generation of <code>opam</code>
  files</a>.</li>
</ul>
<h4 id="build-system-creating-a-new-project">Creating a new project</h4>
<p>To understand how to use Dune, let’s create a small Melange application.</p>
<p>First of all, create an opam switch, as shown in the <a href="#package-management">package management
section</a>:</p>
<pre><code class="language-bash">opam switch create . 4.14.1 --deps-only
</code></pre>
<p>Install Dune and Melange in the switch:</p>
<pre><code class="language-bash">opam pin add dune.dev --dev-repo
opam pin add melange.dev --dev-repo
</code></pre>
<div class="text-reasonml">
As we will be using Reason syntax, let’s install the `reason` package too:


<pre><code class="language-bash">opam install reason
</code></pre>

</div>

<p>Create a file named <code>dune-project</code>. This file will tell Dune a few things about
our project configuration:</p>
<pre><code class="language-text">(lang dune 3.8)

(using melange 0.1)
</code></pre>
<p>The first line <code>(lang dune 3.8)</code> tells Dune which version of the "Dune language"
(the language used in <code>dune</code> files) we want to use. Melange support in Dune is
only available from version 3.8.</p>
<p>The second line <code>(using melange 0.1)</code> tells Dune we want to use the <a href="https://dune.readthedocs.io/en/stable/dune-files.html#using">Melange
extension of the Dune
language</a>.</p>
<h4 id="build-system-adding-a-library">Adding a library</h4>
<p>Next, create a folder <code>lib</code>, and a <code>dune</code> file inside. Put the following content
inside the <code>dune</code> file:</p>
<pre><code class="language-text">(library
 (name lib)
 (modes melange))
</code></pre>
<div class="text-ocaml">
Create a file <code>lib.ml</code> in the same folder:
</div>
<div class="text-reasonml">
Create a file <code>lib.re</code> in the same folder:
</div>

<pre><code class="language-ocaml">let name = &quot;Jane&quot;
</code></pre>
<pre><code class="language-reasonml">let name = &quot;Jane&quot;;
</code></pre>
<p>The top level configuration entries —like the <code>library</code> one that appears in the
<code>dune</code> file— are referred to as <em>stanzas</em>, and the inner ones —like <code>name</code> and
<code>modes</code>— are referred to as <em>fields</em> of the stanza.</p>
<p>All stanzas are well covered in the Dune documentation site, where we can find
the reference for the <a href="https://dune.readthedocs.io/en/stable/dune-files.html#library"><code>library</code>
stanza</a>.</p>
<p>Dune is designed to minimize the need for configuration changes when modifying
the project folder structure. For example, you can move the <code>lib</code> folder to a
different location within the project, and all build commands will continue to
work without requiring any updates to any <code>dune</code> file. This feature proves to be
quite convenient.</p>
<h4 id="build-system-entry-points-with-melangeemit">Entry points with <code>melange.emit</code></h4>
<p><strong>Libraries are useful to encapsulate behavior and logical components of our
application</strong>, but they won’t produce any JavaScript artifacts on their own.</p>
<p>To generate JavaScript code, we need to define an entry point of our
application. In the root folder, create another <code>dune</code> file:</p>
<pre><code class="language-text">(melange.emit
 (target app)
 (libraries lib))
</code></pre>
<div class="text-ocaml">
  And an <code>app.ml</code> file:
</div>
<div class="text-reasonml">
  And an <code>app.re</code> file:
</div>

<pre><code class="language-ocaml">let () = Js.log Lib.name
</code></pre>
<pre><code class="language-reasonml">let () = Js.log(Lib.name);
</code></pre>
<p>The <code>melange.emit</code> stanza tells Dune to generate JavaScript files from a set of
libraries and modules. In-depth documentation about this stanza can be found in
the <a href="https://dune.readthedocs.io/en/stable/melange.html#melange-emit">Dune
docs</a>.</p>
<p>The file structure of the app should look something like this:</p>
<pre class="text-ocaml"><code class="language-text hljs plaintext">project_name/
├── _opam
├── lib
│   ├── dune
│   └── lib.ml
├── dune-project
├── dune
└── app.ml</code></pre>
<pre class="text-reasonml"><code class="language-text hljs plaintext">project_name/
├── _opam
├── lib
│   ├── dune
│   └── lib.re
├── dune-project
├── dune
└── app.re</code></pre>

<h4 id="build-system-building-the-project">Building the project</h4>
<p>We can build the project now, which will produce the JavaScript code from our
sources using the Melange compiler:</p>
<pre><code class="language-bash">$ dune build @melange
</code></pre>
<p>This command tells dune to build all the targets that have an alias <code>melange</code>
attached to them.
<a href="https://dune.readthedocs.io/en/stable/overview.html#term-alias">Aliases</a> are
build targets that don’t produce any file and have configurable dependencies.</p>
<p>By default, all the targets in a <code>melange.emit</code> stanza and the libraries it
depends on are attached to the <code>melange</code> alias. We can define explicit aliases
though, as we will see below.</p>
<p>If everything went well, we should be able to run the resulting JavaScript with
Node.js. As we mentioned above while going through its features, Dune places all
artifacts inside the <code>_build</code> folder to not pollute any source folders. So we
will point Node to the script placed in that folder, to see the expected output:</p>
<pre><code class="language-bash">$ node _build/default/app/app.js
Jane
</code></pre>
<h4 id="build-system-javascript-artifacts-layout">JavaScript artifacts layout</h4>
<p>In the command above we had to look for the <code>app.js</code> file inside an <code>app</code>
folder, but we don’t have any such folder in our sources. This folder is the one
declared in the <code>target</code> field of the <code>melange.emit</code> stanza, which Dune will use
to know where to place the generated JavaScript artifacts.</p>
<p>As a more complex example, consider the following setup:</p>
<pre class="text-ocaml"><code class="language-text hljs plaintext">project_name/
├── dune-project
├── lib
│   ├── dune
│   └── foo.ml
└── emit
    └── dune</code></pre>
<pre class="text-reasonml"><code class="language-text hljs plaintext">project_name/
├── dune-project
├── lib
│   ├── dune
│   └── foo.re
└── emit
    └── dune</code></pre>

<p>With <code>emit/dune</code> being:</p>
<pre><code class="language-text">(melange.emit
 (target app)
 (libraries lib))
</code></pre>
<p>And <code>lib/dune</code>:</p>
<pre><code class="language-text">(library
 (name lib)
 (modes melange))
</code></pre>
<div class="text-ocaml">
Then, the JavaScript artifacts for `foo.ml` will be placed under:
</div>
<div class="text-reasonml">
Then, the JavaScript artifacts for `foo.re` will be placed under:
</div>

<pre><code class="language-text">_build/default/emit/app/lib/foo.js
</code></pre>
<p>More generically:</p>
<ul>
<li>For a <code>melange.emit</code> stanza defined in a <code>dune</code> file located in the relative
  workspace path <code>$melange-emit-folder</code></li>
<li>Which includes a <code>target</code> field named <code>$target</code>, like <code>(target $target)</code></li>
<li>For a source file called <code class="text-ocaml">$name.ml</code><code
  class="text-reasonml">$name.re</code>, placed in the relative workspace path
  <code>$path-to-source-file</code></li>
</ul>
<p>The path to the generated JavaScript file from <code
  class="text-ocaml">$name.ml</code><code class="text-reasonml">$name.re</code>
  will be:</p>
<pre><code class="language-text">_build/default/$melange-emit-folder/$target/$path-to-source-file/$name.js
</code></pre>
<h4 id="build-system-guidelines-for-melangeemit">Guidelines for <code>melange.emit</code></h4>
<p>The following recommendations around <code>melange.emit</code> have been tested within
large industrial projects, and have proven to be helpful guidelines to deal with
complexity, maintenance and build performance.</p>
<ul>
<li>To simplify access to the generated JavaScript files from tools like Webpack,
  it is recommended to place the <code>dune</code> files containing the <code>melange.emit</code>
  stanzas in the project’s root folder. This ensures that the generated
  JavaScript files are directly placed under the <code>_build/default/$target</code> path.</li>
<li>To minimize the risk of inadvertent increases in bundle size, it is advisable
  to reduce the number of <code>melange.emit</code> stanzas to a minimum, ideally just one.
  Having multiple <code>melange.emit</code> stanzas may result in multiple copies of
  JavaScript code generated from the same library. By consolidating the
  <code>melange.emit</code> stanzas, you can mitigate this issue and ensure more efficient
  bundle sizes.</li>
</ul>
<h4 id="build-system-using-aliases">Using aliases</h4>
<p>The default <code>melange</code> alias is useful for prototyping or when working on small
projects, but larger projects might define multiple entry points or
<code>melange.emit</code> stanzas. In these cases, it is useful to have a way to build
individual stanzas. To do so, one can define explicit aliases for each one of
them by using the <code>alias</code> field.</p>
<p>Let’s define a custom alias <code>my-app</code> for our <code>melange.emit</code> stanza:</p>
<pre><code class="language-text">(melange.emit
 (target app)
 (alias my-app)
 (libraries lib))
</code></pre>
<p>Now we can refer to this new alias:</p>
<pre><code class="language-bash">$ dune build @my-app
</code></pre>
<p>Note that if we try to build again using the default <code>melange</code> alias, Dune will
return an error, as there are no more targets attached to it.</p>
<pre><code class="language-text">$ dune build @melange
Error: Alias &quot;melange&quot; specified on the command line is empty.
It is not defined in . or any of its descendants.
</code></pre>
<h4 id="build-system-handling-assets">Handling assets</h4>
<p>Sometimes we want to use CSS files, fonts, or other assets in our Melange
projects. Due to the way Dune works, our assets will have to be copied to the
<code>_build</code> folder and installed. To make this process as easy as possible, Dune
provides a way to specify these dependencies, depending on the stanza:</p>
<ul>
<li>For <code>library</code> stanzas, a field <code>melange.runtime_deps</code></li>
<li>For <code>melange.emit</code> stanzas, a field <code>runtime_deps</code></li>
</ul>
<p>Both fields are documented in the <a href="https://dune.readthedocs.io/en/stable/melange.html#melange-emit">Melange
page</a> of the
Dune documentation site.</p>
<p>For the sake of learning how to work with assets in a Melange project, let’s say
that we want to read the string in <code>Lib.name</code> from a text file. We will combine
the field <code>melange.runtime_deps</code> with some bindings to Node that Melange
provides. Check the next section, <a href="#communicate-with-javascript">"Communicate with
JavaScript"</a>, it you want to learn more about
how bindings work.</p>
<p>So, let’s add a new file <code>name.txt</code> inside <code>lib</code> folder, that just contains the
name <code>Jane</code>.</p>
<p>Then, adapt the <code>lib/dune</code> file. We will need to add the <code>melange.runtime_deps</code>
field, as well as a <a href="https://dune.readthedocs.io/en/stable/reference/preprocessing-spec.html"><code>preprocessing</code>
field</a>
that will allow to use the <code>bs.raw</code> extension (more about these extensions in
the <a href="#communicate-with-javascript">"Communicate with JavaScript"</a> section), in
order to get the value of the <code>__dirname</code> environment variable:</p>
<pre><code class="language-text">(library
 (name lib)
 (modes melange)
 (melange.runtime_deps name.txt)
 (preprocess (pps melange.ppx)))
</code></pre>
<div class="text-ocaml">
Finally, update <code>lib/lib.ml</code> to read from the recently added file:
</div>
<div class="text-reasonml">
Finally, update <code>lib/lib.re</code> to read from the recently added file:
</div>

<pre><code class="language-ocaml">let dir = [%bs.raw &quot;__dirname&quot;]
let file = &quot;name.txt&quot;
let name = Node.Fs.readFileSync (dir ^ &quot;/&quot; ^ file) `ascii
</code></pre>
<pre><code class="language-reasonml">let dir = [%bs.raw &quot;__dirname&quot;];
let file = &quot;name.txt&quot;;
let name = Node.Fs.readFileSync(dir ++ &quot;/&quot; ++ file, `ascii);
</code></pre>
<p>After these changes, once we build the project, we should still be able to run
the application file with Node:</p>
<pre><code class="language-bash">$ dune build @my-app
$ node _build/default/app/app.js
Jane
</code></pre>
<p>The same approach could be used to copy fonts, CSS or SVG files, or any other
asset in your project.</p>
<p>Dune offers great flexibility to specify dependencies. Another interesting
feature are globs, that allow to simplify the configuration when depending on
multiple files. For example:</p>
<pre><code class="language-text">(melange.runtime_deps
 (glob_files styles/*.css)
 (glob_files images/*.png)
 (glob_files static/*.{pdf,txt}))
</code></pre>
<p>See the <a href="https://dune.readthedocs.io/en/stable/concepts/dependency-spec.html">dependency specification
docs</a> to
learn more about it.</p>
<p>With runtime dependencies, we have reached the end of this Dune guide for
Melange developers. For further details about how Dune works and its integration
with Melange, check the <a href="https://dune.readthedocs.io/">Dune documentation</a>, and
the <a href="https://github.com/melange-re/melange-opam-template">Melange opam
template</a>.</p>
<h4 id="build-system-commonjs-or-es6-modules">CommonJS or ES6 modules</h4>
<p>Melange produces JavaScript modules that export the functions they declare, and
declare imports for the values and modules they depend on.</p>
<p>By default, Melange will produce
<a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a> modules, but it is possible
to configure it to generate
<a href="https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015">ES6</a>
modules.</p>
<p>Use the <code>module_systems</code> field in the <a href="https://dune.readthedocs.io/en/stable/melange.html#melange-emit"><code>melange.emit</code>
stanza</a> to emit
ES6 modules:</p>
<pre><code class="language-text">(melange.emit
 (target app)
 (alias my-app)
 (libraries lib)
 (module_systems es6))
</code></pre>
<p>If no extension is specified, the resulting JavaScript files will use <code>.js</code>. You
can specify a different extension with a pair <code>(&lt;module_system&gt; &lt;extension&gt;)</code>,
e.g. <code>(module_systems (es6 mjs))</code>. Multiple module systems can be used in the
same field as long as their extensions are different. For example,
<code>(module_systems commonjs (es6 mjs))</code> will produce one set of JavaScript files
using CommonJS and the <code>.js</code> extension, and another using ES6 and the <code>.mjs</code>
extension.</p></section><section class="print-page" id="communicate-with-javascript"><h1 id="communicate-with-javascript-communicate-with-javascript">Communicate with JavaScript</h1>
<p>Melange interoperates very well with JavaScript, and provides a wide array of
features to consume foreign JavaScript code. To learn about these techniques, we
will first go through the language concepts that they build upon, then we will
see how types in Melange map to JavaScript runtime types. Finally, we will
provide a variety of use cases with examples to show how to communicate to and
from JavaScript.</p>
<h2 id="communicate-with-javascript-language-concepts">Language concepts</h2>
<p>The concepts covered in the following sections are a small subset of the OCaml
language. However, they are essential for understanding how to communicate with
JavaScript, and the features that Melange exposes to do so.</p>
<h3 id="communicate-with-javascript-attributes-and-extension-nodes">Attributes and extension nodes</h3>
<p>In order to interact with JavaScript, Melange needs to extend the language to
provide blocks that express these interactions.</p>
<p>One approach could be to introduce new syntactic constructs (keywords and such)
to do so, for example:</p>
<pre><code class="language-text">javascript add : int -&gt; int -&gt; int = {|function(x,y){
  return x + y
}|}
</code></pre>
<p>But this would break compatibility with OCaml, which is one of the main goals of
Melange.</p>
<p>Fortunately, OCaml provides mechanisms to extend its language without breaking
compatibility with the parser or the language. These mechanisms are composed by
two parts:</p>
<ul>
<li>First, some syntax additions to define parts of the code that will be extended
  or replaced</li>
<li>Second, compile-time OCaml native programs called <a href="https://ocaml.org/docs/metaprogramming">PPX
  rewriters</a>, that will read the syntax
  additions defined above and proceed to extend or replace them</li>
</ul>
<p>The syntax additions come in two flavors, called <a href="https://v2.ocaml.org/manual/extensionnodes.html">extension
nodes</a> and
<a href="https://v2.ocaml.org/manual/attributes.html">attributes</a>.</p>
<h4 id="communicate-with-javascript-extension-nodes">Extension nodes</h4>
<p>Extension nodes are blocks that are supposed to be replaced by a specific type
of PPX rewriters called extenders. Extension nodes use the <code>%</code> character to be
identified. Extenders will take the extension node and replace it with a valid
OCaml AST (abstract syntax tree).</p>
<p>An example where Melange uses extension nodes to communicate with JavaScript is
to produce "raw" JavaScript inside a Melange program:</p>
<pre><code class="language-ocaml">[%%bs.raw &quot;var a = 1; var b = 2&quot;]
let add = [%bs.raw &quot;a + b&quot;]
</code></pre>
<pre><code class="language-reasonml">%bs.raw
&quot;var a = 1; var b = 2&quot;;
let add = [%bs.raw &quot;a + b&quot;];
</code></pre>
<p>Which will generate the following JavaScript code:</p>
<pre><code class="language-js">var a = 1; var b = 2
var add = a + b
</code></pre>
<p>The difference between one and two percentage characters is detailed in the
<a href="https://v2.ocaml.org/manual/extensionnodes.html">OCaml documentation</a>.</p>
<h4 id="communicate-with-javascript-attributes">Attributes</h4>
<p>Attributes are "decorations" applied to specific parts of the code to provide
additional information. In Melange, attributes are used in two ways to enhance
the expressiveness of generating JavaScript code: either reusing existing OCaml
built-in attributes or defining new ones.</p>
<h5 id="communicate-with-javascript-reusing-ocaml-attributes">Reusing OCaml attributes</h5>
<p>The first approach is leveraging the existing <a href="https://v2.ocaml.org/manual/attributes.html#ss:builtin-attributes">OCaml’s built-in
attributes</a>
to be used for JavaScript generation.</p>
<p>One prominent example of OCaml attributes that can be used in Melange projects
is the <code>unboxed</code> attribute, which optimizes the compilation of single-field
records and variants with a single tag to their raw values. This is useful when
defining type aliases that we don’t want to mix up, or when binding to
JavaScript code that uses heterogeneous collections. An example of the latter is
discussed in the <a href="#communicate-with-javascript-variadic-function-arguments">variadic function arguments</a>
section.</p>
<p>For instance:</p>
<pre><code class="language-ocaml">type name =
  | Name of string [@@unboxed]
let student_name = Name &quot;alice&quot;
</code></pre>
<pre><code class="language-reasonml">[@unboxed]
type name =
  | Name(string);
let student_name = Name(&quot;alice&quot;);
</code></pre>
<p>Compiles into:</p>
<pre><code class="language-js">var student_name = &quot;alice&quot;;
</code></pre>
<p>Other OCaml pre-built attributes like <code>alert</code> or <code>deprecated</code> can be used with
Melange as well.</p>
<h5 id="communicate-with-javascript-defining-new-attributes">Defining new attributes</h5>
<p>The second approach is introducing new attributes specifically designed for
Melange, such as the <a href="#communicate-with-javascript-bind-to-global-javascript-functions-or-values"><code>bs.val</code>
attribute</a> used to bind to
global JavaScript values. The complete list of attributes introduced by Melange
can be found <a href="#communicate-with-javascript-list-of-attributes-and-extension-nodes">here</a>.</p>
<p>Attribute annotations can use one, two or three <code>@</code> characters depending on
their placement in the code and which kind of syntax tree node they are
annotating. More information about attributes can be found in the <a href="https://v2.ocaml.org/manual/attributes.html">dedicated
OCaml manual page</a>.</p>
<p>Here are some samples using Melange attributes
<a href="#communicate-with-javascript-bind-to-global-javascript-functions-or-values"><code>bs.val</code></a> and
<a href="#communicate-with-javascript-using-ocaml-records"><code>bs.as</code></a>:</p>
<pre><code class="language-ocaml">external clearTimeout : timeoutId -&gt; unit = &quot;clearTimeout&quot; [@@bs.val]

type t = {
  age : int; [@bs.as &quot;a&quot;]
  name : string; [@bs.as &quot;n&quot;]
}
</code></pre>
<pre><code class="language-reasonml">[@bs.val] external clearTimeout: timeoutId =&gt; unit = &quot;clearTimeout&quot;;

type t = {
  [@bs.as &quot;a&quot;]
  age: int,
  [@bs.as &quot;n&quot;]
  name: string,
};
</code></pre>
<p>To learn more about preprocessors, attributes and extension nodes, check the
<a href="https://ocaml.org/docs/metaprogramming#ppx-rewriters">section about PPX
rewriters</a> in the OCaml
docs.</p>
<h3 id="communicate-with-javascript-external-functions">External functions</h3>
<p>Most of the system that Melange exposes to communicate with JavaScript is built
on top of an OCaml language construct called <code>external</code>.</p>
<p><code>external</code> is a keyword for declaring a value in OCaml that will <a href="https://v2.ocaml.org/manual/intfc.html">interface with
C code</a>:</p>
<pre><code class="language-ocaml">external my_c_function : int -&gt; string = &quot;someCFunctionName&quot;
</code></pre>
<pre><code class="language-reasonml">external my_c_function: int =&gt; string = &quot;someCFunctionName&quot;;
</code></pre>
<p>It is like a <code>let</code> binding, except that the body of an external is a string.
That string has a specific meaning depending on the context. For native OCaml,
it usually refers to a C function with that name. For Melange, it refers to the
functions or values that exist in the runtime JavaScript code, and will be used
from Melange.</p>
<p>Melange externals are always decorated with certain <code>[@bs.xxx]</code> attributes. Each
one of the <a href="#communicate-with-javascript-list-of-attributes-and-extension-nodes">available attributes</a> will
be further explained in the next sections.</p>
<p>Once declared, one can use an <code>external</code> as a normal value. Melange external
functions are turned into the expected JavaScript values, inlined into their
callers during compilation, and completely erased afterwards. They don’t appear
in the JavaScript output, so there are no costs on bundling size.</p>
<p><strong>Note</strong>: it is recommended to use external functions and the <code>[@bs.xxx]</code>
attributes in the interface files as well, as this allows some optimizations
where the resulting JavaScript values can be directly inlined at the call sites.</p>
<h4 id="communicate-with-javascript-special-identity-external">Special identity external</h4>
<p>One external worth mentioning is the following one:</p>
<pre><code class="language-ocaml">type foo = string
type bar = int
external danger_zone : foo -&gt; bar = &quot;%identity&quot;
</code></pre>
<pre><code class="language-reasonml">type foo = string;
type bar = int;
external danger_zone: foo =&gt; bar = &quot;%identity&quot;;
</code></pre>
<p>This is a final escape hatch which does nothing but convert from the type <code>foo</code>
to <code>bar</code>. In the following sections, if you ever fail to write an <code>external</code>,
you can fall back to using this one. But try not to.</p>
<h3 id="communicate-with-javascript-abstract-types">Abstract types</h3>
<p>In the subsequent sections, you will come across examples of bindings where a
type is defined without being assigned to a value. Here is an example:</p>
<pre><code class="language-ocaml">type document
</code></pre>
<pre><code class="language-reasonml">type document;
</code></pre>
<p>These types are referred to as "abstract types" and are commonly used together
with external functions that define operations over values when communicating
with JavaScript.</p>
<p>Abstract types enable defining types for specific values originating from
JavaScript while omitting unnecessary details. An illustration is the <code>document</code>
type mentioned earlier, which has several
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document">properties</a>. By
using abstract types, one can focus solely on the required aspects of the
<code>document</code> value that the Melange program requires, rather than defining all its
properties. Consider the following example:</p>
<pre><code class="language-ocaml">type document

external document : document = &quot;document&quot; [@@bs.val]
external set_title : document -&gt; string -&gt; unit = &quot;title&quot; [@@bs.set]
</code></pre>
<pre><code class="language-reasonml">type document;

[@bs.val] external document: document = &quot;document&quot;;
[@bs.set] external set_title: (document, string) =&gt; unit = &quot;title&quot;;
</code></pre>
<p>Subsequent sections delve into the details of the
<a href="#communicate-with-javascript-bind-to-global-javascript-functions-or-values"><code>bs.val</code></a> and
<a href="#communicate-with-javascript-bind-to-object-properties"><code>bs.set</code></a> attributes.</p>
<p>For a comprehensive understanding of abstract types and their usefulness, refer
to the "Encapsulation" section of the <a href="https://cs3110.github.io/textbook/chapters/modules/encapsulation.html">OCaml Cornell
textbook</a>.</p>
<h3 id="communicate-with-javascript-pipe-operators">Pipe operators</h3>
<p>There are two pipe operators available in Melange:</p>
<ul>
<li>
<p>A <em>pipe last</em> operator <code>|&gt;</code>, available <a href="https://v2.ocaml.org/api/Stdlib.html#1_Compositionoperators">in
  OCaml</a> and
  inherited in Melange</p>
</li>
<li>
<p>A <em>pipe first</em> operator <code class="text-ocaml">|.</code><code
  class="text-reasonml">-></code>, available exclusively in Melange</p>
</li>
</ul>
<p>Let’s see the differences between the two.</p>
<h4 id="communicate-with-javascript-pipe-last">Pipe last</h4>
<p>Since version 4.01, OCaml includes a reverse application or "pipe" (<code>|&gt;</code>)
operator, an infix operator that applies the result from the previous expression
the next function. As a backend for OCaml, Melange inherits this operator.</p>
<p>The pipe operator could be implemented like this (the real implementation is a
bit
<a href="https://github.com/ocaml/ocaml/blob/d9547617e8b14119beacafaa2546cbebfac1bfe5/stdlib/stdlib.ml#L48">different</a>):</p>
<pre><code class="language-ocaml">let ( |&gt; ) f g = g f
</code></pre>
<pre><code class="language-reasonml">let (|&gt;) = (f, g) =&gt; g(f);
</code></pre>
<p>This operator is useful when multiple functions are applied to some value in
sequence, with the output of each function becoming the input of the next (a
<em>pipeline</em>).</p>
<p>For example, assuming we have a function <code>square</code> defined as:</p>
<pre><code class="language-ocaml">let square x = x * x
</code></pre>
<pre><code class="language-reasonml">let square = x =&gt; x * x;
</code></pre>
<p>We are using it like:</p>
<pre><code class="language-ocaml">let ten = succ (square 3)
</code></pre>
<pre><code class="language-reasonml">let ten = succ(square(3));
</code></pre>
<p>The pipe operator allows to write the computation for <code>ten</code> in left-to-right
order, as <a href="https://v2.ocaml.org/manual/expr.html#ss:precedence-and-associativity">it has left
associativity</a>:</p>
<pre><code class="language-ocaml">let ten = 3 |&gt; square |&gt; succ
</code></pre>
<pre><code class="language-reasonml">let ten = 3 |&gt; square |&gt; succ;
</code></pre>
<p>When working with functions that can take multiple arguments, the pipe operator
works best when the functions take the data we are processing as the last
argument. For example:</p>
<pre><code class="language-ocaml">let sum = List.fold_left ( + ) 0

let sum_sq =
  [ 1; 2; 3 ]
  |&gt; List.map square (* [1; 4; 9] *)
  |&gt; sum             (* 1 + 4 + 9 *)
</code></pre>
<pre><code class="language-reasonml">let sum = List.fold_left((+), 0);

let sum_sq =
  [1, 2, 3]
  |&gt; List.map(square)  /* [1; 4; 9] */
  |&gt; sum; /* 1 + 4 + 9 */
</code></pre>
<p>The above example can be written concisely because the <code>List.map</code> function in
the <a href="https://v2.ocaml.org/api/Stdlib.List.html">OCaml standard library</a> takes
the list as the second argument. This convention is sometimes referred to as
"data-last", and is widely adopted in the OCaml ecosystem. Data-last and the
pipe operator <code>|&gt;</code> work great with currying, so they are a great fit for the
language.</p>
<p>However, there are some limitations when using data-last when it comes to error
handling. In the given example, if we mistakenly used the wrong function:</p>
<pre><code class="language-ocaml">let sum_sq =
  [ 1; 2; 3 ]
  |&gt; List.map String.cat
  |&gt; sum
</code></pre>
<pre><code class="language-reasonml">let sum_sq = [1, 2, 3] |&gt; List.map(String.cat) |&gt; sum;
</code></pre>
<p>The compiler would rightfully raise an error:</p>
<pre class="text-ocaml"><code class="language-text hljs plaintext">4 |   [ 1; 2; 3 ]
        ^
Error: This expression has type int but an expression was expected of type
         string</code></pre>
<pre class="text-reasonml"><code class="language-text hljs plaintext">1 |   [ 1, 2, 3 ]
        ^
Error: This expression has type int but an expression was expected of type
         string</code></pre>

<p>Note that instead of telling us that we are passing the wrong function in
<code>List.map</code> (<code>String.cat</code>), the error points to the list itself. This behavior
aligns with the way type inference works, as the compiler infers types from left
to right. Since <code>[ 1; 2; 3 ] |&gt; List.map String.cat</code> is equivalent to <code>List.map
String.cat [ 1; 2; 3 ]</code>, the type mismatch is detected when the list is type
checked, after <code>String.cat</code> has been processed.</p>
<p>With the goal of addressing this kind of limitations, Melange introduces the
pipe first operator <code class="text-ocaml">|.</code><code
class="text-reasonml">-></code>.</p>
<h4 id="communicate-with-javascript-pipe-first">Pipe first</h4>
<p>To overcome the constraints mentioned above, Melange introduces the pipe first
operator <code class="text-ocaml">|.</code><code
class="text-reasonml">-></code>.</p>
<p>As its name suggests, the pipe first operator is better suited for functions
where the data is passed as the first argument.</p>
<p>The functions in the <a href="#communicate-with-javascript-todo-fix-me.md"><code>Belt</code> library</a> included with Melange have
been designed with the data-first convention in mind, so they work best with the
pipe first operator.</p>
<p>For example, we can rewrite the example above using <code>Belt.List.map</code> and the pipe
first operator:</p>
<pre><code class="language-ocaml">let sum_sq =
  [ 1; 2; 3 ]
  |. Belt.List.map square
  |. sum
</code></pre>
<pre><code class="language-reasonml">let sum_sq = [1, 2, 3]-&gt;(Belt.List.map(square))-&gt;sum;
</code></pre>
<p>We can see the difference on the error we get if the wrong function is passed to
<code>Belt.List.map</code>:</p>
<pre><code class="language-ocaml">let sum_sq =
  [ 1; 2; 3 ]
  |. Belt.List.map String.cat
  |. sum
</code></pre>
<pre><code class="language-reasonml">let sum_sq = [1, 2, 3]-&gt;(Belt.List.map(String.cat))-&gt;sum;
</code></pre>
<p>The compiler will show this error message:</p>
<pre class="text-ocaml"><code class="language-text hljs plaintext">4 |   |. Belt.List.map String.cat
                       ^^^^^^^^^^
Error: This expression has type string -> string -> string
       but an expression was expected of type int -> 'a
       Type string is not compatible with type int</code></pre>
<pre class="text-reasonml"><code class="language-text hljs plaintext">2 | let sum_sq = [1, 2, 3]->(Belt.List.map(String.cat))->sum;
                                           ^^^^^^^^^^
Error: This expression has type string -> string -> string
       but an expression was expected of type int -> 'a
       Type string is not compatible with type int</code></pre>

<p>The error points now to the function passed to <code>Belt.List.map</code>, which is more
natural with the way the code is being written.</p>
<p>Melange supports writing bindings to JavaScript using any of the two
conventions, data-first or data-last, as shown in the <a href="#communicate-with-javascript-chaining">"Chaining"
section</a>.</p>
<p>For further details about the differences between the two operators, the
data-first and data-last conventions and the trade-offs between them, one can
refer to <a href="https://www.javierchavarri.com/data-first-and-data-last-a-comparison/">this related blog
post</a>.</p>
<h2 id="communicate-with-javascript-data-types-and-runtime-representation">Data types and runtime representation</h2>
<p>This is how each Melange type is converted into JavaScript values:</p>
<table>
<thead>
<tr>
<th>Melange</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>number</td>
</tr>
<tr>
<td>nativeint</td>
<td>number</td>
</tr>
<tr>
<td>int32</td>
<td>number</td>
</tr>
<tr>
<td>float</td>
<td>number</td>
</tr>
<tr>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>array</td>
<td>array</td>
</tr>
<tr>
<td>tuple <code>(3, 4)</code></td>
<td>array <code>[3, 4]</code></td>
</tr>
<tr>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td><a href="#communicate-with-javascript-todo-fix-me.md">Js.Nullable.t</a></td>
<td><code>null</code> / <code>undefined</code></td>
</tr>
<tr>
<td><a href="#communicate-with-javascript-todo-fix-me.md">Js.Re.t</a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a></td>
</tr>
<tr>
<td>Option.t <code>None</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td>Option.t <code class="text-ocaml">Some( Some .. Some (None))</code><code class="text-reasonml">Some(Some( .. Some(None)))</code></td>
<td>internal representation</td>
</tr>
<tr>
<td><p>foo</p></td>
<td><code>2</code></td>
</tr>
<tr>
<td>record <code class="text-ocaml">{x = 1; y = 2}</code><code class="text-reasonml">{x: 1; y: 2}</code></td>
<td>object <code>{x: 1, y: 2}</code></td>
</tr>
<tr>
<td>int64</td>
<td>array of 2 elements <code>[high, low]</code> high is signed, low unsigned</td>
</tr>
<tr>
<td>char</td>
<td><code>'a'</code> -> <code>97</code> (ascii code)</td>
</tr>
<tr>
<td>bytes</td>
<td>number array</td>
</tr>
<tr>
<td>list <code>[]</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td>list <code class="text-ocaml">[ x; y ]</code><code class="text-reasonml">[x, y]</code></td>
<td><code>{ hd: x, tl: { hd: y, tl: 0 } }</code></td>
</tr>
<tr>
<td>variant</td>
<td>See below</td>
</tr>
<tr>
<td>polymorphic variant</td>
<td>See below</td>
</tr>
</tbody>
</table>
<p>Variants with a single non-nullary constructor:</p>
<pre><code class="language-ocaml">type tree = Leaf | Node of int * tree * tree
(* Leaf -&gt; 0 *)
(* Node(7, Leaf, Leaf) -&gt; { _0: 7, _1: 0, _2: 0 } *)
</code></pre>
<pre><code class="language-reasonml">type tree =
  | Leaf
  | Node(int, tree, tree);
/* Leaf -&gt; 0 */
/* Node(7, Leaf, Leaf) -&gt; { _0: 7, _1: 0, _2: 0 } */
</code></pre>
<p>Variants with more than one non-nullary constructor:</p>
<pre><code class="language-ocaml">type t = A of string | B of int
(* A(&quot;foo&quot;) -&gt; { TAG: 0, _0: &quot;Foo&quot; } *)
(* B(2) -&gt; { TAG: 1, _0: 2 } *)
</code></pre>
<pre><code class="language-reasonml">type t =
  | A(string)
  | B(int);
/* A(&quot;foo&quot;) -&gt; { TAG: 0, _0: &quot;Foo&quot; } */
/* B(2) -&gt; { TAG: 1, _0: 2 } */
</code></pre>
<p>Polymorphic variants:</p>
<pre><code class="language-ocaml">let u = `Foo (* &quot;Foo&quot; *)
let v = `Foo(2) (* { NAME: &quot;Foo&quot;, VAL: &quot;2&quot; } *)
</code></pre>
<pre><code class="language-reasonml">let u = `Foo; /* &quot;Foo&quot; */
let v = `Foo(2); /* { NAME: &quot;Foo&quot;, VAL: &quot;2&quot; } */
</code></pre>
<p>Let’s see now some of these types in detail. We will first describe the <a href="#communicate-with-javascript-shared-types">shared
types</a>, which have a transparent representation as JavaScript
values, and then go through the <a href="#communicate-with-javascript-non-shared-data-types">non-shared types</a>, that
have more complex runtime representations.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> Relying on the non-shared data types runtime representations by
reading or writing them manually from JavaScript code that communicates with
Melange code might lead to runtime errors, as these representations might
change in the future.</p>
</blockquote>
<h3 id="communicate-with-javascript-shared-types">Shared types</h3>
<p>The following are types that can be shared between Melange and JavaScript almost
"as is". Specific caveats are mentioned on the sections where they apply.</p>
<h4 id="communicate-with-javascript-strings">Strings</h4>
<p>JavaScript strings are immutable sequences of UTF-16 encoded Unicode text. OCaml
strings are immutable sequences of bytes and nowadays assumed to be UTF-8
encoded text when interpreted as textual content. This is problematic when
interacting with JavaScript code, because if one tries to use some unicode
characters, like:</p>
<pre><code class="language-ocaml">let () = Js.log &quot;你好&quot;
</code></pre>
<pre><code class="language-reasonml">let () = Js.log(&quot;你好&quot;);
</code></pre>
<p>It will lead to some cryptic console output. To rectify this, Melange allows to
define <a href="https://v2.ocaml.org/manual/lex.html#sss:stringliterals">quoted string
literals</a> using the
<code>js</code> identifier, for example:</p>
<pre><code class="language-ocaml">let () = Js.log {js|你好，
世界|js}
</code></pre>
<pre><code class="language-reasonml">let () = Js.log({js|你好，
世界|js});
</code></pre>
<p>For convenience, Melange exposes another special quoted string identifier: <code>j</code>.
It is similar to JavaScript’ string interpolation, but for variables only (not
arbitrary expressions):</p>
<pre><code class="language-ocaml">let world = {j|世界|j}
let helloWorld = {j|你好，$world|j}
</code></pre>
<pre><code class="language-reasonml">let world = {j|世界|j};
let helloWorld = {j|你好，$world|j};
</code></pre>
<p>You can surround the interpolation variable in parentheses too: <code>{j|你
好，$(world)|j}</code>.</p>
<p>To work with strings, the Melange standard library provides some utilities in
the <a href="#communicate-with-javascript-todo-fix-me.md"><code>Stdlib.String</code> module</a>. The bindings to the native
JavaScript functions to work with strings are in the <a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.String</code>
module</a>.</p>
<h4 id="communicate-with-javascript-floating-point-numbers">Floating-point numbers</h4>
<p>OCaml floats are <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64">IEEE
754</a>
with a 53-bit mantissa and exponents from -1022 to 1023. This happens to be the
same encoding as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#number_encoding">JavaScript
numbers</a>,
so values of these types can be used transparently between Melange code and
JavaScript code. The Melange standard library provides a <a href="#communicate-with-javascript-todo-fix-me.md"><code>Stdlib.Float</code>
module</a>. The bindings to the JavaScript APIs that manipulate
float values can be found in the <a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.Float</code></a> module.</p>
<h4 id="communicate-with-javascript-integers">Integers</h4>
<p>In Melange, integers are limited to 32 bits due to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#fixed-width_number_conversion">fixed-width
conversion</a>
of bitwise operations in JavaScript. While Melange integers compile to
JavaScript numbers, treating them interchangeably can result in unexpected
behavior due to differences in precision. Even though bitwise operations in
JavaScript are constrained to 32 bits, integers themselves are represented using
the same floating-point format <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#number_encoding">as
numbers</a>,
allowing for a larger range of representable integers in JavaScript compared to
Melange. When dealing with large numbers, it is advisable to use floats instead.
For instance, floats are used in bindings like <code>Js.Date</code>.</p>
<p>The Melange standard library provides a <a href="#communicate-with-javascript-todo-fix-me.md"><code>Stdlib.Int</code> module</a>.
The bindings to work with JavaScript integers are in the
<a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.Int</code></a> module.</p>
<h4 id="communicate-with-javascript-arrays">Arrays</h4>
<p>Melange arrays compile to JavaScript arrays. But note that unlike JavaScript
arrays, all the values in a Melange array need to have the same type.</p>
<p>Another difference is that OCaml arrays are fixed-sized, but on Melange side
this constraint is relaxed. You can change an array’s length using functions
like <code>Js.Array.push</code>, available in the bindings to the JavaScript APIs in
<a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.Array</code></a>.</p>
<p>Melange standard library also has a module to work with arrays, available in
<code>Stdlib.Array</code>(todo-fix-me.md) module.</p>
<h4 id="communicate-with-javascript-tuples">Tuples</h4>
<p>OCaml tuples are compiled to JavaScript arrays. This is convenient when writing
bindings that will use a JavaScript array with heterogeneous values, but that
happens to have a fixed length.</p>
<p>As a real world example of this can be found in
<a href="https://github.com/reasonml/reason-react/">ReasonReact</a>, the Melange bindings
for <a href="https://react.dev/">React</a>. In these bindings, component effects
dependencies are represented as OCaml tuples, so they get compiled cleanly to
JavaScript arrays by Melange.</p>
<p>For example, some code like this:</p>
<pre><code class="language-ocaml">let () = React.useEffect2 (fun () -&gt; None) (foo, bar)
</code></pre>
<pre><code class="language-reasonml">let () = React.useEffect2(() =&gt; None, (foo, bar));
</code></pre>
<p>Will produce:</p>
<pre><code class="language-javascript">React.useEffect(function () {}, [foo, bar]);
</code></pre>
<h4 id="communicate-with-javascript-booleans">Booleans</h4>
<p>Values of type <code>bool</code> compile to JavaScript booleans.</p>
<h4 id="communicate-with-javascript-records">Records</h4>
<p>Melange records map directly to JavaScript objects. If the record fields include
non-shared data types (like variants), these values should be transformed
separately, and not be directly used in JavaScript.</p>
<p>Extensive documentation about interfacing with JavaScript objects using records
can be found in <a href="#communicate-with-javascript-bind-to-js-object">the section below</a>.</p>
<h4 id="communicate-with-javascript-regular-expressions">Regular expressions</h4>
<p>Regular expressions created using the <code>%bs.re</code> extension node compile to their
JavaScript counterpart.</p>
<p>For example:</p>
<pre><code class="language-ocaml">let r = [%bs.re &quot;/b/g&quot;]
</code></pre>
<pre><code class="language-reasonml">let r = [%bs.re &quot;/b/g&quot;];
</code></pre>
<p>Will compile to:</p>
<pre><code class="language-js">var r = /b/g;
</code></pre>
<p>A regular expression like the above is of type <code>Js.Re.t</code>. The
<a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.Re</code></a> module provides the bindings to the JavaScript
functions that operate over regular expressions.</p>
<h2 id="communicate-with-javascript-non-shared-data-types">Non-shared data types</h2>
<p>The following types differ too much between Melange and JavaScript, so while
they can always be manipulated from JavaScript, it is recommended to transform
them before doing so.</p>
<ul>
<li>Variants and polymorphic variants: Better transform them into readable
  JavaScript values before manipulating them from JavaScript, Melange provides
  <a href="#communicate-with-javascript-generate-getters-setters-and-constructors">some helpers</a> to do so.</li>
<li>Exceptions</li>
<li>Option (a variant type): Better use the <code>Js.Nullable.fromOption</code> and
  <code>Js.Nullable.toOption</code> functions in the <a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.Nullable</code> module</a>
  to transform them into either <code>null</code> or <code>undefined</code> values.</li>
<li>List (also a variant type): use <code>Array.of_list</code> and <code>Array.to_list</code> in the
  <a href="#communicate-with-javascript-todo-fix-me.md"><code>Array</code> module</a>.</li>
<li>Character</li>
<li>Int64</li>
<li>Lazy values</li>
</ul>
<h2 id="communicate-with-javascript-list-of-attributes-and-extension-nodes">List of attributes and extension nodes</h2>
<blockquote>
<p><strong><em>NOTE:</em></strong> All these attributes and extension nodes are prefixed with <code>bs.</code>
for backwards compatibility. They will be updated to <code>mel.</code> in the future.</p>
</blockquote>
<p><strong>Attributes:</strong></p>
<p>These attributes are used to annotate <code>external</code> definitions:</p>
<ul>
<li><a href="#communicate-with-javascript-bind-to-object-properties"><code>bs.get</code></a>: read JavaScript object properties
  statically by name, using the dot notation <code>.</code></li>
<li><a href="#communicate-with-javascript-bind-to-object-properties"><code>bs.get_index</code></a>: read a JavaScript object’s
  properties dynamically by using the bracket notation <code>[]</code></li>
<li><a href="#communicate-with-javascript-using-functions-from-other-javascript-modules"><code>bs.module</code></a>: bind to a value
  from a JavaScript module</li>
<li><a href="#communicate-with-javascript-javascript-classes"><code>bs.new</code></a>: bind to a JavaScript class constructor</li>
<li><a href="#communicate-with-javascript-using-external-functions"><code>bs.obj</code></a>: create a JavaScript object</li>
<li><a href="#communicate-with-javascript-wrapping-returned-nullable-values"><code>bs.return</code></a>: automate conversion from
  nullable values to <code>Option.t</code> values</li>
<li><a href="#communicate-with-javascript-calling-an-object-method"><code>bs.send</code></a>: call a JavaScript object method using
  <a href="#communicate-with-javascript-todo-fix-me.md">pipe first</a> convention</li>
<li><a href="#communicate-with-javascript-calling-an-object-method"><code>bs.send.pipe</code></a>: call a JavaScript object method
  using <a href="#communicate-with-javascript-todo-fix-me.md">pipe last</a> convention</li>
<li><a href="#communicate-with-javascript-bind-to-object-properties"><code>bs.set</code></a>: set JavaScript object properties
  statically by name, using the dot notation <code>.</code></li>
<li><a href="#communicate-with-javascript-bind-to-object-properties"><code>bs.set_index</code></a>: set JavaScript object properties
  dynamically by using the bracket notation <code>[]</code></li>
<li><a href="#communicate-with-javascript-binding-to-properties-inside-a-module-or-global"><code>bs.scope</code></a>: reach to
  deeper properties inside a JavaScript object</li>
<li><a href="#communicate-with-javascript-variadic-function-arguments"><code>bs.splice</code></a>: a deprecated attribute, is an
  alternate form of <code>bs.variadic</code></li>
<li><a href="#communicate-with-javascript-bind-to-global-javascript-functions-or-values"><code>bs.val</code></a>: bind to global
  JavaScript functions or other values</li>
<li><a href="#communicate-with-javascript-variadic-function-arguments"><code>bs.variadic</code></a>: bind to a function taking
  variadic arguments from an array</li>
</ul>
<p>These attributes are used to annotate arguments in <code>external</code> definitions:</p>
<ul>
<li><a href="#communicate-with-javascript-binding-to-callbacks"><code>bs</code></a>: define function arguments as uncurried (manual)</li>
<li><a href="#communicate-with-javascript-using-polymorphic-variants-to-bind-to-enums"><code>bs.int</code></a>: compile function
  argument to an int</li>
<li><a href="#communicate-with-javascript-using-polymorphic-variants-to-bind-to-enums"><code>bs.string</code></a>: compile function
  argument to a string</li>
<li><a href="#communicate-with-javascript-modeling-this-based-callbacks"><code>bs.this</code></a>: bind to <code>this</code> based callbacks</li>
<li><a href="#communicate-with-javascript-binding-to-callbacks"><code>bs.uncurry</code></a>: define function arguments as uncurried
  (automated)</li>
<li><a href="#communicate-with-javascript-approach-2-polymorphic-variant-bsunwrap"><code>bs.unwrap</code></a>: unwrap variant values</li>
</ul>
<p>These attributes are used in places like records, fields, arguments, functions,
and more:</p>
<ul>
<li><code>bs.as</code>: redefine the name generated in the JavaScript output code. Used in
  <a href="#communicate-with-javascript-constant-values-as-arguments">constant function arguments</a>,
  <a href="#communicate-with-javascript-conversion-functions">variants</a>, polymorphic variants (either <a href="#communicate-with-javascript-using-polymorphic-variants-to-bind-to-enums">inlined in
  external functions</a> or <a href="#communicate-with-javascript-polymorphic-variants">in type
  definitions</a>) and <a href="#communicate-with-javascript-objects-with-static-shape-record-like">record
  fields</a>.</li>
<li><a href="#communicate-with-javascript-generate-getters-setters-and-constructors"><code>bs.deriving</code></a>: generate getters
  and setters for some types</li>
<li><a href="#communicate-with-javascript-inlining-constant-values"><code>bs.inline</code></a>: forcefully inline constant values</li>
<li><a href="#communicate-with-javascript-convert-records-into-abstract-types"><code>bs.optional</code></a>: omit fields in a record
  (combines with <code>bs.deriving</code>)</li>
</ul>
<p><strong>Extension nodes:</strong></p>
<p>In order to use any of these extension nodes, you will have to add the melange
PPX preprocessor to your project. To do so, add the following to the <code>dune</code>
file:</p>
<pre><code class="language-text">(library
 (name lib)
 (modes melange)
 (preprocess
   (pps melange.ppx)))
</code></pre>
<p>The same field <code>preprocess</code> can be added to <code>melange.emit</code>.</p>
<p>Here is the list of all the extension nodes supported by Melange:</p>
<ul>
<li><a href="#communicate-with-javascript-debugger"><code>bs.debugger</code></a>: insert <code>debugger</code> statements</li>
<li><a href="#communicate-with-javascript-detect-global-variables"><code>bs.external</code></a>: read global values</li>
<li><a href="#communicate-with-javascript-using-jst-objects"><code>bs.obj</code></a>: create JavaScript object literals</li>
<li><a href="#communicate-with-javascript-generate-raw-javascript"><code>bs.raw</code></a>: write raw JavaScript code</li>
<li><a href="#communicate-with-javascript-regular-expressions"><code>bs.re</code></a>: insert regular expressions</li>
</ul>
<h2 id="communicate-with-javascript-generate-raw-javascript">Generate raw JavaScript</h2>
<p>It is possible to directly write JavaScript code from a Melange file. This is
unsafe, but it can be useful for prototyping or as an escape hatch.</p>
<p>To do it, we will use the <code>bs.raw</code>
<a href="https://v2.ocaml.org/manual/extensionnodes.html">extension</a>:</p>
<pre><code class="language-ocaml">let add = [%bs.raw {|
  function(a, b) {
    console.log(&quot;hello from raw JavaScript!&quot;);
    return a + b;
  }
|}]

let () = Js.log (add 1 2)
</code></pre>
<pre><code class="language-reasonml">let add = [%bs.raw
  {|
  function(a, b) {
    console.log(&quot;hello from raw JavaScript!&quot;);
    return a + b;
  }
|}
];

let () = Js.log(add(1, 2));
</code></pre>
<p>The <code>{||}</code> strings are called <a href="https://ocaml.org/manual/lex.html#quoted-string-id">"quoted
strings"</a>. They are similar
to JavaScript’s template literals, in the sense that they are multi-line, and
there is no need to escape characters inside the string.</p>
<p>Using <span class="text-ocaml">one percentage sign</span><span
class="text-reasonml">the extension name between square brackets</span>
(<code>[%bs.raw &lt;string&gt;]</code>) is useful to define expressions (function bodies, or
other values) where the implementation is directly JavaScript. This is useful as
we can attach the type signature already in the same line, to make our code
safer. For example:</p>
<pre><code class="language-ocaml">let f : unit -&gt; int = [%bs.raw &quot;function() {return 1}&quot;]
</code></pre>
<pre><code class="language-reasonml">let f: unit =&gt; int = ([%bs.raw &quot;function() {return 1}&quot;]: unit =&gt; int);
</code></pre>
<p>Using <span class="text-ocaml">two percentage signs (<code>[%%bs.raw
&lt;string&gt;]</code>)</span><span class="text-reasonml">the extension name without square
brackets (<code>%bs.raw &lt;string&gt;</code>)</span> is reserved for definitions in a
<a href="https://v2.ocaml.org/manual/moduleexamples.html#s:module:structures">structure</a>
or <a href="https://v2.ocaml.org/manual/moduleexamples.html#s%3Asignature">signature</a>.</p>
<p>For example:</p>
<pre><code class="language-ocaml">[%%bs.raw &quot;var a = 1&quot;]
</code></pre>
<pre><code class="language-reasonml">%bs.raw
&quot;var a = 1&quot;;
</code></pre>
<h2 id="communicate-with-javascript-debugger">Debugger</h2>
<p>Melange allows you to inject a <code>debugger;</code> expression using the <code>bs.debugger</code>
extension:</p>
<pre><code class="language-ocaml">let f x y =
  [%bs.debugger];
  x + y
</code></pre>
<pre><code class="language-reasonml">let f = (x, y) =&gt; {
  [%bs.debugger];
  x + y;
};
</code></pre>
<p>Output:</p>
<pre><code class="language-javascript">function f (x,y) {
  debugger; // JavaScript developer tools will set a breakpoint and stop here
  return x + y | 0;
}
</code></pre>
<h2 id="communicate-with-javascript-detect-global-variables">Detect global variables</h2>
<p>Melange provides a relatively type safe approach to use globals that might be
defined either in the JavaScript runtime environment: <code>bs.external</code>.</p>
<p><code>[%bs.external id]</code> will check if the JavaScript value <code>id</code> is <code>undefined</code> or
not, and return an <code>Option.t</code> value accordingly.</p>
<p>For example:</p>
<pre><code class="language-ocaml">let () = match [%bs.external __DEV__] with
| Some _ -&gt; Js.log &quot;dev mode&quot;
| None -&gt; Js.log &quot;production mode&quot;
</code></pre>
<pre><code class="language-reasonml">let () =
  switch ([%bs.external __DEV__]) {
  | Some(_) =&gt; Js.log(&quot;dev mode&quot;)
  | None =&gt; Js.log(&quot;production mode&quot;)
  };
</code></pre>
<p>Another example:</p>
<pre><code class="language-ocaml">let () = match [%bs.external __filename] with
| Some f -&gt; Js.log f
| None -&gt; Js.log &quot;non-node environment&quot;
</code></pre>
<pre><code class="language-reasonml">let () =
  switch ([%bs.external __filename]) {
  | Some(f) =&gt; Js.log(f)
  | None =&gt; Js.log(&quot;non-node environment&quot;)
  };
</code></pre>
<h2 id="communicate-with-javascript-inlining-constant-values">Inlining constant values</h2>
<p>Some JavaScript idioms require special constants to be inlined since they serve
as de-facto directives for bundlers. A common example is <code>process.env.NODE_ENV</code>:</p>
<pre><code class="language-js">if (process.env.NODE_ENV !== &quot;production&quot;) {
  // Development-only code
}
</code></pre>
<p>becomes:</p>
<pre><code class="language-js">if (&quot;development&quot; !== &quot;production&quot;) {
  // Development-only code
}
</code></pre>
<p>In this case, bundlers such as Webpack can tell that the <code>if</code> statement always
evaluates to a specific branch and eliminate the others.</p>
<p>Melange provides the <code>bs.inline</code> attribute to achieve the same goal in generated
JavaScript. Let’s look at an example:</p>
<pre><code class="language-ocaml">external node_env : string = &quot;NODE_ENV&quot; [@@bs.val] [@@bs.scope &quot;process&quot;, &quot;env&quot;]

let development = &quot;development&quot;
let () = if node_env &lt;&gt; development then Js.log &quot;Only in Production&quot;

let development_inline = &quot;development&quot; [@@bs.inline]
let () = if node_env &lt;&gt; development_inline then Js.log &quot;Only in Production&quot;
</code></pre>
<pre><code class="language-reasonml">[@bs.val] [@bs.scope (&quot;process&quot;, &quot;env&quot;)]
external node_env: string = &quot;NODE_ENV&quot;;

let development = &quot;development&quot;;
let () =
  if (node_env != development) {
    Js.log(&quot;Only in Production&quot;);
  };

[@bs.inline]
let development_inline = &quot;development&quot;;
let () =
  if (node_env != development_inline) {
    Js.log(&quot;Only in Production&quot;);
  };
</code></pre>
<p>As we can see in the generated JavaScript presented below:</p>
<ul>
<li>the <code>development</code> variable is emitted<ul>
<li>it gets used as a variable <code>process.env.NODE_ENV !== development</code> in the
  <code>if</code> statement</li>
</ul>
</li>
<li>the <code>development_inline</code> variable isn’t present in the final output<ul>
<li>its value is inlined in the <code>if</code> statement: <code>process.env.NODE_ENV !==
  "development"</code></li>
</ul>
</li>
</ul>
<pre><code class="language-js">var development = &quot;development&quot;;

if (process.env.NODE_ENV !== development) {
  console.log(&quot;Only in Production&quot;);
}

if (process.env.NODE_ENV !== &quot;development&quot;) {
  console.log(&quot;Only in Production&quot;);
}
</code></pre>
<h2 id="communicate-with-javascript-bind-to-javascript-objects">Bind to JavaScript objects</h2>
<p>JavaScript objects are used in a variety of use cases:</p>
<ul>
<li>As a fixed shape
  <a href="https://en.wikipedia.org/wiki/Record_(computer_science)">record</a>.</li>
<li>As a map or dictionary.</li>
<li>As a class.</li>
<li>As a module to import/export.</li>
</ul>
<p>Melange separates the binding methods for JavaScript objects based on these four
use cases. This section documents the first three. Binding to JavaScript module
objects is described in the <a href="#communicate-with-javascript-using-functions-from-other-javascript-modules">"Using functions from other JavaScript
modules"</a> section.</p>
<!-- TODO: mention scope here too? -->

<h3 id="communicate-with-javascript-objects-with-static-shape-record-like">Objects with static shape (record-like)</h3>
<h4 id="communicate-with-javascript-using-ocaml-records">Using OCaml records</h4>
<p>If your JavaScript object has fixed fields, then it’s conceptually like an
<a href="https://v2.ocaml.org/manual/coreexamples.html#s%3Atut-recvariants">OCaml
record</a>.
Since Melange compiles records into JavaScript objects, the most common way to
bind to JavaScript objects is using records.</p>
<pre><code class="language-ocaml">type person = {
  name : string;
  friends : string array;
  age : int;
}

external john : person = &quot;john&quot; [@@bs.module &quot;MySchool&quot;]
let john_name = john.name
</code></pre>
<pre><code class="language-reasonml">type person = {
  name: string,
  friends: array(string),
  age: int,
};

[@bs.module &quot;MySchool&quot;] external john: person = &quot;john&quot;;
let john_name = john.name;
</code></pre>
<p>This is the generated JavaScript:</p>
<pre><code class="language-js">var MySchool = require(&quot;MySchool&quot;);

var john_name = MySchool.john.name;
</code></pre>
<p>External functions are documented in <a href="#communicate-with-javascript-external-functions">a previous section</a>.
The <code>bs.module</code> attribute is documented
<a href="#communicate-with-javascript-using-functions-from-other-javascript-modules">here</a>.</p>
<p>If you want or need to use different field names on the Melange and the
JavaScript sides, you can use the <code>bs.as</code> decorator:</p>
<pre><code class="language-ocaml">type action = {
  type_ : string [@bs.as &quot;type&quot;]
}

let action = { type_ = &quot;ADD_USER&quot; }
</code></pre>
<pre><code class="language-reasonml">type action = {
  [@bs.as &quot;type&quot;]
  type_: string,
};

let action = {type_: &quot;ADD_USER&quot;};
</code></pre>
<p>Which generates the JavaScript code:</p>
<pre><code class="language-js">var action = {
  type: &quot;ADD_USER&quot;
};
</code></pre>
<p>This is useful to map to JavaScript attribute names that cannot be expressed in
Melange, for example, where the JavaScript name we want to generate is a
<a href="https://v2.ocaml.org/manual/lex.html#sss:keywords">reserved keyword</a>.</p>
<p>It is also possible to map a Melange record to a JavaScript array by passing
indices to the <code>bs.as</code> decorator:</p>
<pre><code class="language-ocaml">type t = {
  foo : int; [@bs.as &quot;0&quot;]
  bar : string; [@bs.as &quot;1&quot;]
}

let value = { foo = 7; bar = &quot;baz&quot; }
</code></pre>
<pre><code class="language-reasonml">type t = {
  [@bs.as &quot;0&quot;]
  foo: int,
  [@bs.as &quot;1&quot;]
  bar: string,
};

let value = {foo: 7, bar: &quot;baz&quot;};
</code></pre>
<p>And its JavaScript generated code:</p>
<pre><code class="language-js">var value = [
  7,
  &quot;baz&quot;
];
</code></pre>
<h4 id="communicate-with-javascript-using-jst-objects">Using <code>Js.t</code> objects</h4>
<p>Alternatively to records, Melange offers another type that can be used to
produce JavaScript objects. This type is <code>'a Js.t</code>, where <code>'a</code> is an <a href="https://v2.ocaml.org/manual/objectexamples.html">OCaml
object</a>.</p>
<p>The advantage of objects versus records is that no type declaration is needed in
advance, which can be helpful for prototyping or quickly generating JavaScript
object literals.</p>
<p>Melange provides some ways to create <code>Js.t</code> object values, as well as accessing
the properties inside them. To create values, the <code>[%bs.obj]</code> extension is used,
and the <code>##</code> infix operator allows to read from the object properties:</p>
<pre><code class="language-ocaml">let john = [%bs.obj { name = &quot;john&quot;; age = 99 }]
let t = john##name
</code></pre>
<pre><code class="language-reasonml">let john = {&quot;name&quot;: &quot;john&quot;, &quot;age&quot;: 99};
let t = john##name;
</code></pre>
<p>Which generates:</p>
<pre><code class="language-js">var john = {
  name: &quot;john&quot;,
  age: 99
};

var t = john.name;
</code></pre>
<p>Note that object types allow for some flexibility that the record types do not
have. For example, an object type can be coerced to another with fewer values or
methods, while it is impossible to coerce a record type to another one with
fewer fields. So different object types that share some methods can be mixed in
a data structure where only their common methods are visible.</p>
<p>To give an example, one can create a function that operates in all the object
types that include a field <code>name</code> that is of type string, e.g.:</p>
<pre><code class="language-ocaml">let name_extended obj = obj##name ^ &quot; wayne&quot;

let one = name_extended [%bs.obj { name = &quot;john&quot;; age = 99 }]
let two = name_extended [%bs.obj { name = &quot;jane&quot;; address = &quot;1 infinite loop&quot; }]
</code></pre>
<pre><code class="language-reasonml">let name_extended = obj =&gt; obj##name ++ &quot; wayne&quot;;

let one = name_extended({&quot;name&quot;: &quot;john&quot;, &quot;age&quot;: 99});
let two = name_extended({&quot;name&quot;: &quot;jane&quot;, &quot;address&quot;: &quot;1 infinite loop&quot;});
</code></pre>
<p>To read more about objects and polymorphism we recommend checking the <a href="https://ocaml.org/docs/objects">OCaml
docs</a> or the <a href="https://v2.ocaml.org/manual/objectexamples.html">OCaml
manual</a>.</p>
<h4 id="communicate-with-javascript-using-external-functions">Using external functions</h4>
<p>We have already explored one approach for creating JavaScript object literals by
using <a href="#communicate-with-javascript-using-jst-objects"><code>Js.t</code> values and the <code>bs.obj</code> extension</a>.</p>
<p>Melange additionally offers the <code>bs.obj</code> attribute, which can be used in
combination with external functions to create JavaScript objects. When these
functions are called, they generate objects with fields corresponding to the
labeled arguments of the function.</p>
<p>If any of these labeled arguments are defined as optional and omitted during
function application, the resulting JavaScript object will exclude the
corresponding fields. This allows to create runtime objects and control whether
optional keys are emitted at runtime.</p>
<p>For example, assuming we need to bind to a JavaScript object like this:</p>
<pre><code class="language-js">var homeRoute = {
  type: &quot;GET&quot;,
  path: &quot;/&quot;,
  action: () =&gt; console.log(&quot;Home&quot;),
  // options: ...
};
</code></pre>
<p>The first three fields are required and the <code>options</code> field is optional. You can
declare a binding function like:</p>
<pre><code class="language-ocaml">external route :
  _type:string -&gt;
  path:string -&gt;
  action:(string list -&gt; unit) -&gt;
  ?options:&lt; .. &gt; -&gt;
  unit -&gt;
  _ = &quot;&quot;
  [@@bs.obj]
</code></pre>
<pre><code class="language-reasonml">[@bs.obj]
external route:
  (
    ~_type: string,
    ~path: string,
    ~action: list(string) =&gt; unit,
    ~options: {..}=?,
    unit
  ) =&gt;
  _;
</code></pre>
<p>Note that the empty string at the end of the function is used to make it
syntactically valid. The value of this string is ignored by the compiler.</p>
<p>Since there is an optional argument <code>options</code>, an additional unlabeled argument
of type <code>unit</code> is included after it. It allows to omit the optional argument on
function application. More information about labeled optional arguments can be
found in the <a href="https://v2.ocaml.org/manual/lablexamples.html#s:optional-arguments">OCaml
manual</a>.</p>
<p>The return type of the function should be left unspecified using the wildcard
type <code>_</code>. Melange will automatically infer the type of the resulting JavaScript
object.</p>
<p>In the route function, the <code>_type</code> argument starts with an underscore. When
binding to JavaScript objects with fields that are reserved keywords in OCaml,
Melange allows the use of an underscore prefix for the labeled arguments. The
resulting JavaScript object will have the underscore removed from the field
names. This is only required for the <code>bs.obj</code> attribute, while for other cases,
the <code>bs.as</code> attribute can be used to rename fields.</p>
<p>If we call the function like this:</p>
<pre><code class="language-ocaml">let homeRoute = route ~_type:&quot;GET&quot; ~path:&quot;/&quot; ~action:(fun _ -&gt; Js.log &quot;Home&quot;) ()
</code></pre>
<pre><code class="language-reasonml">let homeRoute =
  route(~_type=&quot;GET&quot;, ~path=&quot;/&quot;, ~action=_ =&gt; Js.log(&quot;Home&quot;), ());
</code></pre>
<p>We get the following JavaScript, which does not include the <code>options</code> field
since its argument wasn’t present:</p>
<pre><code class="language-javascript">var homeRoute = {
  type: &quot;GET&quot;,
  path: &quot;/&quot;,
  action: (function (param) {
      console.log(&quot;Home&quot;);
    })
};
</code></pre>
<h4 id="communicate-with-javascript-bind-to-object-properties">Bind to object properties</h4>
<p>If you need to bind only to the property of a JavaScript object, you can use
<code>bs.get</code> and <code>bs.set</code> to access it using the dot notation <code>.</code>:</p>
<pre><code class="language-ocaml">(* Abstract type for the `document` value *)
type document

external document : document = &quot;document&quot; [@@bs.val]

external set_title : document -&gt; string -&gt; unit = &quot;title&quot; [@@bs.set]
external get_title : document -&gt; string = &quot;title&quot; [@@bs.get]

let current = get_title document
let () = set_title document &quot;melange&quot;
</code></pre>
<pre><code class="language-reasonml">/* Abstract type for the `document` value */
type document;

[@bs.val] external document: document = &quot;document&quot;;

[@bs.set] external set_title: (document, string) =&gt; unit = &quot;title&quot;;
[@bs.get] external get_title: document =&gt; string = &quot;title&quot;;

let current = get_title(document);
let () = set_title(document, &quot;melange&quot;);
</code></pre>
<p>This generates:</p>
<pre><code class="language-javascript">var current = document.title;
document.title = &quot;melange&quot;;
</code></pre>
<p>Alternatively, if some dynamism is required on the way the property is accessed,
you can use <code>bs.get_index</code> and <code>bs.set_index</code> to access it using the bracket
notation <code>[]</code>:</p>
<pre><code class="language-ocaml">type t
external create : int -&gt; t = &quot;Int32Array&quot; [@@bs.new]
external get : t -&gt; int -&gt; int = &quot;get&quot; [@@bs.get_index]
external set : t -&gt; int -&gt; int -&gt; unit = &quot;set&quot; [@@bs.set_index]

let () =
  let i32arr = (create 3) in
  set i32arr 0 42;
  Js.log (get i32arr 0)
</code></pre>
<pre><code class="language-reasonml">type t;
[@bs.new] external create: int =&gt; t = &quot;Int32Array&quot;;
[@bs.get_index] external get: (t, int) =&gt; int = &quot;get&quot;;
[@bs.set_index] external set: (t, int, int) =&gt; unit = &quot;set&quot;;

let () = {
  let i32arr = create(3);
  set(i32arr, 0, 42);
  Js.log(get(i32arr, 0));
};
</code></pre>
<p>Which generates:</p>
<pre><code class="language-js">var i32arr = new Int32Array(3);
i32arr[0] = 42;
console.log(i32arr[0]);
</code></pre>
<h3 id="communicate-with-javascript-objects-with-dynamic-shape-dictionary-like">Objects with dynamic shape (dictionary-like)</h3>
<p>Sometimes JavaScript objects are used as dictionaries. In these cases:</p>
<ul>
<li>All values stored in the object belong to the same type</li>
<li>Key-value pairs can be added or removed at runtime</li>
</ul>
<p>For this particular use case of JavaScript objects, Melange exposes a specific
type <code>Js.Dict.t</code>. The values and functions to work with values of this type are
defined in the <a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.Dict</code></a> module, with operations like <code>get</code>,
<code>set</code>, etc.</p>
<p>Values of the type <code>Js.Dict.t</code> compile to JavaScript objects.</p>
<h3 id="communicate-with-javascript-javascript-classes">JavaScript classes</h3>
<p>JavaScript classes are special kinds of objects. To interact with classes,
Melange exposes <code>bs.new</code> to emulate e.g. <code>new Date()</code>:</p>
<pre><code class="language-ocaml">type t
external create_date : unit -&gt; t = &quot;Date&quot; [@@bs.new]
let date = create_date ()
</code></pre>
<pre><code class="language-reasonml">type t;
[@bs.new] external create_date: unit =&gt; t = &quot;Date&quot;;
let date = create_date();
</code></pre>
<p>Which generates:</p>
<pre><code class="language-js">var date = new Date();
</code></pre>
<p>You can chain <code>bs.new</code> and <code>bs.module</code> if the JavaScript class you want to work
with is in a separate JavaScript module:</p>
<pre><code class="language-ocaml">type t
external book : unit -&gt; t = &quot;Book&quot; [@@bs.new] [@@bs.module]
let myBook = book ()
</code></pre>
<pre><code class="language-reasonml">type t;
[@bs.new] [@bs.module] external book: unit =&gt; t = &quot;Book&quot;;
let myBook = book();
</code></pre>
<p>Which generates:</p>
<pre><code class="language-js">var Book = require(&quot;Book&quot;);
var myBook = new Book();
</code></pre>
<h2 id="communicate-with-javascript-bind-to-global-javascript-functions-or-values">Bind to global JavaScript functions or values</h2>
<p>Binding to a JavaScript function makes use of <code>external</code>, like with objects. If
we want to bind to a function available globally, Melange offers the <code>bs.val</code>
attribute:</p>
<pre><code class="language-ocaml">(* Abstract type for `timeoutId` *)
type timeoutId
external setTimeout : (unit -&gt; unit) -&gt; int -&gt; timeoutId = &quot;setTimeout&quot;
  [@@bs.val]
external clearTimeout : timeoutId -&gt; unit = &quot;clearTimeout&quot; [@@bs.val]

let id = setTimeout (fun () -&gt; Js.log &quot;hello&quot;) 100
let () = clearTimeout id
</code></pre>
<pre><code class="language-reasonml">/* Abstract type for `timeoutId` */
type timeoutId;
[@bs.val] external setTimeout: (unit =&gt; unit, int) =&gt; timeoutId = &quot;setTimeout&quot;;
[@bs.val] external clearTimeout: timeoutId =&gt; unit = &quot;clearTimeout&quot;;

let id = setTimeout(() =&gt; Js.log(&quot;hello&quot;), 100);
let () = clearTimeout(id);
</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> The bindings to <code>setTimeout</code> and <code>clearTimeout</code> are shown here for
learning purposes, but they are already available in the
<a href="#communicate-with-javascript-todo-fix-me.md"><code>Js.Global</code></a> module.</p>
</blockquote>
<p>Generates:</p>
<pre><code class="language-javascript">var id = setTimeout(function (param) {
  console.log(&quot;hello&quot;);
}, 100);

clearTimeout(id);
</code></pre>
<p>Global bindings can also be applied to values:</p>
<pre><code class="language-ocaml">(* Abstract type for `document` *)
type document

external document : document = &quot;document&quot; [@@bs.val]
let document = document
</code></pre>
<pre><code class="language-reasonml">/* Abstract type for `document` */
type document;

[@bs.val] external document: document = &quot;document&quot;;
let document = document;
</code></pre>
<p>Which generates:</p>
<pre><code class="language-javascript">var doc = document;
</code></pre>
<h3 id="communicate-with-javascript-using-functions-from-other-javascript-modules">Using functions from other JavaScript modules</h3>
<p><code>bs.module</code> is like the <code>bs.val</code> attribute, but it accepts a string with the
name of the module, or the relative path to it.</p>
<pre><code class="language-ocaml">external dirname : string -&gt; string = &quot;dirname&quot; [@@bs.module &quot;path&quot;]
let root = dirname &quot;/User/github&quot;
</code></pre>
<pre><code class="language-reasonml">[@bs.module &quot;path&quot;] external dirname: string =&gt; string = &quot;dirname&quot;;
let root = dirname(&quot;/User/github&quot;);
</code></pre>
<p>Generates:</p>
<pre><code class="language-js">var Path = require(&quot;path&quot;);
var root = Path.dirname(&quot;/User/github&quot;);
</code></pre>
<h3 id="communicate-with-javascript-binding-to-properties-inside-a-module-or-global">Binding to properties inside a module or global</h3>
<p>For cases when we need to create bindings for a property within a module or a
global JavaScript object, Melange provides the <code>bs.scope</code> attribute.</p>
<p>For example, if we want to write some bindings for a specific property
<code>commands</code> from <a href="https://code.visualstudio.com/api/references/vscode-api#commands">the <code>vscode</code>
package</a>, we
can do:</p>
<pre><code class="language-ocaml">type param
external executeCommands : string -&gt; param array -&gt; unit = &quot;&quot;
  [@@bs.scope &quot;commands&quot;] [@@bs.module &quot;vscode&quot;] [@@bs.variadic]

let f a b c = executeCommands &quot;hi&quot; [| a; b; c |]
</code></pre>
<pre><code class="language-reasonml">type param;
[@bs.scope &quot;commands&quot;] [@bs.module &quot;vscode&quot;] [@bs.variadic]
external executeCommands: (string, array(param)) =&gt; unit;

let f = (a, b, c) =&gt; executeCommands(&quot;hi&quot;, [|a, b, c|]);
</code></pre>
<p>Which compiles to:</p>
<pre><code class="language-javascript">var Vscode = require(&quot;vscode&quot;);

function f(a, b, c) {
  Vscode.commands.executeCommands(&quot;hi&quot;, a, b, c);
}
</code></pre>
<p>The <code>bs.scope</code> attribute can take multiple arguments as payload, in case we want
to reach deeper into the object from the module we are importing.</p>
<p>For example:</p>
<pre><code class="language-ocaml">type t

external back : t = &quot;back&quot;
  [@@bs.module &quot;expo-camera&quot;] [@@bs.scope &quot;Camera&quot;, &quot;Constants&quot;, &quot;Type&quot;]

let camera_type_back = back
</code></pre>
<pre><code class="language-reasonml">type t;

[@bs.module &quot;expo-camera&quot;] [@bs.scope (&quot;Camera&quot;, &quot;Constants&quot;, &quot;Type&quot;)]
external back: t = &quot;back&quot;;

let camera_type_back = back;
</code></pre>
<p>Which generates:</p>
<pre><code class="language-javascript">var ExpoCamera = require(&quot;expo-camera&quot;);

var camera_type_back = ExpoCamera.Camera.Constants.Type.back;
</code></pre>
<p>It can also be used in combination with other attributes besides <code>bs.module</code>,
like <code>bs.val</code>:</p>
<pre><code class="language-ocaml">external imul : int -&gt; int -&gt; int = &quot;imul&quot; [@@bs.val] [@@bs.scope &quot;Math&quot;]

let res = imul 1 2
</code></pre>
<pre><code class="language-reasonml">[@bs.val] [@bs.scope &quot;Math&quot;] external imul: (int, int) =&gt; int = &quot;imul&quot;;

let res = imul(1, 2);
</code></pre>
<p>Which produces:</p>
<pre><code class="language-javascript">var res = Math.imul(1, 2);
</code></pre>
<p>Or it can be used together with <code>bs.new</code>:</p>
<pre><code class="language-ocaml">type t

external create : unit -&gt; t = &quot;GUI&quot;
  [@@bs.new] [@@bs.scope &quot;default&quot;] [@@bs.module &quot;dat.gui&quot;]

let gui = create ()
</code></pre>
<pre><code class="language-reasonml">type t;

[@bs.new] [@bs.scope &quot;default&quot;] [@bs.module &quot;dat.gui&quot;]
external create: unit =&gt; t = &quot;GUI&quot;;

let gui = create();
</code></pre>
<p>Which generates:</p>
<pre><code class="language-javascript">var DatGui = require(&quot;dat.gui&quot;);

var gui = new (DatGui.default.GUI)();
</code></pre>
<h3 id="communicate-with-javascript-labeled-arguments">Labeled arguments</h3>
<p>OCaml has <a href="https://v2.ocaml.org/manual/lablexamples.html">labeled arguments</a>,
which can also be optional, and work with <code>external</code> as well.</p>
<p>Labeled arguments can be useful to provide more information about the arguments
of a JavaScript function that is called from Melange.</p>
<p>Let’s say we have the following JavaScript function, that we want to call from
Melange:</p>
<pre><code class="language-js">// MyGame.js

function draw(x, y, border) {
  // let’s assume `border` is optional and defaults to false
}
draw(10, 20)
draw(20, 20, true)
</code></pre>
<p>When writing Melange bindings, we can add labeled arguments to make things more
clear:</p>
<pre><code class="language-ocaml">external draw : x:int -&gt; y:int -&gt; ?border:bool -&gt; unit -&gt; unit = &quot;draw&quot;
  [@@module &quot;MyGame&quot;]

let () = draw ~x:10 ~y:20 ~border:true ()
let () = draw ~x:10 ~y:20 ()
</code></pre>
<pre><code class="language-reasonml">[@module &quot;MyGame&quot;]
external draw: (~x: int, ~y: int, ~border: bool=?, unit) =&gt; unit = &quot;draw&quot;;

let () = draw(~x=10, ~y=20, ~border=true, ());
let () = draw(~x=10, ~y=20, ());
</code></pre>
<p>Generates:</p>
<pre><code class="language-js">var MyGame = require(&quot;MyGame&quot;);

MyGame.draw(10, 20, true);
MyGame.draw(10, 20, undefined);
</code></pre>
<p>The generated JavaScript function is the same, but now the usage in Melange is
much clearer.</p>
<p><strong>Note</strong>: in this particular case, a final param of type unit, <code>()</code> must be
added after <code>border</code>, since <code>border</code> is an optional argument at the last
position. Not having the last param <code>unit</code> would lead to a warning, which is
explained in detail <a href="https://ocaml.org/docs/labels#warning-this-optional-argument-cannot-be-erased">in the OCaml
documentation</a>.</p>
<p>Note that you can freely reorder the labeled arguments when applying the
function on the Melange side. The generated code will maintain the original
order that was used when declaring the function:</p>
<pre><code class="language-ocaml">external draw : x:int -&gt; y:int -&gt; ?border:bool -&gt; unit -&gt; unit = &quot;draw&quot;
  [@@module &quot;MyGame&quot;]
let () = draw ~x:10 ~y:20 ()
let () = draw ~y:20 ~x:10 ()
</code></pre>
<pre><code class="language-reasonml">[@module &quot;MyGame&quot;]
external draw: (~x: int, ~y: int, ~border: bool=?, unit) =&gt; unit = &quot;draw&quot;;
let () = draw(~x=10, ~y=20, ());
let () = draw(~y=20, ~x=10, ());
</code></pre>
<p>Generates:</p>
<pre><code class="language-js">var MyGame = require(&quot;MyGame&quot;);

MyGame.draw(10, 20, undefined);
MyGame.draw(10, 20, undefined);
</code></pre>
<h3 id="communicate-with-javascript-calling-an-object-method">Calling an object method</h3>
<p>If we need to call a JavaScript method, Melange provides the attribute
<code>bs.send</code>:</p>
<pre><code class="language-ocaml">(* Abstract type for the `document` global *)
type document

external document : document = &quot;document&quot; [@@bs.val]
external get_by_id : document -&gt; string -&gt; Dom.element = &quot;getElementById&quot;
  [@@bs.send]

let el = get_by_id document &quot;my-id&quot;
</code></pre>
<pre><code class="language-reasonml">/* Abstract type for the `document` global */
type document;

[@bs.val] external document: document = &quot;document&quot;;
[@bs.send]
external get_by_id: (document, string) =&gt; Dom.element = &quot;getElementById&quot;;

let el = get_by_id(document, &quot;my-id&quot;);
</code></pre>
<p>Generates:</p>
<pre><code class="language-js">var el = document.getElementById(&quot;my-id&quot;);
</code></pre>
<p>When using <code>bs.send</code>, the first argument will be the object that holds the
property with the function we want to call. This combines well with the pipe
first operator <code class="text-ocaml">|.</code><code
class="text-reasonml">-></code>, see the <a href="#communicate-with-javascript-chaining">"Chaining"</a> section
below.</p>
<p>If we want to design our bindings to be used with OCaml pipe last operator <code>|&gt;</code>,
there is an alternate <code>bs.send.pipe</code> attribute. Let’s rewrite the example above
using it:</p>
<pre><code class="language-ocaml">(* Abstract type for the `document` global *)
type document

external document : document = &quot;document&quot; [@@bs.val]
external get_by_id : string -&gt; Dom.element = &quot;getElementById&quot;
  [@@bs.send.pipe: document]

let el = get_by_id &quot;my-id&quot; document
</code></pre>
<pre><code class="language-reasonml">/* Abstract type for the `document` global */
type document;

[@bs.val] external document: document = &quot;document&quot;;
[@bs.send.pipe: document]
external get_by_id: string =&gt; Dom.element = &quot;getElementById&quot;;

let el = get_by_id(&quot;my-id&quot;, document);
</code></pre>
<p>Generates the same code as <code>bs.send</code>:</p>
<pre><code class="language-js">var el = document.getElementById(&quot;my-id&quot;);
</code></pre>
<h4 id="communicate-with-javascript-chaining">Chaining</h4>
<p>It is common to find this kind of API in JavaScript: <code>foo().bar().baz()</code>. This
kind of API can be designed with Melange externals. Depending on which
convention we want to use, there are two attributes available:</p>
<ul>
<li>For a data-first convention, the <code>bs.send</code> attribute, in combination with <a href="#communicate-with-javascript-pipe-first">the
  pipe first operator</a> <code class="text-ocaml">|.</code><code
  class="text-reasonml">-></code></li>
<li>For a data-last convention, the <code>bs.send.pipe</code> attribute, in combination with
  OCaml <a href="#communicate-with-javascript-pipe-last">pipe last operator</a> <code>|&gt;</code>.</li>
</ul>
<p>Let’s see first an example of chaining using data-first convention with the pipe
first operator <code class="text-ocaml">|.</code><code
class="text-reasonml">-></code>:</p>
<pre><code class="language-ocaml">(* Abstract type for the `document` global *)
type document

external document : document = &quot;document&quot; [@@bs.val]
external get_by_id : document -&gt; string -&gt; Dom.element = &quot;getElementById&quot;
  [@@bs.send]
external get_by_classname : Dom.element -&gt; string -&gt; Dom.element
  = &quot;getElementsByClassName&quot;
  [@@bs.send]

let el = document |. get_by_id &quot;my-id&quot; |. get_by_classname &quot;my-class&quot;
</code></pre>
<pre><code class="language-reasonml">/* Abstract type for the `document` global */
type document;

[@bs.val] external document: document = &quot;document&quot;;
[@bs.send]
external get_by_id: (document, string) =&gt; Dom.element = &quot;getElementById&quot;;
[@bs.send]
external get_by_classname: (Dom.element, string) =&gt; Dom.element =
  &quot;getElementsByClassName&quot;;

let el = document-&gt;(get_by_id(&quot;my-id&quot;))-&gt;(get_by_classname(&quot;my-class&quot;));
</code></pre>
<p>Will generate:</p>
<pre><code class="language-javascript">var el = document.getElementById(&quot;my-id&quot;).getElementsByClassName(&quot;my-class&quot;);
</code></pre>
<p>Now with pipe last operator <code>|&gt;</code>:</p>
<pre><code class="language-ocaml">(* Abstract type for the `document` global *)
type document

external document : document = &quot;document&quot; [@@bs.val]
external get_by_id : string -&gt; Dom.element = &quot;getElementById&quot;
  [@@bs.send.pipe: document]
external get_by_classname : string -&gt; Dom.element = &quot;getElementsByClassName&quot;
  [@@bs.send.pipe: Dom.element]

let el = document |&gt; get_by_id &quot;my-id&quot; |&gt; get_by_classname &quot;my-class&quot;
</code></pre>
<pre><code class="language-reasonml">/* Abstract type for the `document` global */
type document;

[@bs.val] external document: document = &quot;document&quot;;
[@bs.send.pipe: document]
external get_by_id: string =&gt; Dom.element = &quot;getElementById&quot;;
[@bs.send.pipe: Dom.element]
external get_by_classname: string =&gt; Dom.element = &quot;getElementsByClassName&quot;;

let el = document |&gt; get_by_id(&quot;my-id&quot;) |&gt; get_by_classname(&quot;my-class&quot;);
</code></pre>
<p>Will generate the same JavaScript as the pipe first version:</p>
<pre><code class="language-javascript">var el = document.getElementById(&quot;my-id&quot;).getElementsByClassName(&quot;my-class&quot;);
</code></pre>
<h3 id="communicate-with-javascript-variadic-function-arguments">Variadic function arguments</h3>
<p>Sometimes JavaScript functions take an arbitrary amount of arguments. For these
cases, Melange provides the <code>bs.variadic</code> attribute, which can be attached to
the <code>external</code> declaration. However, there is one caveat: all the variadic
arguments need to belong to the same type.</p>
<pre><code class="language-ocaml">external join : string array -&gt; string = &quot;join&quot;
  [@@bs.module &quot;path&quot;] [@@bs.variadic]
let v = join [| &quot;a&quot;; &quot;b&quot; |]
</code></pre>
<pre><code class="language-reasonml">[@bs.module &quot;path&quot;] [@bs.variadic]
external join: array(string) =&gt; string = &quot;join&quot;;
let v = join([|&quot;a&quot;, &quot;b&quot;|]);
</code></pre>
<p>Generates:</p>
<pre><code class="language-js">var Path = require(&quot;path&quot;);
var v = Path.join(&quot;a&quot;, &quot;b&quot;);
</code></pre>
<p>If more dynamism is needed, there is a way to inject elements with different
types in the array and still have Melange compile to JavaScript values that are
not wrapped using the OCaml
<a href="https://v2.ocaml.org/manual/attributes.html"><code>unboxed</code></a> attribute, which was
mentioned <a href="#communicate-with-javascript-reusing-ocaml-attributes">in the OCaml attributes section</a>:</p>
<pre><code class="language-ocaml">type hide = Hide : 'a -&gt; hide [@@unboxed]

external join : hide array -&gt; string = &quot;join&quot; [@@bs.module &quot;path&quot;] [@@bs.variadic]

let v = join [| Hide &quot;a&quot;; Hide 2 |]
</code></pre>
<pre><code class="language-reasonml">[@unboxed]
type hide =
  | Hide('a): hide;

[@bs.module &quot;path&quot;] [@bs.variadic]
external join: array(hide) =&gt; string = &quot;join&quot;;

let v = join([|Hide(&quot;a&quot;), Hide(2)|]);
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-javascript">var Path = require(&quot;path&quot;);

var v = Path.join(&quot;a&quot;, 2);
</code></pre>
<h3 id="communicate-with-javascript-bind-to-a-polymorphic-function">Bind to a polymorphic function</h3>
<p>Some JavaScript libraries will define functions where the arguments can vary on
both type and shape. There are two approaches to bind to those, depending on how
dynamic they are.</p>
<h4 id="communicate-with-javascript-approach-1-multiple-external-functions">Approach 1: Multiple external functions</h4>
<p>If it is possible to enumerate the many forms an overloaded JavaScript function
can take, a flexible approach is to bind to each form individually:</p>
<pre><code class="language-ocaml">external drawCat : unit -&gt; unit = &quot;draw&quot; [@@bs.module &quot;MyGame&quot;]
external drawDog : giveName:string -&gt; unit = &quot;draw&quot; [@@bs.module &quot;MyGame&quot;]
external draw : string -&gt; useRandomAnimal:bool -&gt; unit = &quot;draw&quot;
  [@@bs.module &quot;MyGame&quot;]
</code></pre>
<pre><code class="language-reasonml">[@bs.module &quot;MyGame&quot;] external drawCat: unit =&gt; unit = &quot;draw&quot;;
[@bs.module &quot;MyGame&quot;] external drawDog: (~giveName: string) =&gt; unit = &quot;draw&quot;;
[@bs.module &quot;MyGame&quot;]
external draw: (string, ~useRandomAnimal: bool) =&gt; unit = &quot;draw&quot;;
</code></pre>
<p>Note how all three externals bind to the same JavaScript function, <code>draw</code>.</p>
<h4 id="communicate-with-javascript-approach-2-polymorphic-variant-bsunwrap">Approach 2: Polymorphic variant + <code>bs.unwrap</code></h4>
<p>In some cases, the function has a constant number of arguments but the type of
the argument can vary. For cases like this, we can model the argument as a
variant and use the <code>bs.unwrap</code> attribute in the external.</p>
<p>Let’s say we want to bind to the following JavaScript function:</p>
<pre><code class="language-js">function padLeft(value, padding) {
  if (typeof padding === &quot;number&quot;) {
    return Array(padding + 1).join(&quot; &quot;) + value;
  }
  if (typeof padding === &quot;string&quot;) {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>
<p>As the <code>padding</code> argument can be either a number or a string, we can use
<code>bs.unwrap</code> to define it. It is important to note that <code>bs.unwrap</code> imposes
certain requirements on the type it is applied to:</p>
<ul>
<li>It needs to be a <a href="https://v2.ocaml.org/manual/polyvariant.html">polymorphic
  variant</a></li>
<li>Its definition needs to be inlined</li>
<li>Each variant tag needs to have an argument</li>
<li>The variant type can not be opened (can’t use <code>&gt;</code>)</li>
</ul>
<pre><code class="language-ocaml">external padLeft:
  string
  -&gt; ([ `Str of string
      | `Int of int
      ] [@bs.unwrap])
  -&gt; string
  = &quot;padLeft&quot; [@@bs.val]

let _ = padLeft &quot;Hello World&quot; (`Int 4)
let _ = padLeft &quot;Hello World&quot; (`Str &quot;Message from Melange: &quot;)
</code></pre>
<pre><code class="language-reasonml">[@bs.val]
external padLeft:
  (string, [@bs.unwrap] [ | `Str(string) | `Int(int)]) =&gt; string =
  &quot;padLeft&quot;;

let _ = padLeft(&quot;Hello World&quot;, `Int(4));
let _ = padLeft(&quot;Hello World&quot;, `Str(&quot;Message from Melange: &quot;));
</code></pre>
<p>Which produces the following JavaScript:</p>
<pre><code class="language-js">padLeft(&quot;Hello World&quot;, 4);
padLeft(&quot;Hello World&quot;, &quot;Message from Melange: &quot;);
</code></pre>
<p>As we saw in the <a href="#communicate-with-javascript-non-shared-data-types">Non-shared data types</a> section, we
should rather avoid passing variants directly to the JavaScript side. By using
<code>bs.unwrap</code> we get the best of both worlds: from Melange we can use variants,
while JavaScript gets the raw values inside them.</p>
<h3 id="communicate-with-javascript-using-polymorphic-variants-to-bind-to-enums">Using polymorphic variants to bind to enums</h3>
<p>Some JavaScript APIs take a limited subset of values as input. For example,
Node’s <code>fs.readFileSync</code> second argument can only take a few given string
values: <code>"ascii"</code>, <code>"utf8"</code>, etc. Some other functions can take values from a
few given integers, like the <code>createStatusBarItem</code> function in VS Code API,
which can take an <code>alignment</code> parameter that can only be <a href="https://github.com/Microsoft/vscode/blob/2362ec665c84a1519162b50c36ed4f29d1e20f62/src/vs/vscode.d.ts#L4098-L4109"><code>1</code> or
<code>2</code></a>.</p>
<p>One could still type these parameters as just <code>string</code> or <code>int</code>, but this would
not prevent consumers of the external function from calling it using values that
are unsupported by the JavaScript function. Let’s see how we can use polymorphic
variants to avoid runtime errors.</p>
<p>If the values are strings, we can use the <code>bs.string</code> attribute:</p>
<pre><code class="language-ocaml">external read_file_sync :
  name:string -&gt; ([ `utf8 | `ascii ][@bs.string]) -&gt; string = &quot;readFileSync&quot;
  [@@bs.module &quot;fs&quot;]

let _ = read_file_sync ~name:&quot;xx.txt&quot; `ascii
</code></pre>
<pre><code class="language-reasonml">[@bs.module &quot;fs&quot;]
external read_file_sync:
  (~name: string, [@bs.string] [ | `utf8 | `ascii]) =&gt; string =
  &quot;readFileSync&quot;;

let _ = read_file_sync(~name=&quot;xx.txt&quot;, `ascii);
</code></pre>
<p>Which generates:</p>
<pre><code class="language-js">var Fs = require(&quot;fs&quot;);
Fs.readFileSync(&quot;xx.txt&quot;, &quot;ascii&quot;);
</code></pre>
<p>This technique can be combined with the <code>bs.as</code> attribute to modify the strings
produced from the polymorphic variant values. For example:</p>
<pre><code class="language-ocaml">type document
type style

external document : document = &quot;document&quot; [@@bs.val]
external get_by_id : document -&gt; string -&gt; Dom.element = &quot;getElementById&quot;
  [@@bs.send]
external style : Dom.element -&gt; style = &quot;style&quot; [@@bs.get]
external transition_timing_function :
  style -&gt;
  [ `ease
  | `easeIn [@bs.as &quot;ease-in&quot;]
  | `easeOut [@bs.as &quot;ease-out&quot;]
  | `easeInOut [@bs.as &quot;ease-in-out&quot;]
  | `linear
  ] -&gt;
  unit = &quot;transitionTimingFunction&quot;
  [@@bs.set]

let element_style = style (get_by_id document &quot;my-id&quot;)
let () = transition_timing_function element_style `easeIn
</code></pre>
<pre><code class="language-reasonml">type document;
type style;

[@bs.val] external document: document = &quot;document&quot;;
[@bs.send]
external get_by_id: (document, string) =&gt; Dom.element = &quot;getElementById&quot;;
[@bs.get] external style: Dom.element =&gt; style = &quot;style&quot;;
[@bs.set]
external transition_timing_function:
  (
    style,
    [
      | `ease
      | [@bs.as &quot;ease-in&quot;] `easeIn
      | [@bs.as &quot;ease-out&quot;] `easeOut
      | [@bs.as &quot;ease-in-out&quot;] `easeInOut
      | `linear
    ]
  ) =&gt;
  unit =
  &quot;transitionTimingFunction&quot;;

let element_style = style(get_by_id(document, &quot;my-id&quot;));
let () = transition_timing_function(element_style, `easeIn);
</code></pre>
<p>This will generate:</p>
<pre><code class="language-javascript">var element_style = document.getElementById(&quot;my-id&quot;).style;

element_style.transitionTimingFunction = &quot;ease-in&quot;;
</code></pre>
<p>Aside from producing string values, Melange also offers <code>bs.int</code> to produce
integer values. <code>bs.int</code> can also be combined with <code>bs.as</code>:</p>
<pre><code class="language-ocaml">external test_int_type :
  ([ `on_closed | `on_open [@bs.as 20] | `in_bin ][@bs.int]) -&gt; int
  = &quot;testIntType&quot;
  [@@bs.val]

let value = test_int_type `on_open
</code></pre>
<pre><code class="language-reasonml">[@bs.val]
external test_int_type:
  ([@bs.int] [ | `on_closed | [@bs.as 20] `on_open | `in_bin]) =&gt; int =
  &quot;testIntType&quot;;

let value = test_int_type(`on_open);
</code></pre>
<p>In this example, <code>on_closed</code> will be encoded as 0, <code>on_open</code> will be 20 due to
the attribute <code>bs.as</code> and <code>in_bin</code> will be 21, because if no <code>bs.as</code> annotation
is provided for a variant tag, the compiler continues assigning values counting
up from the previous one.</p>
<p>This code generates:</p>
<pre><code class="language-js">var value = testIntType(20);
</code></pre>
<h3 id="communicate-with-javascript-using-polymorphic-variants-to-bind-to-event-listeners">Using polymorphic variants to bind to event listeners</h3>
<p>Polymorphic variants can also be used to wrap event listeners, or any other kind
of callback, for example:</p>
<pre><code class="language-ocaml">type readline

external on :
  readline -&gt;
  ([ `close of unit -&gt; unit | `line of string -&gt; unit ][@bs.string]) -&gt;
  readline = &quot;on&quot;
  [@@bs.send]

let register rl =
  rl |. on (`close (fun event -&gt; ())) |. on (`line (fun line -&gt; Js.log line))
</code></pre>
<pre><code class="language-reasonml">type readline;

[@bs.send]
external on:
  (
    readline,
    [@bs.string] [ | `close(unit =&gt; unit) | `line(string =&gt; unit)]
  ) =&gt;
  readline =
  &quot;on&quot;;

let register = rl =&gt;
  rl-&gt;(on(`close(event =&gt; ())))-&gt;(on(`line(line =&gt; Js.log(line))));
</code></pre>
<p>This generates:</p>
<pre><code class="language-js">function register(rl) {
  return rl
    .on(&quot;close&quot;, function($$event) {})
    .on(&quot;line&quot;, function(line) {
      console.log(line);
    });
}
</code></pre>
<h3 id="communicate-with-javascript-constant-values-as-arguments">Constant values as arguments</h3>
<p>Sometimes we want to call a JavaScript function and make sure one of the
arguments is always constant. For this, the <code>[@bs.as]</code> attribute can be combined
with the wildcard pattern <code>_</code>:</p>
<pre><code class="language-ocaml">external process_on_exit : (_[@bs.as &quot;exit&quot;]) -&gt; (int -&gt; unit) -&gt; unit
  = &quot;process.on&quot;
  [@@bs.val]

let () =
  process_on_exit (fun exit_code -&gt;
    Js.log (&quot;error code: &quot; ^ string_of_int exit_code))
</code></pre>
<pre><code class="language-reasonml">[@bs.val]
external process_on_exit: ([@bs.as &quot;exit&quot;] _, int =&gt; unit) =&gt; unit =
  &quot;process.on&quot;;

let () =
  process_on_exit(exit_code =&gt;
    Js.log(&quot;error code: &quot; ++ string_of_int(exit_code))
  );
</code></pre>
<p>This generates:</p>
<pre><code class="language-js">process.on(&quot;exit&quot;, function (exitCode) {
  console.log(&quot;error code: &quot; + exitCode.toString());
});
</code></pre>
<p>The <code>bs.as "exit"</code> and the wildcard <code>_</code> pattern together will tell Melange to
compile the first argument of the JavaScript function to the string <code>"exit"</code>.</p>
<p>You can also use any JSON literal by passing a quoted string to <code>bs.as</code>: <code>bs.as
{json|true|json}</code> or <code>bs.as {json|{"name": "John"}|json}</code>.</p>
<h3 id="communicate-with-javascript-binding-to-callbacks">Binding to callbacks</h3>
<p>In OCaml, all functions have arity 1. This means that if you define a function
like this:</p>
<pre><code class="language-ocaml">let add x y = x + y
</code></pre>
<pre><code class="language-reasonml">let add = (x, y) =&gt; x + y;
</code></pre>
<p>Its type will be <code>int -&gt; int -&gt; int</code>. This means that one can partially apply
<code>add</code> by calling <code>add 1</code>, which will return another function expecting the
second argument of the addition. This kind of functions are called "curried"
functions, more information about currying in OCaml can be found in <a href="https://cs3110.github.io/textbook/chapters/hop/currying.html">this
chapter</a> of the
"OCaml Programming: Correct + Efficient + Beautiful" book.</p>
<p>This is incompatible with how function calling conventions work in JavaScript,
where all function calls always apply all the arguments. To continue the
example, let’s say we have an <code>add</code> function implemented in JavaScript, similar
to the one above:</p>
<pre><code class="language-javascript">var add = function (a, b) {
    return a + b;
};
</code></pre>
<p>If we call <code>add(1)</code>, the function will be totally applied, with <code>b</code> having
<code>undefined</code> value. And as JavaScript will try to add <code>1</code> with <code>undefined</code>, we
will get <code>NaN</code> as a result.</p>
<p>To illustrate this difference and how it affects Melange bindings, let’s say we
want to write bindings for a JavaScript function like this:</p>
<pre><code class="language-javascript">function map (a, b, f){
  var i = Math.min(a.length, b.length);
  var c = new Array(i);
  for(var j = 0; j &lt; i; ++j){
    c[j] = f(a[i],b[i])
  }
  return c ;
}
</code></pre>
<p>A naive external function declaration could be as below:</p>
<pre><code class="language-ocaml">external map : 'a array -&gt; 'b array -&gt; ('a -&gt; 'b -&gt; 'c) -&gt; 'c array = &quot;map&quot;
  [@@bs.val]
</code></pre>
<pre><code class="language-reasonml">[@bs.val]
external map: (array('a), array('b), ('a, 'b) =&gt; 'c) =&gt; array('c) = &quot;map&quot;;
</code></pre>
<p>Unfortunately, this is not completely correct. The issue is in the callback
function, with type <code>'a -&gt; 'b -&gt; 'c</code>. This means that <code>map</code> will expect a
function like <code>add</code> described above. But as we said, in OCaml, having two
arguments means just to have two functions that take one argument.</p>
<p>Let’s rewrite <code>add</code> to make the problem a bit more clear:</p>
<pre><code class="language-ocaml">let add x = let partial y = x + y in partial
</code></pre>
<pre><code class="language-reasonml">let add = x =&gt; {
  let partial = y =&gt; x + y;
  partial;
};
</code></pre>
<p>This will be compiled to:</p>
<pre><code class="language-javascript">function add(x) {
  return (function (y) {
    return x + y | 0;
  });
}
</code></pre>
<p>Now if we ever used our external function <code>map</code> with our <code>add</code> function by
calling <code>map arr1 arr2 add</code> it would not work as expected. JavaScript function
application does not work the same as in OCaml, so the function call in the
<code>map</code> implementation, <code>f(a[i],b[i])</code>, would be applied over the outer JavaScript
function <code>add</code>, which only takes one argument <code>x</code>, and <code>b[i]</code> would be just
discarded. The value returned from the operation would not be the addition of
the two numbers, but rather the inner anonymous callback.</p>
<p>To solve this mismatch between OCaml and JavaScript functions and their
application, Melange provides a special attribute <code>@bs</code> that can be used to annotate
external functions that need to be "uncurried".</p>
<p><span class="text-reasonml">In Reason syntax, this attribute does not need to be written explicitly, as it is deeply integrated with the Reason parser. To specify some function type as "uncurried", one just needs to add the dot character <code>.</code> to the function type. For example, <code>(. 'a, 'b) =&gt; 'c</code> instead of <code>('a, 'b) =&gt; 'c</code>.</span></p>
<p>In the example above:</p>
<pre><code class="language-ocaml">external map : 'a array -&gt; 'b array -&gt; (('a -&gt; 'b -&gt; 'c)[@bs]) -&gt; 'c array
  = &quot;map&quot;
  [@@bs.val]
</code></pre>
<pre><code class="language-reasonml">[@bs.val]
external map: (array('a), array('b), (. 'a, 'b) =&gt; 'c) =&gt; array('c) = &quot;map&quot;;
</code></pre>
<p>Here <span class="text-ocaml"><code>('a -&gt; 'b -&gt; 'c [@bs])</code></span><span class="text-reasonml"><code>(. 'a, 'b) =&gt; 'c</code></span>will be interpreted as having arity 2. In general, <span class="text-ocaml"><code>'a0 -&gt; 'a1 ...​ 'aN -&gt; 'b0 [@bs]</code> is the same as <code>'a0 -&gt; 'a1 ...​ 'aN -&gt; 'b0</code></span><span class="text-reasonml"><code>. 'a0, 'a1, ...​ 'aN =&gt; 'b0</code> is the same as <code>'a0, 'a1, ...​ 'aN =&gt; 'b0</code></span> except the former’s arity is guaranteed to be N while the latter is unknown.</p>
<p>If we try now to call <code>map</code> using <code>add</code>:</p>
<pre><code class="language-ocaml">let add x y = x + y
let _ = map [||] [||] add
</code></pre>
<pre><code class="language-reasonml">let add = (x, y) =&gt; x + y;
let _ = map([||], [||], add);
</code></pre>
<p>We will get an error:</p>
<pre><code class="language-text">let _ = map [||] [||] add
                      ^^^
This expression has type int -&gt; int -&gt; int
but an expression was expected of type ('a -&gt; 'b -&gt; 'c) Js.Fn.arity2
</code></pre>
<p>To solve this, we add <span class="text-ocaml"><code>@bs</code></span><span class="text-reasonml"><code>.</code></span> in the function definition as well:</p>
<pre><code class="language-ocaml">let add = fun [@bs] x y -&gt; x + y
</code></pre>
<pre><code class="language-reasonml">let add = (. x, y) =&gt; x + y;
</code></pre>
<p>Annotating function definitions can be quite cumbersome when writing a lot of
externals.</p>
<p>To work around the verbosity, Melange offers another attribute called
<code>bs.uncurry</code>.</p>
<p>Let’s see how we could use it in the previous example. We just need to replace
<code>bs</code> with <code>bs.uncurry</code>:</p>
<pre><code class="language-ocaml">external map :
  'a array -&gt; 'b array -&gt; (('a -&gt; 'b -&gt; 'c)[@bs.uncurry]) -&gt; 'c array = &quot;map&quot;
  [@@bs.val]
</code></pre>
<pre><code class="language-reasonml">[@bs.val]
external map:
  (array('a), array('b), [@bs.uncurry] (('a, 'b) =&gt; 'c)) =&gt; array('c) =
  &quot;map&quot;;
</code></pre>
<p>Now if we try to call <code>map</code> with a regular <code>add</code> function:</p>
<pre><code class="language-ocaml">let add x y = x + y
let _ = map [||] [||] add
</code></pre>
<pre><code class="language-reasonml">let add = (x, y) =&gt; x + y;
let _ = map([||], [||], add);
</code></pre>
<p>Everything works fine now, without having to attach any attributes to <code>add</code>.</p>
<p>The main difference between <code>bs</code> and <code>bs.uncurry</code> is that the latter only works
with externals. <code>bs.uncurry</code> is the recommended option to use for bindings,
while <code>bs</code> remains useful for those use cases where performance is crucial and
we want the JavaScript functions generated from OCaml ones to not be applied
partially.</p>
<h3 id="communicate-with-javascript-modeling-this-based-callbacks">Modeling <code>this</code>-based Callbacks</h3>
<p>Many JavaScript libraries have callbacks which rely on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this"><code>this</code>
keyword</a>,
for example:</p>
<pre><code class="language-js">x.onload = function(v) {
  console.log(this.response + v)
}
</code></pre>
<p>Inside the <code>x.onload</code> callback, <code>this</code> would be pointing to <code>x</code>. It would not be
correct to declare <code>x.onload</code> of type <code>unit -&gt; unit</code>. Instead, Melange
introduces a special attribute, <code>bs.this</code>, which allows to type <code>x</code> as this:</p>
<pre><code class="language-ocaml">type x
external x : x = &quot;x&quot; [@@bs.val]
external set_onload : x -&gt; ((x -&gt; int -&gt; unit)[@bs.this]) -&gt; unit = &quot;onload&quot;
  [@@bs.set]
external resp : x -&gt; int = &quot;response&quot; [@@bs.get]
let _ =
  set_onload x
    begin
      fun [@bs.this] o v -&gt; Js.log (resp o + v)
    end
</code></pre>
<pre><code class="language-reasonml">type x;
[@bs.val] external x: x = &quot;x&quot;;
[@bs.set]
external set_onload: (x, [@bs.this] ((x, int) =&gt; unit)) =&gt; unit = &quot;onload&quot;;
[@bs.get] external resp: x =&gt; int = &quot;response&quot;;
let _ = set_onload(x, [@bs.this] (o, v) =&gt; Js.log(resp(o) + v));
</code></pre>
<p>Which generates:</p>
<pre><code class="language-javascript">x.onload = function (v) {
  var o = this;
  console.log((o.response + v) | 0);
};
</code></pre>
<p>Note that the first argument will be reserved for <code>this</code>.</p>
<h3 id="communicate-with-javascript-wrapping-returned-nullable-values">Wrapping returned nullable values</h3>
<p>JavaScript models <code>null</code> and <code>undefined</code> differently, whereas it can be useful
to treat both as <code>'a option</code> in OCaml.</p>
<p>Melange understands the <code>bs.return</code> attribute in externals to model how
nullable return types should be wrapped at the OCaml &lt;-&gt; JavaScript boundary.
An <code>external</code> value with <code>bs.return</code> converts the return value to an <code>option</code>
type, avoiding the need for extra wrapping / unwrapping with functions such as
<code>Js.Nullable.toOption</code>.</p>
<pre><code class="language-ocaml">type element
type document
external get_by_id : document -&gt; string -&gt; element option = &quot;getElementById&quot;
  [@@bs.send] [@@bs.return nullable]

let test document =
  let elem = get_by_id document &quot;header&quot; in
  match elem with
  | None -&gt; 1
  | Some _element -&gt; 2
</code></pre>
<pre><code class="language-reasonml">type element;
type document;
[@bs.send] [@bs.return nullable]
external get_by_id: (document, string) =&gt; option(element) = &quot;getElementById&quot;;

let test = document =&gt; {
  let elem = get_by_id(document, &quot;header&quot;);
  switch (elem) {
  | None =&gt; 1
  | Some(_element) =&gt; 2
  };
};
</code></pre>
<p>Which generates:</p>
<pre><code class="language-js">function test($$document) {
  var elem = $$document.getElementById(&quot;header&quot;);
  if (elem == null) {
    return 1;
  } else {
    return 2;
  }
}
</code></pre>
<p>The <code>bs.return</code> attribute takes an attribute payload, as seen with <code>[@@bs.return
nullable]</code> above. Currently 4 directives are supported: <code>null_to_opt</code>,
<code>undefined_to_opt</code>, <code>nullable</code> and <code>identity</code>.</p>
<p><code>nullable</code> is encouraged, as it will convert from <code>null</code> and <code>undefined</code> to
<code>option</code> type.</p>
<!-- When the return type is unit: the compiler will append its return value with an OCaml unit literal to make sure it does return unit. Its main purpose is to make the user consume FFI in idiomatic OCaml code, the cost is very very small and the compiler will do smart optimizations to remove it when the returned value is not used (mostly likely). -->

<p><code>identity</code> will make sure that compiler will do nothing about the returned
value. It is rarely used, but introduced here for debugging purposes.</p>
<h2 id="communicate-with-javascript-generate-getters-setters-and-constructors">Generate getters, setters and constructors</h2>
<p>As we saw in a <a href="#communicate-with-javascript-non-shared-data-types">previous section</a>, there are some types
in Melange that compile to values that are not easy to manipulate from
JavaScript. To facilitate the communication from JavaScript code with values of
these types, Melange includes an attribute <code>bs.deriving</code> that helps generating
conversion functions, as well as functions to create values from these types. In
particular, for variants and polymorphic variants.</p>
<p>Additionally, <code>bs.deriving</code> can be used with record types, to generate setters
and getters as well as creation functions.</p>
<h3 id="communicate-with-javascript-variants">Variants</h3>
<h4 id="communicate-with-javascript-creating-values">Creating values</h4>
<p>Use <code>@bs.deriving accessors</code> on a variant type to create constructor values for
each branch.</p>
<pre><code class="language-ocaml">type action =
  | Click
  | Submit of string
  | Cancel
[@@bs.deriving accessors]
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving accessors]
type action =
  | Click
  | Submit(string)
  | Cancel;
</code></pre>
<p>Melange will generate one <code>let</code> definition for each variant tag, implemented as
follows:</p>
<ul>
<li>For variant tags with payloads, it will be a function that takes the payload
  value as a parameter.</li>
<li>For variant tags without payloads, it will be a constant with the runtime
  value of the tag.</li>
</ul>
<p>Given the <code>action</code> type definition above, annotated with <code>bs.deriving</code>, Melange
will generate something similar to the following code:</p>
<pre><code class="language-ocaml">type action =
  | Click
  | Submit of string
  | Cancel

let click = (Click : action)
let submit param = (Submit param : action)
let cancel = (Cancel : action)
</code></pre>
<pre><code class="language-reasonml">type action =
  | Click
  | Submit(string)
  | Cancel;

let click: action = Click;
let submit = (param): action =&gt; Submit(param);
let cancel: action = Cancel;
</code></pre>
<p>Which will result in the following JavaScript code after compilation:</p>
<pre><code class="language-javascript">function submit(param_0) {
  return /* Submit */{
          _0: param_0
        };
}

var click = /* Click */0;

var cancel = /* Cancel */1;
</code></pre>
<p>Note the generated definitions are lower-cased, and they can be safely used from
JavaScript code. For example, if the above JavaScript generated code was located
in a <code>generators.js</code> file, the definitions can be used like this:</p>
<pre><code class="language-javascript">const generators = require('./generators.js');

const hello = generators.submit(&quot;Hello&quot;);
const click = generators.click;
</code></pre>
<h4 id="communicate-with-javascript-conversion-functions">Conversion functions</h4>
<p>Use <code>@bs.deriving jsConverter</code> on a variant type to create converter functions
that allow to transform back and forth between JavaScript integers and Melange
variant values.</p>
<p>There are a few differences with <code>@bs.deriving accessors</code>:</p>
<ul>
<li><code>jsConverter</code> works with the <code>bs.as</code> attribute, while <code>accessors</code> does not</li>
<li><code>jsConverter</code> does not support variant tags with payload, while <code>accessors</code>
  does</li>
<li><code>jsConverter</code> generates functions to transform values back and forth, while
  <code>accessors</code> generates functions to create values</li>
</ul>
<p>Let’s see a version of the previous example, adapted to work with <code>jsConverter</code>
given the constraints above:</p>
<pre><code class="language-ocaml">type action =
  | Click
  | Submit [@bs.as 3]
  | Cancel
[@@bs.deriving jsConverter]
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving jsConverter]
type action =
  | Click
  | [@bs.as 3] Submit
  | Cancel;
</code></pre>
<p>This will generate a couple of functions with the following types:</p>
<pre><code class="language-ocaml">val actionToJs : action -&gt; int

val actionFromJs : int -&gt; action option
</code></pre>
<pre><code class="language-reasonml">external actionToJs: action =&gt; int = ;

external actionFromJs: int =&gt; option(action) = ;
</code></pre>
<p><code>actionToJs</code> returns integers from values of <code>action</code> type. It will start with 0
for <code>Click</code>, 3 for <code>Submit</code> (because it was annotated with <code>bs.as</code>), and then 4
for <code>Cancel</code>, in the same way that we described when <a href="#communicate-with-javascript-using-polymorphic-variants-to-bind-to-enums">using <code>bs.int</code> with
polymorphic variants</a>.</p>
<p><code>actionFromJs</code> returns a value of type <code>option</code>, because not every integer can
be converted into a variant tag of the <code>action</code> type.</p>
<h5 id="communicate-with-javascript-hide-runtime-types">Hide runtime types</h5>
<p>For extra type safety, we can hide the runtime representation of variants
(<code>int</code>) from the generated functions, by using <code>{ jsConverter = newType }</code>
payload with <code>@bs.deriving</code>:</p>
<pre><code class="language-ocaml">type action =
  | Click
  | Submit [@bs.as 3]
  | Cancel
[@@bs.deriving { jsConverter = newType }]
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving {jsConverter: newType}]
type action =
  | Click
  | [@bs.as 3] Submit
  | Cancel;
</code></pre>
<p>This feature relies on <a href="#communicate-with-javascript-abstract-types">abstract types</a> to hide the JavaScript
runtime representation. It will generate functions with the following types:</p>
<pre><code class="language-ocaml">val actionToJs : action -&gt; abs_action

val actionFromJs : abs_action -&gt; action
</code></pre>
<pre><code class="language-reasonml">external actionToJs: action =&gt; abs_action = ;

external actionFromJs: abs_action =&gt; action = ;
</code></pre>
<p>In the case of <code>actionFromJs</code>, the return value, unlike the previous case, is
not an option type. This is an example of "correct by construction": the only
way to create an <code>abs_action</code> is by calling the <code>actionToJs</code> function.</p>
<h3 id="communicate-with-javascript-polymorphic-variants">Polymorphic variants</h3>
<p>The <code>@bs.deriving jsConverter</code> attribute is applicable to polymorphic variants
as well.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> Similarly to variants, the <code>@bs.deriving jsConverter</code> attribute
cannot be used when the polymorphic variant tags have payloads. Refer to the
<a href="#communicate-with-javascript-data-types-and-runtime-representation">section on runtime representation</a> to
learn more about how polymorphic variants are represented in JavaScript.</p>
</blockquote>
<p>Let’s see an example:</p>
<pre><code class="language-ocaml">type action =
  [ `Click
  | `Submit [@bs.as &quot;submit&quot;]
  | `Cancel
  ]
[@@bs.deriving jsConverter]
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving jsConverter]
type action = [ | `Click | [@bs.as &quot;submit&quot;] `Submit | `Cancel];
</code></pre>
<p>Akin to the variant example, the following two functions will be generated:</p>
<pre><code class="language-ocaml">val actionToJs : action -&gt; string

val actionFromJs : string -&gt; action option
</code></pre>
<pre><code class="language-reasonml">external actionToJs: action =&gt; string = ;

external actionFromJs: string =&gt; option(action) = ;
</code></pre>
<p>The <code>{ jsConverter = newType }</code> payload can also be used with polymorphic
variants.</p>
<h3 id="communicate-with-javascript-records_1">Records</h3>
<h4 id="communicate-with-javascript-accessing-fields">Accessing fields</h4>
<p>Use <code>@bs.deriving accessors</code> on a record type to create accessor functions for
its record field names.</p>
<pre><code class="language-ocaml">type pet = { name : string } [@@bs.deriving accessors]

let pets = [| { name = &quot;Brutus&quot; }; { name = &quot;Mochi&quot; } |]

let () = pets |. Belt.Array.map name |. Js.Array2.joinWith &quot;&amp;&quot; |. Js.log
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving accessors]
type pet = {name: string};

let pets = [|{name: &quot;Brutus&quot;}, {name: &quot;Mochi&quot;}|];

let () = pets-&gt;(Belt.Array.map(name))-&gt;(Js.Array2.joinWith(&quot;&amp;&quot;))-&gt;Js.log;
</code></pre>
<p>Melange will generate a function for each field defined in the record. In this
case, a function <code>name</code> that allows to get that field from any record of type
<code>pet</code>:</p>
<pre><code class="language-ocaml">let name (param : pet) = param.name
</code></pre>
<pre><code class="language-reasonml">let name = (param: pet) =&gt; param.name;
</code></pre>
<p>Considering all the above, the produced JavaScript will be:</p>
<pre><code class="language-js">function name(param) {
  return param.name;
}

var pets = [
  {
    name: &quot;Brutus&quot;
  },
  {
    name: &quot;Mochi&quot;
  }
];

console.log(Belt_Array.map(pets, name).join(&quot;&amp;&quot;));
</code></pre>
<h4 id="communicate-with-javascript-convert-records-into-abstract-types">Convert records into abstract types</h4>
<p>When binding to JavaScript objects, it is generally recommended to use records
since Melange precisely uses objects as their runtime representation. This
approach was discussed in the section about <a href="#communicate-with-javascript-bind-to-javascript-objects">binding to JavaScript
objects</a>.</p>
<p>But there’s a specific case where records may not be enough: when we want to
emit a JavaScript object where some of the keys might be present or absent.</p>
<p>For instance, consider the following record:</p>
<pre><code class="language-ocaml">type person = {
  name : string;
  age : int option;
}
</code></pre>
<pre><code class="language-reasonml">type person = {
  name: string,
  age: option(int),
};
</code></pre>
<p>An example of this use-case would be expecting <code>{ name = "John"; age = None }</code>
to generate a JavaScript such as <code>{name: "Carl"}</code>, where the <code>age</code> key doesn’t
appear.</p>
<p>The <code>@bs.deriving abstract</code> attribute exists to solve this problem. When present
in a record type, <code>@bs.deriving abstract</code> makes the record definition abstract
and generates the following functions instead:</p>
<ul>
<li>A constructor function for creating values of the type</li>
<li>Getters and setters for accessing the record fields</li>
</ul>
<p><code>@bs.deriving abstract</code> effectively models a record-shaped JavaScript object
exclusively through a set of (generated) functions derived from attribute
annotations on the OCaml type definition.</p>
<p>Let’s see an example. Considering this Melange code:</p>
<pre><code class="language-ocaml">type person = {
  name : string;
  age : int; [@bs.optional]
}
[@@bs.deriving abstract]
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving abstract]
type person = {
  name: string,
  [@bs.optional]
  age: int,
};
</code></pre>
<p>Melange will make the <code>person</code> type abstract and generate constructor, getter
and setter functions. In our example, the OCaml signature would look like this
after preprocessing:</p>
<pre><code class="language-ocaml">type person

val person : name:string -&gt; ?age:int -&gt; unit -&gt; person

val nameGet : person -&gt; string

val ageGet : person -&gt; int option
</code></pre>
<pre><code class="language-reasonml">type person;

external person: (~name: string, ~age: int=?, unit) =&gt; person = ;

external nameGet: person =&gt; string = ;

external ageGet: person =&gt; option(int) = ;
</code></pre>
<p>The <code>person</code> function can be used to create values of <code>person</code>. It is the only
possible way to create values of this type, since Melange makes it abstract.
Using literals like <code>{ name = "Alice"; age = None }</code> directly doesn’t type
check.</p>
<p>Here is an example of how we can use it:</p>
<pre><code class="language-ocaml">let alice = person ~name:&quot;Alice&quot; ~age:20 ()
let bob = person ~name:&quot;Bob&quot; ()
</code></pre>
<pre><code class="language-reasonml">let alice = person(~name=&quot;Alice&quot;, ~age=20, ());
let bob = person(~name=&quot;Bob&quot;, ());
</code></pre>
<p>This will generate the following JavaScript code. Note how there is no
JavaScript runtime overhead:</p>
<pre><code class="language-js">var alice = {
  name: &quot;Alice&quot;,
  age: 20
};

var bob = {
  name: &quot;Bob&quot;
};
</code></pre>
<p>The <code>person</code> function uses labeled arguments to represent record fields. Because
there is an optional argument <code>age</code>, it takes a last argument of type <code>unit</code>.
This non-labeled argument allows to omit the optional argument on function
application. Further details about optional labeled arguments can be found in
<a href="https://v2.ocaml.org/manual/lablexamples.html#s:optional-arguments">the corresponding section of the OCaml
manual</a>.</p>
<p>The functions <code>nameGet</code> and <code>ageGet</code> are accessors for each record field:</p>
<pre><code class="language-ocaml">let twenty = ageGet alice

let bob = nameGet bob
</code></pre>
<pre><code class="language-reasonml">let twenty = ageGet(alice);

let bob = nameGet(bob);
</code></pre>
<p>This generates:</p>
<pre><code class="language-javascript">var twenty = alice.age;

var bob = bob.name;
</code></pre>
<p>The functions are named by appending <code>Get</code> to the field names of the record to
prevent potential clashes with other values within the module. If shorter names
are preferred for the getter functions, there is an alternate <code>{ abstract =
light }</code> payload that can be passed to <code>bs.deriving</code>:</p>
<pre><code class="language-ocaml">type person = {
  name : string;
  age : int;
}
[@@bs.deriving { abstract = light }]

let alice = person ~name:&quot;Alice&quot; ~age:20
let aliceName = name alice
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving {abstract: light}]
type person = {
  name: string,
  age: int,
};

let alice = person(~name=&quot;Alice&quot;, ~age=20);
let aliceName = name(alice);
</code></pre>
<p>Which generates:</p>
<pre><code class="language-javascript">var alice = {
  name: &quot;Alice&quot;,
  age: 20
};

var aliceName = alice.name;
</code></pre>
<p>In this example, the getter functions share the same names as the object fields.
Another distinction from the previous example is that the <code>person</code> constructor
function no longer requires the final <code>unit</code> argument since we have excluded the
optional field in this case.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> The <code>bs.as</code> attribute can still be applied to record fields when
the record type is annotated with <code>bs.deriving</code>, allowing for the renaming of
fields in the resulting JavaScript objects, as demonstrated in the section
about <a href="#communicate-with-javascript-objects-with-static-shape-record-like">binding to objects with static
shape</a>. However, the option to pass
indices to the <code>bs.as</code> decorator (like <code>[@bs.as "0"]</code>) to change the runtime
representation to an array is not available when using <code>bs.deriving</code>.</p>
</blockquote>
<h5 id="communicate-with-javascript-compatibility-with-ocaml-features">Compatibility with OCaml features</h5>
<p>The <code>@bs.deriving abstract</code> attribute and its lightweight variant can be used
with <a href="https://v2.ocaml.org/manual/coreexamples.html#s:imperative-features">mutable
fields</a> and
<a href="https://v2.ocaml.org/manual/privatetypes.html">private types</a>, which are
features inherited by Melange from OCaml.</p>
<p>When the record type has mutable fields, Melange will generate setter functions
for them. For example:</p>
<pre><code class="language-ocaml">type person = {
  name : string;
  mutable age : int;
}
[@@bs.deriving abstract]

let alice = person ~name:&quot;Alice&quot; ~age:20

let () = ageSet alice 21
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving abstract]
type person = {
  name: string,
  mutable age: int,
};

let alice = person(~name=&quot;Alice&quot;, ~age=20);

let () = ageSet(alice, 21);
</code></pre>
<p>This will generate:</p>
<pre><code class="language-javascript">var alice = {
  name: &quot;Alice&quot;,
  age: 20
};

alice.age = 21;
</code></pre>
<p>If the <code>mutable</code> keyword is omitted from the interface file, Melange will not
include the setter function in the module signature, preventing other modules
from mutating any values from the type.</p>
<p>Private types can be used to prevent Melange from creating the constructor
function. For example, if we define <code>person</code> type as private:</p>
<pre><code class="language-ocaml">type person = private {
  name : string;
  age : int;
}
[@@bs.deriving abstract]
</code></pre>
<pre><code class="language-reasonml">[@bs.deriving abstract]
type person =
  pri {
    name: string,
    age: int,
  };
</code></pre>
<p>The accessors <code>nameGet</code> and <code>ageGet</code> will still be generated, but not the
constructor <code>person</code>. This is useful when binding to JavaScript objects while
preventing any Melange code from creating values of such type.</p>
<h2 id="communicate-with-javascript-use-melange-code-from-javascript">Use Melange code from JavaScript</h2>
<p>As mentioned in the <a href="#build-system-commonjs-or-es6-modules">build system
section</a>, Melange allows to produce
both CommonJS and ES6 modules. In both cases, using Melange-generated JavaScript
code from any hand-written JavaScript file works as expected.</p>
<p>The following definition:</p>
<pre><code class="language-ocaml">let print name = &quot;Hello&quot; ^ name
</code></pre>
<pre><code class="language-reasonml">let print = name =&gt; &quot;Hello&quot; ++ name;
</code></pre>
<p>Will generate this JavaScript code, when using CommonJS (the default):</p>
<pre><code class="language-js">function print(name) {
  return &quot;Hello&quot; + name;
}

exports.print = print;
</code></pre>
<p>When using ES6 (through the <code>(module_systems es6)</code> field in <code>melange.emit</code>) this
code will be generated:</p>
<pre><code class="language-js">function print(name) {
  return &quot;Hello&quot; + name;
}

export {
  print ,
}
</code></pre>
<p>So one can use either <code>require</code> or <code>import</code> (depending on the module system of
choice) to import the <code>print</code> value in a JavaScript file.</p>
<h3 id="communicate-with-javascript-default-es6-values">Default ES6 values</h3>
<p>One special case occur when working with JavaScript imports in ES6 modules that
look like this:</p>
<pre><code class="language-js">import ten from 'numbers.js';
</code></pre>
<p>This import expects <code>numbers.js</code> to have a default export, like:</p>
<pre><code class="language-js">export default ten = 10;
</code></pre>
<p>To emulate this kind of exports from Melange, one just needs to define a
<code>default</code> value.</p>
<p>For example, in a file named <code class="text-ocaml">numbers.ml</code><code
class="text-reasonml">numbers.re</code>:</p>
<pre><code class="language-ocaml">let default = 10
</code></pre>
<pre><code class="language-reasonml">let default = 10;
</code></pre>
<p>That way, Melange will set the value on the <code>default</code> export so it can be
consumed as default import on the JavaScript side.</p></section><section class="print-page" id="melange-for-x-developers"><h1 id="melange-for-x-developers-melange-for-x-developers">Melange for X developers</h1>
<p>If you are familiar with other languages, here you will find sections that
compare Melange to a few of them, so it might help you get up and running
quickly. In particular:</p>
<ul>
<li>JavaScript</li>
<li>TypeScript</li>
<li>Js_of_ocaml</li>
<li>ReScript</li>
</ul>
<h2 id="melange-for-x-developers-for-javascript-developers">For JavaScript developers</h2>
<p>Melange is a thin layer over <a href="https://ocaml.org/">OCaml</a>, a strongly typed
functional programming language with an emphasis on expressiveness and safety.
Melange’s goal is to help web developers build and maintain JavaScript
applications safely, thanks to OCaml expressive and powerful type system.</p>
<p>Melange allows to build applications using either OCaml syntax or Reason syntax.
If you don’t know which one to choose, we recommend
<a href="https://reasonml.github.io/en/">Reason</a>, as it has been designed with
JavaScript developers in mind.</p>
<p>Reason syntax has first-class support for
<a href="https://reasonml.github.io/docs/en/jsx">JSX</a>, and there are bindings like
<a href="https://github.com/reasonml/reason-react/">ReasonReact</a> that build on top of
that functionality to provide a great developer experience.</p>
<p>Another advantage is that programs written using Reason syntax are fully
compatible with those written in OCaml syntax.</p>
<p>Here is the cheat sheet with some equivalents between JavaScript and Reason
syntaxes:</p>
<h3 id="melange-for-x-developers-variable">Variable</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const x = 5;</code></td>
<td><code>let x = 5;</code></td>
</tr>
<tr>
<td><code>var x = y;</code></td>
<td>No equivalent</td>
</tr>
<tr>
<td><code>let x = 5; x = x + 1;</code></td>
<td><code>let x = ref(5); x := x^ + 1;</code></td>
</tr>
</tbody>
</table>
<h3 id="melange-for-x-developers-string-character">String &amp; Character</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"Hello world!"</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>'Hello world!'</code></td>
<td>Strings must use <code>"</code></td>
</tr>
<tr>
<td>Characters are strings</td>
<td><code>'a'</code></td>
</tr>
<tr>
<td><code>"hello " + "world"</code></td>
<td><code>"hello " ++ "world"</code></td>
</tr>
</tbody>
</table>
<h3 id="melange-for-x-developers-boolean">Boolean</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true</code>, <code>false</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>!true</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>||</code>, <code>&amp;&amp;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>a === b</code>, <code>a !== b</code></td>
<td>Same</td>
</tr>
<tr>
<td>No deep equality (recursive compare)</td>
<td><code>a == b</code>, <code>a != b</code></td>
</tr>
<tr>
<td><code>a == b</code></td>
<td>No equality with implicit casting</td>
</tr>
</tbody>
</table>
<h3 id="melange-for-x-developers-number">Number</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3</code></td>
<td>Same *</td>
</tr>
<tr>
<td><code>3.1415</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>3 + 4</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>3.0 + 4.5</code></td>
<td><code>3.0 +. 4.5</code></td>
</tr>
<tr>
<td><code>5 % 3</code></td>
<td><code>5 mod 3</code></td>
</tr>
</tbody>
</table>
<p>* JavaScript has no distinction between integer and float.</p>
<h3 id="melange-for-x-developers-objectrecord">Object/Record</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td>no static types</td>
<td><code>type point = {x: int, mutable y: int}</code></td>
</tr>
<tr>
<td><code>{x: 30, y: 20}</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>point.x</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>point.y = 30;</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>{...point, x: 30}</code></td>
<td>Same</td>
</tr>
</tbody>
</table>
<h3 id="melange-for-x-developers-array">Array</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[1, 2, 3]</code></td>
<td><code>[</td>
</tr>
<tr>
<td><code>myArray[1] = 10</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>[1, "Bob", true]</code> *</td>
<td><code>(1, "Bob", true)</code></td>
</tr>
<tr>
<td>No immutable list</td>
<td><code>[1, 2, 3]</code></td>
</tr>
</tbody>
</table>
<p>* Tuples can be simulated in JavaScript with arrays, as JavaScript arrays can
contain multiple types of elements.</p>
<h3 id="melange-for-x-developers-null">Null</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>null</code>, <code>undefined</code></td>
<td><code>None</code> *</td>
</tr>
</tbody>
</table>
<p>* There are no nulls, nor null bugs in OCaml. But it does have <a href="https://reasonml.github.io/docs/en/option">an option
type</a> for when you actually need
nullability.</p>
<h3 id="melange-for-x-developers-function">Function</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arg =&gt; retVal</code></td>
<td><code>(arg) =&gt; retVal</code></td>
</tr>
<tr>
<td><code>function named(arg) {...}</code></td>
<td><code>let named = (arg) =&gt; ...</code></td>
</tr>
<tr>
<td><code>const f = function(arg) {...}</code></td>
<td><code>let f = (arg) =&gt; ...</code></td>
</tr>
<tr>
<td><code>add(4, add(5, 6))</code></td>
<td>Same</td>
</tr>
</tbody>
</table>
<h4 id="melange-for-x-developers-blocks">Blocks</h4>
<table>
  <thead>
    <tr>
      <th>JavaScript</th>
      <th>OCaml (Reason syntax)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
  <pre><code>const myFun = (x, y) => {
  const doubleX = x + x;
  const doubleY = y + y;
  return doubleX + doubleY
};</code></pre>
      </td>
      <td>
  <pre><code>let myFun = (x, y) => {
  let doubleX = x + x;
  let doubleY = y + y;
  doubleX + doubleY
};</code></pre>
      </td>
    </tr>
  </tbody>
</table>

<h4 id="melange-for-x-developers-currying">Currying</h4>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>let add = a =&gt; b =&gt; a + b</code></td>
<td><code>let add = (a, b) =&gt; a + b</code></td>
</tr>
</tbody>
</table>
<p>Both JavaScript and OCaml support currying, but OCaml currying is <strong>built-in and
optimized to avoid intermediate function allocation and calls</strong>, whenever
possible.</p>
<h3 id="melange-for-x-developers-if-else">If-else</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>if (a) {b} else {c}</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>a ? b : c</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>switch</code></td>
<td><code>switch</code> but <a href="https://reasonml.github.io/docs/en/pattern-matching">with pattern matching</a></td>
</tr>
</tbody>
</table>
<h3 id="melange-for-x-developers-destructuring">Destructuring</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const {a, b} = data</code></td>
<td><code>let {a, b} = data</code></td>
</tr>
<tr>
<td><code>const [a, b] = data</code></td>
<td><code>let [|a, b|] = data</code> *</td>
</tr>
<tr>
<td><code>const {a: aa, b: bb} = data</code></td>
<td><code>let {a: aa, b: bb} = data</code></td>
</tr>
</tbody>
</table>
<p>* This will cause the compiler to warn that not all cases are handled, because
<code>data</code> could be of length other than 2. Better switch to pattern-matching
instead.</p>
<h3 id="melange-for-x-developers-loop">Loop</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>for (let i = 0; i &lt;= 10; i++) {...}</code></td>
<td><code>for (i in 0 to 10) {...}</code></td>
</tr>
<tr>
<td><code>for (let i = 10; i &gt;= 0; i--) {...}</code></td>
<td><code>for (i in 10 downto 0) {...}</code></td>
</tr>
<tr>
<td><code>while (true) {...}</code></td>
<td>Same</td>
</tr>
</tbody>
</table>
<h3 id="melange-for-x-developers-jsx">JSX</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;Foo bar=1 baz="hi" onClick={bla} /&gt;</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>&lt;Foo bar=bar /&gt;</code></td>
<td><code>&lt;Foo bar /&gt;</code> *</td>
</tr>
<tr>
<td><code>&lt;input checked /&gt;</code></td>
<td><code>&lt;input checked=true /&gt;</code></td>
</tr>
<tr>
<td>No children spread</td>
<td><code>&lt;Foo&gt;...children&lt;/Foo&gt;</code></td>
</tr>
</tbody>
</table>
<p>* Note the argument punning when creating elements.</p>
<h3 id="melange-for-x-developers-exception">Exception</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>throw new SomeError(...)</code></td>
<td><code>raise(SomeError(...))</code></td>
</tr>
<tr>
<td><code>try {a} catch (Err) {...} finally {...}</code></td>
<td><code>try (a) { | Err => ...}</code> *</td>
</tr>
</tbody>
</table>
<p>* No finally.</p>
<h3 id="melange-for-x-developers-blocks_1">Blocks</h3>
<p>In OCaml, "sequence expressions" are created with <code>{}</code> and evaluate to their
last statement. In JavaScript, this can be simulated via an immediately-invoked
function expression (since function bodies have their own local scope).</p>
<table>
  <thead>
    <tr>
      <th>JavaScript</th>
      <th>OCaml (Reason syntax)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
  <pre><code>let res = (function() {
  const x = 23;
  const y = 34;
  return x + y;
})();</code></pre>
      </td>
      <td>
  <pre><code>let res = {
  let x = 23;
  let y = 34;
  x + y
};</code></pre>
      </td>
    </tr>
  </tbody>
</table>

<h3 id="melange-for-x-developers-comments">Comments</h3>
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/* Comment */</code></td>
<td>Same</td>
</tr>
<tr>
<td><code>// Line comment</code></td>
<td>Same</td>
</tr>
</tbody>
</table>
<h2 id="melange-for-x-developers-for-typescript-developers">For TypeScript developers</h2>
<p>The approach to typing applications using Melange differs somewhat from
TypeScript. TypeScript has been designed with a focus on compatibility with
JavaScript, as outlined in its <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals">design
goals</a>. On
the other hand, Melange is built upon OCaml, a compiler known for its emphasis
on expressiveness and safety.</p>
<p>These are some of the differences between both.</p>
<h3 id="melange-for-x-developers-type-inference">Type inference</h3>
<p>In TypeScript, the types for the input parameters have to be defined:</p>
<pre><code class="language-javascript">let sum = (a: number, b: number) =&gt; a + b;
</code></pre>
<p>OCaml can infer types without barely any type annotations. For example, we can
define a function that adds two numbers as:</p>
<pre><code class="language-ocaml">let add x y = x + y
</code></pre>
<pre><code class="language-reasonml">let add = (x, y) =&gt; x + y;
</code></pre>
<h3 id="melange-for-x-developers-algebraic-data-types">Algebraic data types</h3>
<p>It is not possible to build an ADT in TypeScript the same way as in OCaml.
<a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions">Discriminated
unions</a>
would be the closest analog to them, with libraries like
<a href="https://github.com/gvergnaud/ts-pattern">ts-pattern</a> as an alternative to the
lack of support for pattern matching in the language.</p>
<p>In OCaml, <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">algebraic data types
(ADTs)</a>
are a commonly used functionality of the language. They allow you to build your
own types from small blocks. And with <a href="https://ocaml.org/docs/data-types">pattern
matching</a>, it is easy to access this data.</p>
<h3 id="melange-for-x-developers-nominal-typing">Nominal typing</h3>
<p>In TypeScript, all typing is structural. This means that it is hard sometimes to
establish a boundary or separation between two types that have the same
implementation. For these cases, nominal typing can be emulated using tags:</p>
<pre><code class="language-js">type Email = string &amp; { readonly __tag: unique symbol };
type City = string &amp; { readonly __tag: unique symbol };
</code></pre>
<p>In OCaml, nominal typing is fully supported. Some of the core language types
like <a href="https://v2.ocaml.org/manual/coreexamples.html#s%3Atut-recvariants">records and
variants</a> are
nominal. This means that even if you declare exactly the same type twice,
functions that operate on values from one type will not be compatible with the
other type.</p>
<p>There is also structural typing, used for OCaml
<a href="https://v2.ocaml.org/manual/objectexamples.html">objects</a> and <a href="https://v2.ocaml.org/manual/polyvariant.html">polymorphic
variants</a>.</p>
<h3 id="melange-for-x-developers-immutability">Immutability</h3>
<p>TypeScript has two base primitives to work with immutability: <code>const</code> and
<code>readonly</code>.</p>
<p>The first one is used to prevent variable reference change.</p>
<pre><code class="language-js">const a = 1;
a = 2; // Error: Cannot assign to 'a' because it is a constant.
</code></pre>
<p>And the second one is used to make properties immutable.</p>
<pre><code class="language-js">type A = {
  readonly x: number;
}
const a: A = { x: 1 };
a.x = 12; // Error: Cannot assign to 'x' because it is a read-only property.
</code></pre>
<p>Nevertheless, there are some problems here. <code>const</code> and <code>readonly</code> only block
reference changes but do nothing about values. With <code>const a = [1, 2, 3]</code> or
<code>readonly x: number[]</code>, you can still change the contents of an array.</p>
<p>OCaml provides data types with immutability in mind, like lists, records, or
maps.</p>
<h3 id="melange-for-x-developers-strictness-and-soundness">Strictness and soundness</h3>
<p>In TypeScript, you have the flexibility to use types like <code>any</code> or other
expansive types such as <code>Function</code>. However, TypeScript provides the <code>strict</code>
option in the <code>tsconfig.json</code> file to mitigate the usage of these less type-safe
constructs. On the other hand, OCaml does not offer a similar option to enable
or disable strictness. In OCaml, the language itself promotes type safety
without the need for explicit configuration options to enforce stricter
behavior.</p>
<p>TypeScript, as mentioned in <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness">its
handbook</a>,
may sacrifice soundness for practicality when needed. In contrast, OCaml
implementations provide unsound methods like <a href="#communicate-with-javascript-special-identity-external">the <code>identity</code>
primitive</a> but they
are generally discouraged and rarely used. The OCaml community places a strong
emphasis on maintaining soundness and prefers safer alternatives to ensure code
correctness.</p>
<h3 id="melange-for-x-developers-cheatsheet">Cheatsheet</h3>
<p>The following are some conversions between TypeScript and OCaml idioms, in the
OCaml side we use Reason syntax for familiarity, as mentioned in <a href="#melange-for-x-developers-for-javascript-developers">section for
JavaScript developers</a>.</p>
<h4 id="melange-for-x-developers-type-aliases">Type aliases</h4>
<table>
<thead>
<tr>
<th>TypeScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type Email = string;</code></td>
<td><code>type email = string;</code></td>
</tr>
</tbody>
</table>
<h4 id="melange-for-x-developers-abstract-types">Abstract types</h4>
<table>
  <thead>
    <tr>
      <th>TypeScript</th>
      <th>OCaml (Reason syntax)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre><code>type Email = string &
{ readonly __tag: unique symbol };</code></pre>
      </td>
      <td>
        <pre><code>/* in interface `rei` file */
type email;
</code></pre>
        <pre><code>/* in implementation `re` file */
type email = string;</code></pre> </td> </tr>
  </tbody>
</table>

<h4 id="melange-for-x-developers-union-types-variants">Union types / Variants</h4>
<table>
  <thead>
    <tr>
      <th>TypeScript</th>
      <th>OCaml (Reason syntax)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre><code>type Result = "Error" | "Success";
</code></pre>
      </td>
      <td>
        <pre><code>type result = Error | Success</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <pre><code>type Result =
| { type: "Error"; message: string }
| { type: "Success"; n: number };
</code></pre>
      </td>
      <td>
        <pre><code>type result =
| Error(string)
| Success(int)</code></pre>
      </td>
    </tr>
  </tbody>
</table>

<h4 id="melange-for-x-developers-immutability_1">Immutability</h4>
<table>
  <thead>
    <tr>
      <th>TypeScript</th>
      <th>OCaml (Reason syntax)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre><code>const a = 1;
type A = { readonly x: number };
type ImmutableA = Readonly<A>;
const arr: ReadonlyArray<number> = [1, 2, 3];
type A = { readonly [x: string]: number };
</code></pre>
      </td>
      <td>Enabled by default</td>
    </tr>
  </tbody>
</table>

<h4 id="melange-for-x-developers-currying_1">Currying</h4>
<table>
  <thead>
    <tr>
      <th>TypeScript</th>
      <th>OCaml (Reason syntax)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre><code>type addT = (_: number) => (_: number) => number;
const add: addT = (l) => (r) => l + r;
add(5)(3);
</code></pre>
      </td>
      <td>Enabled by default</td>
    </tr>
  </tbody>
</table>

<h4 id="melange-for-x-developers-parametric-polymorphism">Parametric polymorphism</h4>
<table>
<thead>
<tr>
<th>TypeScript</th>
<th>OCaml (Reason syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type length = &lt;T&gt;(_: T[]) =&gt; number;</code></td>
<td><code>let length: list('a) =&gt; int;</code></td>
</tr>
</tbody>
</table>
<h2 id="melange-for-x-developers-for-js_of_ocaml-developers">For Js_of_ocaml developers</h2>
<p>There are many similarities between Js_of_ocaml and Melange:</p>
<ul>
<li>Both compile OCaml to JavaScript.</li>
<li>Both are available as libraries in the official opam repository.</li>
<li>Both have access to the OCaml platform developer toolchain: the OCaml LSP
  server, Merlin, and the different editor extensions.</li>
<li>Both have implemented extensive integration with Dune.</li>
</ul>
<p>However, while Js_of_ocaml transforms OCaml bytecode into JavaScript, Melange
starts the conversion process earlier in the compiler pipeline, as it transforms
the compiler lambda representation into JavaScript.</p>
<p>Js_of_ocaml is a project with years of development and evolution behind it,
while Melange <a href="#rationale-a-bit-of-history">appearance</a> is relatively recent
in comparison.</p>
<p>These aspects translate into different trade-offs. Compared to Js_of_ocaml:</p>
<ul>
<li>Melange can be installed in an OCaml 5 opam switch, but the editor integration
  is not working at the time (May 2023).</li>
<li>Similarly, any OCaml 5 features like effects are currently unsupported in
  Melange.</li>
<li>Js_of_ocaml allows to compile the compiler itself and create "toplevels",
  which is not possible with Melange.</li>
<li><code>Marshal</code> is well supported in Js_of_ocaml, while Melange does not support
  it.</li>
<li>Libraries like <code>Unix</code> or <code>Str</code> are available in Js_of_ocaml but not in
  Melange.</li>
<li>Js_of_ocaml supports sourcemaps, which Melange do not support yet (as of May
  2023).</li>
</ul>
<p>On the upside, in Melange:</p>
<ul>
<li>Consuming existing JavaScript packages might be a bit easier in Melange,
  thanks to its compilation model and the extensive availability of mechanisms
  to bind to JavaScript code.</li>
<li>There is great support for some of the most used JavaScript libraries like
  <a href="https://github.com/reasonml/reason-react/">ReactJS</a> or GraphQL clients.</li>
<li>The generated JavaScript bundles are generally smaller.</li>
<li>The generated JavaScript code is generally more readable.</li>
<li>Straight-forward integration with modern JavaScript tooling like Webpack,
  NextJS, etc. This is possible thanks to the 1 module \&lt;-> 1 JavaScript file
  compilation model.</li>
</ul>
<h2 id="melange-for-x-developers-for-rescript-developers">For ReScript developers</h2>
<p>As a project that shares a common ancestry with ReScript, Melange inherits a lot
of its characteristics:</p>
<ul>
<li>The compilation model involves compiling a single module into a single
  JavaScript file.</li>
<li>The libraries provided by ReScript (Belt and Js) are available in Melange too.</li>
<li>The mechanisms provided for <a href="#communicate-with-javascript">communicating with JavaScript
  code</a> are mostly the same.</li>
</ul>
<p>However, one of Melange’s goals is to maximize compatibility with the OCaml
ecosystem. This goal translates into fundamental differences in how Melange and
ReScript function from the perspective of both library authors and users.</p>
<h3 id="melange-for-x-developers-package-manager">Package manager</h3>
<p>ReScript projects rely exclusively on npm for all packages they depend on.
Melange projects, on the other hand, will use opam for native packages, and npm
for JavaScript ones. Melange package management is explained in detail in <a href="#package-management">the
dedicated section</a>.</p>
<h3 id="melange-for-x-developers-build-system">Build system</h3>
<p>ReScript has its own build system, originally based on Ninja.</p>
<p>Melange defers to <a href="https://dune.build/">Dune</a> for build orchestration, as it is
explained in detail in <a href="#build-system">the corresponding section</a>. By
integrating with Dune, Melange can benefit from the multiple features provided.
One of the most useful features is first-class supports for monorepos. But there
are multiple others, like virtual libraries, watch mode, or integrations with
tools like <a href="https://github.com/ocaml/odoc">odoc</a>.</p>
<p>The divergences caused by the different build systems have a lot of implications
and nuances that might be too complex to explain in this section, but some of
the specific details have been discussed in <a href="https://discuss.ocaml.org/t/ahrefs-is-now-built-with-melange/12107/3">the OCaml
forum</a>.</p>
<h3 id="melange-for-x-developers-source-based-vs-pre-built-distribution">Source-based vs pre-built distribution</h3>
<p>While with ReScript every dependency can be downloaded with just npm, Melange
projects will have to use opam and npm. This is a trade-off: on one hand, some
Melange projects might need to include two package configuration files. But on
the other hand they can benefit from opam’s source-based package distribution
model for things like PPXs, linters, or any other OCaml tooling.</p>
<p>In comparison, consuming any OCaml tool in ReScript is more challenging. Since
ReScript lacks a native toolchain, authors of the tools need to provide
pre-built binaries for all the supported systems and architectures. This poses
difficulties for the authors in terms of maintenance, and it can also result in
certain users being unable to access these tools if their systems or
architectures are not included in the pre-built binaries.</p>
<h3 id="melange-for-x-developers-ocaml-compiler-version">OCaml compiler version</h3>
<p>ReScript is compatible with the 4.06 version of the OCaml compiler, while
Melange is compatible with the version 4.14 (as of May 2023).</p>
<p>The <a href="#melange-for-x-developers-todo-fix-me.md">Melange roadmap</a> includes a milestone to upgrade to the
latest version of the compiler to the 5.x release line.</p>
<h3 id="melange-for-x-developers-editor-integration">Editor integration</h3>
<p>Melange is fully compatible with the <a href="https://ocaml.org/docs/up-and-running#configuring-your-editor">OCaml platform editor
tools</a>, which
makes possible to work in projects that include OCaml and Melange code using the
same editor configuration.</p>
<p>ReScript has its <a href="https://rescript-lang.org/docs/manual/latest/editor-plugins">own set of editor
plugins</a>.</p>
<h3 id="melange-for-x-developers-feature-choice-and-alignment-with-ocaml">Feature choice and alignment with OCaml</h3>
<p>ReScript’s goal is to model the language to bring it as close to JavaScript as
possible. From the website <a href="https://rescript-lang.org/docs/manual/latest/introduction">introduction
section</a>:</p>
<blockquote>
<p>ReScript looks like JS, acts like JS, and compiles to the highest quality of
clean, readable and performant JS (...)</p>
</blockquote>
<p>New features added to ReScript might close its alignment with JavaScript, but
some of these features can lead to greater divergence from OCaml. As Melange
prioritizes compatibility with OCaml, it avoids incorporating those features
that widen the gap between the two.</p>
<p>Here is a non-exhaustive list of the features that ReScript has added and will
not be supported in Melange:</p>
<ul>
<li>The <code>async</code> / <code>await</code> syntax: similar functionality can be achieved in Melange
  through the usage of <a href="https://v2.ocaml.org/manual/bindingops.html">binding
  operators</a> (introduced in OCaml
  4.13).</li>
<li>Optional fields in records, like <code>type t = { x : int, @optional y : int }</code>.</li>
<li>Uncurried by default.</li>
</ul>
<p>The restriction above only applies to features that compromise compatibility
with OCaml, but otherwise Melange can incorporate bugfixes or new functionality
from ReScript.</p>
<p>On the other hand, as Melange goal is to keep up with the version of the OCaml
compiler, there are features inherited from OCaml that are not supported by
ReScript at the moment (May 2023), for example:</p>
<ul>
<li><a href="https://v2.ocaml.org/manual/bindingops.html">Binding operators</a> / <code>let</code>
  bindings</li>
<li>Better type errors for some specific cases</li>
<li>Additions to the stdlib</li>
</ul>
<p>The whole list of changes added to the OCaml compiler can be checked
<a href="https://ocaml.org/releases">here</a>.</p>
<h3 id="melange-for-x-developers-syntax">Syntax</h3>
<p>ReScript encourages using <a href="https://rescript-lang.org/docs/manual/latest/migrate-from-bucklescript-reason">the new
syntax</a>
for any new code. While OCaml syntax might be supported today, its usage is not
documented. Reason syntax is no longer supported.</p>
<p>Melange supports and documents both Reason and OCaml syntaxes. It also includes
a best-effort support for ReScript syntax for backwards compatibility, provided
through the <code>rescript-syntax</code> package, available <a href="#melange-for-x-developers-todo-fix-me.md">in opam</a>. To
build any code written using ReScript syntax, the only requirement is to
download this package, as Melange and Dune will already coordinate to make use
of it when <code>res</code> or <code>resi</code> files are found.</p></section><h1 class='nav-section-title-end'>Ended: Learn</h1>
                        <h1 class='nav-section-title' id='section-reference'>
                            Reference <a class='headerlink' href='#section-reference' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="api"><h1 id="api-api">API</h1>
<p>Melange exposes three libraries:</p>
<ul>
<li>A standard library, which mostly replicates that of OCaml for compatibility;
see the docs: the <a href="#api-todo-fix-me.md"><code>Stdlib</code></a> library</li>
<li>Bindings to several browser and Node JavaScript APIs in the <a href="#api-todo-fix-me.md"><code>Js</code>
  library</a>.</li>
<li>Data structures and collection types in the <a href="#api-todo-fix-me.md"><code>Belt</code> library</a></li>
</ul>
<p>Using one or the other will depend on your application requirements, how much
integration you need with existing JavaScript libraries, or other specific
characteristics of your project. In any case, the three of them can be used in
the same project without issues.</p></section><h1 class='nav-section-title-end'>Ended: Reference</h1>
                        <h1 class='nav-section-title' id='section-try'>
                            Try <a class='headerlink' href='#section-try' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="try"><h1 id="try-try">Try</h1>
<p>TBD. In this page, we will show some playground, in the same spirit as
<a href="https://reasonml.github.io/en/try">https://reasonml.github.io/en/try</a>.</p></section><h1 class='nav-section-title-end'>Ended: Try</h1>
                        <h1 class='nav-section-title' id='section-talk'>
                            Talk <a class='headerlink' href='#section-talk' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="community"><h1 id="community-community">Community</h1>
<p>The community tends to congregate in the following forums:</p>
<ul>
<li><a href="https://discuss.ocaml.org/">OCaml Discourse Web Forum</a> is a friendly, online
  forum for OCaml discussion. If you prefer to have long-form conversation
  rather than just chatting, this is the place to do it.</li>
<li><a href="https://discord.gg/reasonml">Reason Discord</a>, where there is a specific
  <code>#melange</code> channel</li>
<li><a href="https://tinyurl.com/discord-ocaml">OCaml Discord</a></li>
<li><a href="https://github.com/melange-re/melange">Melange GitHub repository</a></li>
</ul>
<h2 id="community-resources">Resources</h2>
<p>The following are resources about Melange collected around the web:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=MdHDewVSDtM">David Sancho chats to Antonio Monteiro about OCaml and Melange (May
  2023)</a></li>
<li>"<a href="https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4">Ahrefs.com is now built with
  Melange</a>"
  announcement</li>
</ul></section><h1 class='nav-section-title-end'>Ended: Talk</h1></div>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span>
            <a href="https://github.com/melange-re/melange" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
      
      
    </span>
</div>
    <script>var base_url = '/unstable';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../js/print-site.js" defer></script>
      <script src="../js/toggleSyntaxButton.js" defer></script>
      <script src="../js/reasonml.js" defer></script>
      <script src="../search/main.js" defer></script>
      <script src="../js/version-select.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
