import{_ as e,c as t,o as a,V as i}from"./chunks/framework.BCxdY_ip.js";const b=JSON.parse('{"title":"Melange for X developers","description":"","frontmatter":{},"headers":[],"relativePath":"melange-for-x-developers.md","filePath":"melange-for-x-developers.md"}'),s={name:"melange-for-x-developers.md"},r=i(`<h1 id="melange-for-x-developers" tabindex="-1">Melange for X developers <a class="header-anchor" href="#melange-for-x-developers" aria-label="Permalink to &quot;Melange for X developers&quot;">​</a></h1><p>If you are familiar with other languages/platforms, here you will find sections that compare Melange to a few of them, so it might help you get up and running quickly. In particular:</p><ul><li>JavaScript</li><li>TypeScript</li><li>Js_of_ocaml</li><li>ReScript</li></ul><h2 id="for-javascript-developers" tabindex="-1">For JavaScript developers <a class="header-anchor" href="#for-javascript-developers" aria-label="Permalink to &quot;For JavaScript developers&quot;">​</a></h2><p>Melange is a thin layer over <a href="https://ocaml.org/" target="_blank" rel="noreferrer">OCaml</a>, a strongly typed functional programming language with an emphasis on expressiveness and safety. Melange’s goal is to help web developers build and maintain JavaScript applications safely, thanks to OCaml expressive and powerful type system.</p><p>Melange allows to build applications using either OCaml syntax or Reason syntax. If you don’t know which one to choose, we recommend <a href="https://reasonml.github.io/en/" target="_blank" rel="noreferrer">Reason</a>, as it has been designed with JavaScript developers in mind.</p><p>Reason syntax has first-class support for <a href="https://reasonml.github.io/docs/en/jsx" target="_blank" rel="noreferrer">JSX</a>, and there are bindings like <a href="https://github.com/reasonml/reason-react/" target="_blank" rel="noreferrer">ReasonReact</a> that build on top of that functionality to provide a great developer experience.</p><p>Another advantage is that programs written using Reason syntax are fully compatible with those written in OCaml syntax.</p><p>Here is the cheat sheet with some equivalents between JavaScript and Reason syntaxes:</p><h3 id="variable" tabindex="-1">Variable <a class="header-anchor" href="#variable" aria-label="Permalink to &quot;Variable&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>const x = 5;</code></td><td><code>let x = 5;</code></td></tr><tr><td><code>var x = y;</code></td><td>No equivalent</td></tr><tr><td><code>let x = 5; x = x + 1;</code></td><td><code>let x = ref(5); x := x^ + 1;</code></td></tr></tbody></table><h3 id="string-character" tabindex="-1">String &amp; Character <a class="header-anchor" href="#string-character" aria-label="Permalink to &quot;String &amp; Character&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>&quot;Hello world!&quot;</code></td><td>Same</td></tr><tr><td><code>&#39;Hello world!&#39;</code></td><td>Strings must use <code>&quot;</code></td></tr><tr><td>Characters are strings</td><td><code>&#39;a&#39;</code></td></tr><tr><td><code>&quot;hello &quot; + &quot;world&quot;</code></td><td><code>&quot;hello &quot; ++ &quot;world&quot;</code></td></tr></tbody></table><h3 id="boolean" tabindex="-1">Boolean <a class="header-anchor" href="#boolean" aria-label="Permalink to &quot;Boolean&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>true</code>, <code>false</code></td><td>Same</td></tr><tr><td><code>!true</code></td><td>Same</td></tr><tr><td>\`</td><td></td></tr><tr><td><code>a === b</code>, <code>a !== b</code></td><td>Same</td></tr><tr><td>No deep equality (recursive compare)</td><td><code>a == b</code>, <code>a != b</code></td></tr><tr><td><code>a == b</code></td><td>No equality with implicit casting</td></tr></tbody></table><h3 id="number" tabindex="-1">Number <a class="header-anchor" href="#number" aria-label="Permalink to &quot;Number&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>3</code></td><td>Same *</td></tr><tr><td><code>3.1415</code></td><td>Same</td></tr><tr><td><code>3 + 4</code></td><td>Same</td></tr><tr><td><code>3.0 + 4.5</code></td><td><code>3.0 +. 4.5</code></td></tr><tr><td><code>5 % 3</code></td><td><code>5 mod 3</code></td></tr></tbody></table><p>* JavaScript has no distinction between integer and float.</p><h3 id="object-record" tabindex="-1">Object/Record <a class="header-anchor" href="#object-record" aria-label="Permalink to &quot;Object/Record&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td>no static types</td><td><code>type point = {x: int, mutable y: int}</code></td></tr><tr><td><code>{x: 30, y: 20}</code></td><td>Same</td></tr><tr><td><code>point.x</code></td><td>Same</td></tr><tr><td><code>point.y = 30;</code></td><td>Same</td></tr><tr><td><code>{...point, x: 30}</code></td><td>Same</td></tr></tbody></table><h3 id="array" tabindex="-1">Array <a class="header-anchor" href="#array" aria-label="Permalink to &quot;Array&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>[1, 2, 3]</code></td><td><code>[|1, 2, 3|]</code></td></tr><tr><td><code>myArray[1] = 10</code></td><td>Same</td></tr><tr><td><code>[1, &quot;Bob&quot;, true]</code> *</td><td><code>(1, &quot;Bob&quot;, true)</code></td></tr><tr><td>No immutable list</td><td><code>[1, 2, 3]</code></td></tr></tbody></table><p>* Tuples can be simulated in JavaScript with arrays, as JavaScript arrays can contain multiple types of elements.</p><h3 id="null" tabindex="-1">Null <a class="header-anchor" href="#null" aria-label="Permalink to &quot;Null&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>null</code>, <code>undefined</code></td><td><code>None</code> *</td></tr></tbody></table><p>* There are no nulls, nor null bugs in OCaml. But it does have <a href="https://reasonml.github.io/docs/en/option" target="_blank" rel="noreferrer">an option type</a> for when you actually need nullability.</p><h3 id="function" tabindex="-1">Function <a class="header-anchor" href="#function" aria-label="Permalink to &quot;Function&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>arg =&gt; retVal</code></td><td><code>(arg) =&gt; retVal</code></td></tr><tr><td><code>function named(arg) {...}</code></td><td><code>let named = (arg) =&gt; ...</code></td></tr><tr><td><code>const f = function(arg) {...}</code></td><td><code>let f = (arg) =&gt; ...</code></td></tr><tr><td><code>add(4, add(5, 6))</code></td><td>Same</td></tr></tbody></table><h4 id="blocks" tabindex="-1">Blocks <a class="header-anchor" href="#blocks" aria-label="Permalink to &quot;Blocks&quot;">​</a></h4><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><pre><code>const myFun = (x, y) =&gt; {
  const doubleX = x + x;
  const doubleY = y + y;
  return doubleX + doubleY
};</code></pre></td><td><pre><code>let myFun = (x, y) =&gt; {
  let doubleX = x + x;
  let doubleY = y + y;
  doubleX + doubleY
};</code></pre></td></tr></tbody></table><h4 id="currying" tabindex="-1">Currying <a class="header-anchor" href="#currying" aria-label="Permalink to &quot;Currying&quot;">​</a></h4><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>let add = a =&gt; b =&gt; a + b</code></td><td><code>let add = (a, b) =&gt; a + b</code></td></tr></tbody></table><p>Both JavaScript and OCaml support currying, but OCaml currying is <strong>built-in and optimized to avoid intermediate function allocation and calls</strong>, whenever possible.</p><h3 id="if-else" tabindex="-1">If-else <a class="header-anchor" href="#if-else" aria-label="Permalink to &quot;If-else&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>if (a) {b} else {c}</code></td><td>Same</td></tr><tr><td><code>a ? b : c</code></td><td>Same</td></tr><tr><td><code>switch</code></td><td><code>switch</code> but <a href="https://reasonml.github.io/docs/en/pattern-matching" target="_blank" rel="noreferrer">with pattern matching</a></td></tr></tbody></table><h3 id="destructuring" tabindex="-1">Destructuring <a class="header-anchor" href="#destructuring" aria-label="Permalink to &quot;Destructuring&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>const {a, b} = data</code></td><td><code>let {a, b} = data</code></td></tr><tr><td><code>const [a, b] = data</code></td><td><code>let [|a, b|] = data</code> *</td></tr><tr><td><code>const {a: aa, b: bb} = data</code></td><td><code>let {a: aa, b: bb} = data</code></td></tr></tbody></table><p>* This will cause the compiler to warn that not all cases are handled, because <code>data</code> could be of length other than 2. Better switch to pattern-matching instead.</p><h3 id="loop" tabindex="-1">Loop <a class="header-anchor" href="#loop" aria-label="Permalink to &quot;Loop&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>for (let i = 0; i &lt;= 10; i++) {...}</code></td><td><code>for (i in 0 to 10) {...}</code></td></tr><tr><td><code>for (let i = 10; i &gt;= 0; i--) {...}</code></td><td><code>for (i in 10 downto 0) {...}</code></td></tr><tr><td><code>while (true) {...}</code></td><td>Same</td></tr></tbody></table><h3 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>&lt;Foo bar=1 baz=&quot;hi&quot; onClick={bla} /&gt;</code></td><td>Same</td></tr><tr><td><code>&lt;Foo bar=bar /&gt;</code></td><td><code>&lt;Foo bar /&gt;</code> *</td></tr><tr><td><code>&lt;input checked /&gt;</code></td><td><code>&lt;input checked=true /&gt;</code></td></tr><tr><td>No children spread</td><td><code>&lt;Foo&gt;...children&lt;/Foo&gt;</code></td></tr></tbody></table><p>* Note the argument punning when creating elements.</p><h3 id="exception" tabindex="-1">Exception <a class="header-anchor" href="#exception" aria-label="Permalink to &quot;Exception&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>throw new SomeError(...)</code></td><td><code>raise(SomeError(...))</code></td></tr><tr><td><code>try {a} catch (Err) {...} finally {...}</code></td><td><code>try (a) { | Err =&gt; ...}</code> *</td></tr></tbody></table><p>* No finally.</p><h3 id="blocks-1" tabindex="-1">Blocks <a class="header-anchor" href="#blocks-1" aria-label="Permalink to &quot;Blocks&quot;">​</a></h3><p>In OCaml, &quot;sequence expressions&quot; are created with <code>{}</code> and evaluate to their last statement. In JavaScript, this can be simulated via an immediately-invoked function expression (since function bodies have their own local scope).</p><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><pre><code>let res = (function() {
  const x = 23;
  const y = 34;
  return x + y;
})();</code></pre></td><td><pre><code>let res = {
  let x = 23;
  let y = 34;
  x + y
};</code></pre></td></tr></tbody></table><h3 id="comments" tabindex="-1">Comments <a class="header-anchor" href="#comments" aria-label="Permalink to &quot;Comments&quot;">​</a></h3><table><thead><tr><th>JavaScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>/* Comment */</code></td><td>Same</td></tr><tr><td><code>// Line comment</code></td><td>Same</td></tr></tbody></table><h2 id="for-typescript-developers" tabindex="-1">For TypeScript developers <a class="header-anchor" href="#for-typescript-developers" aria-label="Permalink to &quot;For TypeScript developers&quot;">​</a></h2><p>The approach to typing applications using Melange differs somewhat from TypeScript. TypeScript has been designed with a focus on compatibility with JavaScript, as outlined in its <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" target="_blank" rel="noreferrer">design goals</a>. On the other hand, Melange is built upon OCaml, a compiler known for its emphasis on expressiveness and safety.</p><p>These are some of the differences between both.</p><h3 id="type-inference" tabindex="-1">Type inference <a class="header-anchor" href="#type-inference" aria-label="Permalink to &quot;Type inference&quot;">​</a></h3><p>In TypeScript, the types for the input parameters have to be defined:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span></code></pre></div><p>OCaml can infer types without barely any type annotations. For example, we can define a function that adds two numbers as:</p><div class="language-ocaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;--shiki-light-text-decoration:underline;--shiki-dark-text-decoration:underline;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;--shiki-light-text-decoration:underline;--shiki-dark-text-decoration:underline;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;--shiki-light-text-decoration:underline;--shiki-dark-text-decoration:underline;"> y</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y</span></span></code></pre></div><div class="language-reasonml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">reasonml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y) </span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;">;</span></span></code></pre></div><h3 id="algebraic-data-types" tabindex="-1">Algebraic data types <a class="header-anchor" href="#algebraic-data-types" aria-label="Permalink to &quot;Algebraic data types&quot;">​</a></h3><p>It is not possible to build an ADT in TypeScript the same way as in OCaml. <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions" target="_blank" rel="noreferrer">Discriminated unions</a> would be the closest analog to them, with libraries like <a href="https://github.com/gvergnaud/ts-pattern" target="_blank" rel="noreferrer">ts-pattern</a> as an alternative to the lack of support for pattern matching in the language.</p><p>In OCaml, <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html" target="_blank" rel="noreferrer">algebraic data types (ADTs)</a> are a commonly used functionality of the language. They allow you to build your own types from small blocks. And with <a href="https://ocaml.org/docs/data-types" target="_blank" rel="noreferrer">pattern matching</a>, it is easy to access this data.</p><h3 id="nominal-typing" tabindex="-1">Nominal typing <a class="header-anchor" href="#nominal-typing" aria-label="Permalink to &quot;Nominal typing&quot;">​</a></h3><p>In TypeScript, all typing is structural. This means that it is hard sometimes to establish a boundary or separation between two types that have the same implementation. For these cases, nominal typing can be emulated using tags:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Email</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> __tag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unique</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> City</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> __tag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unique</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span></code></pre></div><p>In OCaml, nominal typing is fully supported. Some of the core language types like <a href="https://v2.ocaml.org/manual/coreexamples.html#s%3Atut-recvariants" target="_blank" rel="noreferrer">records and variants</a> are nominal. This means that even if you declare exactly the same type twice, functions that operate on values from one type will not be compatible with the other type.</p><p>There is also structural typing, used for OCaml <a href="https://v2.ocaml.org/manual/objectexamples.html" target="_blank" rel="noreferrer">objects</a> and <a href="https://v2.ocaml.org/manual/polyvariant.html" target="_blank" rel="noreferrer">polymorphic variants</a>.</p><h3 id="immutability" tabindex="-1">Immutability <a class="header-anchor" href="#immutability" aria-label="Permalink to &quot;Immutability&quot;">​</a></h3><p>TypeScript has two base primitives to work with immutability: <code>const</code> and <code>readonly</code>.</p><p>The first one is used to prevent variable reference change.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: Cannot assign to &#39;a&#39; because it is a constant.</span></span></code></pre></div><p>And the second one is used to make properties immutable.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { x: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: Cannot assign to &#39;x&#39; because it is a read-only property.</span></span></code></pre></div><p>Nevertheless, there are some problems here. <code>const</code> and <code>readonly</code> only block reference changes but do nothing about values. With <code>const a = [1, 2, 3]</code> or <code>readonly x: number[]</code>, you can still change the contents of an array.</p><p>OCaml provides data types with immutability in mind, like lists, records, or maps.</p><h3 id="strictness-and-soundness" tabindex="-1">Strictness and soundness <a class="header-anchor" href="#strictness-and-soundness" aria-label="Permalink to &quot;Strictness and soundness&quot;">​</a></h3><p>In TypeScript, you have the flexibility to use types like <code>any</code> or other expansive types such as <code>Function</code>. However, TypeScript provides the <code>strict</code> option in the <code>tsconfig.json</code> file to mitigate the usage of these less type-safe constructs. On the other hand, OCaml does not offer a similar option to enable or disable strictness. In OCaml, the language itself promotes type safety without the need for explicit configuration options to enforce stricter behavior.</p><p>TypeScript, as mentioned in <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness" target="_blank" rel="noreferrer">its handbook</a>, may sacrifice soundness for practicality when needed. In contrast, OCaml implementations provide unsound methods like <a href="./communicate-with-javascript.html#special-identity-external">the <code>identity</code> primitive</a> but they are generally discouraged and rarely used. The OCaml community places a strong emphasis on maintaining soundness and prefers safer alternatives to ensure code correctness.</p><h3 id="cheatsheet" tabindex="-1">Cheatsheet <a class="header-anchor" href="#cheatsheet" aria-label="Permalink to &quot;Cheatsheet&quot;">​</a></h3><p>The following are some conversions between TypeScript and OCaml idioms, in the OCaml side we use Reason syntax for familiarity, as mentioned in <a href="#for-javascript-developers">section for JavaScript developers</a>.</p><h4 id="type-aliases" tabindex="-1">Type aliases <a class="header-anchor" href="#type-aliases" aria-label="Permalink to &quot;Type aliases&quot;">​</a></h4><table><thead><tr><th>TypeScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>type Email = string;</code></td><td><code>type email = string;</code></td></tr></tbody></table><h4 id="abstract-types" tabindex="-1">Abstract types <a class="header-anchor" href="#abstract-types" aria-label="Permalink to &quot;Abstract types&quot;">​</a></h4><table><thead><tr><th>TypeScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><pre><code>type Email = string &amp;
{ readonly __tag: unique symbol };</code></pre></td><td><pre><code>/* in interface \`rei\` file */
type email;
</code></pre><pre><code>/* in implementation \`re\` file */
type email = string;</code></pre></td></tr></tbody></table><h4 id="union-types-variants" tabindex="-1">Union types / Variants <a class="header-anchor" href="#union-types-variants" aria-label="Permalink to &quot;Union types / Variants&quot;">​</a></h4><table><thead><tr><th>TypeScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><pre><code>type Result = &quot;Error&quot; | &quot;Success&quot;;
</code></pre></td><td><pre><code>type result = Error | Success</code></pre></td></tr><tr><td><pre><code>type Result =
| { type: &quot;Error&quot;; message: string }
| { type: &quot;Success&quot;; n: number };
</code></pre></td><td><pre><code>type result =
| Error(string)
| Success(int)</code></pre></td></tr></tbody></table><h4 id="immutability-1" tabindex="-1">Immutability <a class="header-anchor" href="#immutability-1" aria-label="Permalink to &quot;Immutability&quot;">​</a></h4><table><thead><tr><th>TypeScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><pre><code>const a = 1;
type A = { readonly x: number };
type ImmutableA = Readonly&lt;A&gt;;
const arr: ReadonlyArray&lt;number&gt; = [1, 2, 3];
type A = { readonly [x: string]: number };
</code></pre></td><td>Enabled by default</td></tr></tbody></table><h4 id="currying-1" tabindex="-1">Currying <a class="header-anchor" href="#currying-1" aria-label="Permalink to &quot;Currying&quot;">​</a></h4><table><thead><tr><th>TypeScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><pre><code>type addT = (_: number) =&gt; (_: number) =&gt; number;
const add: addT = (l) =&gt; (r) =&gt; l + r;
add(5)(3);
</code></pre></td><td>Enabled by default</td></tr></tbody></table><h4 id="parametric-polymorphism" tabindex="-1">Parametric polymorphism <a class="header-anchor" href="#parametric-polymorphism" aria-label="Permalink to &quot;Parametric polymorphism&quot;">​</a></h4><table><thead><tr><th>TypeScript</th><th>OCaml (Reason syntax)</th></tr></thead><tbody><tr><td><code>type length = &lt;T&gt;(_: T[]) =&gt; number;</code></td><td><code>let length: list(&#39;a) =&gt; int;</code></td></tr></tbody></table><h2 id="for-js-of-ocaml-developers" tabindex="-1">For Js_of_ocaml developers <a class="header-anchor" href="#for-js-of-ocaml-developers" aria-label="Permalink to &quot;For Js\\_of\\_ocaml developers&quot;">​</a></h2><p>There are many similarities between Js_of_ocaml and Melange:</p><ul><li>Both compile OCaml to JavaScript.</li><li>Both are available as libraries in the official opam repository.</li><li>Both have access to the OCaml platform developer toolchain: the OCaml LSP server, Merlin, and the different editor extensions.</li><li>Both have implemented extensive integration with Dune.</li></ul><p>However, while Js_of_ocaml transforms OCaml bytecode into JavaScript, Melange starts the conversion process earlier in the compiler pipeline, as it transforms the compiler lambda representation into JavaScript.</p><p>Js_of_ocaml is a project with years of development and evolution behind it, while Melange <a href="./rationale.html#a-bit-of-history">appearance</a> is relatively recent in comparison.</p><p>These aspects translate into different trade-offs. Compared to Js_of_ocaml:</p><ul><li>Melange can be installed in an OCaml 5 opam switch, but the editor integration is not working at the time (May 2023).</li><li>Similarly, any OCaml 5 features like effects are currently unsupported in Melange.</li><li>Js_of_ocaml allows to compile the compiler itself and create &quot;toplevels&quot;, which is not possible with Melange.</li><li><code>Marshal</code> is well supported in Js_of_ocaml, while Melange does not support it.</li><li>Libraries like <code>Unix</code> or <code>Str</code> are available in Js_of_ocaml but not in Melange.</li><li>Js_of_ocaml supports sourcemaps, which Melange do not support yet (as of May 2023).</li></ul><p>On the upside, in Melange:</p><ul><li>Consuming existing JavaScript packages might be a bit easier in Melange, thanks to its compilation model and the extensive availability of mechanisms to bind to JavaScript code.</li><li>There is great support for some of the most used JavaScript libraries like <a href="https://github.com/reasonml/reason-react/" target="_blank" rel="noreferrer">ReactJS</a> or GraphQL clients.</li><li>The generated JavaScript bundles are generally smaller.</li><li>The generated JavaScript code is generally more readable.</li><li>Melange can generate ES6 or commonjs while Js_of_ocaml generates an IIFE (Immediately Invoked Function Expression) (as of Sep 2023)</li><li>Straight-forward integration with modern JavaScript tooling like Webpack, NextJS, etc. This is possible thanks to the 1 module &lt;-&gt; 1 JavaScript file compilation model.</li></ul><h2 id="for-rescript-developers" tabindex="-1">For ReScript developers <a class="header-anchor" href="#for-rescript-developers" aria-label="Permalink to &quot;For ReScript developers&quot;">​</a></h2><p>As a project that shares a common ancestry with ReScript, Melange inherits a lot of its characteristics:</p><ul><li>The compilation model involves compiling a single module into a single JavaScript file.</li><li>The libraries provided by ReScript (Belt and Js) are available in Melange too.</li><li>The mechanisms provided for <a href="./communicate-with-javascript.html">communicating with JavaScript code</a> are mostly the same.</li></ul><p>However, one of Melange’s goals is to maximize compatibility with the OCaml ecosystem. This goal translates into fundamental differences in how Melange and ReScript function from the perspective of both library authors and users.</p><h3 id="package-manager" tabindex="-1">Package manager <a class="header-anchor" href="#package-manager" aria-label="Permalink to &quot;Package manager&quot;">​</a></h3><p>ReScript projects rely exclusively on npm for all packages they depend on. Melange projects, on the other hand, will use opam for native packages, and npm for JavaScript ones. Melange package management is explained in detail in <a href="./package-management.html">the dedicated section</a>.</p><h3 id="build-system" tabindex="-1">Build system <a class="header-anchor" href="#build-system" aria-label="Permalink to &quot;Build system&quot;">​</a></h3><p>ReScript has its own build system, originally based on Ninja.</p><p>Melange defers to <a href="https://dune.build/" target="_blank" rel="noreferrer">Dune</a> for build orchestration, as it is explained in detail in <a href="./build-system.html">the corresponding section</a>. By integrating with Dune, Melange can benefit from the multiple features provided. One of the most useful features is first-class supports for monorepos. But there are multiple others, like virtual libraries, watch mode, or integrations with tools like <a href="https://github.com/ocaml/odoc" target="_blank" rel="noreferrer">odoc</a>.</p><p>The divergences caused by the different build systems have a lot of implications and nuances that might be too complex to explain in this section, but some of the specific details have been discussed in <a href="https://discuss.ocaml.org/t/ahrefs-is-now-built-with-melange/12107/3" target="_blank" rel="noreferrer">the OCaml forum</a>.</p><h3 id="source-based-vs-pre-built-distribution" tabindex="-1">Source-based vs pre-built distribution <a class="header-anchor" href="#source-based-vs-pre-built-distribution" aria-label="Permalink to &quot;Source-based vs pre-built distribution&quot;">​</a></h3><p>While with ReScript every dependency can be downloaded with just npm, Melange projects will have to use opam and npm. This is a trade-off: on one hand, some Melange projects might need to include two package configuration files. But on the other hand they can benefit from opam’s source-based package distribution model for things like PPXs, linters, or any other OCaml tooling.</p><p>In comparison, consuming any OCaml tool in ReScript is more challenging. Since ReScript lacks a native toolchain, authors of the tools need to provide pre-built binaries for all the supported systems and architectures. This poses difficulties for the authors in terms of maintenance, and it can also result in certain users being unable to access these tools if their systems or architectures are not included in the pre-built binaries.</p><h3 id="ocaml-compiler-version" tabindex="-1">OCaml compiler version <a class="header-anchor" href="#ocaml-compiler-version" aria-label="Permalink to &quot;OCaml compiler version&quot;">​</a></h3><p>ReScript is compatible with the 4.06 version of the OCaml compiler, while Melange is compatible with the version 5.1.1 (as of Dec 2023).</p><h3 id="editor-integration" tabindex="-1">Editor integration <a class="header-anchor" href="#editor-integration" aria-label="Permalink to &quot;Editor integration&quot;">​</a></h3><p>Melange is fully compatible with the <a href="https://ocaml.org/docs/up-and-running#configuring-your-editor" target="_blank" rel="noreferrer">OCaml platform editor tools</a>, which makes possible to work in projects that include OCaml and Melange code using the same editor configuration.</p><p>ReScript has its <a href="https://rescript-lang.org/docs/manual/latest/editor-plugins" target="_blank" rel="noreferrer">own set of editor plugins</a>.</p><h3 id="feature-choice-and-alignment-with-ocaml" tabindex="-1">Feature choice and alignment with OCaml <a class="header-anchor" href="#feature-choice-and-alignment-with-ocaml" aria-label="Permalink to &quot;Feature choice and alignment with OCaml&quot;">​</a></h3><p>ReScript’s goal is to model the language to bring it as close to JavaScript as possible. From the website <a href="https://rescript-lang.org/docs/manual/latest/introduction" target="_blank" rel="noreferrer">introduction section</a>:</p><blockquote><p>ReScript looks like JS, acts like JS, and compiles to the highest quality of clean, readable and performant JS (...)</p></blockquote><p>New features added to ReScript might close its alignment with JavaScript, but some of these features can lead to greater divergence from OCaml. As Melange prioritizes compatibility with OCaml, it avoids incorporating those features that widen the gap between the two.</p><p>Here is a non-exhaustive list of the features that ReScript has added and will not be supported in Melange:</p><ul><li>The <code>async</code> / <code>await</code> syntax: similar functionality can be achieved in Melange through the usage of <a href="https://v2.ocaml.org/manual/bindingops.html" target="_blank" rel="noreferrer">binding operators</a> (introduced in OCaml 4.13).</li><li>Optional fields in records, like <code>type t = { x : int, @optional y : int }</code>.</li><li>Uncurried by default.</li></ul><p>The restriction above only applies to features that compromise compatibility with OCaml, but otherwise Melange can incorporate bugfixes or new functionality from ReScript.</p><p>On the other hand, as Melange goal is to keep up with the version of the OCaml compiler, there are features inherited from OCaml that are not supported by ReScript at the moment (May 2023), for example:</p><ul><li><a href="https://v2.ocaml.org/manual/bindingops.html" target="_blank" rel="noreferrer">Binding operators</a> / <code>let</code> bindings</li><li>Better type errors for some specific cases</li><li>Additions to the stdlib</li></ul><p>The whole list of changes added to the OCaml compiler can be checked <a href="https://ocaml.org/releases" target="_blank" rel="noreferrer">here</a>.</p><h3 id="syntax" tabindex="-1">Syntax <a class="header-anchor" href="#syntax" aria-label="Permalink to &quot;Syntax&quot;">​</a></h3><p>ReScript encourages using <a href="https://rescript-lang.org/docs/manual/latest/migrate-from-bucklescript-reason" target="_blank" rel="noreferrer">the new syntax</a> for any new code. While OCaml syntax might be supported today, its usage is not documented. Reason syntax is no longer supported.</p><p>Melange supports and documents both Reason and OCaml syntaxes. It also includes a best-effort support for ReScript syntax for backwards compatibility, provided through the <code>rescript-syntax</code> package, available <a href="https://opam.ocaml.org/packages/rescript-syntax/" target="_blank" rel="noreferrer">in opam</a>. To build any code written using ReScript syntax, the only requirement is to download this package, as Melange and Dune will already coordinate to make use of it when <code>res</code> or <code>resi</code> files are found.</p>`,133),o=[r];function n(l,d,h,c,p,m){return a(),t("div",null,o)}const g=e(s,[["render",n]]);export{b as __pageData,g as default};
